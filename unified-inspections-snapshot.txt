===== FILE: ./app/api/inspections/unified/session/[lineId]/finish/route.ts =====

import { NextResponse } from "next/server";

export async function POST(
  req: Request,
  { params }: { params: { lineId: string } },
) {
  const body = await req.json().catch(() => null);
  // TODO: mark inspection finished, write inspection_results + quote lines
  return NextResponse.json({ ok: true, lineId: params.lineId, body });
}


===== FILE: ./app/api/inspections/unified/session/[lineId]/quote/route.ts =====

import { NextResponse } from "next/server";

export async function POST(
  req: Request,
  { params }: { params: { lineId: string } },
) {
  const body = await req.json().catch(() => null);
  // TODO: send to parts / work_order_quote_lines / parts_quote_requests
  return NextResponse.json({ ok: true, lineId: params.lineId, body });
}


===== FILE: ./app/api/inspections/unified/session/[lineId]/route.ts =====

import { NextResponse } from "next/server";

export async function GET(
  _req: Request,
  { params }: { params: { lineId: string } },
) {
  // TODO: load from Supabase (inspection_sessions + templates)
  return NextResponse.json({ ok: true, lineId: params.lineId });
}

export async function POST(
  req: Request,
  { params }: { params: { lineId: string } },
) {
  const body = await req.json().catch(() => null);
  // TODO: persist unified session state
  return NextResponse.json({ ok: true, lineId: params.lineId, body });
}


===== FILE: ./features/inspections/unified/custom-draft/page.tsx =====

"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import type {
  InspectionSession,
  InspectionSection,
} from "@inspections/lib/inspection/types";
import InspectionUnifiedScreen from "@/features/inspections/unified/ui/InspectionUnifiedScreen";
import { saveInspectionSessionUnified } from "@/features/inspections/unified/data/saveSession";

function safeParseSections(raw: string | null): InspectionSection[] {
  if (!raw) return [];
  try {
    const parsed = JSON.parse(raw) as unknown;
    if (!Array.isArray(parsed)) return [];
    // already shaped by custom builder / draft
    return parsed as InspectionSection[];
  } catch {
    return [];
  }
}

export default function UnifiedCustomDraftPage() {
  const router = useRouter();
  const sp = useSearchParams();

  const [session, setSession] = useState<InspectionSession | null>(null);
  const [bootError, setBootError] = useState<string | null>(null);

  const sessionIdFromUrl = sp.get("sessionId");
  const workOrderId = sp.get("workOrderId") ?? "";
  const vehicleId = sp.get("vehicleId") ?? "";
  const customerId = sp.get("customerId") ?? "";
  const templateId = sp.get("templateId") ?? "";
  const location = sp.get("location") ?? "";

  const sessionId = useMemo(
    () =>
      sessionIdFromUrl ||
      (typeof crypto !== "undefined" && "randomUUID" in crypto
        ? crypto.randomUUID()
        : `local-${Date.now()}`),
    [sessionIdFromUrl],
  );

  useEffect(() => {
    if (typeof window === "undefined") return;

    // Pull staged sections from the classic custom builder / draft
    const sectionsRaw = window.sessionStorage.getItem(
      "customInspection:sections",
    );
    const titleFromStorage =
      window.sessionStorage.getItem("customInspection:title") ?? "";
    const dutyClass =
      window.sessionStorage.getItem("customInspection:dutyClass") ?? "";

    const sections = safeParseSections(sectionsRaw);

    if (!sections.length) {
      setBootError("No staged sections found for custom inspection.");
      return;
    }

    const title =
      titleFromStorage ||
      sp.get("template") ||
      "Custom Inspection (Unified)";

    const now = new Date().toISOString();

    const unifiedSession: InspectionSession = {
      id: sessionId,
      workOrderId,
      vehicleId,
      customerId,
      templateId,
      templateName: title,
      location,
      currentSectionIndex: 0,
      currentItemIndex: 0,
      transcript: "",
      status: "in_progress",
      started: true,
      completed: false,
      isPaused: false,
      isListening: false,
      quote: [],
      lastUpdated: now,
      customer: {
        first_name: "",
        last_name: "",
        phone: "",
        email: "",
        address: "",
        city: "",
        province: "",
        postal_code: "",
      },
      vehicle: {
        year: "",
        make: "",
        model: "",
        vin: "",
        license_plate: "",
        mileage: "",
        color: "",
      },
      sections,
      // extra metadata – allowed by the updated types
      meta: {
        dutyClass,
        source: "custom-builder",
      } as any,
    };

    setSession(unifiedSession);
  }, [
    sessionId,
    workOrderId,
    vehicleId,
    customerId,
    templateId,
    location,
    sp,
  ]);

  const handleUpdateSession = async (patch: Partial<InspectionSession>) => {
    if (!session) return;
    const next: InspectionSession = {
      ...session,
      ...patch,
      lastUpdated: new Date().toISOString(),
    };
    setSession(next);

    try {
      await saveInspectionSessionUnified(next);
    } catch (e) {
      // currently a stub – keep UI quiet
      // eslint-disable-next-line no-console
      console.debug("saveInspectionSessionUnified error (stub)", e);
    }
  };

  if (bootError) {
    return (
      <div className="min-h-[60vh] bg-gradient-to-b from-black via-slate-950 to-slate-950 px-4 py-6 text-sm text-red-200">
        <div className="mx-auto max-w-3xl rounded-2xl border border-red-500/40 bg-red-950/40 px-4 py-3 shadow-[0_18px_45px_rgba(0,0,0,0.85)]">
          <div className="mb-2 text-xs font-semibold uppercase tracking-[0.18em] text-red-200/80">
            Custom Inspection
          </div>
          <p>{bootError}</p>
          <button
            type="button"
            onClick={() => router.back()}
            className="mt-3 inline-flex items-center rounded-full border border-red-500/70 bg-red-600/80 px-3 py-1.5 text-[11px] font-semibold text-black hover:bg-red-500"
          >
            ← Back
          </button>
        </div>
      </div>
    );
  }

  if (!session) {
    return (
      <div className="min-h-[60vh] bg-gradient-to-b from-black via-slate-950 to-slate-950 px-4 py-6 text-sm text-neutral-300">
        <div className="mx-auto max-w-3xl rounded-2xl border border-white/10 bg-black/60 px-4 py-3 shadow-[0_18px_45px_rgba(0,0,0,0.85)]">
          Preparing unified inspection…
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-[60vh] bg-gradient-to-b from-black via-slate-950 to-slate-950 px-4 py-6">
      <div className="mx-auto max-w-6xl rounded-2xl border border-white/10 bg-black/60 p-4 shadow-[0_22px_55px_rgba(0,0,0,0.95)]">
        <div className="mb-3 flex items-center justify-between gap-2">
          <div>
            <h1 className="text-sm font-semibold uppercase tracking-[0.18em] text-neutral-300">
              Unified Inspection
            </h1>
            <p className="text-xs text-neutral-500">
              Built from custom template draft ·{" "}
              <span className="text-[color:var(--accent-copper-light,#fb923c)]">
                {session.templateName || "Custom Inspection"}
              </span>
            </p>
          </div>
        </div>

        <InspectionUnifiedScreen
          session={session}
          onUpdateSession={handleUpdateSession}
        />
      </div>
    </div>
  );
}

===== FILE: ./features/inspections/unified/data/finishSession.ts =====

import type { InspectionSession } from "@inspections/lib/inspection/types";

export async function finishInspectionSessionUnified(
  session: InspectionSession,
): Promise<void> {
  console.debug("finishInspectionSessionUnified (stub)", session.id);
}


===== FILE: ./features/inspections/unified/data/loadSession.ts =====

import type { InspectionSession } from "@inspections/lib/inspection/types";

export async function loadInspectionSession(
  lineId: string,
): Promise<InspectionSession | null> {
  console.debug("loadInspectionSession (stub)", lineId);
  return null;
}


===== FILE: ./features/inspections/unified/data/saveSession.ts =====

import type { InspectionSession } from "@inspections/lib/inspection/types";

export async function saveInspectionSessionUnified(
  session: InspectionSession,
): Promise<void> {
  console.debug("saveInspectionSessionUnified (stub)", session.id);
}


===== FILE: ./features/inspections/unified/data/sessionStore.ts =====

import type { InspectionSession } from "@inspections/lib/inspection/types";

let inMemoryStore: Record<string, InspectionSession> = {};

export function getSessionFromStore(id: string): InspectionSession | null {
  return inMemoryStore[id] ?? null;
}

export function saveSessionToStore(id: string, session: InspectionSession) {
  inMemoryStore[id] = session;
}


===== FILE: ./features/inspections/unified/data/templateLoader.ts =====

import type {
  InspectionTemplate,
  InspectionSection,
} from "@inspections/lib/inspection/types";

export async function loadInspectionTemplateUnified(
  templateId: string,
): Promise<InspectionTemplate | null> {
  console.debug("loadInspectionTemplateUnified (stub)", templateId);
  return null;
}

export function templateToSectionsUnified(
  template: InspectionTemplate,
): InspectionSection[] {
  return (template.sections as InspectionSection[]) ?? [];
}


===== FILE: ./features/inspections/unified/data/toQuoteLines.ts =====

import type {
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

export function inspectionToQuoteLinesUnified(
  session: InspectionSession,
): QuoteLineItem[] {
  console.debug("inspectionToQuoteLinesUnified (stub)", session.id);
  return [];
}


===== FILE: ./features/inspections/unified/hooks/useInspectionTemplate.ts =====

"use client";

import { useEffect, useState } from "react";
import type {
  InspectionTemplate,
} from "@inspections/lib/inspection/types";
import { loadInspectionTemplateUnified } from "../data/templateLoader";

export function useInspectionTemplate(templateId: string | null) {
  const [template, setTemplate] = useState<InspectionTemplate | null>(null);

  useEffect(() => {
    if (!templateId) return;
    loadInspectionTemplateUnified(templateId).then(setTemplate);
  }, [templateId]);

  return { template };
}


===== FILE: ./features/inspections/unified/hooks/useUnifiedInspection.ts =====

"use client";

import { useState } from "react";
import type { InspectionSession } from "@inspections/lib/inspection/types";

export default function useUnifiedInspection(initial: InspectionSession) {
  const [session, setSession] = useState<InspectionSession>(initial);

  const updateSession = (patch: Partial<InspectionSession>) =>
    setSession((prev) => ({ ...prev, ...patch }));

  return {
    session,
    updateSession,
  };
}


===== FILE: ./features/inspections/unified/SectionDisplay.tsx =====

// features/inspections/unified/ui/SectionDisplay.tsx
"use client";

import { useMemo, useState } from "react";
import type {
  InspectionSection,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";
import { Button } from "@shared/components/ui/Button";

type SectionDisplayProps = {
  title: string;
  section: InspectionSection;
  sectionIndex: number;
  showNotes: boolean;
  showPhotos: boolean;
  onUpdateStatus: (
    sectionIndex: number,
    itemIndex: number,
    status: InspectionItemStatus,
  ) => void;
  onUpdateNote: (
    sectionIndex: number,
    itemIndex: number,
    note: string,
  ) => void;
  onUpload: (
    photoUrl: string,
    sectionIndex: number,
    itemIndex: number,
  ) => void;
};

export default function SectionDisplay({
  title,
  section,
  sectionIndex,
  showNotes,
  showPhotos,
  onUpdateStatus,
  onUpdateNote,
  onUpload,
}: SectionDisplayProps) {
  const [open, setOpen] = useState<boolean>(true);

  const stats = useMemo(() => {
    const total = section.items.length;
    const counts: Record<
      "ok" | "fail" | "na" | "recommend" | "unset",
      number
    > = { ok: 0, fail: 0, na: 0, recommend: 0, unset: 0 };

    for (const it of section.items) {
      const status = (it.status ?? "unset") as keyof typeof counts;
      if (status in counts) counts[status] += 1;
      else counts.unset += 1;
    }

    return { total, ...counts };
  }, [section.items]);

  const markAll = (status: InspectionItemStatus) => {
    section.items.forEach((_item, itemIndex) =>
      onUpdateStatus(sectionIndex, itemIndex, status),
    );
  };

  return (
    <div className="mb-6 rounded-2xl border border-white/8 bg-black/30 px-4 py-3 shadow-card backdrop-blur-md md:px-5 md:py-4">
      {/* Header */}
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-white/5 pb-3">
        <button
          type="button"
          onClick={() => setOpen((v) => !v)}
          className="text-left text-lg font-semibold tracking-wide text-orange-400"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
          aria-expanded={open}
        >
          {title}
        </button>

        <div className="flex flex-wrap items-center gap-2">
          <span
            className="hidden text-[11px] uppercase tracking-wide text-neutral-400 md:inline"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {stats.ok} OK · {stats.fail} FAIL · {stats.na} NA ·{" "}
            {stats.recommend} REC · {stats.unset} —
          </span>

          <div className="flex flex-wrap items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("ok")}
            >
              All OK
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("fail")}
            >
              All FAIL
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("na")}
            >
              All NA
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("recommend")}
            >
              All REC
            </Button>

            <Button
              variant="ghost"
              size="sm"
              className="ml-1 h-7 px-2 text-[11px]"
              type="button"
              onClick={() => setOpen((v) => !v)}
              aria-expanded={open}
              title={open ? "Collapse section" : "Expand section"}
            >
              {open ? "Collapse" : "Expand"}
            </Button>
          </div>
        </div>
      </div>

      {/* Body */}
      {open && (
        <div className="space-y-3 pt-3">
          {section.items.map((item, itemIndex) => {
            const keyBase =
              item.item ?? item.name ?? `item-${sectionIndex}-${itemIndex}`;

            const status = (item.status ?? "").toString().toLowerCase();
            const note = (item.notes ?? "").toString();
            const photoUrls = (item.photoUrls ?? []) as string[];

            return (
              <div
                key={`${keyBase}-${itemIndex}`}
                className="rounded-xl border border-white/5 bg-black/40 p-3 md:p-3.5"
              >
                {/* Top row: label + status buttons */}
                <div className="flex flex-wrap items-center justify-between gap-2">
                  <div className="min-w-0 flex-1 text-sm font-medium text-white">
                    {item.item ?? item.name ?? "Item"}
                  </div>

                  <div className="flex flex-wrap items-center gap-1">
                    {(["ok", "fail", "na", "recommend"] as const).map(
                      (s) => (
                        <Button
                          key={s}
                          type="button"
                          size="sm"
                          variant={
                            (status as InspectionItemStatus) === s
                              ? "orange"
                              : "outline"
                          }
                          className="h-7 px-2 text-[11px]"
                          onClick={() =>
                            onUpdateStatus(
                              sectionIndex,
                              itemIndex,
                              s as InspectionItemStatus,
                            )
                          }
                        >
                          {s.toUpperCase()}
                        </Button>
                      ),
                    )}
                  </div>
                </div>

                {/* Measurement + notes/photos */}
                <div className="mt-2 space-y-2 text-xs text-neutral-200">
                  <div className="flex flex-wrap items-center gap-2">
                    <span className="text-neutral-400">Value:</span>
                    <span>
                      {item.value ?? "—"}
                      {item.unit ? ` ${item.unit}` : ""}
                    </span>
                  </div>

                  {showNotes && (
                    <div className="space-y-1">
                      <div className="text-neutral-400">Notes</div>
                      <textarea
                        className="min-h-[60px] w-full rounded-md border border-white/10 bg-black/40 px-2 py-1 text-xs text-white outline-none focus:border-orange-400 focus:ring-1 focus:ring-orange-400"
                        value={note}
                        onChange={(e) =>
                          onUpdateNote(
                            sectionIndex,
                            itemIndex,
                            e.currentTarget.value,
                          )
                        }
                      />
                    </div>
                  )}

                  {showPhotos && (
                    <div className="space-y-1">
                      <div className="flex items-center justify-between text-neutral-400">
                        <span>Photos ({photoUrls.length})</span>
                        {/* hook up to actual uploader later */}
                        <Button
                          type="button"
                          size="xs"
                          variant="outline"
                          className="h-6 px-2 text-[10px]"
                          onClick={() => {
                            const dummyUrl = window.prompt(
                              "Photo URL (stub for now)",
                            );
                            if (!dummyUrl) return;
                            onUpload(dummyUrl, sectionIndex, itemIndex);
                          }}
                        >
                          + Add
                        </Button>
                      </div>

                      {photoUrls.length > 0 && (
                        <div className="flex flex-wrap gap-2">
                          {photoUrls.map((url) => (
                            <div
                              key={url}
                              className="h-12 w-12 overflow-hidden rounded border border-white/10 bg-neutral-900"
                            >
                              {/* eslint-disable-next-line @next/next/no-img-element */}
                              <img
                                src={url}
                                alt="Inspection"
                                className="h-full w-full object-cover"
                              />
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}

===== FILE: ./features/inspections/unified/ui/AxleGrid.tsx =====

"use client";


import type { InspectionItem } from "@inspections/lib/inspection/types";

type GridUnitMode = "metric" | "imperial";
type Side = "left" | "right";
type Variant = "main" | "inner" | "outer";

interface AxleGridProps {
  title?: string;
  sectionIndex: number;
  items: InspectionItem[];
  unitMode: GridUnitMode;
  showKpaHint: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
  onAddAxle?: () => void;
}

interface AxleCell {
  itemIndex: number;
  item: InspectionItem;
}

interface AxleSideInputs {
  main?: AxleCell;
  inner?: AxleCell;
  outer?: AxleCell;
}

interface AxleMetricRow {
  metricKey: string;
  metricLabel: string;
  left: AxleSideInputs;
  right: AxleSideInputs;
}

interface AxleBlock {
  axleName: string;
  rows: AxleMetricRow[];
}

interface ParsedAirLabel {
  axle: string;
  side: Side;
  variant: Variant;
  metric: string;
  metricBase: string;
}

function normaliseMetric(metric: string): string {
  return metric
    .replace(/\(\s*(inner|outer)\s*\)/gi, "")
    .replace(/\b(inner|outer)\b/gi, "")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/**
 * Supported label shapes:
 *  - "Steer Left Tire Pressure"
 *  - "Drive 1 Right Inner Tire Tread"
 *  - "Drive 2 LRI Pushrod Travel"
 *  - "Trailer 1 RRO Drum / Rotor Thickness"
 */
function parseAirLabel(labelRaw: string): ParsedAirLabel | null {
  const label = labelRaw.trim();
  if (!label) return null;

  // Abbreviation: "<axle> <code> <metric>"
  const abbrMatch = label.match(
    /^(?<axle>.+?)\s+(?<code>LRI|LRO|RRI|RRO|LF|RF|LR|RR)\s+(?<metric>.+)$/i,
  );
  if (abbrMatch && abbrMatch.groups) {
    const axle = abbrMatch.groups.axle.trim();
    const code = abbrMatch.groups.code.toUpperCase();
    const metric = abbrMatch.groups.metric.trim();
    if (!axle || !metric) return null;

    const side: Side = code.startsWith("L") ? "left" : "right";
    let variant: Variant = "main";
    if (code.endsWith("I")) variant = "inner";
    if (code.endsWith("O")) variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      axle,
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  // Text form: "<axle> Left [Inner|Outer] Metric..."
  const textMatch = label.match(
    /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?:(?<io>Inner|Outer)\s+)?(?<metric>.+)$/i,
  );
  if (textMatch && textMatch.groups) {
    const axle = textMatch.groups.axle.trim();
    const side: Side =
      textMatch.groups.side.toLowerCase() === "left" ? "left" : "right";
    const ioRaw = (textMatch.groups.io ?? "").toLowerCase();
    const metric = textMatch.groups.metric.trim();
    if (!axle || !metric) return null;

    let variant: Variant = "main";
    if (ioRaw === "inner") variant = "inner";
    if (ioRaw === "outer") variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      axle,
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  return null;
}

function buildAxles(items: InspectionItem[]): {
  axles: AxleBlock[];
  loose: Array<{ itemIndex: number; item: InspectionItem }>;
} {
  const perAxle = new Map<string, Map<string, AxleMetricRow>>();
  const loose: Array<{ itemIndex: number; item: InspectionItem }> = [];

  items.forEach((item, idx) => {
    const label = item.item ?? item.name ?? "";
    const parsed = parseAirLabel(label);
    if (!parsed) {
      loose.push({ itemIndex: idx, item });
      return;
    }

    const axleMap =
      perAxle.get(parsed.axle) ?? new Map<string, AxleMetricRow>();

    const existingRow =
      axleMap.get(parsed.metricBase) ??
      ({
        metricKey: parsed.metricBase,
        metricLabel: parsed.metricBase,
        left: {},
        right: {},
      } as AxleMetricRow);

    const cell: AxleCell = { itemIndex: idx, item };

    if (parsed.side === "left") {
      existingRow.left[parsed.variant] = cell;
    } else {
      existingRow.right[parsed.variant] = cell;
    }

    axleMap.set(parsed.metricBase, existingRow);
    perAxle.set(parsed.axle, axleMap);
  });

  const axles: AxleBlock[] = Array.from(perAxle.entries()).map(
    ([axleName, rowsMap]) => ({
      axleName,
      rows: Array.from(rowsMap.values()),
    }),
  );

  return { axles, loose };
}

function getUnitLabel(metricLabel: string, unitMode: GridUnitMode): string {
  const lower = metricLabel.toLowerCase();

  // Air pressure always psi, regardless of unit toggle.
  if (lower.includes("pressure")) return "psi";

  // Pushrod travel / drum / rotor / shoe thickness etc.
  if (
    lower.includes("tread") ||
    lower.includes("pad") ||
    lower.includes("shoe") ||
    lower.includes("drum") ||
    lower.includes("rotor") ||
    lower.includes("thickness") ||
    lower.includes("pushrod") ||
    lower.includes("push-rod") ||
    lower.includes("push rod")
  ) {
    return unitMode === "metric" ? "mm" : "in";
  }

  return unitMode === "metric" ? "mm" : "in";
}

interface ValueInputProps {
  value: string | number | null | undefined;
  unit: string;
  showKpaHint?: boolean;
  isPressure?: boolean;
  onChange: (next: string) => void;
}

const ValueInput: React.FC<ValueInputProps> = ({
  value,
  unit,
  showKpaHint,
  isPressure,
  onChange,
}) => {
  const display = value ?? "";

  return (
    <div className="flex items-center gap-2 rounded-xl border border-[color:var(--metal-border-soft)] bg-black/70 px-3 py-1.5 text-xs shadow-[0_10px_25px_rgba(0,0,0,0.9)] backdrop-blur-md">
      <input
        type="number"
        inputMode="decimal"
        className="w-full bg-transparent text-sm text-white placeholder:text-neutral-500 focus:outline-none"
        placeholder="Value"
        value={display}
        onChange={(e) => onChange(e.target.value)}
      />
      <div className="flex flex-col items-end text-[10px] leading-tight text-neutral-400">
        <span>{unit}</span>
        {isPressure && showKpaHint && (
          <span className="text-[9px] text-neutral-500">kPa hint</span>
        )}
      </div>
    </div>
  );
};

interface SideStackProps {
  sideLabel: string; // "Left" / "Right"
  side: AxleSideInputs;
  sectionIndex: number;
  unit: string;
  isPressure: boolean;
  showKpaHint: boolean;
  alignRight?: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

const SideStack: React.FC<SideStackProps> = ({
  sideLabel,
  side,
  sectionIndex,
  unit,
  isPressure,
  showKpaHint,
  alignRight = false,
  onUpdateItem,
}) => {
  const pieces: Array<{ key: string; caption: string; cell: AxleCell }> = [];

  if (side.main) {
    pieces.push({ key: "main", caption: sideLabel, cell: side.main });
  }
  if (side.outer) {
    pieces.push({
      key: "outer",
      caption: `${sideLabel} Outer`,
      cell: side.outer,
    });
  }
  if (side.inner) {
    pieces.push({
      key: "inner",
      caption: `${sideLabel} Inner`,
      cell: side.inner,
    });
  }

  if (!pieces.length) return null;

  return (
    <div className="space-y-1 sm:max-w-[40%]">
      {pieces.map(({ key, caption, cell }) => (
        <div key={key} className="space-y-1">
          <div
            className={`text-[11px] font-medium uppercase tracking-[0.18em] text-neutral-400 ${
              alignRight ? "text-right" : ""
            }`}
          >
            {caption}
          </div>
          <ValueInput
            value={cell.item.value}
            unit={unit}
            isPressure={isPressure}
            showKpaHint={isPressure && showKpaHint}
            onChange={(next) =>
              onUpdateItem(sectionIndex, cell.itemIndex, { value: next })
            }
          />
        </div>
      ))}
    </div>
  );
};

const AxleGrid: React.FC<AxleGridProps> = ({
  title,
  sectionIndex,
  items,
  unitMode,
  showKpaHint,
  onUpdateItem,
  onAddAxle,
}) => {
  const { axles, loose } = buildAxles(items);

  if (axles.length === 0 && loose.length === 0) return null;

  return (
    <section className="space-y-4">
      <div className="flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title ?? "Axle Measurements (Air Brake)"}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Steer, drive, and trailer axles – tire pressure, tread depth,
            push-rod travel, drum/rotor, pads/shoes. Values only.
          </p>
        </div>
        {onAddAxle && (
          <button
            type="button"
            onClick={onAddAxle}
            className="rounded-full bg-[color:var(--accent-copper)] px-3 py-1.5 text-[11px] font-semibold text-black shadow-[0_0_20px_rgba(193,102,59,0.75)] hover:bg-[color:var(--accent-copper-soft)]"
          >
            + Add axle
          </button>
        )}
      </div>

      <div className="space-y-4">
        {axles.map((axle) => (
          <div
            key={axle.axleName}
            className="metal-card rounded-2xl p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)]"
          >
            <div className="mb-3 flex items-center justify-between gap-2">
              <div className="text-xs font-semibold uppercase tracking-[0.18em] text-neutral-400">
                {axle.axleName}
              </div>
            </div>

            {/* Desktop header */}
            <div className="hidden text-[11px] text-neutral-400 sm:grid sm:grid-cols-[minmax(0,1fr)_minmax(0,2fr)_minmax(0,1fr)] sm:gap-2 sm:border-t sm:border-white/10 sm:pt-2">
              <div className="px-2 py-1">Left</div>
              <div className="px-2 py-1 text-center">Item</div>
              <div className="px-2 py-1 text-right">Right</div>
            </div>

            <div className="space-y-3 pt-1">
              {axle.rows.map((row) => {
                const unit = getUnitLabel(row.metricLabel, unitMode);
                const isPressure =
                  row.metricLabel.toLowerCase().includes("pressure");

                return (
                  <div
                    key={row.metricKey}
                    className="rounded-xl border border-white/10 bg-black/65 p-3 backdrop-blur-md"
                  >
                    <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
                      <SideStack
                        sideLabel="Left"
                        side={row.left}
                        sectionIndex={sectionIndex}
                        unit={unit}
                        isPressure={isPressure}
                        showKpaHint={showKpaHint}
                        onUpdateItem={onUpdateItem}
                      />

                      <div className="flex-1 text-center text-sm font-medium text-neutral-100">
                        {row.metricLabel}
                      </div>

                      <SideStack
                        sideLabel="Right"
                        side={row.right}
                        sectionIndex={sectionIndex}
                        unit={unit}
                        isPressure={isPressure}
                        showKpaHint={showKpaHint}
                        alignRight
                        onUpdateItem={onUpdateItem}
                      />
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ))}
      </div>

      {loose.length > 0 && (
        <div className="rounded-xl border border-amber-500/30 bg-amber-950/30 p-3 text-[11px] text-amber-100">
          <div className="mb-1 font-semibold tracking-wide">
            Other axle measurements
          </div>
          <div className="space-y-2">
            {loose.map(({ item, itemIndex }) => {
              const label = item.item ?? item.name ?? "Item";
              const unit = getUnitLabel(label, unitMode);
              const isPressure = label.toLowerCase().includes("pressure");

              return (
                <div key={itemIndex} className="space-y-1">
                  <div className="text-[11px] text-amber-100/80">
                    {label}
                  </div>
                  <ValueInput
                    value={item.value}
                    unit={unit}
                    isPressure={isPressure}
                    showKpaHint={showKpaHint}
                    onChange={(next) =>
                      onUpdateItem(sectionIndex, itemIndex, { value: next })
                    }
                  />
                </div>
              );
            })}
          </div>
        </div>
      )}
    </section>
  );
};

export default AxleGrid;

===== FILE: ./features/inspections/unified/ui/BatteryGrid.tsx =====

"use client";



export interface BatteryMeasurement {
  label: string;
  factoryCca: number | null;
  testedCca: number | null;
  notes?: string;
}

interface BatteryGridProps {
  title?: string;
  batteries: BatteryMeasurement[];
  onChange: (index: number, patch: Partial<BatteryMeasurement>) => void;
  onAddBattery: () => void;
  onRemoveBattery?: (index: number) => void;
}

const BatteryGrid: React.FC<BatteryGridProps> = ({
  title = "Battery Measurements",
  batteries,
  onChange,
  onAddBattery,
  onRemoveBattery,
}) => {
  return (
    <section className="metal-card rounded-2xl p-4 sm:p-5">
      <div className="mb-3 flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Capture factory and tested CCA for each battery. Values only – any
            FAIL / RECOMMEND status is handled in the main inspection sections.
          </p>
        </div>
        <button
          type="button"
          onClick={onAddBattery}
          className="rounded-full bg-[color:var(--accent-copper)] px-3 py-1.5 text-[11px] font-semibold text-black shadow-[0_0_20px_rgba(193,102,59,0.75)] hover:bg-[color:var(--accent-copper-soft)]"
        >
          + Add battery
        </button>
      </div>

      {batteries.length === 0 ? (
        <p className="text-xs text-neutral-400">
          No batteries added yet. Use “Add battery” to start.
        </p>
      ) : (
        <div className="space-y-3">
          {batteries.map((batt, idx) => (
            <div
              key={idx}
              className="rounded-xl border border-white/10 bg-black/65 p-3 shadow-[0_12px_30px_rgba(0,0,0,0.9)] backdrop-blur-md"
            >
              <div className="mb-2 flex items-center justify-between gap-2">
                <div className="flex flex-col">
                  <span className="text-[11px] font-semibold uppercase tracking-[0.18em] text-neutral-400">
                    Battery {idx + 1}
                  </span>
                  <input
                    type="text"
                    className="mt-1 w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="Location / label (Start, Aux, LH, RH...)"
                    value={batt.label}
                    onChange={(e) =>
                      onChange(idx, { label: e.target.value })
                    }
                  />
                </div>

                {onRemoveBattery && batteries.length > 1 && (
                  <button
                    type="button"
                    onClick={() => onRemoveBattery(idx)}
                    className="rounded-full border border-red-500/70 px-2 py-1 text-[10px] font-medium text-red-100 hover:bg-red-500/10"
                  >
                    Remove
                  </button>
                )}
              </div>

              <div className="grid gap-3 text-xs sm:grid-cols-3">
                <div className="space-y-1">
                  <div className="text-[11px] text-neutral-400">
                    Factory CCA
                  </div>
                  <input
                    type="number"
                    inputMode="numeric"
                    className="w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="e.g. 750"
                    value={batt.factoryCca ?? ""}
                    onChange={(e) =>
                      onChange(idx, {
                        factoryCca:
                          e.target.value === ""
                            ? null
                            : Number(e.target.value),
                      })
                    }
                  />
                </div>

                <div className="space-y-1">
                  <div className="text-[11px] text-neutral-400">
                    Tested CCA
                  </div>
                  <input
                    type="number"
                    inputMode="numeric"
                    className="w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="e.g. 680"
                    value={batt.testedCca ?? ""}
                    onChange={(e) =>
                      onChange(idx, {
                        testedCca:
                          e.target.value === ""
                            ? null
                            : Number(e.target.value),
                      })
                    }
                  />
                </div>

                <div className="space-y-1 sm:col-span-1">
                  <div className="text-[11px] text-neutral-400">Notes</div>
                  <textarea
                    rows={2}
                    className="w-full resize-none rounded border border-white/15 bg-black/40 px-2 py-1 text-xs text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="Additional info (age, location, condition...)"
                    value={batt.notes ?? ""}
                    onChange={(e) =>
                      onChange(idx, { notes: e.target.value })
                    }
                  />
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </section>
  );
};

export default BatteryGrid;

===== FILE: ./features/inspections/unified/ui/CornerGrid.tsx =====

"use client";


import type { InspectionItem } from "@inspections/lib/inspection/types";

type GridUnitMode = "metric" | "imperial";
type Side = "left" | "right";
type Variant = "main" | "inner" | "outer";

interface CornerGridProps {
  title?: string;
  sectionIndex: number;
  items: InspectionItem[];
  unitMode: GridUnitMode;
  showKpaHint: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

interface CornerCell {
  itemIndex: number;
  item: InspectionItem;
}

interface CornerSideInputs {
  main?: CornerCell; // LF / RF / LR / RR
  inner?: CornerCell; // LRI / RRI
  outer?: CornerCell; // LRO / RRO
}

interface CornerRow {
  metricKey: string;
  metricLabel: string;
  left: CornerSideInputs;
  right: CornerSideInputs;
}

interface ParsedHydLocation {
  side: Side;
  variant: Variant;
  metric: string;
  metricBase: string;
}

/**
 * Remove "Inner" / "Outer" markup from a metric to group rows,
 * e.g. "Tire Tread (Outer)" + "Tire Tread (Inner)" → "Tire Tread".
 */
function normaliseMetric(metric: string): string {
  return metric
    .replace(/\(\s*(inner|outer)\s*\)/gi, "")
    .replace(/\b(inner|outer)\b/gi, "")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/**
 * Support:
 *  - "LF Tire Pressure"
 *  - "RRI Brake Pad Thickness"
 *  - "Left Front Tire Tread"
 *  - "Right Rear Inner Tire Tread (Outer)"
 */
function parseHydLabel(labelRaw: string): ParsedHydLocation | null {
  const label = labelRaw.trim();
  if (!label) return null;

  // Abbreviated location codes
  const abbrMatch = label.match(
    /^(LF|RF|LR|RR|LRI|LRO|RRI|RRO)\s+(.+)$/i,
  );
  if (abbrMatch) {
    const code = abbrMatch[1].toUpperCase();
    const metric = abbrMatch[2].trim();
    if (!metric) return null;

    const side: Side = code.startsWith("L") ? "left" : "right";
    let variant: Variant = "main";

    if (code.endsWith("I")) variant = "inner";
    if (code.endsWith("O")) variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  // Full text – e.g. "Left Rear Inner Tire Tread"
  const fullMatch = label.match(
    /^(Left|Right)\s+(Front|Rear)(?:\s+(Inner|Outer))?\s+(.+)$/i,
  );
  if (fullMatch) {
    const side: Side = fullMatch[1].toLowerCase() === "left" ? "left" : "right";
    const innerOuter = (fullMatch[3] ?? "").toLowerCase();
    const metric = fullMatch[4].trim();
    if (!metric) return null;

    let variant: Variant = "main";
    if (innerOuter === "inner") variant = "inner";
    if (innerOuter === "outer") variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  return null;
}

function buildRows(items: InspectionItem[]): {
  rows: CornerRow[];
  loose: Array<{ itemIndex: number; item: InspectionItem }>;
} {
  const rowsMap = new Map<string, CornerRow>();
  const loose: Array<{ itemIndex: number; item: InspectionItem }> = [];

  items.forEach((item, idx) => {
    const label = item.item ?? item.name ?? "";
    const parsed = parseHydLabel(label);
    if (!parsed) {
      loose.push({ itemIndex: idx, item });
      return;
    }

    const existing =
      rowsMap.get(parsed.metricBase) ??
      ({
        metricKey: parsed.metricBase,
        metricLabel: parsed.metricBase,
        left: {},
        right: {},
      } as CornerRow);

    const cell: CornerCell = { itemIndex: idx, item };

    if (parsed.side === "left") {
      existing.left[parsed.variant] = cell;
    } else {
      existing.right[parsed.variant] = cell;
    }

    rowsMap.set(parsed.metricBase, existing);
  });

  return { rows: Array.from(rowsMap.values()), loose };
}

function getUnitLabel(metricLabel: string, unitMode: GridUnitMode): string {
  const lower = metricLabel.toLowerCase();

  // Pressure is always psi – unit toggle does not affect this.
  if (lower.includes("pressure")) return "psi";

  // Everything else here is a length/thickness-style measurement.
  if (
    lower.includes("tread") ||
    lower.includes("pad") ||
    lower.includes("rotor") ||
    lower.includes("thickness")
  ) {
    return unitMode === "metric" ? "mm" : "in";
  }

  return unitMode === "metric" ? "mm" : "in";
}

interface ValueInputProps {
  value: string | number | null | undefined;
  unit: string;
  showKpaHint?: boolean;
  isPressure?: boolean;
  placeholder?: string;
  onChange: (next: string) => void;
}

const ValueInput: React.FC<ValueInputProps> = ({
  value,
  unit,
  showKpaHint,
  isPressure,
  placeholder = "Value",
  onChange,
}) => {
  const display = value ?? "";

  return (
    <div className="flex items-center gap-2 rounded-xl border border-[color:var(--metal-border-soft)] bg-black/70 px-3 py-1.5 text-xs shadow-[0_10px_25px_rgba(0,0,0,0.9)] backdrop-blur-md">
      <input
        type="number"
        inputMode="decimal"
        className="w-full bg-transparent text-sm text-white placeholder:text-neutral-500 focus:outline-none"
        placeholder={placeholder}
        value={display}
        onChange={(e) => onChange(e.target.value)}
      />
      <div className="flex flex-col items-end text-[10px] leading-tight text-neutral-400">
        <span>{unit}</span>
        {isPressure && showKpaHint && (
          <span className="text-[9px] text-neutral-500">kPa hint</span>
        )}
      </div>
    </div>
  );
};

interface SideStackProps {
  label: string;
  side: CornerSideInputs;
  sectionIndex: number;
  unit: string;
  isPressure: boolean;
  showKpaHint: boolean;
  alignRight?: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

const SideStack: React.FC<SideStackProps> = ({
  label,
  side,
  sectionIndex,
  unit,
  isPressure,
  showKpaHint,
  alignRight = false,
  onUpdateItem,
}) => {
  const pieces: Array<{ key: string; caption: string; cell: CornerCell }> = [];

  if (side.main) {
    pieces.push({ key: "main", caption: label, cell: side.main });
  }
  if (side.outer) {
    pieces.push({ key: "outer", caption: `${label} Outer`, cell: side.outer });
  }
  if (side.inner) {
    pieces.push({ key: "inner", caption: `${label} Inner`, cell: side.inner });
  }

  if (!pieces.length) return null;

  return (
    <div className="space-y-1 sm:max-w-[40%]">
      {pieces.map(({ key, caption, cell }) => (
        <div key={key} className="space-y-1">
          <div
            className={`text-[11px] font-medium uppercase tracking-[0.18em] text-neutral-400 ${
              alignRight ? "text-right" : ""
            }`}
          >
            {caption}
          </div>
          <ValueInput
            value={cell.item.value}
            unit={unit}
            isPressure={isPressure}
            showKpaHint={isPressure && showKpaHint}
            onChange={(next) =>
              onUpdateItem(sectionIndex, cell.itemIndex, { value: next })
            }
          />
        </div>
      ))}
    </div>
  );
};

const CornerGrid: React.FC<CornerGridProps> = ({
  title,
  sectionIndex,
  items,
  unitMode,
  showKpaHint,
  onUpdateItem,
}) => {
  const { rows, loose } = buildRows(items);

  if (rows.length === 0 && loose.length === 0) return null;

  return (
    <section className="metal-card rounded-2xl p-4 sm:p-5">
      <div className="mb-3 flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title ?? "Measurements (Hydraulic)"}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Corner-based measurements: tire pressure, tread depth, pad / rotor
            thickness. Values only – statuses live in other sections.
          </p>
        </div>
      </div>

      {/* Desktop header */}
      <div className="hidden text-[11px] text-neutral-400 sm:grid sm:grid-cols-[minmax(0,1fr)_minmax(0,2fr)_minmax(0,1fr)] sm:gap-2 sm:border-t sm:border-white/10 sm:pt-3">
        <div className="px-2 py-1">Left</div>
        <div className="px-2 py-1 text-center">Item</div>
        <div className="px-2 py-1 text-right">Right</div>
      </div>

      <div className="space-y-3 pt-1">
        {rows.map((row) => {
          const unit = getUnitLabel(row.metricLabel, unitMode);
          const isPressure = row.metricLabel.toLowerCase().includes("pressure");

          return (
            <div
              key={row.metricKey}
              className="rounded-xl border border-white/10 bg-black/60 p-3 shadow-[0_12px_30px_rgba(0,0,0,0.9)] backdrop-blur-md"
            >
              <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
                <SideStack
                  label="Left"
                  side={row.left}
                  sectionIndex={sectionIndex}
                  unit={unit}
                  isPressure={isPressure}
                  showKpaHint={showKpaHint}
                  onUpdateItem={onUpdateItem}
                />

                <div className="flex-1 text-center text-sm font-medium text-neutral-100">
                  {row.metricLabel}
                </div>

                <SideStack
                  label="Right"
                  side={row.right}
                  sectionIndex={sectionIndex}
                  unit={unit}
                  isPressure={isPressure}
                  showKpaHint={showKpaHint}
                  alignRight
                  onUpdateItem={onUpdateItem}
                />
              </div>
            </div>
          );
        })}
      </div>

      {loose.length > 0 && (
        <div className="mt-4 rounded-xl border border-amber-500/30 bg-amber-950/30 p-3 text-[11px] text-amber-100">
          <div className="mb-1 font-semibold tracking-wide">
            Other measurements
          </div>
          <div className="space-y-2">
            {loose.map(({ item, itemIndex }) => {
              const label = item.item ?? item.name ?? "Item";
              const unit = getUnitLabel(label, unitMode);
              const isPressure = label.toLowerCase().includes("pressure");

              return (
                <div key={itemIndex} className="space-y-1">
                  <div className="text-[11px] text-amber-100/80">
                    {label}
                  </div>
                  <ValueInput
                    value={item.value}
                    unit={unit}
                    isPressure={isPressure}
                    showKpaHint={showKpaHint}
                    onChange={(next) =>
                      onUpdateItem(sectionIndex, itemIndex, { value: next })
                    }
                  />
                </div>
              );
            })}
          </div>
        </div>
      )}
    </section>
  );
};

export default CornerGrid;

===== FILE: ./features/inspections/unified/ui/InspectionActionBar.tsx =====

"use client";



type Props = {
  onSave?: () => void;
  onFinish?: () => void;
  onStartVoice?: () => void;
  onStopVoice?: () => void;
  isListening?: boolean;
};

export default function InspectionActionBar({
  onSave,
  onFinish,
  onStartVoice,
  onStopVoice,
  isListening,
}: Props) {
  return (
    <div className="flex flex-wrap items-center justify-between gap-2 rounded-xl border border-white/10 bg-black/40 p-3 text-xs">
      <div className="font-semibold text-neutral-200">Inspection actions</div>
      <div className="flex gap-2">
        <button
          type="button"
          onClick={onSave}
          className="rounded bg-neutral-800 px-3 py-1 text-xs text-white"
        >
          Save
        </button>
        <button
          type="button"
          onClick={onFinish}
          className="rounded bg-orange-600 px-3 py-1 text-xs text-white"
        >
          Finish
        </button>
        {isListening ? (
          <button
            type="button"
            onClick={onStopVoice}
            className="rounded bg-red-600 px-3 py-1 text-xs text-white"
          >
            Stop voice
          </button>
        ) : (
          <button
            type="button"
            onClick={onStartVoice}
            className="rounded bg-green-600 px-3 py-1 text-xs text-white"
          >
            Start voice
          </button>
        )}
      </div>
    </div>
  );
}


===== FILE: ./features/inspections/unified/ui/InspectionHeader.tsx =====

"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";

type Props = {
  session: InspectionSession;
};

export default function InspectionHeader({ session }: Props) {
  return (
    <div className="flex flex-col gap-1 rounded-xl border border-white/10 bg-black/40 p-3 text-xs text-neutral-200">
      <div className="text-sm font-semibold text-orange-400">
        {session.templateName || "Inspection"}
      </div>
      <div>
        Vehicle:{" "}
        {session.vehicle?.year} {session.vehicle?.make}{" "}
        {session.vehicle?.model}
      </div>
      <div>Customer: {session.customer?.first_name} {session.customer?.last_name}</div>
      <div>Status: {session.status}</div>
    </div>
  );
}


===== FILE: ./features/inspections/unified/ui/InspectionSummary.tsx =====

"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";

type Props = {
  session: InspectionSession;
};

export default function InspectionSummary({ session }: Props) {
  const sections = session.sections ?? [];
  const totalItems = sections.reduce(
    (sum, s) => sum + (s.items?.length ?? 0),
    0,
  );

  return (
    <div className="rounded-xl border border-white/10 bg-black/40 p-3 text-xs text-neutral-200">
      <div className="mb-1 text-sm font-semibold text-orange-400">
        Quick summary
      </div>
      <div>Sections: {sections.length}</div>
      <div>Items: {totalItems}</div>
      <div>Status: {session.status}</div>
    </div>
  );
}


===== FILE: ./features/inspections/unified/ui/InspectionUnifiedScreen.tsx =====

"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";
import SectionRenderer from "./SectionRenderer";

type Props = {
  session: InspectionSession;
  onUpdateSession: (patch: Partial<InspectionSession>) => void;
};

export default function InspectionUnifiedScreen({ session, onUpdateSession }: Props) {
  // thin stub – we’ll wire real logic later
  return (
    <div className="flex flex-col gap-4">
      <h1 className="text-xl font-semibold text-orange-400">
        Unified Inspection (beta)
      </h1>
      <SectionRenderer
        sections={session.sections ?? []}
        onUpdateItem={(sectionIndex, itemIndex, patch) => {
          const next = { ...(session as InspectionSession) };
          const sections = [...(next.sections ?? [])];
          if (!sections[sectionIndex]) return;
          const items = [...(sections[sectionIndex].items ?? [])];
          if (!items[itemIndex]) return;
          items[itemIndex] = { ...items[itemIndex], ...patch };
          sections[sectionIndex] = { ...sections[sectionIndex], items };
          onUpdateSession({ sections });
        }}
      />
    </div>
  );
}


===== FILE: ./features/inspections/unified/ui/SectionRenderer.tsx =====

"use client";


import type {
  InspectionSection,
  InspectionItem,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/unified/ui/CornerGrid";
import AxleGrid from "@inspections/unified/ui/AxleGrid";
import SectionDisplay from "@inspections/unified/SectionDisplay";

type Props = {
  sections: InspectionSection[];
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
};

// Steer / Drive / Trailer Left|Right ...
const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
// LF / RF / LR / RR ...
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
// Left Front / Right Rear ...
const HYD_FULL_RE =
  /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

function detectLayout(items: InspectionItem[]): "air" | "hyd" | "plain" {
  let airMatches = 0;
  let hydMatches = 0;

  for (const it of items) {
    const label = it.item ?? it.name ?? "";
    if (!label) continue;

    if (AIR_RE.test(label)) airMatches += 1;
    if (HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label)) hydMatches += 1;
  }

  if (airMatches > 0) return "air";
  if (hydMatches > 0) return "hyd";
  return "plain";
}

export default function SectionRenderer({ sections, onUpdateItem }: Props) {
  return (
    <div className="flex flex-col gap-4">
      {sections.map((section, sectionIndex) => {
        const items = section.items ?? [];
        const layout = detectLayout(items);

        // HYDRAULIC CORNER GRID (LF/RF/LR/RR + metrics)
        if (layout === "hyd") {
          return (
            <CornerGrid
              key={`${sectionIndex}-${section.title || "hyd"}`}
              sectionIndex={sectionIndex}
              items={items}
              onUpdateItem={onUpdateItem}
            />
          );
        }

        // AIR / AXLE GRID (Steer / Drive / Trailer Left/Right + metrics)
        if (layout === "air") {
          return (
            <AxleGrid
              key={`${sectionIndex}-${section.title || "air"}`}
              sectionIndex={sectionIndex}
              items={items}
              onUpdateItem={onUpdateItem}
            />
          );
        }

        // GENERIC “CARD” SECTION – unified theme, no legacy imports
        return (
          <SectionDisplay
            key={`${sectionIndex}-${section.title || "plain"}`}
            title={section.title ?? `Section ${sectionIndex + 1}`}
            section={section}
            sectionIndex={sectionIndex}
            showNotes
            showPhotos
            onUpdateStatus={(
              secIdx: number,
              itemIdx: number,
              status: InspectionItemStatus,
            ) => onUpdateItem(secIdx, itemIdx, { status })}
            onUpdateNote={(
              secIdx: number,
              itemIdx: number,
              note: string,
            ) => onUpdateItem(secIdx, itemIdx, { notes: note })}
            onUpload={(
              photoUrl: string,
              secIdx: number,
              itemIdx: number,
            ) => {
              const item = sections[secIdx]?.items?.[itemIdx];
              const existing = (item?.photoUrls ?? []) as string[];
              onUpdateItem(secIdx, itemIdx, {
                photoUrls: [...existing, photoUrl],
              });
            }}
          />
        );
      })}
    </div>
  );
}

===== FILE: ./features/inspections/unified/voice/commandMapper.ts =====

import type { VoiceCommand } from "./voiceTypes";
import type {
  InspectionSession,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";

type UpdateSessionFn = (patch: Partial<InspectionSession>) => void;

export function applyVoiceCommands(
  commands: VoiceCommand[],
  session: InspectionSession,
  updateSession: UpdateSessionFn,
) {
  // stub that does nothing yet – safe placeholder
  console.debug("applyVoiceCommands (stub)", commands.length);
}


===== FILE: ./features/inspections/unified/voice/interpretTranscript.ts =====

import type { VoiceCommand } from "./voiceTypes";

/**
 * Thin wrapper around your AI interpreter (to be implemented).
 * For now we just return an empty array.
 */
export async function interpretTranscript(
  transcript: string,
): Promise<VoiceCommand[]> {
  console.debug("interpretTranscript (stub)", transcript);
  return [];
}


===== FILE: ./features/inspections/unified/voice/VoiceInspectionController.tsx =====

"use client";

import { useState } from "react";
import type { InspectionSession } from "@inspections/lib/inspection/types";
import { interpretTranscript } from "./interpretTranscript";
import { applyVoiceCommands } from "./commandMapper";

type Props = {
  session: InspectionSession;
  onUpdateSession: (patch: Partial<InspectionSession>) => void;
};

export default function VoiceInspectionController({ session, onUpdateSession }: Props) {
  const [isListening, setIsListening] = useState(false);

  // We'll wire browser SpeechRecognition here later
  const handleFakeTranscript = async () => {
    const transcript = "dummy transcript";
    const cmds = await interpretTranscript(transcript);
    applyVoiceCommands(cmds, session, onUpdateSession);
  };

  return (
    <div className="mt-2 text-xs text-neutral-300">
      <button
        type="button"
        onClick={handleFakeTranscript}
        className="rounded bg-neutral-800 px-3 py-1 text-xs text-white"
      >
        Test voice (stub)
      </button>
    </div>
  );
}


===== FILE: ./features/inspections/unified/voice/voiceTypes.ts =====

export type VoiceCommandType =
  | "update_status"
  | "measurement"
  | "add_note"
  | "recommend"
  | "complete_item";

export type VoiceCommand = {
  type: VoiceCommandType;
  raw: string;
  sectionName?: string;
  itemName?: string;
  value?: string | number;
  unit?: string;
  status?: string;
  note?: string;
};


