import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database, Json } from "@shared/types/types/supabase";
import { ProFixAI, type QuoteEnginePart } from "@/features/integrations/ai";

type DB = Database;

type ConfidenceLevel = "low" | "medium" | "high";

// Keep the response structured and easy to consume
export type AISuggestion = {
  parts: { name: string; qty?: number; cost?: number; notes?: string }[];
  laborHours: number;
  laborRate?: number;
  summary: string;
  confidence?: ConfidenceLevel;
  price?: number;
  notes?: string;
  title?: string;
};

interface VehicleInput {
  year?: string | number | null;
  make?: string | null;
  model?: string | null;
  vin?: string | null;
}

interface RequestBody {
  item: string;
  notes?: string;
  section: string;
  status: string;
  value?: string;
  unit?: string;
  vehicle?: VehicleInput | null;
}

function isRequestBody(value: unknown): value is RequestBody {
  if (typeof value !== "object" || value === null) return false;
  const obj = value as Record<string, unknown>;
  return (
    typeof obj.item === "string" &&
    typeof obj.section === "string" &&
    typeof obj.status === "string"
  );
}

function mapConfidence(score: number): ConfidenceLevel {
  if (score >= 0.75) return "high";
  if (score >= 0.5) return "medium";
  return "low";
}

function buildVehicleYmm(vehicle?: VehicleInput | null): string | null {
  if (!vehicle) return null;

  const year =
    vehicle.year !== undefined && vehicle.year !== null
      ? String(vehicle.year)
      : "";
  const make = vehicle.make ?? "";
  const model = vehicle.model ?? "";

  const combined = [year, make, model].join(" ").trim();
  return combined.length > 0 ? combined : null;
}

function buildComplaint(input: RequestBody): string {
  const parts: string[] = [];

  if (input.section) {
    parts.push(`[${input.section}]`);
  }

  if (input.status) {
    parts.push(`Status: ${input.status}`);
  }

  parts.push(input.item);

  if (typeof input.notes === "string" && input.notes.trim().length > 0) {
    parts.push(`Notes: ${input.notes.trim()}`);
  }

  if (input.value) {
    const valuePart = input.unit ? `${input.value} ${input.unit}` : input.value;
    parts.push(`Value: ${valuePart}`);
  }

  return parts.join(" | ");
}

export async function POST(req: Request) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    const rawBody: unknown = await req.json();
    if (!isRequestBody(rawBody)) {
      return NextResponse.json(
        { error: "Invalid request body" },
        { status: 400 },
      );
    }

    const body: RequestBody = rawBody;
    const { item, notes, section, status, vehicle } = body;

    // Resolve shopId from the authenticated user (if available)
    let shopId: string | null = null;
    try {
      const {
        data: { session },
      } = await supabase.auth.getSession();

      const userId = session?.user?.id ?? null;
      if (userId) {
        const { data: profile } = await supabase
          .from("profiles")
          .select("shop_id")
          .eq("user_id", userId)
          .maybeSingle();

        if (profile?.shop_id) {
          shopId = profile.shop_id;
        }
      }
    } catch (resolveErr) {
      // Do not block suggestion if shop resolution fails
      console.warn(
        "[AI] Failed to resolve shopId for quote-suggest:",
        resolveErr,
      );
    }

    const complaint = buildComplaint(body);
    const vehicleYmm = buildVehicleYmm(vehicle);

    // Call central AI engine
    const aiResult = await ProFixAI.suggestQuote({
      shopId: shopId ?? "unknown_shop",
      vehicleYmm,
      complaint,
    });

    const baseSummary =
      typeof notes === "string" && notes.trim().length > 0
        ? notes.trim()
        : item;

    let suggestion: AISuggestion;

    if (aiResult) {
      suggestion = {
        parts: aiResult.parts.map((p: QuoteEnginePart) => ({
          name: p.description || "Suggested part",
          qty: p.qty,
          cost: p.price,
          notes: p.partId ? `Part ID: ${p.partId}` : undefined,
        })),
        laborHours: aiResult.laborHours,
        summary: baseSummary,
        confidence: mapConfidence(aiResult.confidence),
      };
    } else {
      // Fallback: minimal but valid suggestion
      suggestion = {
        parts: [],
        laborHours: 0.5,
        summary: baseSummary,
        confidence: "low",
      };
    }

    // Persist the inference into ai_events (best-effort; ignore failures)
    try {
      const vehiclePayload =
        vehicle !== undefined && vehicle !== null
          ? {
              year: vehicle.year ?? null,
              make: vehicle.make ?? null,
              model: vehicle.model ?? null,
              vin: vehicle.vin ?? null,
            }
          : null;

      const payload: Json = {
        input: {
          item,
          notes: notes ?? null,
          section,
          status,
          value: body.value ?? null,
          unit: body.unit ?? null,
          vehicle: vehiclePayload,
          complaint,
        },
        output: suggestion,
      } as unknown as Json;

      await supabase.from("ai_events").insert({
        event_type: "quote_suggest",
        payload,
        shop_id: shopId,
        entity_id: null,
        entity_table: "inspection_results",
      });
    } catch (logErr) {
      console.warn("[AI] Failed to log quote-suggest event:", logErr);
    }

    return NextResponse.json({ suggestion });
  } catch (err) {
    // eslint-disable-next-line no-console
    console.error("quote-suggest error:", err);
    return NextResponse.json(
      { error: "AI suggestion failed" },
      { status: 500 },
    );
  }
}
import { NextResponse } from "next/server";
import masterServicesList from "@/features/inspections/lib/inspection/masterServicesList";

type JobType = "maintenance" | "repair" | "diagnosis" | "inspection";

interface VehicleContext {
  year?: string | number | null;
  make?: string | null;
  model?: string | null;
  mileage?: string | number | null;
}

// ---------------- mileage rules ----------------
function getMileageRecommendations(mileage: number | null | undefined): string[] {
  if (mileage == null || Number.isNaN(mileage)) return [];
  const mi = mileage;

  const rec: string[] = [];
  if (mi >= 5_000) rec.push("oil"); // ‚ÄúEngine oil and filter change‚Äù
  if (mi >= 20_000) rec.push("tire rotation", "brake inspection");
  if (mi >= 50_000) rec.push("transmission", "differential", "transfer case");
  if (mi >= 100_000) rec.push("coolant", "fuel filter");
  if (mi >= 150_000) rec.push("timing", "major inspection");
  return rec;
}

// ---------------- vehicle heuristics ----------------
function detectKind(v: VehicleContext | null): {
  isDiesel: boolean;
  isHeavyDuty: boolean;
  isCommercial: boolean;
  hint: string;
  mileageNumber: number | null;
} {
  const make = (v?.make ?? "").toLowerCase();
  const model = (v?.model ?? "").toLowerCase();
  const yearStr = v?.year != null ? String(v.year) : "";
  const hintParts = [yearStr, v?.make, v?.model].filter(Boolean);
  const hint = hintParts.length ? ` (${hintParts.join(" ")})` : "";

  // Simple diesel detection
  const dieselMarkers = ["diesel", "tdi", "power stroke", "duramax", "cummins"];
  const isDiesel =
    dieselMarkers.some((m) => model.includes(m) || make.includes(m)) ||
    /2500|3500|4500|5500/.test(model);

  // Heavy duty pickup / chassis
  const isHeavyDuty =
    /f[- ]?250|f[- ]?350|2500|3500|4500|5500|ram\s?(25|35|45|55)00|silverado\s?(25|35)00|sierra\s?(25|35)00/i.test(
      `${make} ${model}`,
    );

  // Commercial vans / fleet
  const isCommercial =
    /(sprinter|transit|promaster|express|savanna|nv200|e-?series)/i.test(model) ||
    /cvip|fleet|cube|cargo/i.test(model);

  const mileageNumber = v?.mileage != null ? Number(v.mileage) : null;

  return { isDiesel, isHeavyDuty, isCommercial, hint, mileageNumber };
}

// helper: fuzzy match into master list
function pickByKeywords(keywords: string[]): string[] {
  const picks: string[] = [];
  for (const cat of masterServicesList) {
    for (const it of cat.items) {
      const li = it.item.toLowerCase();
      if (keywords.some((k) => li.includes(k.toLowerCase()))) {
        picks.push(it.item);
      }
    }
  }
  // de-dupe while preserving order
  return Array.from(new Set(picks));
}

export async function POST(req: Request) {
  try {
    const body = (await req.json()) as {
      prompt?: string | null;
      vehicle?: VehicleContext | null;
    };

    const v = body.vehicle ?? null;
    const { isDiesel, isHeavyDuty, isCommercial, hint, mileageNumber } = detectKind(v);
    const userPrompt = String(body.prompt ?? "").trim().toLowerCase();

    // ---------- A/B: build suggestions ----------
    // 1) Prompt ‚Üí repair/diagnosis phrasing (very basic contains for now)
    const promptMatches =
      userPrompt.length === 0
        ? []
        : masterServicesList.flatMap((category) =>
            category.items
              .filter((i) => i.item.toLowerCase().includes(userPrompt))
              .map((i) => ({
                name: `${i.item}${hint}`,
                jobType: "repair" as const,
                laborHours: 1.0,
                notes: `Based on issue: ${body.prompt}`,
              })),
          );

    // 2) Mileage rules ‚Üí maintenance
    const mileageKeys = getMileageRecommendations(mileageNumber);
    const mileageItems = pickByKeywords(mileageKeys);
    const mileageMatches = mileageItems.map((name) => ({
      name: `${name}${hint}`,
      jobType: "maintenance" as JobType,
      laborHours: 1.0,
      notes: v?.mileage != null ? `Recommended at ~${v.mileage} km/mi` : "Mileage-based recommendation",
    }));

    // 3) Diesel / Heavy-duty / Commercial heuristics
    const dieselKeys = isDiesel ? ["DEF", "DPF", "EGR", "diesel fuel filter", "water separator"] : [];
    const hdKeys = isHeavyDuty ? ["Grease chassis (heavy-duty)", "Push rod travel", "5th wheel", "brake shoes"] : [];
    const commKeys = isCommercial ? ["CVIP", "Annual safety inspection"] : [];
    const kindItems = pickByKeywords([...dieselKeys, ...hdKeys, ...commKeys]);
    const kindMatches = kindItems.map((name) => ({
      name: `${name}${hint}`,
      jobType: name.toLowerCase().includes("inspection") ? ("inspection" as JobType) : ("maintenance" as JobType),
      laborHours: 1.0,
      notes: isDiesel
        ? "Diesel/HD recommendation"
        : isHeavyDuty
        ? "Heavy-duty maintenance"
        : "Commercial/fleet maintenance",
    }));

    // ---------- D: fallback ----------
    const fallback =
      promptMatches.length || mileageMatches.length || kindMatches.length
        ? []
        : ([
            {
              name: `General inspection${hint}`,
              jobType: "inspection" as JobType,
              laborHours: 1.0,
              notes: "Multi-point inspection",
            },
            {
              name: `Oil & filter service${hint}`,
              jobType: "maintenance" as JobType,
              laborHours: 0.8,
              notes: "Basic preventative maintenance",
            },
          ] satisfies { name: string; jobType: JobType; laborHours: number; notes: string }[]);

    const items = [...promptMatches, ...mileageMatches, ...kindMatches, ...fallback].slice(0, 8);

    return NextResponse.json({ items });
  } catch (err) {
    return NextResponse.json(
      { error: err instanceof Error ? err.message : "AI Suggest failed" },
      { status: 400 },
    );
  }
}import { NextResponse } from "next/server";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import type { Database } from "@shared/types/types/supabase";
import { recordWorkOrderTraining } from "@/features/integrations/ai";

type DB = Database;

function getIdFromUrl(url: string): string | null {
  const parts = new URL(url).pathname.split("/"); // ["", "api", "work-orders", "<id>", "ai-review"]
  return parts.length >= 5 ? parts[3] : null;
}

function isError(x: unknown): x is Error {
  return typeof x === "object" && x !== null && "message" in x;
}

export async function POST(req: Request) {
  const supabase = createRouteHandlerClient<DB>({ cookies });
  const woId = getIdFromUrl(req.url);

  if (!woId) {
    return NextResponse.json(
      {
        ok: false,
        issues: [{ kind: "bad_request", message: "Missing work order id" }],
      },
      { status: 400 },
    );
  }

  try {
    const { data: wo, error: woErr } = await supabase
      .from("work_orders")
      .select("*")
      .eq("id", woId)
      .maybeSingle();

    if (woErr) throw woErr;
    if (!wo) {
      return NextResponse.json(
        {
          ok: false,
          issues: [{ kind: "missing_wo", message: "WO not found" }],
        },
        { status: 404 },
      );
    }

    const { data: lines, error: lnErr } = await supabase
      .from("work_order_lines")
      .select("*")
      .eq("work_order_id", wo.id);

    if (lnErr) throw lnErr;

    const issues: { kind: string; lineId?: string; message: string }[] = [];

    for (const ln of lines ?? []) {
      const st = String(ln.status ?? "awaiting");

      if (st !== "completed") {
        issues.push({
          kind: "line_not_completed",
          lineId: ln.id,
          message: `Line not completed: ${
            ln.description ?? ln.complaint ?? "job"
          }`,
        });
      }

      // optional ‚Äúmarked N/A‚Äù booleans if you add them later; kept narrow without any
      const causeNA =
        (ln as Record<string, unknown>)["cause_marked_na"] === true;
      const correctionNA =
        (ln as Record<string, unknown>)["correction_marked_na"] === true;

      if (!ln.cause && !causeNA) {
        issues.push({
          kind: "missing_cause",
          lineId: ln.id,
          message: `Missing cause: ${ln.description ?? "job"}`,
        });
      }

      if (!ln.correction && !correctionNA) {
        issues.push({
          kind: "missing_correction",
          lineId: ln.id,
          message: `Missing correction: ${ln.description ?? "job"}`,
        });
      }

      if (!(typeof ln.labor_time === "number" && ln.labor_time > 0)) {
        issues.push({
          kind: "no_labor_time",
          lineId: ln.id,
          message: `No labor time set: ${ln.description ?? "job"}`,
        });
      }
    }

    if (!wo.customer_id) {
      issues.push({
        kind: "missing_customer",
        message: "Missing customer on WO",
      });
    } else {
      const { data: cust } = await supabase
        .from("customers")
        .select("email")
        .eq("id", wo.customer_id)
        .maybeSingle();

      if (!cust?.email) {
        issues.push({
          kind: "missing_email",
          message: "Customer has no email",
        });
      }
    }

    const ok = issues.length === 0;

    // üîé AI training hook: log each AI review run as a training event
    if (wo.shop_id) {
      try {
        await recordWorkOrderTraining({
          shopId: wo.shop_id,
          workOrderId: wo.id,
          vehicleYmm: null, // TODO: hydrate from vehicles table if you want Y/M/M context
          payload: {
            kind: "ai_review",
            ok,
            issue_count: issues.length,
            issues,
          },
        });
      } catch (trainErr) {
        // Never block users on training/logging problems
        console.warn("AI training (ai-review) failed:", trainErr);
      }
    }

    return NextResponse.json({ ok, issues });
  } catch (e: unknown) {
    const msg = isError(e) ? e.message : "AI review failed";
    return NextResponse.json(
      { ok: false, issues: [{ kind: "error", message: msg }] },
      { status: 500 },
    );
  }
}
// app/api/work-orders/quotes/[id]/mark-quoted/route.ts
import "server-only";
import { NextResponse, type NextRequest } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

export const runtime = "nodejs";

type DB = Database;

export async function PATCH(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    // Extract `[id]` from the pathname .../quotes/<id>/mark-quoted
    const segments = req.nextUrl.pathname.split("/").filter(Boolean);
    const id = segments[segments.length - 2]; // segment before "mark-quoted"

    if (!id) {
      return NextResponse.json({ error: "Missing quote line id" }, { status: 400 });
    }

    // Mark the quote line as quoted
    const { error: updErr } = await supabase
      .from("work_order_quote_lines")
      .update({ status: "quoted", updated_at: new Date().toISOString() })
      .eq("id", id);

    if (updErr) {
      return NextResponse.json({ error: updErr.message }, { status: 500 });
    }

    return NextResponse.json({ ok: true });
  } catch {
    return NextResponse.json({ error: "Failed to mark as quoted" }, { status: 500 });
  }
}// app/api/work-orders/quotes/[id]/authorize/route.ts
import "server-only";
import { NextResponse, type NextRequest } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database, TablesInsert } from "@shared/types/types/supabase";

export const runtime = "nodejs";

type DB = Database;
type WorkOrderLineInsert = TablesInsert<"work_order_lines">;

export async function POST(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    // Extract `[id]` from the pathname .../quotes/<id>/authorize
    const segments = req.nextUrl.pathname.split("/").filter(Boolean);
    const id = segments[segments.length - 2]; // the segment before "authorize"

    if (!id) {
      return NextResponse.json({ error: "Missing quote line id" }, { status: 400 });
    }

    // 1) Load the quote line we‚Äôre authorizing
    const { data: q, error: qErr } = await supabase
      .from("work_order_quote_lines")
      .select("*")
      .eq("id", id)
      .single();

    if (qErr || !q) {
      return NextResponse.json({ error: "Quote line not found" }, { status: 404 });
    }

    // 2) Turn it into a punchable job line
    const newLine: WorkOrderLineInsert = {
      work_order_id: q.work_order_id,
      vehicle_id: q.vehicle_id,
      description: q.description,
      job_type: q.job_type ?? "repair",
      status: "queued",
      labor_time: q.est_labor_hours ?? null,
      complaint: q.ai_complaint ?? q.description,
      cause: q.ai_cause ?? null,
      correction: q.ai_correction ?? null,
    };

    const { data: inserted, error: insErr } = await supabase
      .from("work_order_lines")
      .insert(newLine)
      .select("id")
      .single();

    if (insErr) {
      return NextResponse.json({ error: insErr.message }, { status: 500 });
    }

    // 3) Mark quote line as converted
    const { error: updErr } = await supabase
      .from("work_order_quote_lines")
      .update({ status: "converted", updated_at: new Date().toISOString() })
      .eq("id", id);

    if (updErr) {
      return NextResponse.json({ error: updErr.message }, { status: 500 });
    }

    return NextResponse.json({ ok: true, jobLineId: inserted?.id ?? null });
  } catch {
    return NextResponse.json({ error: "Failed to authorize" }, { status: 500 });
  }
}import "server-only";
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;

export async function POST(req: Request) {
  const supabase = createServerComponentClient<DB>({ cookies });
  try {
    const { workOrderId, vehicleId, items } = await req.json() as {
      workOrderId: string;
      vehicleId?: string | null;
      items: Array<{
        description: string;
        jobType?: "diagnosis"|"repair"|"maintenance"|"tech-suggested";
        estLaborHours?: number;
        notes?: string;
        aiComplaint?: string;
        aiCause?: string;
        aiCorrection?: string;
      }>;
    };

    if (!workOrderId || !Array.isArray(items) || items.length === 0) {
      return NextResponse.json({ error: "Missing workOrderId or items" }, { status: 400 });
    }

    const { data: { user } } = await supabase.auth.getUser();
    const suggested_by = user?.id ?? null;

    const rows = items.map(i => ({
      work_order_id: workOrderId,
      vehicle_id: vehicleId ?? null,
      suggested_by,
      description: i.description,
      job_type: i.jobType ?? "tech-suggested",
      est_labor_hours: i.estLaborHours ?? null,
      notes: i.notes ?? null,
      status: "pending_parts",
      ai_complaint: i.aiComplaint ?? null,
      ai_cause: i.aiCause ?? null,
      ai_correction: i.aiCorrection ?? null,
    }));

    const { error } = await supabase.from("work_order_quote_lines").insert(rows);
    if (error) return NextResponse.json({ error: error.message }, { status: 500 });

    return NextResponse.json({ ok: true });
  } catch {
    return NextResponse.json({ error: "Failed to add quote items" }, { status: 500 });
  }
}// app/api/work-orders/suggest-lines/route.ts
import "server-only";
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { openai } from "lib/server/openai";

export const runtime = "nodejs";

type DB = Database;

type VehicleLite = {
  id: string | null;
  year: string | null;
  make: string | null;
  model: string | null;
};

type ReqBody =
  | { jobId: string; vehicleId?: VehicleLite | string | null }
  | { workOrderId: string; vehicleId?: VehicleLite | string | null };

type Suggestion = {
  name: string;
  laborHours: number;
  jobType: "diagnosis" | "repair" | "maintenance" | "tech-suggested";
  notes: string;
  aiComplaint?: string;
  aiCause?: string;
  aiCorrection?: string;
};

function isVehicleLite(v: unknown): v is VehicleLite {
  if (typeof v !== "object" || v === null) return false;
  const o = v as Record<string, unknown>;
  return (
    "id" in o &&
    "year" in o &&
    "make" in o &&
    "model" in o &&
    (o.id === null || typeof o.id === "string") &&
    (o.year === null || typeof o.year === "string") &&
    (o.make === null || typeof o.make === "string") &&
    (o.model === null || typeof o.model === "string")
  );
}

function coerceSuggestion(u: unknown): Suggestion | null {
  if (typeof u !== "object" || u === null) return null;
  const o = u as Record<string, unknown>;

  const name = typeof o.name === "string" ? o.name : null;
  const laborHours =
    typeof o.laborHours === "number" && Number.isFinite(o.laborHours)
      ? o.laborHours
      : null;
  const jobType =
    o.jobType === "diagnosis" ||
    o.jobType === "repair" ||
    o.jobType === "maintenance" ||
    o.jobType === "tech-suggested"
      ? o.jobType
      : null;
  const notes = typeof o.notes === "string" ? o.notes : "";

  if (!name || laborHours === null || !jobType) return null;

  const aiComplaint =
    typeof o.aiComplaint === "string" ? o.aiComplaint : undefined;
  const aiCause = typeof o.aiCause === "string" ? o.aiCause : undefined;
  const aiCorrection =
    typeof o.aiCorrection === "string" ? o.aiCorrection : undefined;

  return { name, laborHours, jobType, notes, aiComplaint, aiCause, aiCorrection };
}

export async function POST(req: Request) {
  const supabase = createServerComponentClient<DB>({ cookies });

  try {
    const body = (await req.json()) as ReqBody;

    // Gather context
    let complaint: string | null = null;
    let vehicle: VehicleLite | null = null;

    if ("jobId" in body) {
      const { data: line } = await supabase
        .from("work_order_lines")
        .select("complaint, vehicle_id, vehicles:vehicle_id ( year, make, model )")
        .eq("id", body.jobId)
        .single();

      if (line?.complaint) complaint = line.complaint;

      // Prefer explicit vehicleId passed in the request, else derive from the joined record
      if (isVehicleLite(body.vehicleId)) {
        vehicle = body.vehicleId;
      } else if (line?.vehicles) {
        const v = line.vehicles as unknown as { year: number | null; make: string | null; model: string | null };
        vehicle = {
          id: (line as unknown as { vehicle_id: string | null }).vehicle_id ?? null,
          year: v?.year != null ? String(v.year) : null,
          make: v?.make ?? null,
          model: v?.model ?? null,
        };
      }
    } else if ("workOrderId" in body) {
      // Pull minimal context from the work order (first line complaint if present)
      const { data: lines } = await supabase
        .from("work_order_lines")
        .select("complaint, vehicle_id")
        .eq("work_order_id", body.workOrderId)
        .order("created_at", { ascending: true })
        .limit(1);

      if (lines && lines.length > 0) {
        complaint = lines[0]?.complaint ?? null;
      }

      if (isVehicleLite(body.vehicleId)) {
        vehicle = body.vehicleId;
      }
    }

    // Compose prompt
    const vStr =
      vehicle && (vehicle.make || vehicle.model || vehicle.year)
        ? `${vehicle.year ?? ""} ${vehicle.make ?? ""} ${vehicle.model ?? ""}`.trim()
        : "Unknown vehicle";

    const userContext =
      [
        complaint ? `Complaint: ${complaint}` : null,
        vehicle ? `Vehicle: ${vStr}` : null,
      ]
        .filter(Boolean)
        .join("\n") || "No complaint provided. Vehicle unknown.";

    const system = [
      "You are a service advisor assistant for an auto shop.",
      "Return a JSON array of 3-6 suggested jobs related to the complaint and vehicle.",
      "Each item must have fields: name (string), laborHours (number), jobType ('diagnosis'|'repair'|'maintenance'|'tech-suggested'), notes (string).",
      "When helpful, include aiComplaint, aiCause, aiCorrection to pre-fill story text.",
      "Keep laborHours realistic; do not exceed 8 hours for a single item.",
      "Only output raw JSON (no markdown).",
    ].join(" ");

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      temperature: 0.4,
      messages: [
        { role: "system", content: system },
        { role: "user", content: userContext },
      ],
      max_tokens: 500,
    });

    const raw = completion.choices[0]?.message?.content ?? "[]";

    // Parse & validate
    let parsed: unknown;
    try {
      parsed = JSON.parse(raw);
    } catch {
      parsed = [];
    }

    const suggestions: Suggestion[] = Array.isArray(parsed)
      ? (parsed
          .map(coerceSuggestion)
          .filter((s): s is Suggestion => s !== null)
          .slice(0, 6))
      : [];

    return NextResponse.json({ suggestions });
  } catch {
    return NextResponse.json(
      { error: "Failed to generate suggestions" },
      { status: 500 }
    );
  }
}// app/api/work-orders/lines/[id]/finish/route.ts
export const runtime = "nodejs";

import { NextRequest, NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type Body = { cause?: string; correction?: string };

function extractLineId(req: NextRequest) {
  // matches /api/work-orders/lines/<id>/finish
  const m = req.nextUrl.pathname.match(/\/api\/work-orders\/lines\/([^/]+)\/finish$/);
  return m?.[1] ?? null;
}

export async function POST(req: NextRequest) {
  const id = extractLineId(req);
  if (!id) return NextResponse.json({ error: "Missing id" }, { status: 400 });

  const supabase = createRouteHandlerClient<Database>({ cookies });

  const { data: auth, error: authErr } = await supabase.auth.getUser();
  if (authErr) return NextResponse.json({ error: authErr.message }, { status: 500 });
  if (!auth?.user) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const now = new Date().toISOString();
  const { cause, correction } = (await req.json().catch(() => ({}))) as Body;

  const updatePayload: Database["public"]["Tables"]["work_order_lines"]["Update"] = {
    status: "completed",
    punched_out_at: now,
    ...(cause !== undefined ? { cause } : {}),
    ...(correction !== undefined ? { correction } : {}),
  };

  const { data, error } = await supabase
    .from("work_order_lines")
    .update(updatePayload)
    .eq("id", id)
    .select("id, status, punched_in_at, punched_out_at, cause, correction")
    .single();

  if (error) return NextResponse.json({ error: error.message }, { status: 400 });

  await supabase.from("activity_logs").insert({
    entity_type: "work_order_line",
    entity_id: id,
    action: "finish",
    actor_id: auth.user.id,
    created_at: now,
  });

  return NextResponse.json({ success: true, line: data });
}