
      .in("id", ids);
    if (error) {
      toast.error(error.message);
      return;
    }
    setBulkQueue(ids);
    setBulkActive(true);
    setPartsLineId(ids[0] ?? null);
    toast.success("Queued all pending lines for parts quoting");
  }, [approvalPending]);

  // open inspection
  const openInspectionForLine = useCallback(
    async (ln: WorkOrderLine) => {
      if (!ln?.id) return;

      const desc = String(ln.description ?? "").toLowerCase();
      const isAir = /\bair\b|cvip|push\s*rod|air\s*brake/.test(desc);
      const isCustom = /\bcustom\b|\bbuilder\b|\bprompt\b|\bad[-\s]?hoc\b/.test(
        desc
      );

      let templateSlug = isAir ? "maintenance50-air" : "maintenance50";
      if (isCustom) {
        templateSlug = "custom:pending";
      }

      try {
        const res = await fetch("/api/inspections/session/create", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            workOrderId: wo?.id ?? null,
            workOrderLineId: ln.id,
            vehicleId: vehicle?.id ?? null,
            customerId: customer?.id ?? null,
            template: templateSlug,
          }),
        });

        const j = (await res.json().catch(() => null)) as
          | { sessionId?: string; error?: string }
          | null;

        if (!res.ok || !j?.sessionId) {
          throw new Error(j?.error || "Failed to create inspection session");
        }

        if (isCustom) {
          templateSlug = `custom:${j.sessionId}`;
        }

        const sp = new URLSearchParams();
        if (wo?.id) sp.set("workOrderId", wo.id);
        sp.set("workOrderLineId", ln.id);
        sp.set("inspectionId", j.sessionId);
        sp.set("template", templateSlug);
        sp.set("embed", "1");
        if (isCustom && ln.description)
          sp.set("seed", String(ln.description));

        const url = `/inspection/${templateSlug}?${sp.toString()}`;

        setInspectionSrc(url);
        setInspectionOpen(true);
        toast.success("Inspection opened");
      } catch (e) {
        const err = e as { message?: string };
        toast.error(err?.message ?? "Unable to open inspection");
      }
    },
    [wo?.id, vehicle?.id, customer?.id]
  );

  // parts drawer close / bulk
  useEffect(() => {
    if (!partsLineId) return;

    const evtName = `parts-drawer:closed:${partsLineId}`;

    const handler = () => {
      if (bulkActive && bulkQueue.length > 0) {
        const [, ...rest] = bulkQueue;
        setBulkQueue(rest);
        setPartsLineId(rest[0] ?? null);
        if (rest.length === 0) {
          setBulkActive(false);
          void fetchAll();
        }
      } else {
        setPartsLineId(null);
        void fetchAll();
      }
    };

    window.addEventListener(evtName, handler as EventListener);
    return () => window.removeEventListener(evtName, handler as EventListener);
  }, [partsLineId, bulkActive, bulkQueue, fetchAll]);

  /* -------------------------- UI -------------------------- */
  if (!routeId)
    return <div className="p-6 text-red-500">Missing work order id.</div>;

  const Skeleton = ({ className = "" }: { className?: string }) => (
    <div className={`animate-pulse rounded-lg bg-neutral-800/60 ${className}`} />
  );

  return (
    <div className="mx-auto flex min-h-screen max-w-4xl flex-col px-3 py-4 bg-background text-foreground">
      <VoiceContextSetter
        currentView="work_order_page_mobile"
        workOrderId={wo?.id}
        vehicleId={vehicle?.id}
        customerId={customer?.id}
        lineId={null}
      />

      {/* header bar */}
      <div className="mb-4 flex items-center justify-between gap-2">
        <PreviousPageButton to="/mobile/work-orders" />
        {wo?.custom_id && (
          <span className="rounded-full border border-neutral-800 bg-neutral-900/70 px-3 py-1 text-[11px] text-neutral-300">
            Internal ID: {wo.id.slice(0, 8)}
          </span>
        )}
      </div>

      {!currentUserId && (
        <div className="mb-4 rounded-lg border border-amber-500/30 bg-amber-900/10 p-3 text-xs text-amber-100">
          You appear signed out on this tab. If actions fail, open{" "}
            <Link href="/sign-in" className="underline hover:text-white">
              Sign In
            </Link>{" "}
            and return here.
        </div>
      )}

      {viewError && (
        <div className="mb-4 whitespace-pre-wrap rounded-lg border border-red-500/40 bg-red-950/60 p-3 text-xs text-red-200">
          {viewError}
        </div>
      )}

      {loading ? (
        <div className="mt-4 grid gap-4">
          <Skeleton className="h-20" />
          <Skeleton className="h-32" />
          <Skeleton className="h-40" />
        </div>
      ) : !wo ? (
        <div className="mt-4 text-sm text-red-400">Work order not found.</div>
      ) : (
        <div className="space-y-5">
          {/* Header */}
          <div className="rounded-xl border border-border bg-card/95 p-4 shadow-sm">
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
              <div className="space-y-1">
                <div className="flex flex-wrap items-center gap-2">
                  <h1 className="text-lg font-semibold text-white sm:text-xl">
                    Work Order{" "}
                    <span className="text-orange-400">
                      {wo.custom_id || `#${wo.id.slice(0, 8)}`}
                    </span>
                  </h1>
                  <span className={chip(wo.status)}>
                    {(wo.status ?? "awaiting").replaceAll("_", " ")}
                  </span>
                </div>
                <p className="text-[11px] text-neutral-400">
                  Created {createdAtText}
                </p>
              </div>
            </div>

            <div className="mt-3 grid gap-3 text-[11px] text-neutral-300 sm:grid-cols-2">
              <div>
                <div className="text-neutral-500">Created</div>
                <div>{createdAtText}</div>
              </div>
              <div>
                <div className="text-neutral-500">WO ID</div>
                <div className="truncate font-mono text-[11px] text-neutral-200">
                  {wo.id}
                </div>
              </div>
              <div>
                <div className="text-neutral-500">Custom ID</div>
                <div className="truncate">
                  {wo.custom_id ?? (
                    <span className="text-neutral-500">Not set</span>
                  )}
                </div>
              </div>
              <div>
                <div className="text-neutral-500">Status</div>
                <div className="mt-0.5">
                  <span className={chip(wo.status)}>
                    {(wo.status ?? "awaiting").replaceAll("_", " ")}
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* Vehicle & Customer */}
          <div className="rounded-xl border border-border bg-card/95 p-4">
            <div className="flex items-center justify-between gap-2">
              <h2 className="text-sm font-semibold text-white sm:text-base">
                Vehicle &amp; Customer
              </h2>
              <button
                type="button"
                className="text-[11px] font-medium text-orange-400 hover:text-orange-300 hover:underline"
                onClick={() => setShowDetails((v) => !v)}
                aria-expanded={showDetails}
              >
                {showDetails ? "Hide details" : "Show details"}
              </button>
            </div>

            {showDetails && (
              <div className="mt-3 grid gap-4 sm:grid-cols-2">
                <div className="rounded-lg bg-neutral-950/60 p-3">
                  <h3 className="mb-1 text-[11px] font-semibold uppercase tracking-wide text-neutral-400">
                    Vehicle
                  </h3>
                  {vehicle ? (
                    <>
                      <p className="text-sm font-medium text-white">
                        {(vehicle.year ?? "").toString()} {vehicle.make ?? ""}{" "}
                        {vehicle.model ?? ""}
                      </p>
                      <p className="mt-1 text-[11px] text-neutral-400">
                        VIN:{" "}
                        <span className="font-mono">
                          {vehicle.vin ?? "—"}
                        </span>
                        <br />
                        Plate:{" "}
                        {vehicle.license_plate ?? (
                          <span className="text-neutral-500">—</span>
                        )}
                      </p>
                    </>
                  ) : (
                    <p className="text-sm text-neutral-500">
                      No vehicle linked yet.
                    </p>
                  )}
                </div>

                <div className="rounded-lg bg-neutral-950/60 p-3">
                  <h3 className="mb-1 text-[11px] font-semibold uppercase tracking-wide text-neutral-400">
                    Customer
                  </h3>
                  {customer ? (
                    <>
                      <p className="text-sm font-medium text-white">
                        {[
                          customer.first_name ?? "",
                          customer.last_name ?? "",
                        ]
                          .filter(Boolean)
                          .join(" ") || "—"}
                      </p>
                      <p className="mt-1 text-[11px] text-neutral-400">
                        {customer.phone ?? "—"}{" "}
                        {customer.email ? (
                          <>
                            <span className="mx-1 text-neutral-600">•</span>
                            {customer.email}
                          </>
                        ) : null}
                      </p>
                      {customer.id && (
                        <Link
                          href={`/customers/${customer.id}`}
                          className="mt-2 inline-flex text-[11px] font-medium text-orange-400 hover:text-orange-300 hover:underline"
                          title="Open customer profile"
                        >
                          View customer profile →
                        </Link>
                      )}
                    </>
                  ) : (
                    <p className="text-sm text-neutral-500">
                      No customer linked yet.
                    </p>
                  )}
                </div>
              </div>
            )}
          </div>

          {/* Awaiting Customer Approval */}
          <div className="rounded-xl border border-blue-900/60 bg-gradient-to-b from-slate-950 to-slate-950/90 p-4">
            <div className="mb-3 flex items-center justify-between gap-2">
              <h2 className="text-sm font-semibold text-blue-200 sm:text-base">
                Awaiting customer approval
              </h2>
              {approvalPending.length > 1 && (
                <button
                  type="button"
                  className="rounded-md bg-blue-600 px-3 py-1.5 text-xs font-semibold text-white shadow-sm hover:bg-blue-500"
                  onClick={sendAllPendingToParts}
                  title="Queue all lines for parts quoting"
                >
                  Quote all pending lines
                </button>
              )}
            </div>

            {approvalPending.length === 0 ? (
              <p className="text-xs text-neutral-400">
                No lines waiting for approval.
              </p>
            ) : (
              <div className="space-y-2">
                {approvalPending.map((ln, idx) => {
                  const isAwaitingParts =
                    (ln.status === "on_hold" &&
                      (ln.hold_reason ?? "")
                        .toLowerCase()
                        .includes("part")) ||
                    (ln.hold_reason ?? "")
                      .toLowerCase()
                      .includes("quote");

                  return (
                    <div
                      key={ln.id}
                      className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3"
                    >
                      <div className="flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
                        <div className="min-w-0">
                          <div className="truncate text-sm font-medium text-white">
                            {idx + 1}.{" "}
                            {ln.description ||
                              ln.complaint ||
                              "Untitled job"}
                          </div>
                          <div className="mt-0.5 text-[11px] text-neutral-400">
                            {String(ln.job_type ?? "job").replaceAll(
                              "_",
                              " "
                            )}{" "}
                            •{" "}
                            {typeof ln.labor_time === "number"
                              ? `${ln.labor_time}h`
                              : "—"}{" "}
                            • Status:{" "}
                            {(ln.status ?? "awaiting").replaceAll("_", " ")}{" "}
                            • Approval:{" "}
                            {(ln.approval_state ?? "pending").replaceAll(
                              "_",
                              " "
                            )}
                          </div>
                          {ln.notes && (
                            <div className="mt-1 text-[11px] text-neutral-400">
                              Notes: {ln.notes}
                            </div>
                          )}
                        </div>

                        <div className="flex flex-wrap items-center gap-2">
                          <button
                            type="button"
                            className="rounded-md border border-green-700 px-2 py-1 text-[11px] font-medium text-green-200 hover:bg-green-900/25"
                            onClick={() => approveLine(ln.id)}
                          >
                            Approve
                          </button>
                          <button
                            type="button"
                            className="rounded-md border border-red-700 px-2 py-1 text-[11px] font-medium text-red-200 hover:bg-red-900/30"
                            onClick={() => declineLine(ln.id)}
                          >
                            Decline
                          </button>

                          {isAwaitingParts ? (
                            <button
                              type="button"
                              disabled
                              className="cursor-not-allowed rounded-md border border-neutral-700 px-2 py-1 text-[11px] text-neutral-400"
                            >
                              Sent to parts
                            </button>
                          ) : (
                            <button
                              type="button"
                              className="rounded-md border border-blue-700 px-2 py-1 text-[11px] font-medium text-blue-200 hover:bg-blue-900/25"
                              onClick={() => sendToParts(ln.id)}
                              title="Send to parts for quoting"
                            >
                              Send to parts
                            </button>
                          )}
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          {/* Jobs list */}
          <div className="rounded-xl border border-border bg-card/95 p-4">
            <div className="mb-3 flex items-center justify-between gap-2">
              <div>
                <h2 className="text-sm font-semibold text-white sm:text-base">
                  Jobs in this work order
                </h2>
                <p className="text-[11px] text-neutral-500">
                  Tap a job to open its full-screen mobile view.
                </p>
              </div>
            </div>

            {sortedLines.length === 0 ? (
              <p className="text-sm text-neutral-400">No lines yet.</p>
            ) : (
              <div className="space-y-2">
                {sortedLines.map((ln, idx) => {
                  const statusKey = (ln.status ?? "awaiting")
                    .toLowerCase()
                    .replaceAll(" ", "_");
                  const borderCls =
                    statusBorder[statusKey] ||
                    "border-l-4 border-gray-400";
                  const tintCls =
                    statusRowTint[statusKey] || "bg-neutral-950";
                  const punchedIn =
                    !!ln.punched_in_at && !ln.punched_out_at;

                  const partsForLine = allocsByLine[ln.id] ?? [];

                  const lineTechIds = lineTechsByLine[ln.id] ?? [];
                  const primaryId =
                    typeof ln.assigned_to === "string"
                      ? (ln.assigned_to as string)
                      : null;

                  const orderedTechIds: string[] = [];
                  if (primaryId) orderedTechIds.push(primaryId);
                  lineTechIds.forEach((tid) => {
                    if (!orderedTechIds.includes(tid)) {
                      orderedTechIds.push(tid);
                    }
                  });

                  return (
                    <button
                      key={ln.id}
                      type="button"
                      className={`group block w-full rounded-lg border border-neutral-800 ${tintCls} p-3 text-left transition hover:border-orange-500/70 hover:bg-neutral-900/80 ${borderCls} ${
                        punchedIn ? "ring-2 ring-orange-500/80" : ""
                      }`}
                      title="Open focused job"
                      onClick={() => {
                        router.push(`/mobile/jobs/${ln.id}`);
                      }}
                    >
                      <div className="flex flex-col gap-2">
                        <div className="flex flex-wrap items-start justify-between gap-2">
                          <div className="min-w-0">
                            <div className="flex flex-wrap items-center gap-2">
                              <div className="truncate text-sm font-medium text-white">
                                {idx + 1}.{" "}
                                {ln.description ||
                                  ln.complaint ||
                                  "Untitled job"}
                              </div>
                              {ln.job_type === "inspection" && (
                                <button
                                  type="button"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    void openInspectionForLine(ln);
                                  }}
                                  className={`rounded-md border px-2 py-0.5 text-[11px] font-medium ${
                                    ln.status === "completed"
                                      ? "border-green-400 text-green-200"
                                      : "border-orange-400 text-orange-200 hover:bg-orange-500/10"
                                  }`}
                                >
                                  {ln.status === "completed"
                                    ? "View inspection"
                                    : "Open inspection"}
                                </button>
                              )}
                              {canAssign && (
                                <button
                                  type="button"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setAssignLineId(ln.id);
                                    setAssignOpen(true);
                                  }}
                                  className="rounded-md border border-sky-500/70 px-2 py-0.5 text-[11px] font-medium text-sky-200 hover:bg-sky-900/25"
                                  title="Assign mechanic to this line"
                                >
                                  Assign mechanic
                                </button>
                              )}
                            </div>
                            <div className="mt-0.5 text-[11px] text-neutral-400">
                              {String(ln.job_type ?? "job").replaceAll(
                                "_",
                                " "
                              )}{" "}
                              •{" "}
                              {typeof ln.labor_time === "number"
                                ? `${ln.labor_time}h`
                                : "—"}{" "}
                              • Status:{" "}
                              {(ln.status ?? "awaiting").replaceAll(
                                "_",
                                " "
                              )}
                            </div>

                            {orderedTechIds.length > 0 && (
                              <div className="mt-1 flex flex-wrap gap-1">
                                {orderedTechIds.map((tid) => {
                                  const info = assignablesById[tid];
                                  const label =
                                    info?.full_name ?? "Mechanic";
                                  return (
                                    <span
                                      key={tid}
                                      className="inline-flex items-center gap-1 rounded-full bg-sky-900/40 px-2 py-0.5 text-[10px] text-sky-100"
                                    >
                                      <span className="h-1.5 w-1.5 rounded-full bg-sky-300" />
                                      {label}
                                    </span>
                                  );
                                })}
                              </div>
                            )}

                            {(ln.complaint ||
                              ln.cause ||
                              ln.correction) && (
                              <div className="mt-1 flex flex-wrap items-center gap-2 text-[11px] text-neutral-400">
                                {ln.complaint ? (
                                  <span>Cmpl: {ln.complaint}</span>
                                ) : null}
                                {ln.cause ? (
                                  <span>| Cause: {ln.cause}</span>
                                ) : null}
                                {ln.correction ? (
                                  <span>| Corr: {ln.correction}</span>
                                ) : null}
                              </div>
                            )}

                            {/* Parts used */}
                            <div className="mt-2 rounded-lg border border-neutral-800 bg-neutral-950/80 p-2">
                              <div className="mb-1 flex items-center justify-between gap-2">
                                <div className="text-[11px] font-semibold uppercase tracking-wide text-neutral-300">
                                  Parts used
                                </div>
                                <div className="shrink-0">
                                  <UsePartButton
                                    workOrderLineId={ln.id}
                                    onApplied={() =>
                                      window.dispatchEvent(
                                        new CustomEvent("wo:parts-used")
                                      )
                                    }
                                    label="Add part"
                                  />
                                </div>
                              </div>
                              {partsForLine.length ? (
                                <ul className="mt-1 divide-y divide-neutral-800 rounded border border-neutral-800 text-sm">
                                  {partsForLine.map((a) => (
                                    <li
                                      key={a.id}
                                      className="flex items-center justify-between bg-neutral-900/70 p-2"
                                    >
                                      <div className="min-w-0">
                                        <div className="truncate text-sm text-white">
                                          {a.parts?.name ?? "Part"}
                                        </div>
                                        <div className="text-[11px] text-neutral-500">
                                          loc{" "}
                                          {String(a.location_id).slice(
                                            0,
                                            6
                                          )}
                                          …
                                        </div>
                                      </div>
                                      <div className="pl-3 text-sm font-semibold text-neutral-100">
                                        × {a.qty}
                                      </div>
                                    </li>
                                  ))}
                                </ul>
                              ) : (
                                <div className="mt-1 text-[11px] text-neutral-500">
                                  No parts used yet.
                                </div>
                              )}
                            </div>
                          </div>

                          <span className={chip(ln.status)}>
                            {(ln.status ?? "awaiting").replaceAll(
                              "_",
                              " "
                            )}
                          </span>
                        </div>
                      </div>
                    </button>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      )}

      {/* Parts Drawer */}
      {partsLineId && wo?.id && (
        <PartsDrawer
          open={!!partsLineId}
          workOrderId={wo.id}
          workOrderLineId={partsLineId}
          vehicleSummary={
            vehicle
              ? {
                  year: (
                    vehicle.year as string | number | null
                  )?.toString() ?? null,
                  make: vehicle.make ?? null,
                  model: vehicle.model ?? null,
                }
              : null
          }
          jobDescription={
            lines.find((l) => l.id === partsLineId)?.description ??
            lines.find((l) => l.id === partsLineId)?.complaint ??
            null
          }
          jobNotes={
            lines.find((l) => l.id === partsLineId)?.notes ?? null
          }
          closeEventName={`parts-drawer:closed:${partsLineId}`}
        />
      )}

      {/* Inspection modal */}
      {inspectionOpen && inspectionSrc && (
        <InspectionModal
          open={inspectionOpen}
          src={inspectionSrc}
          title="Inspection"
          onClose={() => setInspectionOpen(false)}
        />
      )}

      {/* Assign mechanic modal */}
      {assignOpen && assignLineId && (
        <AssignTechModal
          isOpen={assignOpen}
          onClose={() => setAssignOpen(false)}
          workOrderLineId={assignLineId}
          mechanics={assignables}
          onAssigned={async () => {
            await fetchAll();
          }}
        />
      )}

      <div className="mt-4 flex justify-center">
        <VoiceButton />
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/lib/capabilities.ts */
/* =============================== */

export function capabilities(role: string | null) {
  const r = (role || "").toLowerCase();
  const staff = ["owner", "admin", "manager", "advisor", "tech"];
  return {
    canView: true,
    canEditWoMeta: ["owner", "admin", "manager", "advisor"].includes(r),
    canTechOps: ["tech", "manager"].includes(r),
    canAddJobs: staff.includes(r),
    canGenerateQuote: staff.includes(r),
  } as const;
}


/* =============================== */
/* FILE: features/work-orders/lib/work-orders/generateQuotePdf.ts */
/* =============================== */

import { PDFDocument, rgb, StandardFonts } from "pdf-lib";
import type {
  QuoteLine,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

/**
 * Normalizes either QuoteLine or QuoteLineItem into a common shape
 * so the PDF renderer doesn't care which one you pass.
 */
function toUnified(line: QuoteLine | QuoteLineItem) {
  // Heuristic: QuoteLine has "parts" or "laborTime"
  const isQuoteLine =
    (line as QuoteLine).parts !== undefined ||
    (line as QuoteLine).laborTime !== undefined;

  if (isQuoteLine) {
    const q = line as QuoteLine;
    const first = q.parts?.[0];
    const laborHours = q.laborTime ?? 0;
    const laborRate = q.laborRate ?? 0;
    const laborPrice = laborRate * laborHours;

    return {
      name: q.item ?? q.inspectionItem ?? "",
      description: q.description ?? "",
      status: (q.status ?? "ok") as "ok" | "fail" | "na" | "recommend",
      notes: q.notes ?? "",
      partName: first?.name ?? "",
      partPrice:
        typeof first?.price === "number"
          ? first!.price
          : Number(first?.price ?? 0),
      laborHours,
      laborPrice,
    };
  }

  // Otherwise treat as QuoteLineItem
  const qi = line as QuoteLineItem;
  const numericPartPrice =
    typeof qi.part?.price === "number"
      ? qi.part?.price
      : typeof qi.partPrice === "number"
        ? qi.partPrice
        : Number(qi.partPrice ?? 0);

  return {
    name: qi.name ?? (qi.item ?? ""),
    description: qi.description ?? "",
    status: qi.status,
    notes: qi.notes ?? "",
    partName: qi.part?.name ?? qi.partName ?? "",
    partPrice: numericPartPrice ?? 0,
    laborHours: qi.laborHours ?? 0,
    laborPrice: qi.price ?? 0,
  };
}

export async function generateQuotePDFBytes(
  quoteLines: ReadonlyArray<QuoteLine | QuoteLineItem>,
  summaryText: string,
): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create();
  let page = pdfDoc.addPage();
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const fontSize = 12;

  const drawText = (text: string, x = 50, dy = fontSize + 6) => {
    const { height } = page.getSize();
    // track y on the page
    if ((drawText as any)._y === undefined) (drawText as any)._y = height - 40;
    let y = (drawText as any)._y as number;

    page.drawText(text, { x, y, size: fontSize, font, color: rgb(0, 0, 0) });
    y -= dy;

    // Start new page if we’re near the bottom
    if (y < 60) {
      page = pdfDoc.addPage();
      y = page.getSize().height - 40;
    }
    (drawText as any)._y = y;
  };

  // Summary
  drawText("Inspection Summary:");
  for (const line of (summaryText || "").split("\n")) {
    drawText(line);
  }

  // Spacer + header
  drawText("", 50, 20);
  drawText("Quote Items:");

  // Items
  for (const raw of quoteLines) {
    const u = toUnified(raw);

    drawText(`• ${u.name || "(unnamed item)"}`);
    if (u.description) drawText(`   ${u.description}`);

    const priceStr =
      typeof u.partPrice === "number" ? u.partPrice.toFixed(2) : "0.00";
    drawText(`   Part: ${u.partName || "—"} - $${priceStr}`);

    drawText(
      `   Labor: ${u.laborHours ?? 0} hrs - $${(u.laborPrice ?? 0).toFixed(2)}`,
    );

    drawText(`   Status: ${u.status}`);
    if (u.notes) drawText(`   Notes: ${u.notes}`);

    // Extra gap between items
    drawText("", 50, 10);
  }

  return pdfDoc.save(); // Uint8Array
}

/** Back-compat alias so existing imports `{ generateQuotePDF }` still compile */
export const generateQuotePDF = generateQuotePDFBytes;

/* =============================== */
/* FILE: features/work-orders/api/update-status/route.ts */
/* =============================== */

import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import type { Database } from "@shared/types/types/supabase";

const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
);

type Command = "punch-in" | "complete";

type QuoteLineItem = {
  name: string;
  description?: string;
  labor_time?: number;
  part_name?: string;
  part_price?: number;
  parts_cost?: number;
  total_price?: number;
};

interface RequestBody {
  workOrderId: string;
  command: Command;
  quote?: QuoteLineItem[];
  summary?: string;
}

export async function POST(req: NextRequest) {
  try {
    const body: RequestBody = await req.json();
    const { workOrderId, command, quote, summary } = body;

    if (!workOrderId || !command) {
      return NextResponse.json(
        { error: "Missing workOrderId or command" },
        { status: 400 },
      );
    }

    let updateFields: Partial<
      Database["public"]["Tables"]["work_orders"]["Update"]
    > = {};

    if (command === "punch-in") {
      updateFields = {
        status: "in_progress",
      };
    } else if (command === "complete") {
      updateFields = {
        status: "completed",
      };

      if (quote && summary) {
        updateFields.quote = {
          summary,
          items: quote,
        } as any; // keep if `quote` column is jsonb; remove `as any` if typed
      }
    } else {
      return NextResponse.json({ error: "Unknown command" }, { status: 400 });
    }

    const { error } = await supabase
      .from("work_orders")
      .update(updateFields)
      .eq("id", workOrderId);

    if (error) throw error;

    return NextResponse.json({ success: true, updated: updateFields });
  } catch (err: unknown) {
    const message = err instanceof Error ? err.message : String(err);
    console.error("Work order update failed:", message);
    return NextResponse.json({ error: "Update failed" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: features/work-orders/app/work-orders/page.tsx */
/* =============================== */

// app/work-orders/page.tsx
"use client";

import Link from "next/link";

export const revalidate = 0;

type TileProps = {
  href: string;
  title: string;
  subtitle?: string;
  cta?: string;
};

function Tile(props: TileProps) {
  return (
    <Link
      href={props.href}
      className="block rounded-lg border border-white/10 bg-neutral-900 p-4 transition
                 hover:-translate-y-0.5 hover:border-orange-500 hover:shadow-lg hover:shadow-orange-500/10"
      aria-label={props.title}
    >
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-white">{props.title}</h2>
        {props.cta ? (
          <span className="rounded bg-orange-500 px-3 py-1 text-sm font-semibold text-black">
            {props.cta}
          </span>
        ) : null}
      </div>
      {props.subtitle ? (
        <p className="mt-1 text-sm text-white/70">{props.subtitle}</p>
      ) : null}
    </Link>
  );
}

export default function WorkOrdersHome() {
  return (
    <div className="mx-auto max-w-3xl px-4 py-8 text-white">
      <h1 className="mb-6 text-3xl font-bold text-orange-400">Work Orders</h1>

      <div className="grid grid-cols-1 gap-4">
        <Tile
          href="/work-orders/create"
          title="Create Work Order"
          subtitle="Start a new job for a vehicle"
          cta="+"
        />
        <Tile
          href="/work-orders/queue"
          title="Job Queue"
          subtitle="See active, paused, and in-progress jobs"
        />
        <Tile
          href="/work-orders/editor"
          title="Work Order Editor"
          subtitle="Compose job lines from menu items or free-type"
        />
        <Tile
          href="/work-orders/quote-review"
          title="Quote Review"
          subtitle="Review and send estimates"
        />
        <Tile
          href="/work-orders/view"
          title="View Work Orders"
          subtitle="Browse and manage all work orders"
        />
        <Tile
          href="/customers"
          title="Customer Profiles"
          subtitle="Browse customers, history, and vehicles"
        />
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/app/work-orders/quote-review/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import SignaturePad, {
  openSignaturePad,
} from "@/features/shared/signaturePad/controller";
import { formatCurrency } from "@/features/shared/lib/formatCurrency";

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type Line = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Shop = DB["public"]["Tables"]["shops"]["Row"];

const SIGNATURE_BUCKET = "signatures";

/* ----------------------------- helpers ----------------------------- */

function dataUrlToBlob(dataUrl: string): Blob {
  const [header, b64] = dataUrl.split(",");
  const mime = /data:(.*?);base64/.exec(header)?.[1] ?? "image/png";
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return new Blob([bytes], { type: mime });
}

const fmt = (n: number) => {
  try {
    return formatCurrency(n);
  } catch {
    return `$${n.toFixed(2)}`;
  }
};

/* ----------------------- approvals list (cards) ----------------------- */

function ApprovalsList() {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [rows, setRows] = useState<WorkOrderWithMeta[]>([]);
  const [loading, setLoading] = useState(true);

  type WorkOrderWithMeta = WorkOrder & {
    shops?: Pick<Shop, "name"> | null;
    labor_hours?: number | null;
  };

  const load = async () => {
    setLoading(true);

    // Only show awaiting_approval here
    const { data: wo } = await supabase
      .from("work_orders")
      .select(`*, shops!inner(name)`)
      .eq("status", "awaiting_approval")
      .order("created_at", { ascending: false });

    let withMeta: WorkOrderWithMeta[] = (wo ?? []) as any;

    if (withMeta.length) {
      const woIds = withMeta.map((w) => w.id);
      const { data: lines } = await supabase
        .from("work_order_lines")
        .select("work_order_id, labor_time")
        .in("work_order_id", woIds);

      const hoursByWO = new Map<string, number>();
      (lines ?? []).forEach((l) => {
        const cur = hoursByWO.get(l.work_order_id) ?? 0;
        hoursByWO.set(
          l.work_order_id,
          cur +
            (typeof l.labor_time === "number" ? l.labor_time : 0)
        );
      });

      withMeta = withMeta.map((w) => ({
        ...w,
        labor_hours: hoursByWO.get(w.id) ?? 0,
      }));
    }

    setRows(withMeta);
    setLoading(false);
  };

  useEffect(() => {
    void load();

    // Realtime: if any WO flips status, refresh the list
    const ch = supabase
      .channel("qr:work_orders")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "work_orders" },
        () => void load()
      )
      .subscribe();

    return () => {
      try {
        supabase.removeChannel(ch);
      } catch {
        /* ignore */
      }
    };
  }, [supabase]);

  if (loading)
    return <div className="mt-6 text-muted-foreground">Loading…</div>;
  if (rows.length === 0)
    return (
      <div className="mt-6 text-muted-foreground">
        No work orders waiting for approval.
      </div>
    );

  return (
    <div className="mt-4 rounded-lg border border-border bg-card">
      <div className="border-b border-border px-4 py-2 font-semibold">
        Awaiting Approval
      </div>

      <div className="divide-y divide-border">
        {rows.map((w) => (
          <div
            key={w.id}
            className="flex items-center justify-between gap-3 px-4 py-3"
          >
            <div className="min-w-0">
              <div className="truncate font-medium">
                {w.custom_id ? `#${w.custom_id}` : `#${w.id.slice(0, 8)}`}
              </div>
              <div className="text-xs text-muted-foreground">
                {w.shops?.name ? `${w.shops.name} • ` : ""}
                {(w.status ?? "").replaceAll("_", " ")}
                {typeof w.labor_hours === "number"
                  ? ` • ${w.labor_hours.toFixed(1)}h`
                  : ""}
              </div>
            </div>
            <div className="flex shrink-0 gap-2">
              <a
                href={`/work-orders/${w.id}/approve`}
                className="rounded border border-orange-500 px-3 py-1 text-sm text-orange-500 hover:bg-orange-500/10"
                title="Open customer-facing approval workflow"
              >
                Review &amp; Sign
              </a>
              <a
                href={`/work-orders/${w.id}`}
                className="rounded border border-border px-3 py-1 text-sm hover:bg-muted"
                title="Open this work order"
              >
                Open WO
              </a>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

/* ---------------------- single WO review + sign ---------------------- */

function SingleQuoteReview({ woId }: { woId: string }) {
  const router = useRouter();
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);

  const [wo, setWo] = useState<WorkOrder | null>(null);
  const [shop, setShop] = useState<Shop | null>(null);
  const [lines, setLines] = useState<Line[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!woId) return;
    (async () => {
      setLoading(true);

      const { data: woRow } = await supabase
        .from("work_orders")
        .select("*")
        .eq("id", woId)
        .maybeSingle();
      setWo(woRow ?? null);

      if (woRow?.shop_id) {
        const { data: shopRow } = await supabase
          .from("shops")
          .select("*")
          .eq("id", woRow.shop_id)
          .maybeSingle();
        setShop(shopRow ?? null);
      }

      const { data: lineRows } = await supabase
        .from("work_order_lines")
        .select("*")
        .eq("work_order_id", woId)
        .order("created_at", { ascending: true });
      setLines(lineRows ?? []);

      setLoading(false);
    })();
  }, [woId, supabase]);

  const laborRate = 120;
  const totalLaborHours = lines.reduce(
    (sum, l) => sum + (typeof l.labor_time === "number" ? l.labor_time : 0),
    0
  );
  const laborTotal = totalLaborHours * laborRate;
  const partsTotal = 0;
  const grandTotal = laborTotal + partsTotal;

  async function handleSignatureSave(base64: string) {
    if (!woId) return;
    try {
      const blob = dataUrlToBlob(base64);
      const filename = `wo/${wo?.shop_id ?? "unknown"}/${woId}/${Date.now()}.png`;

      const { error: upErr } = await supabase.storage
        .from(SIGNATURE_BUCKET)
        .upload(filename, blob, { contentType: "image/png", upsert: false });
      if (upErr) throw upErr;

      const { error: updErr } = await supabase
        .from("work_orders")
        .update({
          // @ts-ignore pending schema fields in types
          customer_approval_signature_path: filename,
          // @ts-ignore pending schema fields in types
          customer_approval_at: new Date().toISOString() as any,
          status: "queued" as any, // moves it out of Quote Review
        })
        .eq("id", woId);
      if (updErr) throw updErr;

      alert("Work order approved and signed!");
      router.push("/work-orders/create?from=review&new=1");
    } catch (err: unknown) {
      const msg =
        err instanceof Error ? err.message : "Failed to save signature";
      alert(msg);
    }
  }

  async function markAwaitingApproval() {
    if (!woId) return;
    try {
      const { error } = await supabase
        .from("work_orders")
        .update({
          status: "awaiting_approval" as any,
          // @ts-ignore pending schema fields in types
          customer_approval_signature_path: null,
          // @ts-ignore pending schema fields in types
          customer_approval_at: null,
        })
        .eq("id", woId);
      if (error) throw error;
      alert("Saved. This work order is now awaiting customer approval.");
    } catch (e: unknown) {
      const msg = e instanceof Error ? e.message : "Failed to update status.";
      alert(msg);
    }
  }

  function copyApprovalLink() {
    if (!woId) return;
    const origin =
      typeof window !== "undefined"
        ? window.location.origin
        : (process.env.NEXT_PUBLIC_SITE_URL || "").replace(/\/$/, "");
    const url = `${origin || ""}/work-orders/${woId}/approve`;
    navigator.clipboard
      .writeText(url)
      .then(() => alert("Approval link copied to clipboard."))
      .catch(() => alert(url));
  }

  if (loading) return <div className="mt-6 text-muted-foreground">Loading…</div>;
  if (!wo) return <div className="mt-6 text-destructive">Work order not found.</div>;

  return (
    <>
      <div className="mt-2 text-sm text-muted-foreground">
        <div>Work Order ID: {wo.id}</div>
        <div>Status: {(wo.status ?? "").replaceAll("_", " ") || "—"}</div>
        {shop?.name && <div>Shop: {shop.name}</div>}
      </div>

      <div className="mt-6 rounded-lg border border-border bg-card">
        <div className="border-b border-border px-4 py-2 font-semibold">
          Line Items
        </div>
        <div className="divide-y divide-border">
          {lines.length === 0 ? (
            <div className="px-4 py-3 text-muted-foreground">
              No items yet.
            </div>
          ) : (
            lines.map((l) => (
              <div key={l.id} className="px-4 py-3">
                <div className="flex items-center justify-between">
                  <div className="min-w-0">
                    <div className="truncate font-medium">
                      {l.description || l.complaint || "Untitled job"}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      {String(l.job_type ?? "job").replaceAll("_", " ")} •{" "}
                      {typeof l.labor_time === "number"
                        ? `${l.labor_time}h`
                        : "—"}{" "}
                      • {(l.status ?? "awaiting").replaceAll("_", " ")}
                    </div>
                  </div>
                  <div className="text-right text-sm">
                    {typeof l.labor_time === "number"
                      ? fmt(l.labor_time * 120)
                      : "—"}
                  </div>
                </div>
              </div>
            ))
          )}
        </div>

        <div className="px-4 py-3 text-sm">
          <div className="flex items-center justify-between">
            <span>
              Labor ({totalLaborHours.toFixed(1)}h @ {fmt(120)}/hr)
            </span>
            <span className="font-medium">{fmt(laborTotal)}</span>
          </div>
          <div className="mt-1 flex items-center justify-between">
            <span>Parts</span>
            <span className="font-medium">{fmt(0)}</span>
          </div>
          <div className="mt-2 flex items-center justify-between border-t border-border pt-2">
            <span className="font-semibold">Total</span>
            <span className="font-bold text-orange-500">{fmt(grandTotal)}</span>
          </div>
        </div>
      </div>

      <div className="mt-6 flex flex-wrap gap-2">
        <button
          onClick={async () => {
            const base64 = await openSignaturePad({ shopName: shop?.name || "" });
            if (!base64) return;
            await handleSignatureSave(base64);
          }}
          className="rounded bg-green-600 px-4 py-2 font-semibold text-white hover:bg-green-700"
        >
          Approve &amp; Sign
        </button>

        <button
          onClick={markAwaitingApproval}
          className="rounded border border-border px-4 py-2 hover:bg-muted"
          title="Save this work order as awaiting customer approval"
        >
          Save for Customer Approval
        </button>

        <button
          onClick={copyApprovalLink}
          className="rounded border border-border px-4 py-2 hover:bg-muted"
          title="Copy link to the customer-facing approval page"
        >
          Copy Approval Link
        </button>

        <a
          href={`/work-orders/${woId}`}
          className="rounded border border-border px-4 py-2 hover:bg-muted"
        >
          Back to Work Order
        </a>
      </div>
    </>
  );
}

/* ------------------------------ page ------------------------------ */

export default function QuoteReviewPage() {
  const woId = useSearchParams().get("woId");
  const router = useRouter();

  return (
    <div className="min-h-screen bg-background px-4 py-6 text-foreground">
      <div className="mx-auto max-w-5xl">
        <div className="mb-4">
          <button
            onClick={() => router.back()}
            className="text-sm text-orange-500 hover:underline"
          >
            ← Back
          </button>
        </div>

        <h1 className="text-2xl font-semibold">Quote Review</h1>

        {!woId ? (
          <>
            <p className="mt-1 text-muted-foreground">
              Work orders waiting for customer approval
            </p>
            <ApprovalsList />
            <SignaturePad />
          </>
        ) : (
          <>
            <SingleQuoteReview woId={woId!} />
            <SignaturePad />
          </>
        )}
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/components/SuggestedQuickAdd.tsx */
/* =============================== */

"use client";

import { useEffect, useState } from "react";

type Suggestion = {
  name: string;
  laborHours: number | null; // ← allow null in our TS shape
  jobType: "diagnosis" | "repair" | "maintenance" | "tech-suggested";
  notes: string;
  aiComplaint?: string;
  aiCause?: string;
  aiCorrection?: string;
};

function asSuggestions(input: any): Suggestion[] {
  if (!Array.isArray(input)) return [];
  return input.map((raw) => {
    const name = typeof raw?.name === "string" && raw.name.trim() ? raw.name.trim() : "Suggested item";
    const hours = Number(raw?.laborHours);
    const jobType =
      raw?.jobType === "diagnosis" ||
      raw?.jobType === "repair" ||
      raw?.jobType === "maintenance" ||
      raw?.jobType === "tech-suggested"
        ? raw.jobType
        : "maintenance"; // sane default
    const notes = typeof raw?.notes === "string" ? raw.notes : "";
    return {
      name,
      laborHours: Number.isFinite(hours) ? hours : null,
      jobType,
      notes,
      aiComplaint: typeof raw?.aiComplaint === "string" ? raw.aiComplaint : undefined,
      aiCause: typeof raw?.aiCause === "string" ? raw.aiCause : undefined,
      aiCorrection: typeof raw?.aiCorrection === "string" ? raw.aiCorrection : undefined,
    } as Suggestion;
  });
}

export default function SuggestedQuickAdd({
  jobId,
  workOrderId,
  vehicleId,
  onAdded, // <-- NEW
}: {
  jobId: string;
  workOrderId: string;
  vehicleId?: string | null;
  onAdded?: () => void | Promise<void>; // <-- NEW
}) {
  const [loading, setLoading] = useState(false);
  const [adding, setAdding] = useState<string | null>(null);
  const [items, setItems] = useState<Suggestion[]>([]);
  const [error, setError] = useState<string | null>(null);

  async function fetchSuggestions() {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch("/api/work-orders/suggest-lines", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ jobId }),
      });
      const j = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error(j?.error || "Failed to load suggestions");
      setItems(asSuggestions(j?.suggestions));
    } catch (e) {
      setError(e instanceof Error ? e.message : "Failed to load suggestions");
      setItems([]);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    if (jobId) void fetchSuggestions();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [jobId]);

  async function addQuote(s: Suggestion) {
    setAdding(s.name);
    try {
      const res = await fetch("/api/work-orders/quotes/add", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          workOrderId,
          vehicleId: vehicleId ?? null,
          items: [
            {
              description: s.name,
              jobType: s.jobType,
              estLaborHours: s.laborHours ?? 0, // ← safe default
              notes: s.notes,
              aiComplaint: s.aiComplaint,
              aiCause: s.aiCause,
              aiCorrection: s.aiCorrection,
            },
          ],
        }),
      });
      if (!res.ok) {
        const j = await res.json().catch(() => ({}));
        throw new Error(j?.error || "Failed to add quote line");
      }

      // ✅ Notify parent if provided
      await onAdded?.();
    } catch (e) {
      alert(e instanceof Error ? e.message : "Failed to add quote line");
    } finally {
      setAdding(null);
    }
  }

  return (
    <div className="rounded border border-neutral-800 bg-neutral-950 p-3">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold text-orange-400">AI Suggestions</h3>
        <button
          onClick={fetchSuggestions}
          disabled={loading}
          className="text-xs px-2 py-1 rounded border border-neutral-700 hover:bg-neutral-800 disabled:opacity-60"
        >
          {loading ? "Thinking…" : "Regenerate"}
        </button>
      </div>

      {error && <p className="mt-2 text-xs text-red-400">{error}</p>}

      <div className="mt-3 grid gap-2 sm:grid-cols-2">
        {items.map((s) => (
          <button
            key={s.name}
            onClick={() => addQuote(s)}
            disabled={adding === s.name}
            className="text-left border border-neutral-800 bg-neutral-900 hover:bg-neutral-800 rounded p-3 disabled:opacity-60"
          >
            <div className="font-medium">{s.name}</div>
            <div className="text-xs text-neutral-400">
              {s.jobType} • {typeof s.laborHours === "number" ? s.laborHours.toFixed(1) : "—"}h
            </div>
            {s.notes && <div className="text-xs text-neutral-500 mt-1">{s.notes}</div>}
          </button>
        ))}

        {!loading && items.length === 0 && (
          <div className="text-xs text-neutral-400">No suggestions yet.</div>
        )}
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/components/MenuQuickAdd.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";
import type { Database, TablesInsert } from "@shared/types/types/supabase";

type DB = Database;
type WorkOrderLineInsert = TablesInsert<"work_order_lines">;

type JobType = "maintenance" | "repair" | "diagnosis" | "inspection";

type PackageItem = {
  description: string;
  jobType?: JobType;
  laborHours?: number | null;
  notes?: string | null;
};

type PackageDef = {
  id: string;
  name: string;
  summary: string;
  jobType: "inspection" | "maintenance";
  estLaborHours: number | null;
  items: PackageItem[];
};

type MenuItemRow = DB["public"]["Tables"]["menu_items"]["Row"];

// DB table has labor_hours, so add it if your generated type is missing it
type TemplateRow = DB["public"]["Tables"]["inspection_templates"]["Row"] & {
  labor_hours?: number | null;
};

type VehicleLite = {
  id?: string | null;
  year?: string | number | null;
  make?: string | null;
  model?: string | null;
  vin?: string | null;
  license_plate?: string | null;
};

type CustomerLite = {
  id?: string | null;
  first_name?: string | null;
  last_name?: string | null;
  phone?: string | null;
  email?: string | null;
};

type PartToAllocate = {
  sku?: string | null;
  name?: string | null;
  qty: number;
};

type AddMenuParams =
  | {
      kind?: "normal";
      name: string;
      jobType: JobType;
      laborHours?: number | null;
      notes?: string | null;
      source?: "single" | "package" | "menu_item" | "ai" | "inspection";
      returnLineId?: boolean;
      partsToAllocate?: PartToAllocate[];
    }
  | {
      kind: "template";
      template: TemplateRow;
      name?: string;
      laborHours?: number | null;
    };

export function MenuQuickAdd({ workOrderId }: { workOrderId: string }) {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const router = useRouter();

  // curated packages
  const packages: PackageDef[] = [
    {
      id: "oil-gas",
      name: "Oil Change – Gasoline",
      jobType: "maintenance",
      estLaborHours: 0.8,
      summary: "Oil & filter, fluids, tire pressures, quick leak check.",
      items: [],
    },
    {
      id: "insp-gas",
      name: "Multi-Point Inspection – Gas",
      jobType: "inspection",
      estLaborHours: 1.0,
      summary: "Brakes, tires, suspension, battery, lights, codes scan.",
      items: [],
    },
    {
      id: "maintenance-50",
      name: "Maintenance 50",
      jobType: "inspection",
      estLaborHours: 1.0,
      summary: "50-point inspection checklist.",
      items: [],
    },
    {
      id: "maintenance-50-air",
      name: "Maintenance 50 – Air",
      jobType: "inspection",
      estLaborHours: 1.0,
      summary: "50-point inspection checklist (air systems focus).",
      items: [],
    },
  ];

  const [addingId, setAddingId] = useState<string | null>(null);
  const [vehicle, setVehicle] = useState<VehicleLite | null>(null);
  const [, setCustomer] = useState<CustomerLite | null>(null);
  const [woLineCount, setWoLineCount] = useState<number | null>(null);

  // saved menu items
  const [menuItems, setMenuItems] = useState<MenuItemRow[]>([]);
  const [menuLoading, setMenuLoading] = useState(false);

  // inspection templates
  const [templates, setTemplates] = useState<TemplateRow[]>([]);
  const [templatesLoading, setTemplatesLoading] = useState(false);

  // shop context
  const [shopId, setShopId] = useState<string | null>(null);
  const shopReady = !!shopId;
  const vehicleId = vehicle?.id ?? null;

  // AI modal
  const [aiOpen, setAiOpen] = useState(false);
  const [aiPrompt, setAiPrompt] = useState("");
  const [aiBusy, setAiBusy] = useState(false);

  const lastSetShopId = useRef<string | null>(null);
  async function ensureShopContext(id: string | null) {
    if (!id) return;
    if (lastSetShopId.current === id) return;
    const { error } = await supabase.rpc("set_current_shop_id", { p_shop_id: id });
    if (!error) {
      lastSetShopId.current = id;
    } else {
      throw error;
    }
  }

  // bootstrap WO + related
  useEffect(() => {
    (async () => {
      const { data: wo } = await supabase
        .from("work_orders")
        .select("id, vehicle_id, customer_id, shop_id")
        .eq("id", workOrderId)
        .maybeSingle();

      setShopId(wo?.shop_id ?? null);

      if (wo?.vehicle_id) {
        const { data: v } = await supabase
          .from("vehicles")
          .select("id, year, make, model, vin, license_plate")
          .eq("id", wo.vehicle_id)
          .maybeSingle();
        if (v) setVehicle(v as VehicleLite);
      } else {
        setVehicle(null);
      }

      if (wo?.customer_id) {
        const { data: c } = await supabase
          .from("customers")
          .select("id, first_name, last_name, phone, email")
          .eq("id", wo.customer_id)
          .maybeSingle();
        if (c) setCustomer(c as CustomerLite);
      } else {
        setCustomer(null);
      }

      const { count } = await supabase
        .from("work_order_lines")
        .select("*", { count: "exact", head: true })
        .eq("work_order_id", workOrderId);
      setWoLineCount(typeof count === "number" ? count : null);
    })();
  }, [supabase, workOrderId]);

  // load saved menu items
  const loadMenuItems = useCallback(async () => {
    setMenuLoading(true);
    try {
      const { data, error } = await supabase
        .from("menu_items")
        .select("*")
        .order("created_at", { ascending: false })
        .limit(20);
      if (error) throw error;
      setMenuItems(data ?? []);
    } catch {
      // ignore
    } finally {
      setMenuLoading(false);
    }
  }, [supabase]);

  // load inspection templates (mine + public)
  const loadTemplates = useCallback(async () => {
    setTemplatesLoading(true);
    try {
      const { data: me } = await supabase.auth.getUser();
      const uid = me?.user?.id ?? null;

      const minePromise = uid
        ? supabase
            .from("inspection_templates")
            .select("*")
            .eq("user_id", uid)
            .order("created_at", { ascending: false })
        : Promise.resolve({ data: [] as TemplateRow[], error: null });

      const sharedPromise = supabase
        .from("inspection_templates")
        .select("*")
        .eq("is_public", true)
        .order("created_at", { ascending: false });

      const [{ data: mineRaw }, { data: sharedRaw }] = await Promise.all([
        minePromise,
        sharedPromise,
      ]);

      setTemplates([
        ...(Array.isArray(mineRaw) ? mineRaw : []),
        ...(Array.isArray(sharedRaw) ? sharedRaw : []),
      ]);
    } catch {
      // ignore
    } finally {
      setTemplatesLoading(false);
    }
  }, [supabase]);

  // initial loads
  useEffect(() => {
    void loadMenuItems();
    void loadTemplates();
  }, [loadMenuItems, loadTemplates]);

  // ============================================================
  // add line (menu or template)
  // ============================================================
  async function addMenuItem(params: AddMenuParams): Promise<string | null> {
    if (!shopReady) return null;

    setAddingId(params.kind === "template" ? params.template.id : params.name);
    try {
      await ensureShopContext(shopId);

      // template-backed line
      if (params.kind === "template") {
        const line: WorkOrderLineInsert & { inspection_template_id?: string | null } = {
          work_order_id: workOrderId,
          vehicle_id: vehicleId,
          description:
            params.name ?? params.template.template_name ?? "Inspection",
          job_type: "inspection",
          labor_time:
            params.laborHours ??
            (typeof params.template.labor_hours === "number"
              ? params.template.labor_hours
              : null),
          status: "awaiting",
          priority: 3,
          notes: params.template.description ?? null,
          shop_id: shopId!,
          inspection_template_id: params.template.id,
        };

        const { data, error } = await supabase
          .from("work_order_lines")
          .insert(line)
          .select("id")
          .single();

        if (error) throw error;

        window.dispatchEvent(new CustomEvent("wo:line-added"));
        toast.success("Inspection added");
        return data?.id ?? null;
      }

      // normal branch
      const line: WorkOrderLineInsert = {
        work_order_id: workOrderId,
        vehicle_id: vehicleId,
        description: params.name,
        job_type: params.jobType,
        labor_time: params.laborHours ?? null,
        status: "awaiting",
        priority: 3,
        notes: params.notes ?? null,
        shop_id: shopId!,
      };

      const { data, error } = await supabase
        .from("work_order_lines")
        .insert(line)
        .select("id")
        .single();

      if (error) throw error;

      if (params.partsToAllocate && params.partsToAllocate.length && data?.id) {
        await autoAllocateExplicitParts(params.partsToAllocate, data.id);
      }

      window.dispatchEvent(new CustomEvent("wo:line-added"));
      toast.success(
        params.source === "ai"
          ? "AI suggestion added"
          : params.source === "menu_item"
          ? "Menu item added"
          : "Job added",
      );

      return params.returnLineId ? (data?.id ?? null) : null;
    } catch (e: unknown) {
      const msg = e instanceof Error ? e.message : "Failed to add job.";
      lastSetShopId.current = null;
      toast.error(msg);
      return null;
    } finally {
      setAddingId(null);
    }
  }

  // ---------- allocation helpers ----------
  type MenuItemPartRow = {
    id: string;
    name: string | null;
    sku: string | null;
    quantity: number | null;
    unit_cost: number | null;
  };

  async function findPartIdForShop({
    sku,
    name,
    shop,
  }: {
    sku?: string | null;
    name?: string | null;
    shop: string;
  }): Promise<string | null> {
    if (sku) {
      const bySku = await supabase
        .from("parts")
        .select("id")
        .eq("shop_id", shop)
        .eq("sku", sku)
        .limit(1)
        .maybeSingle();
      if (!bySku.error && bySku.data?.id) return bySku.data.id;
    }
    if (name) {
      const byName = await supabase
        .from("parts")
        .select("id")
        .eq("shop_id", shop)
        .ilike("name", name)
        .limit(1)
        .maybeSingle();
      if (byName.data?.id) return byName.data.id;
    }
    return null;
  }

  async function pickDefaultLocationId(
    partId: string,
    shop: string,
  ): Promise<string | null> {
    const withStock = await supabase
      .from("part_stock")
      .select("location_id, qty")
      .eq("part_id", partId)
      .order("qty", { ascending: false })
      .limit(1);

    if (!withStock.error && withStock.data?.length) {
      return withStock.data[0].location_id as unknown as string;
    }

    const anyLoc = await supabase
      .from("stock_locations")
      .select("id")
      .eq("shop_id", shop)
      .order("created_at", { ascending: true })
      .limit(1)
      .maybeSingle();

    return anyLoc.data?.id ?? null;
  }

  async function autoAllocateMenuParts(
    menuItemId: string,
    workOrderLineId: string,
  ) {
    if (!shopId) return;

    const { data: rows, error } = await supabase
      .from("menu_item_parts")
      .select("id, name, sku, quantity, unit_cost")
      .eq("menu_item_id", menuItemId);

    if (error) {
      toast.message("Added job, but couldn't read menu parts.");
      return;
    }

    const mParts = (rows ?? []) as MenuItemPartRow[];
    const allocations: {
      work_order_line_id: string;
      part_id: string;
      location_id: string;
      qty: number;
    }[] = [];

    for (const p of mParts) {
      const qty =
        typeof p.quantity === "number" && p.quantity > 0 ? p.quantity : 0;
      if (!qty) continue;

      const partId = await findPartIdForShop({
        sku: p.sku ?? undefined,
        name: p.name ?? undefined,
        shop: shopId,
      });
      if (!partId) {
        toast.message(
          `Skipped "${p.name ?? p.sku ?? "part"}" (not in Parts).`,
        );
        continue;
      }
      const locId = await pickDefaultLocationId(partId, shopId);
      if (!locId) {
        toast.message(
          `Skipped "${p.name ?? p.sku ?? "part"}" (no stock location).`,
        );
        continue;
      }
      allocations.push({
        work_order_line_id: workOrderLineId,
        part_id: partId,
        location_id: locId,
        qty,
      });
    }

    if (!allocations.length) return;

    const { error: allocErr } = await supabase
      .from("work_order_part_allocations")
      .insert(allocations);
    if (allocErr) {
      toast.warning("Job added, but parts couldn't be allocated.");
    } else {
      window.dispatchEvent(new CustomEvent("wo:parts-used"));
      toast.success(
        `Allocated ${allocations.length} part${
          allocations.length > 1 ? "s" : ""
        }`,
      );
    }
  }

  async function autoAllocateExplicitParts(
    list: PartToAllocate[],
    workOrderLineId: string,
  ) {
    if (!shopId || !list.length) return;

    const allocations: {
      work_order_line_id: string;
      part_id: string;
      location_id: string;
      qty: number;
    }[] = [];

    for (const raw of list) {
      const qty = typeof raw.qty === "number" && raw.qty > 0 ? raw.qty : 0;
      if (!qty) continue;

      const partId = await findPartIdForShop({
        sku: raw.sku ?? undefined,
        name: raw.name ?? undefined,
        shop: shopId,
      });
      if (!partId) continue;

      const locId = await pickDefaultLocationId(partId, shopId);
      if (!locId) continue;

      allocations.push({
        work_order_line_id: workOrderLineId,
        part_id: partId,
        location_id: locId,
        qty,
      });
    }

    if (!allocations.length) return;
    const { error } = await supabase
      .from("work_order_part_allocations")
      .insert(allocations);
    if (!error) window.dispatchEvent(new CustomEvent("wo:parts-used"));
  }

  // tiny wrappers
  async function addPackage(pkg: PackageDef) {
    await addMenuItem({
      kind: "normal",
      name: pkg.name,
      jobType: pkg.jobType === "inspection" ? "inspection" : "maintenance",
      laborHours: pkg.estLaborHours ?? null,
      notes: pkg.summary,
      source: "package",
    });
  }

  async function addSavedMenuItem(mi: MenuItemRow) {
    const lineId = await addMenuItem({
      kind: "normal",
      name: mi.name ?? "Service",
      jobType: "maintenance",
      laborHours:
        typeof mi.labor_time === "number"
          ? mi.labor_time
          : // fallback in case you add labor_hours to menu_items later
            null,
      notes: mi.description ?? null,
      source: "menu_item",
      returnLineId: true,
    });
    if (lineId && mi.id) {
      await autoAllocateMenuParts(mi.id, lineId);
    }
  }

  async function addTemplateAsLine(t: TemplateRow) {
    await addMenuItem({
      kind: "template",
      template: t,
    });
  }

  // AI
  async function runAiSuggest() {
    if (!aiPrompt.trim()) return;
    setAiBusy(true);
    try {
      const res = await fetch("/api/ai/menu/suggest", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: aiPrompt,
          vehicle: vehicle
            ? {
                year: vehicle.year,
                make: vehicle.make,
                model: vehicle.model,
              }
            : null,
        }),
      });
      const j = (await res.json()) as {
        items?: {
          name: string;
          jobType: JobType;
          laborHours?: number | null;
          notes?: string | null;
          parts?: PartToAllocate[];
        }[];
        error?: string;
      };
      if (!res.ok || j.error) throw new Error(j.error || "AI suggestion failed");

      const items = (j.items ?? []).slice(0, 5);
      if (!items.length) {
        toast.message("No suggestions returned.");
        return;
      }

      for (const it of items) {
        await addMenuItem({
          kind: "normal",
          name: it.name,
          jobType: it.jobType,
          laborHours: it.laborHours ?? null,
          notes: it.notes ?? null,
          partsToAllocate: Array.isArray(it.parts) ? it.parts : undefined,
          source: "ai",
        });
      }
      setAiOpen(false);
      setAiPrompt("");
    } catch (e: unknown) {
      const msg =
        e instanceof Error ? e.message : "Could not get suggestions.";
      toast.error(msg);
    } finally {
      setAiBusy(false);
    }
  }

  // ---------------------------------------------------------------------------
  // UI
  // ---------------------------------------------------------------------------
  const vehicleLabel =
    vehicle && (vehicle.year || vehicle.make || vehicle.model)
      ? `${vehicle.year ?? ""} ${vehicle.make ?? ""} ${vehicle.model ?? ""}`.trim()
      : vehicle?.license_plate
      ? `Plate ${vehicle.license_plate}`
      : null;

  return (
    <div className="space-y-5 text-white">
      {/* Header / context */}
      <div className="rounded-lg border border-neutral-800 bg-neutral-950/80 px-3 py-3 sm:px-4 sm:py-3">
        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div className="space-y-1">
            <div className="flex items-center gap-2">
              <h3 className="text-sm font-semibold text-orange-400">
                Quick Add Jobs
              </h3>
              <span className="rounded-full border border-neutral-700 bg-neutral-900 px-2 py-0.5 text-[10px] font-mono text-neutral-300">
                WO {workOrderId.slice(0, 8)}…
              </span>
            </div>
            {vehicleLabel && (
              <p className="text-[11px] text-neutral-400">
                Vehicle:&nbsp;
                <span className="font-medium text-neutral-200">
                  {vehicleLabel}
                </span>
              </p>
            )}
            {!vehicleLabel && (
              <p className="text-[11px] text-neutral-500">
                Add lines now — you can update vehicle details later.
              </p>
            )}
          </div>

          <div className="flex flex-wrap items-center justify-end gap-2">
            <button
              type="button"
              onClick={() =>
                router.push(`/work-orders/quote-review?woId=${workOrderId}`)
              }
              className="rounded-md border border-neutral-700 bg-neutral-900 px-3 py-1.5 text-xs sm:text-sm text-neutral-100 hover:border-orange-500 hover:bg-neutral-800"
            >
              Review quote
              {typeof woLineCount === "number" && woLineCount > 0
                ? ` (${woLineCount})`
                : ""}
            </button>
            <button
              type="button"
              onClick={() => setAiOpen(true)}
              className="rounded-md border border-blue-600 bg-neutral-950 px-3 py-1.5 text-xs sm:text-sm text-blue-300 hover:bg-blue-900/30"
              title="Describe work and let AI suggest service lines"
            >
              AI Suggest
            </button>
          </div>
        </div>
      </div>

      {/* Packages */}
      <div className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3 sm:p-4">
        <div className="mb-2 flex items-center justify-between gap-2">
          <h4 className="text-xs font-semibold uppercase tracking-wide text-neutral-300">
            Packages
          </h4>
          <p className="text-[10px] text-neutral-500">
            Common services with pre-set labor & notes.
          </p>
        </div>
        <div className="grid gap-2 sm:grid-cols-2">
          {packages.map((p) => (
            <button
              type="button"
              key={p.id}
              onClick={() => addPackage(p)}
              disabled={addingId === p.id || !shopReady}
              className="flex flex-col rounded-md border border-neutral-800 bg-neutral-950 p-3 text-left text-sm hover:border-orange-500/70 hover:bg-neutral-900 disabled:opacity-60"
              title={p.summary}
            >
              <div className="flex items-center justify-between gap-2">
                <span className="font-medium text-neutral-50">{p.name}</span>
                <span className="rounded-full border border-neutral-700 bg-neutral-900 px-2 py-0.5 text-[10px] uppercase tracking-wide text-neutral-300">
                  {p.jobType}
                </span>
              </div>
              <div className="mt-1 text-xs text-neutral-400">
                {p.estLaborHours != null
                  ? `~${p.estLaborHours.toFixed(1)}h`
                  : "Labor TBD"}
              </div>
              <div className="mt-1 line-clamp-2 text-[11px] text-neutral-500">
                {p.summary}
              </div>
            </button>
          ))}
        </div>
      </div>

      {/* Inspection templates */}
      <div className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3 sm:p-4">
        <div className="mb-2 flex items-center justify-between gap-2">
          <h4 className="text-xs font-semibold uppercase tracking-wide text-neutral-300">
            Inspection Templates
          </h4>
          <p className="text-[10px] text-neutral-500">
            Saved/standard inspections you can attach as jobs.
          </p>
        </div>
        <div className="grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
          {templatesLoading && (
            <div className="col-span-full w-full py-2 text-center text-sm text-neutral-400">
              Loading templates…
            </div>
          )}
          {!templatesLoading &&
            (templates.length ? (
              templates.slice(0, 9).map((t) => (
                <button
                  key={t.id}
                  type="button"
                  onClick={() => addTemplateAsLine(t)}
                  disabled={addingId === t.id || !shopReady}
                  className="flex flex-col rounded-md border border-neutral-800 bg-neutral-950 p-3 text-left text-sm hover:border-orange-500/70 hover:bg-neutral-900 disabled:opacity-60"
                  title={t.description ?? undefined}
                >
                  <span className="font-medium text-neutral-50">
                    {t.template_name ?? "Inspection"}
                  </span>
                  <div className="mt-1 text-xs text-neutral-400">
                    inspection •{" "}
                    {typeof t.labor_hours === "number"
                      ? `${t.labor_hours.toFixed(1)}h`
                      : "Labor TBD"}
                  </div>
                  {t.description && (
                    <div className="mt-1 line-clamp-2 text-[11px] text-neutral-500">
                      {t.description}
                    </div>
                  )}
                </button>
              ))
            ) : (
              <div className="col-span-full w-full py-2 text-center text-sm text-neutral-400">
                No templates yet.
              </div>
            ))}
        </div>
      </div>

      {/* From My Menu */}
      <div className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3 sm:p-4">
        <div className="mb-2 flex items-center justify-between gap-2">
          <h4 className="text-xs font-semibold uppercase tracking-wide text-neutral-300">
            From My Menu
          </h4>
          <p className="text-[10px] text-neutral-500">
            Saved services — great for repeat jobs.
          </p>
        </div>
        <div className="grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
          {menuLoading && (
            <div className="col-span-full w-full py-2 text-center text-sm text-neutral-400">
              Loading menu items…
            </div>
          )}
          {!menuLoading &&
            (menuItems.length ? (
              menuItems.slice(0, 9).map((mi) => (
                <button
                  type="button"
                  key={mi.id}
                  onClick={() => addSavedMenuItem(mi)}
                  disabled={addingId === (mi.name ?? "") || !shopReady}
                  className="flex flex-col rounded-md border border-neutral-800 bg-neutral-950 p-3 text-left text-sm hover:border-orange-500/70 hover:bg-neutral-900 disabled:opacity-60"
                  title={mi.description ?? undefined}
                >
                  <span className="font-medium text-neutral-50">
                    {mi.name}
                  </span>
                  <div className="mt-1 text-xs text-neutral-400">
                    {typeof mi.labor_time === "number"
                      ? `${mi.labor_time.toFixed(1)}h`
                      : "Labor TBD"}{" "}
                    •{" "}
                    {typeof mi.total_price === "number"
                      ? `$${mi.total_price.toFixed(0)}`
                      : "No price"}
                  </div>
                  {mi.description && (
                    <div className="mt-1 line-clamp-2 text-[11px] text-neutral-500">
                      {mi.description}
                    </div>
                  )}
                </button>
              ))
            ) : (
              <div className="col-span-full w-full py-2 text-center text-sm text-neutral-400">
                No saved menu items yet.
              </div>
            ))}
        </div>
      </div>

      {/* AI modal */}
      {aiOpen && (
        <div className="fixed inset-0 z-[300] grid place-items-center">
          <div
            className="absolute inset-0 bg-black/70 backdrop-blur-sm"
            onClick={() => setAiOpen(false)}
          />
          <div
            className="relative z-[310] w-full max-w-xl rounded-lg border border-orange-400 bg-neutral-950 p-4 sm:p-5 text-white shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="mb-3 flex items-center justify-between gap-2">
              <div>
                <div className="text-sm font-semibold text-orange-400">
                  AI: Suggest Services
                </div>
                <p className="text-[11px] text-neutral-400">
                  Describe the concern; we’ll suggest jobs and add them to this
                  work order.
                </p>
              </div>
              <button
                type="button"
                className="rounded-md border border-neutral-700 px-2 py-1 text-xs text-neutral-200 hover:bg-neutral-800"
                onClick={() => setAiOpen(false)}
              >
                ✕
              </button>
            </div>

            {vehicleLabel && (
              <div className="mb-2 rounded-md border border-neutral-800 bg-neutral-900/70 px-3 py-1.5 text-[11px] text-neutral-300">
                Using context for:{" "}
                <span className="font-medium text-neutral-100">
                  {vehicleLabel}
                </span>
              </div>
            )}

            <textarea
              rows={4}
              className="w-full rounded-md border border-neutral-700 bg-neutral-900 p-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-400 focus:outline-none"
              placeholder="Example: Customer reports vibration at highway speeds, no dash lights on. Recently replaced front tires."
              value={aiPrompt}
              onChange={(e) => setAiPrompt(e.target.value)}
            />
            <div className="mt-3 flex justify-end gap-2">
              <button
                type="button"
                className="rounded-md border border-neutral-700 px-3 py-1.5 text-xs sm:text-sm text-neutral-200 hover:bg-neutral-800"
                onClick={() => setAiOpen(false)}
              >
                Cancel
              </button>
              <button
                type="button"
                disabled={aiBusy}
                className="rounded-md border border-blue-600 bg-neutral-950 px-3 py-1.5 text-xs sm:text-sm text-blue-300 hover:bg-blue-900/30 disabled:opacity-60"
                onClick={runAiSuggest}
              >
                {aiBusy ? "Thinking…" : "Suggest & Add"}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/components/TechPanel.tsx */
/* =============================== */

"use client";

import * as React from "react";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
export type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
export type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
export type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];
export type Customer = DB["public"]["Tables"]["customers"]["Row"];

export default function TechPanel({
  workOrder,
  vehicle,
  customer,
  lines,
}: {
  workOrder: WorkOrder;
  vehicle: Vehicle | null;
  customer: Customer | null;
  lines: WorkOrderLine[];
}) {
  const vehicleText = vehicle
    ? `${vehicle.year ?? ""} ${vehicle.make ?? ""} ${vehicle.model ?? ""}${
        vehicle.license_plate ? ` (${vehicle.license_plate})` : ""
      }`.trim()
    : "—";

  const customerText = customer
    ? [customer.first_name ?? "", customer.last_name ?? ""].filter(Boolean).join(" ").trim() || "—"
    : "—";

  return (
    <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
      <div className="mb-2 font-semibold text-orange-400">Tech Panel</div>
      <p className="text-sm text-neutral-300">
        Work on <strong>{workOrder.custom_id || workOrder.id.slice(0, 8)}</strong>.{" "}
        Vehicle: {vehicleText} · Customer: {customerText}.
      </p>
      <p className="mt-2 text-sm text-neutral-400">Jobs: {lines.length}</p>

      <div className="mt-3">
        <button
          onClick={() => window.location.reload()}
          className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:border-orange-500"
        >
          Refresh
        </button>
      </div>

      <div className="mt-4 text-xs text-neutral-500">
        Placeholder: wire your existing tech UI (punch, cause/correction, add job/quote, AI suggestions, photos) here.
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: src/profixiq/knowledge/base.ts */
/* =============================== */

/**
 * Lightweight, hard-coded knowledge base for the ProFixIQ agent.
 *
 * This is intentionally simple and file-based so we can:
 *  - keep core concepts/versioning in git
 *  - hydrate vector search or prompt scaffolding for the agent
 *
 * Later we can replace/augment this with DB-backed content.
 */

export type KnowledgeTag =
  | "ai"
  | "architecture"
  | "work_orders"
  | "inspections"
  | "payments"
  | "integrations"
  | "support"
  | "pricing";

export interface KnowledgeItem {
  id: string;
  title: string;
  body: string;
  tags: KnowledgeTag[];
  /**
   * Optional link back into the app (e.g. settings page, report, etc.)
   * so the agent can point users to the right screen.
   */
  appPath?: string;
}

/**
 * Seed knowledge items. Keep these high-level and durable; ephemeral,
 * shop-specific stuff belongs in the DB, not here.
 */
export const ProFixIQKnowledgeBase: KnowledgeItem[] = [
  {
    id: "ai-overview",
    title: "ProFixIQ AI overview",
    body: [
      "ProFixIQ uses AI to assist with inspections, quotes, and work orders.",
      "Key AI features include:",
      "- AI quote suggestions based on menu items and past work.",
      "- Inspection-to-quote automation, turning failed items into jobs.",
      "- Work-order and invoice review to highlight inconsistencies.",
      "- Future TechBot / InspectionBot style chat helpers for technicians.",
      "",
      "AI should never silently override user choices. Human edits, approvals,",
      "and overrides are always the source of truth and are used as training data.",
    ].join(" "),
    tags: ["ai", "architecture"],
    appPath: "/ai",
  },
  {
    id: "work-orders-core",
    title: "Work orders & job lines",
    body: [
      "A work order represents a single visit/RO. Individual jobs are tracked",
      "as work_order_lines, which may be created manually, from inspections,",
      "or from saved menu items. Approval state and technician assignment live",
      "on the line, not the work order.",
    ].join(" "),
    tags: ["work_orders", "architecture"],
    appPath: "/work-orders",
  },
  {
    id: "inspections-core",
    title: "Inspections & results",
    body: [
      "Inspections are built from configurable templates. Each template has",
      "sections and items with statuses like ok, fail, recommend, and na.",
      "Inspection results can be converted into quote/work-order lines by",
      "mapping failed items to saved menu items or ad-hoc jobs.",
    ].join(" "),
    tags: ["inspections", "ai"],
    appPath: "/inspections",
  },
  {
    id: "payments-core",
    title: "Stripe subscriptions & payments",
    body: [
      "ProFixIQ uses Stripe for subscription billing and card payments.",
      "Each shop has a Stripe customer record tied to its ProFixIQ account.",
      "Invoices and receipts are generated in Stripe but surfaced inside the app.",
    ].join(" "),
    tags: ["payments", "integrations"],
    appPath: "/settings/billing",
  },
];


/* =============================== */
/* FILE: app/parts/requests/[id]/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type Request = DB["public"]["Tables"]["part_requests"]["Row"];
type Item = DB["public"]["Tables"]["part_request_items"]["Row"] & {
  // schema is catching up
  work_order_line_id?: string | null;
  markup_pct?: number | null;
  qty?: number | null;
};
type Status = Request["status"];
type Part = DB["public"]["Tables"]["parts"]["Row"];

const DEFAULT_MARKUP = 30; // %

export default function PartsRequestDetail() {
  const { id } = useParams<{ id: string }>();
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const router = useRouter();

  const [req, setReq] = useState<Request | null>(null);
  const [items, setItems] = useState<Item[]>([]);
  const [loading, setLoading] = useState(true);
  const [parts, setParts] = useState<Part[]>([]);
  const [markupPct, setMarkupPct] = useState<Record<string, number>>({});
  const [savedRows, setSavedRows] = useState<Record<string, boolean>>({});
  // per-line manual part inputs
  const [manualParts, setManualParts] = useState<
    Record<string, { name: string; sku: string }>
  >({});

  async function load() {
    setLoading(true);

    // header
    const { data: r, error: rErr } = await supabase
      .from("part_requests")
      .select("*")
      .eq("id", id)
      .maybeSingle();
    if (rErr) toast.error(rErr.message);
    setReq(r ?? null);

    // items
    const { data: its, error: itErr } = await supabase
      .from("part_request_items")
      .select("*")
      .eq("request_id", id);
    if (itErr) toast.error(itErr.message);
    const itemsList = (its ?? []) as Item[];
    setItems(itemsList);

    // inventory
    if (r?.shop_id) {
      const { data: ps } = await supabase
        .from("parts")
        .select("*")
        .eq("shop_id", r.shop_id)
        .order("name")
        .limit(500);
      setParts(ps ?? []);
    } else {
      setParts([]);
    }

    // markup init
    const m: Record<string, number> = {};
    for (const it of itemsList) {
      m[it.id] =
        typeof it.markup_pct === "number" && !Number.isNaN(it.markup_pct)
          ? it.markup_pct
          : DEFAULT_MARKUP;
    }
    setMarkupPct(m);

    // clear saved flags on fresh load
    setSavedRows({});

    setLoading(false);
  }

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id]);

  function getLineIdFromItems(list: Item[]): string | null {
    for (const it of list) {
      if (it.work_order_line_id) return it.work_order_line_id;
    }
    return null;
  }

  async function setStatus(s: Status) {
    const { error } = await supabase.rpc("set_part_request_status", {
      p_request: id,
      p_status: s,
    });
    if (error) {
      toast.error(error.message);
      return;
    }

    if (s === "quoted") {
      const lineId = getLineIdFromItems(items);
      if (lineId) {
        // mark line quoted
        const { error: wolErr } = await supabase
          .from("work_order_lines")
          .update({
            status: "quoted",
          } as DB["public"]["Tables"]["work_order_lines"]["Update"])
          .eq("id", lineId);
        if (wolErr) {
          console.warn("could not set line to quoted:", wolErr.message);
        }

        // save to menu items
        try {
          const res = await fetch("/api/menu-items/save-from-line", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ workOrderLineId: lineId }),
          });
          const j = (await res.json().catch(() => null)) as {
            ok?: boolean;
            error?: string;
          } | null;
          if (!res.ok) {
            console.warn("menu save failed:", j?.error);
            toast.warning("Quoted, but couldn’t save to menu items.");
          } else {
            toast.success("Quoted and saved to menu items.");
          }
        } catch (e) {
          console.warn("menu save error:", e);
          toast.warning("Quoted, but couldn’t save to menu items.");
        }
      } else {
        toast.success("Parts request marked as quoted.");
      }
    } else {
      toast.success(`Parts request marked as ${s}.`);
    }

    await load();
  }

  async function saveLine(it: Item) {
    const qty =
      typeof it.qty === "number" && !Number.isNaN(it.qty) ? it.qty : null;
    if (!qty || qty <= 0) {
      toast.error("Enter a quantity greater than 0 before saving.");
      return;
    }

    const cost =
      typeof it.quoted_price === "number" && !Number.isNaN(it.quoted_price)
        ? it.quoted_price
        : 0;
    const m = markupPct[it.id] ?? DEFAULT_MARKUP;

    const { error } = await supabase
      .from("part_request_items")
      .update({
        vendor: it.vendor ?? null,
        quoted_price: cost,
        qty,
        markup_pct: m,
      })
      .eq("id", it.id);

    if (error) {
      toast.error(error.message);
      return;
    }

    setSavedRows((prev) => ({ ...prev, [it.id]: true }));
    toast.success("Line saved");
  }

  async function attachPartToItem(itemId: string, partId: string) {
    const p = parts.find((x) => x.id === partId);
    const desc = p?.name ?? "Part";

    const { error } = await supabase
      .from("part_request_items")
      .update({
        part_id: partId,
        description: desc,
      })
      .eq("id", itemId);

    if (error) {
      console.warn("attachPartToItem failed:", error.message);
      toast.error("Cannot attach part — check RLS.");
    } else {
      // change → unsave
      setSavedRows((prev) => ({ ...prev, [itemId]: false }));
      await load();
    }
  }

  // manual: create part in inventory, then attach
  async function createManualPartAndAttach(
    itemId: string,
    name: string,
    sku: string
  ) {
    const item = items.find((x) => x.id === itemId);
    if (!item) return;
    if (!req?.shop_id) {
      toast.error("Cannot create part — missing shop.");
      return;
    }
    if (!name.trim()) {
      toast.error("Enter a name for the part.");
      return;
    }

    // create part in inventory
    const { data: inserted, error } = await supabase
      .from("parts")
      .insert({
        shop_id: req.shop_id,
        name: name.trim(),
        sku: sku.trim() || null,
      })
      .select("*")
      .maybeSingle<Part>();

    if (error) {
      toast.error(error.message);
      return;
    }

    if (!inserted) {
      toast.error("Unable to create part.");
      return;
    }

    // attach to item
    const { error: attachErr } = await supabase
      .from("part_request_items")
      .update({
        part_id: inserted.id,
        description: inserted.name ?? name.trim(),
      })
      .eq("id", itemId);

    if (attachErr) {
      toast.error(attachErr.message);
      return;
    }

    toast.success("Part created and attached.");
    // clear manual fields for that line
    setManualParts((prev) => {
      const copy = { ...prev };
      delete copy[itemId];
      return copy;
    });

    // reload so the new part shows up in the select too
    await load();
  }

  const grandTotals = (() => {
    let sum = 0;
    for (const it of items) {
      const cost =
        typeof it.quoted_price === "number" && !Number.isNaN(it.quoted_price)
          ? it.quoted_price
          : 0;
      const m = markupPct[it.id] ?? DEFAULT_MARKUP;
      const unitSell = cost * (1 + m / 100);
      const qty =
        typeof it.qty === "number" && it.qty > 0 ? Number(it.qty) : 0;
      sum += unitSell * qty;
    }
    return sum;
  })();

  return (
    <div className="p-6 text-white space-y-4">
      <button
        className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
        onClick={() => router.back()}
      >
        ← Back
      </button>

      {loading || !req ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-neutral-400">
          Loading…
        </div>
      ) : (
        <>
          {/* header */}
          <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
            <div className="flex flex-wrap items-center justify-between gap-2">
              <div>
                <div className="text-xl font-semibold">
                  Request #{req.id.slice(0, 8)}
                </div>
                <div className="text-sm text-neutral-400">
                  WO: {req.work_order_id ?? "—"} ·{" "}
                  {req.created_at
                    ? new Date(req.created_at).toLocaleString()
                    : "—"}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-sm text-neutral-300 capitalize">
                  Status: {req.status}
                </span>
                {req.status !== "approved" && (
                  <button
                    className="rounded border border-blue-600 text-blue-300 px-3 py-1.5 text-sm hover:bg-blue-900/20"
                    onClick={() => void setStatus("approved")}
                  >
                    Mark Approved
                  </button>
                )}
                {req.status !== "quoted" && (
                  <button
                    className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10"
                    onClick={() => void setStatus("quoted")}
                  >
                    Mark Quoted
                  </button>
                )}
              </div>
            </div>
          </div>

          {/* table */}
          <div className="rounded border border-neutral-800 overflow-hidden">
            <table className="w-full text-sm">
              <thead className="bg-neutral-900 text-neutral-400">
                <tr>
                  <th className="p-2 text-left">Inventory</th>
                  <th className="p-2 text-left">Description</th>
                  <th className="p-2 text-right">Qty</th>
                  <th className="p-2 text-left">Vendor</th>
                  <th className="p-2 text-right">Cost (unit)</th>
                  <th className="p-2 text-right">Markup %</th>
                  <th className="p-2 text-right">Sell (unit)</th>
                  <th className="p-2 text-right">Line total</th>
                  <th className="p-2 w-28"></th>
                </tr>
              </thead>
              <tbody>
                {items.map((it) => {
                  const cost =
                    typeof it.quoted_price === "number" &&
                    !Number.isNaN(it.quoted_price)
                      ? it.quoted_price
                      : 0;
                  const m = markupPct[it.id] ?? DEFAULT_MARKUP;
                  const qty =
                    typeof it.qty === "number" && it.qty > 0 ? it.qty : null;
                  const unitSell = cost * (1 + m / 100);
                  const lineTotal = unitSell * (qty ?? 0);
                  const isSaved = savedRows[it.id] === true;

                  const manual = manualParts[it.id] || { name: "", sku: "" };

                  return (
                    <tr
                      key={it.id}
                      className={`border-t border-neutral-800 ${
                        isSaved ? "bg-neutral-900/50 text-neutral-400" : ""
                      }`}
                    >
                      <td className="p-2 align-top">
                        <div className="flex flex-col gap-1">
                          <select
                            className="w-40 rounded border border-neutral-700 bg-neutral-900 p-1 text-xs disabled:opacity-50"
                            value={it.part_id ?? ""}
                            onChange={(e) => {
                              setSavedRows((prev) => ({
                                ...prev,
                                [it.id]: false,
                              }));
                              void attachPartToItem(it.id, e.target.value);
                            }}
                            disabled={isSaved}
                          >
                            <option value="">— select —</option>
                            {parts.map((p) => (
                              <option key={p.id} value={p.id as string}>
                                {p.sku ? `${p.sku} — ${p.name}` : p.name}
                              </option>
                            ))}
                          </select>

                          {/* manual entry */}
                          <div className="flex gap-1">
                            <input
                              className="flex-1 rounded border border-neutral-700 bg-neutral-900 p-1 text-xs disabled:opacity-50"
                              placeholder="Manual part name"
                              value={manual.name}
                              onChange={(e) =>
                                setManualParts((prev) => ({
                                  ...prev,
                                  [it.id]: {
                                    name: e.target.value,
                                    sku: prev[it.id]?.sku ?? "",
                                  },
                                }))
                              }
                              disabled={isSaved}
                            />
                            <input
                              className="w-20 rounded border border-neutral-700 bg-neutral-900 p-1 text-xs disabled:opacity-50"
                              placeholder="SKU"
                              value={manual.sku}
                              onChange={(e) =>
                                setManualParts((prev) => ({
                                  ...prev,
                                  [it.id]: {
                                    name: prev[it.id]?.name ?? "",
                                    sku: e.target.value,
                                  },
                                }))
                              }
                              disabled={isSaved}
                            />
                          </div>
                          <button
                            className="rounded border border-neutral-700 bg-neutral-900 px-2 py-0.5 text-xs hover:bg-neutral-800 disabled:opacity-50"
                            onClick={() =>
                              void createManualPartAndAttach(
                                it.id,
                                manual.name,
                                manual.sku
                              )
                            }
                            disabled={isSaved}
                          >
                            Add & attach
                          </button>
                        </div>
                      </td>
                      <td className="p-2 align-top">{it.description}</td>
                      <td className="p-2 text-right align-top">
                        <input
                          type="number"
                          min={1}
                          step={1}
                          className="w-16 rounded border border-neutral-700 bg-neutral-900 p-1 text-right disabled:opacity-50"
                          value={qty ?? ""} // allow empty
                          onChange={(e) => {
                            const raw = e.target.value;
                            setItems((prev) => {
                              return prev.map((x) => {
                                if (x.id !== it.id) return x;
                                return {
                                  ...x,
                                  qty: raw === "" ? null : Number(raw),
                                } as Item;
                              });
                            });
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 align-top">
                        <input
                          className="w-32 rounded border border-neutral-700 bg-neutral-900 p-1 disabled:opacity-50"
                          value={it.vendor ?? ""}
                          onChange={(e) => {
                            const v = e.target.value;
                            setItems((prev) =>
                              prev.map((x) =>
                                x.id === it.id ? { ...x, vendor: v } : x
                              )
                            );
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 text-right align-top">
                        <input
                          type="number"
                          step={0.01}
                          className="w-24 rounded border border-neutral-700 bg-neutral-900 p-1 text-right disabled:opacity-50"
                          value={cost === 0 ? "" : cost}
                          onChange={(e) => {
                            const raw = e.target.value;
                            const v = raw === "" ? null : Number(raw);
                            setItems((prev) =>
                              prev.map((x) =>
                                x.id === it.id ? { ...x, quoted_price: v } : x
                              )
                            );
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 text-right align-top">
                        <input
                          type="number"
                          step={1}
                          className="w-20 rounded border border-neutral-700 bg-neutral-900 p-1 text-right disabled:opacity-50"
                          value={m}
                          onChange={(e) => {
                            setMarkupPct((prev) => ({
                              ...prev,
                              [it.id]: Math.max(
                                0,
                                Number(e.target.value || DEFAULT_MARKUP)
                              ),
                            }));
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 text-right tabular-nums align-top">
                        {unitSell.toFixed(2)}
                      </td>
                      <td className="p-2 text-right tabular-nums align-top">
                        {lineTotal.toFixed(2)}
                      </td>
                      <td className="p-2 text-right align-top">
                        <button
                          className={`rounded border px-2 py-1 text-xs ${
                            isSaved
                              ? "border-neutral-700 bg-neutral-800/60 text-neutral-300 cursor-default"
                              : "border-neutral-700 hover:bg-neutral-800"
                          }`}
                          onClick={() => !isSaved && void saveLine(it)}
                          disabled={isSaved}
                        >
                          {isSaved ? "Saved" : "Save"}
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
              <tfoot>
                <tr className="bg-neutral-900/50">
                  <td className="p-2 text-right" colSpan={7}>
                    <span className="text-sm text-neutral-300">
                      Total (with markup)
                    </span>
                  </td>
                  <td className="p-2 text-right tabular-nums font-semibold">
                    {grandTotals.toFixed(2)}
                  </td>
                  <td />
                </tr>
              </tfoot>
            </table>
          </div>
        </>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: app/parts/requests/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type Request = DB["public"]["Tables"]["part_requests"]["Row"];
type Item = DB["public"]["Tables"]["part_request_items"]["Row"];

const STATUSES: Request["status"][] = [
  "requested",
  "quoted",
  "approved",
  "fulfilled",
  "rejected",
  "cancelled",
];

export default function PartsRequestsPage() {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [byStatus, setByStatus] = useState<
    Record<Request["status"], (Request & { items: Item[] })[]>
  >({
    requested: [],
    quoted: [],
    approved: [],
    fulfilled: [],
    rejected: [],
    cancelled: [],
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    void (async () => {
      setLoading(true);

      // 1) fetch all requests
      const { data: reqs, error } = await supabase
        .from("part_requests")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) {
        console.error("load part_requests failed:", error.message);
        setLoading(false);
        return;
      }

      const requestList = reqs ?? [];
      const ids = requestList.map((r) => r.id);

      // 2) fetch all items for these requests
      const itemsMap: Record<string, Item[]> = {};
      if (ids.length) {
        const { data: items } = await supabase
          .from("part_request_items")
          .select("*")
          .in("request_id", ids);

        for (const it of items ?? []) {
          (itemsMap[it.request_id] ||= []).push(it);
        }
      }

      // 3) group by status
      const grouped: Record<Request["status"], (Request & { items: Item[] })[]> = {
        requested: [],
        quoted: [],
        approved: [],
        fulfilled: [],
        rejected: [],
        cancelled: [],
      };

      for (const r of requestList) {
  const status = (r.status ?? "requested") as Request["status"];
  const bucket = grouped[status];
  bucket.push({ ...r, items: itemsMap[r.id] ?? [] });
}

      setByStatus(grouped);
      setLoading(false);
    })();
  }, [supabase]);

  return (
    <div className="p-6 text-white space-y-4">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Parts Requests</h1>
        <Link
          href="/parts"
          className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
        >
          Parts Catalog
        </Link>
      </div>

      {loading ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-neutral-400">
          Loading…
        </div>
      ) : (
        <div className="grid gap-4 lg:grid-cols-3 xl:grid-cols-4">
          {STATUSES.map((status) => {
            const list = byStatus[status] ?? [];
            return (
              <div
                key={status}
                className="rounded border border-neutral-800 bg-neutral-900 flex flex-col"
              >
                <div className="border-b border-neutral-800 px-3 py-2 text-neutral-300 capitalize">
                  {status}
                </div>
                <div className="flex-1 space-y-3 p-3">
                  {list.length === 0 ? (
                    <div className="text-sm text-neutral-500">No requests</div>
                  ) : (
                    list.map((r) => (
                      <Link
                        key={r.id}
                        href={`/parts/requests/${r.id}`}
                        className="block rounded border border-neutral-800 p-3 hover:border-orange-500"
                      >
                        <div className="text-sm font-semibold">
                          WO: {r.work_order_id ?? "—"}
                        </div>
                        <div className="text-xs text-neutral-400">
                          {r.created_at
                            ? new Date(r.created_at).toLocaleString()
                            : "—"}
                        </div>
                        <ul className="mt-2 list-disc space-y-1 pl-5 text-sm">
                          {(r.items ?? []).slice(0, 4).map((it) => (
                            <li key={it.id}>
                              {it.description} × {Number(it.qty)}
                            </li>
                          ))}
                          {(r.items ?? []).length > 4 && (
                            <li>
                              + {(r.items ?? []).length - 4} more…
                            </li>
                          )}
                        </ul>
                      </Link>
                    ))
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: app/parts/quoting/page.tsx */
/* =============================== */

"use client";

import React, { useCallback, useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { toast } from "sonner";
import { format } from "date-fns";
import dynamic from "next/dynamic";

import { createBrowserSupabase } from "@/features/shared/lib/supabase/client";
import type { Database } from "@shared/types/types/supabase";
import VoiceContextSetter from "@/features/shared/voice/VoiceContextSetter";
import VoiceButton from "@/features/shared/voice/VoiceButton";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";

const PartsDrawer = dynamic(() => import("@/features/parts/components/PartsDrawer"), {
  ssr: false,
});

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];
type Customer = DB["public"]["Tables"]["customers"]["Row"];

type QueueRow = WorkOrderLine & {
  work_order: WorkOrder | null;
  vehicle: Vehicle | null;
  customer: Customer | null;
};

const BASE_BADGE =
  "inline-flex items-center whitespace-nowrap rounded border px-2 py-0.5 text-xs font-medium";
const BADGE: Record<string, string> = {
  awaiting: "bg-sky-900/20 border-sky-500/40 text-sky-300",
  awaiting_approval: "bg-blue-900/20 border-blue-500/40 text-blue-300",
  queued: "bg-indigo-900/20 border-indigo-500/40 text-indigo-300",
  in_progress: "bg-orange-900/20 border-orange-500/40 text-orange-300",
  on_hold: "bg-amber-900/20 border-amber-500/40 text-amber-300",
  completed: "bg-green-900/20 border-green-500/40 text-green-300",
};
const chip = (s: string | null | undefined): string => {
  const k = (s ?? "awaiting").toLowerCase().replaceAll(" ", "_");
  return `${BASE_BADGE} ${BADGE[k] ?? BADGE.awaiting}`;
};

export default function QuotingQueuePage(): JSX.Element {
  const supabase = useMemo(() => createBrowserSupabase(), []);

  const [rows, setRows] = useState<QueueRow[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [err, setErr] = useState<string | null>(null);

  const [selectedId, setSelectedId] = useState<string | null>(null);
  const selected = useMemo(() => rows.find((r) => r.id === selectedId) ?? null, [rows, selectedId]);

  const [bulkQueue, setBulkQueue] = useState<string[]>([]);
  const bulkActive = bulkQueue.length > 0;

  const fetchQueue = useCallback(async () => {
    setLoading(true);
    setErr(null);
    try {
      const { data: lines, error: lerr } = await supabase
        .from("work_order_lines")
        .select("*")
        .eq("approval_state", "pending")
        .order("created_at", { ascending: true });

      if (lerr) throw lerr;

      const wol = (lines ?? []) as WorkOrderLine[];
      if (wol.length === 0) {
        setRows([]);
        setLoading(false);
        return;
      }

      const woIds = [...new Set(wol.map((l) => l.work_order_id).filter(Boolean) as string[])];
      const { data: woRows } = await supabase.from("work_orders").select("*").in("id", woIds);

      const woById = new Map<string, WorkOrder>();
      (woRows ?? []).forEach((w) => woById.set(w.id, w as WorkOrder));

      const vehIds = [...new Set((woRows ?? []).map(w => (w as WorkOrder).vehicle_id).filter(Boolean) as string[])];
      const custIds = [...new Set((woRows ?? []).map(w => (w as WorkOrder).customer_id).filter(Boolean) as string[])];

      const [vehRes, custRes] = await Promise.all([
        vehIds.length ? supabase.from("vehicles").select("*").in("id", vehIds) : Promise.resolve({ data: [] } as const),
        custIds.length
          ? supabase.from("customers").select("*").in("id", custIds)
          : Promise.resolve({ data: [] } as const),
      ]);

      const vById = new Map<string, Vehicle>();
      (vehRes.data ?? []).forEach((v) => vById.set((v as Vehicle).id, v as Vehicle));

      const cById = new Map<string, Customer>();
      (custRes.data ?? []).forEach((c) => cById.set((c as Customer).id, c as Customer));

      const out: QueueRow[] = wol.map((l) => {
        const wo = l.work_order_id ? woById.get(l.work_order_id) ?? null : null;
        const vehicle = wo?.vehicle_id ? vById.get(wo.vehicle_id) ?? null : null;
        const customer = wo?.customer_id ? cById.get(wo.customer_id) ?? null : null;
        return { ...l, work_order: wo, vehicle, customer };
      });

      setRows(out);
    } catch (e) {
      const msg = (e as { message?: string })?.message ?? "Failed to load quoting queue.";
      setErr(msg);
    } finally {
      setLoading(false);
    }
  }, [supabase]);

  useEffect(() => { void fetchQueue(); }, [fetchQueue]);

  useEffect(() => {
    const ch = supabase
      .channel("quote-queue")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "work_order_lines", filter: "approval_state=eq.pending" },
        () => void fetchQueue()
      )
      .subscribe();
    return () => { try { supabase.removeChannel(ch); } catch {} };
  }, [supabase, fetchQueue]);

  const startBulk = useCallback(() => {
    if (!rows.length) return;
    const ids = rows.map((r) => r.id);
    setBulkQueue(ids);
    setSelectedId(ids[0] ?? null);
    toast.message(`Quoting ${ids.length} pending line(s)…`);
  }, [rows]);

  useEffect(() => {
    if (!selectedId) return;
    const evt = `parts-drawer:closed:${selectedId}`;
    const handler = () => {
      if (bulkActive) {
        const [, ...rest] = bulkQueue;
        setBulkQueue(rest);
        setSelectedId(rest[0] ?? null);
        if (rest.length === 0) void fetchQueue();
      } else {
        setSelectedId(null);
        void fetchQueue();
      }
    };
    window.addEventListener(evt, handler as EventListener);
    return () => window.removeEventListener(evt, handler as EventListener);
  }, [selectedId, bulkActive, bulkQueue, fetchQueue]);

  // ---- AI Apply: suggest + server inserts allocations + labor
  const aiApply = useCallback(async (row: QueueRow) => {
    if (!row.id) return;
    toast.loading("AI preparing parts & labor…", { id: `ai-${row.id}` });

    try {
      const suggestion = await requestQuoteSuggestion({
        item: row.description ?? "Job",
        notes: row.notes ?? "",
        section: "Quote Queue",
        status: "recommend",
        vehicle: row.vehicle ?? undefined,
      });

      if (!suggestion) {
        toast.error("AI returned no suggestion.", { id: `ai-${row.id}` });
        return;
      }

      const r = await fetch("/api/quotes/apply-ai", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ workOrderLineId: row.id, suggestion }),
      });

      const j = (await r.json()) as { ok?: boolean; labor_applied?: boolean; unmatched?: { name: string; qty: number }[]; error?: string };
      if (!r.ok || !j?.ok) {
        throw new Error(j?.error || "Apply AI failed");
      }

      if (j.unmatched && j.unmatched.length) {
        const list = j.unmatched.map(u => `${u.qty}× ${u.name}`).join(", ");
        toast.message(`Some parts need manual matching: ${list}`, { id: `ai-${row.id}` });
      } else {
        toast.success("AI parts & labor applied", { id: `ai-${row.id}` });
      }
      await fetchQueue();
    } catch (e) {
      toast.error((e as { message?: string })?.message ?? "AI apply failed", { id: `ai-${row.id}` });
    }
  }, [fetchQueue]);

  // ---- Mark as quoted (still pending approval) + grow Saved Menu
  const markQuoted = useCallback(async (row: QueueRow) => {
    if (!row.id) return;
    toast.loading("Marking as quoted…", { id: `quoted-${row.id}` });

    try {
      // Create/merge Saved Menu record for this Y/M/M + job title
      const r = await fetch("/api/menu-items/upsert-from-line", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ workOrderLineId: row.id }),
      });
      const j = (await r.json()) as { id?: string | null; ok?: boolean; error?: string };
      if (!r.ok || j?.error) {
        throw new Error(j?.error || "Could not upsert saved menu item");
      }

      // Keep status & approval_state unchanged (still pending).
      // You can optionally stamp a small flag in notes that says "quoted".
      const nextNotes = `${row.notes ?? ""}`.includes("[quoted]")
        ? row.notes
        : ([row.notes ?? "", "[quoted]"].filter(Boolean).join(" ").trim());

      const { error: ue } = await supabase
        .from("work_order_lines")
        .update({ notes: nextNotes } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", row.id);
      if (ue) throw ue;

      toast.success("Marked as quoted (awaiting approval). Saved Menu updated.", { id: `quoted-${row.id}` });
      await fetchQueue();
    } catch (e) {
      toast.error((e as { message?: string })?.message ?? "Failed to mark as quoted", { id: `quoted-${row.id}` });
    }
  }, [supabase, fetchQueue]);

  return (
    <div className="p-4 sm:p-6 text-white">
      <VoiceContextSetter currentView="parts_quoting" />

      <div className="mb-4 flex items-center justify-between">
        <h1 className="text-2xl font-semibold">Quoting Queue</h1>
        <div className="flex items-center gap-2">
          <Link href="/parts/inventory" className="text-sm text-orange-400 hover:underline">Open Inventory →</Link>
          <button
            type="button"
            className="rounded bg-blue-600 px-3 py-1.5 text-sm font-semibold text-white hover:bg-blue-500 disabled:opacity-50"
            onClick={startBulk}
            disabled={rows.length === 0}
          >
            Quote all pending ({rows.length})
          </button>
        </div>
      </div>

      {err && <div className="mb-4 rounded border border-red-500/40 bg-red-500/10 p-3 text-red-300">{err}</div>}

      <div className="grid grid-cols-1 gap-6 lg:grid-cols-[420px_1fr]">
        {/* LEFT: queue */}
        <div className="rounded border border-neutral-800 bg-neutral-900">
          <div className="border-b border-neutral-800 p-3 text-sm text-neutral-300">Pending approval lines</div>
          {loading ? (
            <div className="p-3 text-neutral-400">Loading…</div>
          ) : rows.length === 0 ? (
            <div className="p-3 text-neutral-400">Nothing awaiting quoting.</div>
          ) : (
            <ul className="divide-y divide-neutral-800">
              {rows.map((r) => (
                <li key={r.id} className="p-3">
                  <div className="flex items-start justify-between gap-3">
                    <div className="min-w-0">
                      <div className="truncate font-medium">{r.description || r.complaint || "Untitled job"}</div>
                      <div className="mt-0.5 text-xs text-neutral-400">
                        WO: {r.work_order?.custom_id || r.work_order?.id?.slice(0, 8) || "—"} •{" "}
                        {r.vehicle
                          ? `${r.vehicle.year ?? ""} ${r.vehicle.make ?? ""} ${r.vehicle.model ?? ""}`.trim()
                          : "No vehicle"}
                        {" • "}
                        {r.created_at ? format(new Date(r.created_at), "PPp") : "—"}
                      </div>
                      {r.notes && <div className="mt-1 truncate text-xs text-neutral-400">Notes: {r.notes}</div>}
                    </div>

                    <div className="flex shrink-0 items-center gap-2">
                      <span className={chip(r.status)}>{(r.status ?? "awaiting").replaceAll("_", " ")}</span>
                      <button
                        type="button"
                        className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                        onClick={() => void aiApply(r)}
                        title="AI: allocate parts + labor"
                      >
                        AI Apply
                      </button>
                      <button
                        type="button"
                        className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                        onClick={() => setSelectedId(r.id)}
                        title="Open Parts Drawer"
                      >
                        Quote
                      </button>
                      <button
                        type="button"
                        className="rounded bg-emerald-600 px-2 py-1 text-xs font-semibold text-black hover:bg-emerald-500"
                        onClick={() => void markQuoted(r)}
                        title="Mark as quoted (keeps awaiting approval) and grow Saved Menu"
                      >
                        Mark Quoted
                      </button>
                    </div>
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>

        {/* RIGHT: details */}
        <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
          <h2 className="mb-2 text-lg font-semibold">Details</h2>
          {selected ? (
            <div className="space-y-2 text-sm">
              <div className="text-neutral-400">Work Order</div>
              <div className="font-medium">
                {selected.work_order
                  ? selected.work_order.custom_id || selected.work_order.id?.slice(0, 8)
                  : "—"}
              </div>

              <div className="text-neutral-400">Vehicle</div>
              <div className="font-medium">
                {selected.vehicle
                  ? `${selected.vehicle.year ?? ""} ${selected.vehicle.make ?? ""} ${selected.vehicle.model ?? ""}`.trim() ||
                    "—"
                  : "—"}
              </div>

              <div className="text-neutral-400">Customer</div>
              <div className="font-medium">
                {selected.customer
                  ? [selected.customer.first_name ?? "", selected.customer.last_name ?? ""].filter(Boolean).join(" ") ||
                    "—"
                  : "—"}
              </div>

              <div className="text-neutral-400">Description</div>
              <div className="font-medium">{selected.description ?? "—"}</div>

              <div className="text-neutral-400">Notes</div>
              <div className="whitespace-pre-wrap font-medium">{selected.notes ?? "—"}</div>
            </div>
          ) : (
            <div className="text-neutral-400">Select a line on the left to see details.</div>
          )}
        </div>
      </div>

      {/* Parts drawer */}
      {selected && selected.work_order?.id && (
        <PartsDrawer
          open
          workOrderId={selected.work_order.id}
          workOrderLineId={selected.id}
          vehicleSummary={
            selected.vehicle
              ? {
                  year: (selected.vehicle.year as string | number | null)?.toString() ?? null,
                  make: selected.vehicle.make ?? null,
                  model: selected.vehicle.model ?? null,
                }
              : null
          }
          jobDescription={selected.description ?? null}
          jobNotes={selected.notes ?? null}
          closeEventName={`parts-drawer:closed:${selected.id}`}
        />
      )}

      <VoiceButton />
    </div>
  );
}

/* =============================== */
/* FILE: app/parts/inventory/page.tsx */
/* =============================== */

"use client";

import React, { useCallback, useEffect, useMemo, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { v4 as uuidv4 } from "uuid";

/* ----------------------------- Types ----------------------------- */

type DB = Database;
type Part = DB["public"]["Tables"]["parts"]["Row"];
type PartInsert = DB["public"]["Tables"]["parts"]["Insert"];
type PartUpdate = DB["public"]["Tables"]["parts"]["Update"];
type StockLoc = DB["public"]["Tables"]["stock_locations"]["Row"];
type StockMove = DB["public"]["Tables"]["stock_moves"]["Row"];

// app-side view of the enum
type StockMoveReason = "receive" | "adjust" | "consume" | "transfer";

/* --------------------------- UI helpers -------------------------- */

function Modal(props: {
  open: boolean;
  title: string;
  onClose: () => void;
  children: React.ReactNode;
  footer?: React.ReactNode;
  widthClass?: string;
}) {
  const { open, title, onClose, children, footer, widthClass = "max-w-xl" } = props;
  if (!open) return null;
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 p-4">
      <div
        className={`w-full ${widthClass} rounded border border-orange-500 bg-neutral-950 p-4 text-white shadow-xl`}
        onClick={(e) => e.stopPropagation()}
        role="dialog"
        aria-modal="true"
      >
        <div className="mb-3 flex items-center justify-between">
          <h2 className="text-lg font-semibold">{title}</h2>
          <button
            onClick={onClose}
            className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
            aria-label="Close"
          >
            ✕
          </button>
        </div>
        <div>{children}</div>
        {footer ? <div className="mt-4">{footer}</div> : null}
      </div>
    </div>
  );
}

function TextField(props: {
  label: string;
  value: string;
  placeholder?: string;
  onChange: (v: string) => void;
}) {
  const { label, value, placeholder, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <input
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
      />
    </div>
  );
}

function NumberField(props: {
  label: string;
  value: number | "";
  min?: number;
  step?: number;
  onChange: (v: number | "") => void;
}) {
  const { label, value, min = 0, step = 0.01, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <input
        type="number"
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value === "" ? "" : value}
        min={min}
        step={step}
        onChange={(e) => {
          const raw = e.target.value;
          onChange(raw === "" ? "" : Number(raw));
        }}
      />
    </div>
  );
}

function SelectField(props: {
  label: string;
  value: string;
  options: { value: string; label: string }[];
  onChange: (v: string) => void;
}) {
  const { label, value, options, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <select
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value}
        onChange={(e) => onChange(e.target.value)}
      >
        {options.map((o) => (
          <option key={o.value} value={o.value}>
            {o.label}
          </option>
        ))}
      </select>
    </div>
  );
}

/* ---------------------- CSV parsing helper ---------------------- */

function parseCSV(text: string): string[][] {
  const rows: string[][] = [];
  let row: string[] = [];
  let cell = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (inQuotes) {
      if (ch === '"') {
        const next = text[i + 1];
        if (next === '"') {
          cell += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        cell += ch;
      }
    } else {
      if (ch === '"') inQuotes = true;
      else if (ch === ",") {
        row.push(cell.trim());
        cell = "";
      } else if (ch === "\n") {
        row.push(cell.trim());
        rows.push(row);
        row = [];
        cell = "";
      } else if (ch !== "\r") {
        cell += ch;
      }
    }
  }
  if (cell.length > 0 || row.length > 0) {
    row.push(cell.trim());
    rows.push(row);
  }
  return rows.filter((r) => r.length > 0 && r.some((c) => c.length > 0));
}

/* ------------------------- Error helper ------------------------- */
function errMsg(err: unknown): string {
  if (typeof err === "string") return err;
  if (err && typeof err === "object" && "message" in err) {
    return String((err as Record<string, unknown>).message);
  }
  try {
    return JSON.stringify(err);
  } catch {
    return String(err);
  }
}

/* ------------------------- RPC helper --------------------------- */
/** Try 6-arg function first; if schema cache hasn’t picked it up,
 * fall back to the 5-arg legacy shape. Strictly typed; ignores return value.
 */
async function applyStockMoveRPC(
  supabase: ReturnType<typeof createClientComponentClient<DB>>,
  args: {
    p_part: string;
    p_loc: string;
    p_qty: number;
    p_reason: StockMoveReason;
    p_ref_kind: string;
    p_ref_id?: string | null;
  },
): Promise<void> {
  type FnArgs = DB["public"]["Functions"]["apply_stock_move"]["Args"];

  // 6-arg (conditionally include p_ref_id so shapes match)
  const payload6 = {
    p_part: args.p_part,
    p_loc: args.p_loc,
    p_qty: args.p_qty,
    p_reason: args.p_reason as FnArgs extends { p_reason: infer R } ? R : never,
    p_ref_kind: args.p_ref_kind,
    ...(args.p_ref_id !== undefined ? { p_ref_id: args.p_ref_id } : {}),
  } as FnArgs;

  const call6 = await supabase.rpc("apply_stock_move", payload6);
  if (!call6.error) return;

  const msg = (call6.error?.message ?? "").toLowerCase();
  const cacheShapeIssue =
    msg.includes("could not find the function") ||
    msg.includes("schema cache") ||
    msg.includes("function apply_stock_move(");

  if (!cacheShapeIssue) throw new Error(call6.error?.message ?? "apply_stock_move failed");

  // 5-arg (legacy, no p_ref_id)
  const payload5 = {
    p_part: args.p_part,
    p_loc: args.p_loc,
    p_qty: args.p_qty,
    p_reason: args.p_reason as FnArgs extends { p_reason: infer R } ? R : never,
    p_ref_kind: args.p_ref_kind,
  } as FnArgs;

  const call5 = await supabase.rpc("apply_stock_move", payload5);
  if (call5.error) {
    throw new Error(call5.error.message ?? "apply_stock_move failed");
  }
}

/* ---------------------------- Page ---------------------------- */

export default function InventoryPage(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [shopId, setShopId] = useState<string>("");
  const [search, setSearch] = useState<string>("");
  const [parts, setParts] = useState<Part[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  // stock locations
  const [locs, setLocs] = useState<StockLoc[]>([]);

  // on-hand map: partId -> total qty
  const [onHand, setOnHand] = useState<Record<string, number>>({});
  // per-location detail modal
  const [ohOpen, setOhOpen] = useState<boolean>(false);
  const [ohForPart, setOhForPart] = useState<Part | null>(null);
  const [ohLines, setOhLines] = useState<{ location: string; qty: number }[]>([]);

  // add modal
  const [addOpen, setAddOpen] = useState<boolean>(false);
  const [name, setName] = useState<string>("");
  const [sku, setSku] = useState<string>("");
  const [category, setCategory] = useState<string>("");
  const [price, setPrice] = useState<number | "">("");

  // initial receive (optional) for Add
  const [initLoc, setInitLoc] = useState<string>("");
  const [initQty, setInitQty] = useState<number | "">("");

  // edit modal
  const [editOpen, setEditOpen] = useState<boolean>(false);
  const [editPart, setEditPart] = useState<Part | null>(null);
  const [editName, setEditName] = useState<string>("");
  const [editSku, setEditSku] = useState<string>("");
  const [editCategory, setEditCategory] = useState<string>("");
  const [editPrice, setEditPrice] = useState<number | "">("");

  // receive modal (standalone quick receive)
  const [recvOpen, setRecvOpen] = useState<boolean>(false);
  const [recvPart, setRecvPart] = useState<Part | null>(null);
  const [recvLoc, setRecvLoc] = useState<string>("");
  const [recvQty, setRecvQty] = useState<number | "">("");

  // CSV Import
  const [csvOpen, setCsvOpen] = useState<boolean>(false);
  const [csvText, setCsvText] = useState<string>("");
  const [csvRows, setCsvRows] = useState<
    { name: string; sku?: string; category?: string; price?: number; qty?: number }[]
  >([]);
  const [csvPreview, setCsvPreview] = useState<boolean>(false);
  const [csvDefaultLoc, setCsvDefaultLoc] = useState<string>("");

  // ---------- on-hand loader (pass sid directly; avoids first-render zeros)
  const loadOnHand = useCallback(
    async (sid: string, partIds: string[]) => {
      if (!partIds.length) {
        setOnHand({});
        return;
      }
      const { data, error } = await supabase
        .from("stock_moves")
        .select("part_id, qty_change")
        .in("part_id", partIds)
        .eq("shop_id", sid);

      if (error || !data) {
        setOnHand({});
        return;
      }

      const totals: Record<string, number> = {};
      (data as StockMove[]).forEach((m) => {
        const delta = Number(m.qty_change) || 0;
        totals[m.part_id] = (totals[m.part_id] ?? 0) + delta;
      });
      setOnHand(totals);
    },
    [supabase],
  );

  const load = async (sid: string) => {
    setLoading(true);
    const base = supabase
      .from("parts")
      .select("*")
      .eq("shop_id", sid)
      .order("name", { ascending: true });

    const { data, error } = await (search.trim()
      ? base.or(
          [
            `name.ilike.%${search}%`,
            `sku.ilike.%${search}%`,
            `category.ilike.%${search}%`,
          ].join(","),
        )
      : base);

    const partRows = (!error && (data as Part[])) || [];
    setParts(partRows);
    setLoading(false);

    void loadOnHand(sid, partRows.map((p) => p.id));
  };

  // --- on-hand detail (per-location)
  const openOnHandDetail = async (p: Part) => {
    setOhForPart(p);
    const { data, error } = await supabase
      .from("stock_moves")
      .select("location_id, qty_change")
      .eq("part_id", p.id)
      .eq("shop_id", shopId);

    if (error || !data) {
      setOhLines([]);
      setOhOpen(true);
      return;
    }

    const byLoc: Record<string, number> = {};
    (data as StockMove[]).forEach((r) => {
      const loc = r.location_id as string;
      const q = Number(r.qty_change) || 0;
      byLoc[loc] = (byLoc[loc] ?? 0) + q;
    });

    const lines = locs
      .map((l) => ({
        location: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
        qty: byLoc[l.id] ?? 0,
      }))
      .filter((x) => x.qty !== 0);

    setOhLines(lines);
    setOhOpen(true);
  };

  /* boot */
  useEffect(() => {
    (async () => {
      const { data: u } = await supabase.auth.getUser();
      const uid = u.user?.id ?? null;
      if (!uid) return;

      const { data: prof } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("user_id", uid)
        .maybeSingle();

      const sid = (prof?.shop_id as string) || "";
      setShopId(sid);
      if (!sid) return;

      const { data: l } = await supabase
        .from("stock_locations")
        .select("*")
        .eq("shop_id", sid)
        .order("code");

      const locRows = (l as StockLoc[]) ?? [];
      setLocs(locRows);

      const main = locRows.find((x) => (x.code ?? "").toUpperCase() === "MAIN");
      if (main) {
        setInitLoc(main.id);
        setRecvLoc(main.id);
        setCsvDefaultLoc(main.id);
      }

      await load(sid);
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [supabase]);

  /* refetch on search */
  useEffect(() => {
    if (shopId) void load(shopId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [search, shopId]);

  /* ----------------------- CRUD handlers ----------------------- */

  const createPart = async () => {
    if (!shopId || !name.trim()) return;

    const id = uuidv4();
    const insert: PartInsert = {
      id,
      shop_id: shopId,
      name: name.trim(),
      sku: sku.trim() ? sku.trim() : undefined,
      category: category.trim() ? category.trim() : undefined,
      price: typeof price === "number" ? price : undefined,
    };

    const { error } = await supabase.from("parts").insert(insert);
    if (error) {
      alert(error.message);
      return;
    }

    // optional initial receive
    if (initLoc && typeof initQty === "number" && initQty > 0) {
      try {
        await applyStockMoveRPC(supabase, {
          p_part: id,
          p_loc: initLoc,
          p_qty: initQty,
          p_reason: "receive",
          p_ref_kind: "manual_receive",
          p_ref_id: null,
        });
      } catch (err: unknown) {
        alert(`Part created, but stock receive failed: ${errMsg(err)}`);
      }
    }

    setAddOpen(false);
    setName("");
    setSku("");
    setCategory("");
    setPrice("");
    setInitQty("");
    await load(shopId);
  };

  const openEdit = (p: Part) => {
    setEditPart(p);
    setEditName(p.name ?? "");
    setEditSku(p.sku ?? "");
    setEditCategory(p.category ?? "");
    setEditPrice(typeof p.price === "number" ? p.price : "");
    setEditOpen(true);
  };

  const saveEdit = async () => {
    if (!editPart?.id) return;

    const patch: PartUpdate = {
      name: editName.trim() ? editName.trim() : undefined,
      sku: editSku.trim() ? editSku.trim() : undefined,
      category: editCategory.trim() ? editCategory.trim() : undefined,
      price: typeof editPrice === "number" ? editPrice : undefined,
    };

    const { error } = await supabase.from("parts").update(patch).eq("id", editPart.id);
    if (error) {
      alert(error.message);
      return;
    }

    setEditOpen(false);
    await load(shopId);
  };

  const openReceive = (p: Part) => {
    setRecvPart(p);
    setRecvQty("");
    setRecvOpen(true);
  };

  const applyReceive = async () => {
    if (!recvPart?.id || !recvLoc || typeof recvQty !== "number" || recvQty <= 0) return;
    try {
      await applyStockMoveRPC(supabase, {
        p_part: recvPart.id,
        p_loc: recvLoc,
        p_qty: recvQty,
        p_reason: "receive",
        p_ref_kind: "manual_receive",
        p_ref_id: null,
      });
      setRecvOpen(false);
      await load(shopId);
    } catch (err: unknown) {
      alert(errMsg(err));
    }
  };

  /* -------------------------- CSV Import -------------------------- */

  const parseAndPreviewCSV = (raw: string) => {
    const rows = parseCSV(raw);
    if (!rows.length) {
      setCsvRows([]);
      setCsvPreview(false);
      return;
    }
    const header = rows[0].map((h) => h.toLowerCase().trim());
    const idx = {
      name: header.indexOf("name"),
      sku: header.indexOf("sku"),
      category: header.indexOf("category"),
      price: header.indexOf("price"),
      qty: header.indexOf("qty"),
    };

    const out: { name: string; sku?: string; category?: string; price?: number; qty?: number }[] = [];

    for (let r = 1; r < rows.length; r++) {
      const row = rows[r];
      const name = idx.name >= 0 ? row[idx.name] : "";
      if (!name) continue;
      const sku = idx.sku >= 0 ? row[idx.sku] : undefined;
      const category = idx.category >= 0 ? row[idx.category] : undefined;
      const priceStr = idx.price >= 0 ? row[idx.price] : undefined;
      const qtyStr = idx.qty >= 0 ? row[idx.qty] : undefined;

      const price = priceStr && priceStr.length ? Number(priceStr) : undefined;
      const qty = qtyStr && qtyStr.length ? Number(qtyStr) : undefined;

      out.push({
        name,
        sku: sku && sku.length ? sku : undefined,
        category: category && category.length ? category : undefined,
        price: typeof price === "number" && !Number.isNaN(price) ? price : undefined,
        qty: typeof qty === "number" && !Number.isNaN(qty) ? qty : undefined,
      });
    }

    setCsvRows(out);
    setCsvPreview(true);
  };

  const handleCsvFile = async (file: File) => {
    const text = await file.text();
    setCsvText(text);
    parseAndPreviewCSV(text);
  };

  const runCsvImport = async () => {
    if (!shopId || !csvRows.length) return;

    for (const row of csvRows) {
      let partId: string | null = null;

      if (row.sku) {
        const { data: found } = await supabase
          .from("parts")
          .select("id")
          .eq("shop_id", shopId)
          .eq("sku", row.sku)
          .maybeSingle();
        if (found?.id) partId = found.id;
      }

      if (!partId) {
        const id = uuidv4();
        const insert: PartInsert = {
          id,
          shop_id: shopId,
          name: row.name,
          sku: row.sku || undefined,
          category: row.category || undefined,
          price: typeof row.price === "number" ? row.price : undefined,
        };
        const { error } = await supabase.from("parts").insert(insert);
        if (error) {
          console.warn("Insert failed:", row, error.message);
          continue;
        }
        partId = id;
      } else {
        const patch: PartUpdate = {
          name: row.name || undefined,
          sku: row.sku || undefined,
          category: row.category || undefined,
          price: typeof row.price === "number" ? row.price : undefined,
        };
        await supabase.from("parts").update(patch).eq("id", partId);
      }

      if (partId && csvDefaultLoc && typeof row.qty === "number" && row.qty > 0) {
        try {
          await applyStockMoveRPC(supabase, {
            p_part: partId,
            p_loc: csvDefaultLoc,
            p_qty: row.qty,
            p_reason: "receive",
            p_ref_kind: "csv_import",
            p_ref_id: null,
          });
        } catch (err: unknown) {
          console.warn("Stock receive failed for row:", row, errMsg(err));
        }
      }
    }

    setCsvOpen(false);
    setCsvPreview(false);
    setCsvText("");
    setCsvRows([]);
    await load(shopId);
  };

  /* ----------------------------- UI ----------------------------- */

  return (
    <div className="space-y-4 p-6 text-white">
      <div className="flex flex-wrap items-center justify-between gap-3">
        <h1 className="text-2xl font-bold">Inventory</h1>
        <div className="flex items-center gap-2">
          <input
            className="w-64 rounded border border-neutral-700 bg-neutral-900 p-2 text-sm"
            placeholder="Search name / SKU / category"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
          <button
            className="font-header rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
            onClick={() => setAddOpen(true)}
            disabled={!shopId}
          >
            Add Part
          </button>
          <button
            className="font-header rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
            onClick={() => setCsvOpen(true)}
            disabled={!shopId}
          >
            CSV Import
          </button>
        </div>
      </div>

      {loading ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          Loading…
        </div>
      ) : parts.length === 0 ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          No parts yet. Click “Add Part” to create your first item or use CSV Import.
        </div>
      ) : (
        <div className="overflow-hidden rounded border border-neutral-800 bg-neutral-900">
          <table className="w-full text-sm">
            <thead className="bg-neutral-900">
              <tr className="text-left text-neutral-400">
                <th className="p-2">Name</th>
                <th className="p-2">SKU</th>
                <th className="p-2">Category</th>
                <th className="p-2">Price</th>
                <th className="p-2">On hand</th>
                <th className="p-2 w-48 text-right">Actions</th>
              </tr>
            </thead>
            <tbody>
              {parts.map((p) => {
                const total = onHand[p.id] ?? 0;
                return (
                  <tr key={p.id} className="border-t border-neutral-800">
                    <td className="p-2">{p.name}</td>
                    <td className="p-2">{p.sku ?? "—"}</td>
                    <td className="p-2">{p.category ?? "—"}</td>
                    <td className="p-2">
                      {typeof p.price === "number" ? `$${p.price.toFixed(2)}` : "—"}
                    </td>
                    <td className="p-2">
                      <button
                        className="rounded border border-neutral-700 px-2 py-0.5 text-xs hover:bg-neutral-800"
                        onClick={() => openOnHandDetail(p)}
                        title="View per-location balance"
                      >
                        {total}
                      </button>
                    </td>
                    <td className="p-2">
                      <div className="flex justify-end gap-2">
                        <button
                          className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                          onClick={() => openEdit(p)}
                        >
                          Edit
                        </button>
                        <button
                          className="rounded border border-blue-600 px-2 py-1 text-xs text-blue-300 hover:bg-blue-900/20"
                          onClick={() => openReceive(p)}
                        >
                          Receive
                        </button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      )}

      {/* Add Part */}
      <Modal
        open={addOpen}
        title="Add Part"
        onClose={() => setAddOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setAddOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
              onClick={createPart}
              disabled={!name.trim()}
            >
              Save Part
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <div className="sm:col-span-2">
            <TextField label="Name*" value={name} onChange={setName} placeholder="Part name" />
          </div>
          <TextField label="SKU" value={sku} onChange={setSku} placeholder="Optional" />
          <TextField label="Category" value={category} onChange={setCategory} placeholder="Optional" />
          <NumberField
            label="Price"
            value={price}
            onChange={(v) => setPrice(v === "" ? "" : v)}
          />
        </div>

        <div className="mt-4 rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="mb-2 text-sm font-semibold">Initial Stock (optional)</div>
          <div className="grid gap-3 sm:grid-cols-2">
            <SelectField
              label="Location"
              value={initLoc}
              onChange={setInitLoc}
              options={[
                { value: "", label: "— none —" },
                ...locs.map((l) => ({
                  value: l.id,
                  label: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
                })),
              ]}
            />
            <NumberField
              label="Qty"
              value={initQty}
              min={0}
              step={1}
              onChange={(v) => setInitQty(v === "" ? "" : Math.max(0, v))}
            />
          </div>
        </div>
      </Modal>

      {/* Edit Part */}
      <Modal
        open={editOpen}
        title="Edit Part"
        onClose={() => setEditOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setEditOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
              onClick={saveEdit}
              disabled={!editName.trim()}
            >
              Save Changes
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <div className="sm:col-span-2">
            <TextField label="Name*" value={editName} onChange={setEditName} />
          </div>
          <TextField label="SKU" value={editSku} onChange={setEditSku} />
          <TextField label="Category" value={editCategory} onChange={setEditCategory} />
          <NumberField label="Price" value={editPrice} onChange={(v) => setEditPrice(v === "" ? "" : v)} />
        </div>
      </Modal>

      {/* Receive Stock */}
      <Modal
        open={recvOpen}
        title={recvPart ? `Receive — ${recvPart.name}` : "Receive Stock"}
        onClose={() => setRecvOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setRecvOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
              onClick={applyReceive}
              disabled={!recvPart?.id || !recvLoc || typeof recvQty !== "number" || recvQty <= 0}
            >
              Apply Receive
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <SelectField
            label="Location"
            value={recvLoc}
            onChange={setRecvLoc}
            options={locs.map((l) => ({
              value: l.id,
              label: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
            }))}
          />
          <NumberField
            label="Qty"
            value={recvQty}
            min={0}
            step={1}
            onChange={(v) => setRecvQty(v === "" ? "" : Math.max(0, v))}
          />
        </div>
      </Modal>

      {/* On-hand detail */}
      <Modal
        open={ohOpen}
        title={ohForPart ? `On hand — ${ohForPart.name}` : "On hand"}
        onClose={() => setOhOpen(false)}
        widthClass="max-w-lg"
      >
        {ohLines.length === 0 ? (
          <div className="text-sm text-neutral-400">No movement found for this part.</div>
        ) : (
          <div className="rounded border border-neutral-800">
            <table className="w-full text-sm">
              <thead className="text-left text-neutral-400">
                <tr>
                  <th className="p-2">Location</th>
                  <th className="p-2">Qty</th>
                </tr>
              </thead>
              <tbody>
                {ohLines.map((l, i) => (
                  <tr key={i} className="border-t border-neutral-800">
                    <td className="p-2">{l.location}</td>
                    <td className="p-2">{l.qty}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </Modal>

      {/* CSV Import */}
      <Modal
        open={csvOpen}
        title="CSV Import"
        onClose={() => setCsvOpen(false)}
        widthClass="max-w-3xl"
        footer={
          <div className="flex w-full flex-wrap items-center justify-between gap-3">
            <div className="flex items-center gap-2">
              <SelectField
                label="Default receive location (for rows with qty)"
                value={csvDefaultLoc}
                onChange={setCsvDefaultLoc}
                options={[
                  { value: "", label: "— none —" },
                  ...locs.map((l) => ({ value: l.id, label: `${l.code ?? "LOC"} — ${l.name ?? ""}` })),
                ]}
              />
            </div>
            <div className="flex items-center gap-2">
              <button
                className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
                onClick={() => {
                  setCsvPreview(false);
                  setCsvText("");
                  setCsvRows([]);
                  setCsvOpen(false);
                }}
              >
                Close
              </button>
              <button
                className="rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
                onClick={runCsvImport}
                disabled={!csvPreview || csvRows.length === 0}
              >
                Import
              </button>
            </div>
          </div>
        }
      >
        <div className="grid gap-3">
          <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-300">
            Expected headers (case-insensitive): <code>name, sku, category, price, qty</code>. Extra columns are ignored.
          </div>

          <div className="flex flex-wrap items-center gap-2">
            <input
              type="file"
              accept=".csv,text/csv"
              onChange={(e) => {
                const f = e.target.files?.[0];
                if (f) void handleCsvFile(f);
              }}
              className="text-sm"
            />
            <button
              className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
              onClick={() => {
                if (csvText.trim().length) parseAndPreviewCSV(csvText);
              }}
            >
              Parse text
            </button>
          </div>

          <textarea
            rows={8}
            className="w-full rounded border border-neutral-700 bg-neutral-900 p-2 text-sm"
            placeholder={`Paste CSV here… e.g.:
name,sku,category,price,qty
Oil Filter – Ford,OF-FORD-01,Filters,9.95,10
Spark Plug – Iridium,SP-IR-01,Ignition,9.95,24
`}
            value={csvText}
            onChange={(e) => setCsvText(e.target.value)}
          />

          {csvPreview && (
            <div className="rounded border border-neutral-800">
              <table className="w-full text-sm">
                <thead className="text-left text-neutral-400">
                  <tr>
                    <th className="p-2">Name</th>
                    <th className="p-2">SKU</th>
                    <th className="p-2">Category</th>
                    <th className="p-2">Price</th>
                    <th className="p-2">Qty</th>
                  </tr>
                </thead>
                <tbody>
                  {csvRows.map((r, i) => (
                    <tr key={i} className="border-t border-neutral-800">
                      <td className="p-2">{r.name}</td>
                      <td className="p-2">{r.sku ?? "—"}</td>
                      <td className="p-2">{r.category ?? "—"}</td>
                      <td className="p-2">{typeof r.price === "number" ? r.price.toFixed(2) : "—"}</td>
                      <td className="p-2">{typeof r.qty === "number" ? r.qty : "—"}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </Modal>
    </div>
  );
}

/* =============================== */
/* FILE: app/api/parts/requests/create/route.ts */
/* =============================== */

// app/api/parts/requests/create/route.ts
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type PRInsert = DB["public"]["Tables"]["part_requests"]["Insert"];
type PRIInsert = DB["public"]["Tables"]["part_request_items"]["Insert"];
type WORow = DB["public"]["Tables"]["work_orders"]["Row"];
type WOLUpdate = DB["public"]["Tables"]["work_order_lines"]["Update"];

const DEFAULT_MARKUP = 30; // %

type BodyItem = {
  description: string;
  qty: number;
};

type Body = {
  workOrderId: string;
  jobId?: string | null;
  items: BodyItem[];
  notes?: string | null;
};

// extend the generated insert type with the columns you just added in Supabase
type PartRequestItemInsertWithExtras = PRIInsert & {
  markup_pct: number;
  work_order_line_id: string | null;
};

export async function POST(req: Request) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  // 1) parse + validate
  const body = (await req.json().catch(() => null)) as Body | null;
  if (
    !body ||
    typeof body.workOrderId !== "string" ||
    !Array.isArray(body.items) ||
    body.items.length === 0
  ) {
    return NextResponse.json(
      { error: "Invalid body. Expect { workOrderId, items[] }." },
      { status: 400 },
    );
  }

  const { workOrderId, jobId, items, notes } = body;

  // 2) auth
  const {
    data: { user },
    error: userErr,
  } = await supabase.auth.getUser();
  if (userErr) {
    return NextResponse.json({ error: userErr.message }, { status: 401 });
  }
  if (!user) {
    return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
  }

  // 3) load WO for shop_id
  const { data: wo, error: woErr } = await supabase
    .from("work_orders")
    .select("id, shop_id")
    .eq("id", workOrderId)
    .maybeSingle<WORow>();

  if (woErr) {
    return NextResponse.json({ error: woErr.message }, { status: 400 });
  }
  if (!wo?.id || !wo.shop_id) {
    return NextResponse.json({ error: "Work order not found" }, { status: 404 });
  }

  // 4) insert header
  const header: PRInsert = {
    work_order_id: workOrderId,
    shop_id: wo.shop_id,
    requested_by: user.id,
    status: "requested",
    notes: notes ?? null,
  };

  const { data: pr, error: prErr } = await supabase
    .from("part_requests")
    .insert(header)
    .select("id")
    .single();

  if (prErr || !pr?.id) {
    return NextResponse.json(
      { error: prErr?.message ?? "Failed to create part request" },
      { status: 500 },
    );
  }

  // 5) insert item rows — now with markup_pct + work_order_line_id
  const itemRows: PartRequestItemInsertWithExtras[] = items.map((it) => ({
    request_id: pr.id,
    description: it.description.trim(),
    qty: Number(it.qty),
    approved: false,
    part_id: null,
    quoted_price: null,
    vendor: null,
    markup_pct: DEFAULT_MARKUP,
    work_order_line_id: jobId ?? null,
  }));

  const { error: itemsErr } = await supabase
    .from("part_request_items")
    .insert(itemRows);

  if (itemsErr) {
    // best-effort rollback if items fail
    await supabase.from("part_requests").delete().eq("id", pr.id);
    return NextResponse.json(
      { error: itemsErr.message ?? "Failed to insert request items" },
      { status: 500 },
    );
  }

  // 6) optionally put the line on hold / approval pending
  if (jobId) {
    const updatePayload: WOLUpdate = {
      status: "on_hold",
      approval_state: "pending",
    };
    await supabase
      .from("work_order_lines")
      .update(updatePayload)
      .eq("id", jobId);
  }

  return NextResponse.json({ requestId: pr.id });
}

/* =============================== */
/* FILE: app/api/ai/quote-suggest/route.ts */
/* =============================== */

import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database, Json } from "@shared/types/types/supabase";
import { ProFixAI, type QuoteEnginePart } from "@/features/integrations/ai";

type DB = Database;

type ConfidenceLevel = "low" | "medium" | "high";

// Keep the response structured and easy to consume
export type AISuggestion = {
  parts: { name: string; qty?: number; cost?: number; notes?: string }[];
  laborHours: number;
  laborRate?: number;
  summary: string;
  confidence?: ConfidenceLevel;
  price?: number;
  notes?: string;
  title?: string;
};

interface VehicleInput {
  year?: string | number | null;
  make?: string | null;
  model?: string | null;
  vin?: string | null;
}

interface RequestBody {
  item: string;
  notes?: string;
  section: string;
  status: string;
  value?: string;
  unit?: string;
  vehicle?: VehicleInput | null;
}

function isRequestBody(value: unknown): value is RequestBody {
  if (typeof value !== "object" || value === null) return false;
  const obj = value as Record<string, unknown>;
  return (
    typeof obj.item === "string" &&
    typeof obj.section === "string" &&
    typeof obj.status === "string"
  );
}

function mapConfidence(score: number): ConfidenceLevel {
  if (score >= 0.75) return "high";
  if (score >= 0.5) return "medium";
  return "low";
}

function buildVehicleYmm(vehicle?: VehicleInput | null): string | null {
  if (!vehicle) return null;

  const year =
    vehicle.year !== undefined && vehicle.year !== null
      ? String(vehicle.year)
      : "";
  const make = vehicle.make ?? "";
  const model = vehicle.model ?? "";

  const combined = [year, make, model].join(" ").trim();
  return combined.length > 0 ? combined : null;
}

function buildComplaint(input: RequestBody): string {
  const parts: string[] = [];

  if (input.section) {
    parts.push(`[${input.section}]`);
  }

  if (input.status) {
    parts.push(`Status: ${input.status}`);
  }

  parts.push(input.item);

  if (typeof input.notes === "string" && input.notes.trim().length > 0) {
    parts.push(`Notes: ${input.notes.trim()}`);
  }

  if (input.value) {
    const valuePart = input.unit ? `${input.value} ${input.unit}` : input.value;
    parts.push(`Value: ${valuePart}`);
  }

  return parts.join(" | ");
}

export async function POST(req: Request) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    const rawBody: unknown = await req.json();
    if (!isRequestBody(rawBody)) {
      return NextResponse.json(
        { error: "Invalid request body" },
        { status: 400 },
      );
    }

    const body: RequestBody = rawBody;
    const { item, notes, section, status, vehicle } = body;

    // Resolve shopId from the authenticated user (if available)
    let shopId: string | null = null;
    try {
      const {
        data: { session },
      } = await supabase.auth.getSession();

      const userId = session?.user?.id ?? null;
      if (userId) {
        const { data: profile } = await supabase
          .from("profiles")
          .select("shop_id")
          .eq("user_id", userId)
          .maybeSingle();

        if (profile?.shop_id) {
          shopId = profile.shop_id;
        }
      }
    } catch (resolveErr) {
      // Do not block suggestion if shop resolution fails
      console.warn(
        "[AI] Failed to resolve shopId for quote-suggest:",
        resolveErr,
      );
    }

    const complaint = buildComplaint(body);
    const vehicleYmm = buildVehicleYmm(vehicle);

    // Call central AI engine
    const aiResult = await ProFixAI.suggestQuote({
      shopId: shopId ?? "unknown_shop",
      vehicleYmm,
      complaint,
    });

    const baseSummary =
      typeof notes === "string" && notes.trim().length > 0
        ? notes.trim()
        : item;

    let suggestion: AISuggestion;

    if (aiResult) {
      suggestion = {
        parts: aiResult.parts.map((p: QuoteEnginePart) => ({
          name: p.description || "Suggested part",
          qty: p.qty,
          cost: p.price,
          notes: p.partId ? `Part ID: ${p.partId}` : undefined,
        })),
        laborHours: aiResult.laborHours,
        summary: baseSummary,
        confidence: mapConfidence(aiResult.confidence),
      };
    } else {
      // Fallback: minimal but valid suggestion
      suggestion = {
        parts: [],
        laborHours: 0.5,
        summary: baseSummary,
        confidence: "low",
      };
    }

    // Persist the inference into ai_events (best-effort; ignore failures)
    try {
      const vehiclePayload =
        vehicle !== undefined && vehicle !== null
          ? {
              year: vehicle.year ?? null,
              make: vehicle.make ?? null,
              model: vehicle.model ?? null,
              vin: vehicle.vin ?? null,
            }
          : null;

      const payload: Json = {
        input: {
          item,
          notes: notes ?? null,
          section,
          status,
          value: body.value ?? null,
          unit: body.unit ?? null,
          vehicle: vehiclePayload,
          complaint,
        },
        output: suggestion,
      } as unknown as Json;

      await supabase.from("ai_events").insert({
        event_type: "quote_suggest",
        payload,
        shop_id: shopId,
        entity_id: null,
        entity_table: "inspection_results",
      });
    } catch (logErr) {
      console.warn("[AI] Failed to log quote-suggest event:", logErr);
    }

    return NextResponse.json({ suggestion });
  } catch (err) {
    // eslint-disable-next-line no-console
    console.error("quote-suggest error:", err);
    return NextResponse.json(
      { error: "AI suggestion failed" },
      { status: 500 },
    );
  }
}


/* =============================== */
/* FILE: app/api/inspections/complete/route.ts */
/* =============================== */

// app/api/inspections/complete/route.ts
import "server-only";
import { NextResponse, type NextRequest } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database, TablesInsert } from "@shared/types/types/supabase";

import type { InspectionItem } from "@/features/inspections/lib/inspection/types";

import { generateQuoteFromInspection } from "@quotes/lib/quote/generateQuoteFromInspection";
import { normalizeQuoteLine } from "@quotes/lib/quote/normalizeQuoteLine";

export const runtime = "nodejs";

type DB = Database;
type QuoteLinesInsert = TablesInsert<"quote_lines">;

/* ----------------------------- Type guards ----------------------------- */
function isInspectionItem(value: unknown): value is InspectionItem {
  if (typeof value !== "object" || value === null) return false;
  return true; // minimal structural check
}
function isInspectionItemArray(value: unknown): value is InspectionItem[] {
  return Array.isArray(value) && value.every(isInspectionItem);
}

/* -------------------------------- Types -------------------------------- */
type CompleteRequest = {
  workOrderId: string;
  workOrderLineId: string;
  results: InspectionItem[];
  templateName?: string | null; // accepted, but we won't write it (no column)
};

/* --------------------------------- Route -------------------------------- */
export async function POST(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    // 1) Parse & validate
    const body = (await req.json()) as Partial<CompleteRequest>;
    const workOrderId = String(body.workOrderId ?? "");
    const workOrderLineId = String(body.workOrderLineId ?? "");
    const results = body.results;

    if (!workOrderId || !workOrderLineId) {
      return NextResponse.json(
        { error: "Missing workOrderId or workOrderLineId." },
        { status: 400 }
      );
    }
    if (!isInspectionItemArray(results)) {
      return NextResponse.json(
        { error: "results must be an array of InspectionItem." },
        { status: 400 }
      );
    }

    // current user (for quote_lines.user_id)
    const {
      data: { user },
    } = await supabase.auth.getUser();
    const userId = user?.id ?? null;

    // 2) Verify the WO line exists
    const { data: line, error: lineErr } = await supabase
      .from("work_order_lines")
      .select("*")
      .eq("id", workOrderLineId)
      .maybeSingle();

    if (lineErr) {
      return NextResponse.json(
        { error: `Failed to load work order line: ${lineErr.message}` },
        { status: 500 }
      );
    }
    if (!line) {
      return NextResponse.json(
        { error: "Work order line not found." },
        { status: 404 }
      );
    }

    // 3) Generate AI summary and quote lines from inspection results
    const { summary, quote } = await generateQuoteFromInspection(results);
    const normalized = await Promise.all(quote.map((q) => normalizeQuoteLine(q)));

    // 4) Insert quote_lines (match your schema exactly)
    const nowIso = new Date().toISOString();
    const quoteRows: QuoteLinesInsert[] = normalized.map((n): QuoteLinesInsert => ({
      work_order_id: workOrderId,

      // text columns used by your UI
      description: n.description,
      item: n.item ?? n.name ?? n.description,
      name: n.name ?? n.description,
      title: n.description, // required by your schema

      // pricing / labor
      quantity: 1,
      labor_time: typeof n.laborHours === "number" ? n.laborHours : null,
      price: typeof n.price === "number" ? n.price : null,
      total: typeof n.price === "number" ? n.price : null,

      // parts info if present / inferred
      part_name: n.part?.name ?? n.partName ?? null,
      part_price:
        typeof n.part?.price === "number"
          ? n.part.price
          : n.partPrice ?? null,

      // misc columns
      photo_urls: Array.isArray(n.photoUrls) ? n.photoUrls : null,
      status: "draft",
      user_id: userId,
      updated_at: nowIso,
    }));

    if (quoteRows.length > 0) {
      const { error: insErr } = await supabase
        .from("quote_lines")
        .insert(quoteRows);
      if (insErr) {
        return NextResponse.json(
          { error: `Failed to insert quote lines: ${insErr.message}` },
          { status: 500 }
        );
      }
    }

    // 5) Mark the inspection line complete & store AI summary in correction
    const { error: updErr } = await supabase
      .from("work_order_lines")
      .update({
        status: "completed",
        correction: summary ?? null,
        updated_at: nowIso,
      })
      .eq("id", workOrderLineId);

    if (updErr) {
      return NextResponse.json(
        { error: `Failed to update work order line: ${updErr.message}` },
        { status: 500 }
      );
    }

    // 6) Done
    return NextResponse.json({
      ok: true,
      workOrderId,
      workOrderLineId,
      summary,
      inserted: quoteRows.length,
    });
  } catch (err) {
    const message =
      err instanceof Error
        ? err.message
        : "Unexpected error handling inspection completion.";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/settings/update/route.ts */
/* =============================== */

// app/api/settings/update/route.ts
import { NextResponse } from "next/server";
import { cookies as nextCookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

const COOKIE_NAME = "pfq_owner_pin_shop";

// Whitelist fields that can be updated from Settings
const ALLOWED_FIELDS = new Set([
  "name",
  "address",
  "city",
  "province",
  "postal_code",
  "phone_number",
  "email",
  "logo_url",

  // numeric settings
  "labor_rate",
  "supplies_percent",
  "diagnostic_fee",
  "tax_rate",

  // boolean flags
  "use_ai",
  "require_cause_correction",
  "require_authorization",
  "email_on_complete",
  "auto_generate_pdf",
  "auto_send_quote_email",

  // text
  "invoice_terms",
  "invoice_footer",
]);

type Payload = {
  shopId?: string;
  update?: Record<string, unknown>;
};

export async function POST(req: Request) {
  try {
    // Pass the cookies FUNCTION to Supabase
    const supabase = createRouteHandlerClient<Database>({ cookies: nextCookies });

    // 1) Auth required
    const {
      data: { user },
      error: userErr,
    } = await supabase.auth.getUser();
    if (userErr || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2) Parse body
    const { shopId, update } = (await req.json().catch(() => ({}))) as Payload;
    if (!shopId || !update || typeof update !== "object") {
      return NextResponse.json(
        { error: "Missing shopId or update payload" },
        { status: 400 },
      );
    }

    // 3) Role + shop scope check (staff of this shop)
    const { data: profile } = await supabase
      .from("profiles")
      .select("role, shop_id")
      .eq("id", user.id)
      .single();

    if (!profile?.shop_id || profile.shop_id !== shopId) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // 4) Require valid owner-PIN cookie for this shop
    // 4) Require valid owner-PIN cookie for this shop
const cookieStore = await nextCookies();                // <-- add this
const pinCookie = cookieStore.get(COOKIE_NAME)?.value;  // <-- use store
if (!pinCookie || pinCookie !== shopId) {
  return NextResponse.json({ error: "Owner PIN required" }, { status: 401 });
}

    // 5) Filter payload to allowed fields only
    const safeUpdate: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(update)) {
      if (!ALLOWED_FIELDS.has(k)) continue;

      if (["labor_rate", "supplies_percent", "diagnostic_fee", "tax_rate"].includes(k)) {
        safeUpdate[k] =
          v === null || v === "" ? null : typeof v === "number" ? v : Number(v);
        continue;
      }

      if (
        [
          "use_ai",
          "require_cause_correction",
          "require_authorization",
          "email_on_complete",
          "auto_generate_pdf",
          "auto_send_quote_email",
        ].includes(k)
      ) {
        safeUpdate[k] = Boolean(v);
        continue;
      }

      safeUpdate[k] = v;
    }

    if (Object.keys(safeUpdate).length === 0) {
      return NextResponse.json({ error: "No valid fields to update" }, { status: 400 });
    }

    // 6) Update only within this shop
    const { error: updErr } = await supabase.from("shops").update(safeUpdate).eq("id", shopId);
    if (updErr) {
      return NextResponse.json({ error: updErr.message ?? "Update failed" }, { status: 500 });
    }

    return NextResponse.json({ ok: true });
  } catch (err) {
    console.error("settings.update error", err);
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/quotes/apply-ai/route.ts */
/* =============================== */

import { NextResponse } from "next/server";
import { createClient, type SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "@shared/types/types/supabase";
import { recordQuoteTraining } from "@/features/integrations/ai";

type DB = Database;

/* -------------------------- AI Suggestion Types -------------------------- */

type AISuggestion = {
  parts: { name: string; qty?: number; cost?: number; notes?: string }[];
  laborHours: number;
  laborRate: number;
  summary: string;
  confidence: "low" | "medium" | "high";
  price?: number;
  notes?: string;
  title?: string;
};

interface Body {
  workOrderLineId: string;
  suggestion: AISuggestion;
}

function isBody(x: unknown): x is Body {
  if (typeof x !== "object" || x === null) return false;
  const o = x as Record<string, unknown>;
  return (
    typeof o.workOrderLineId === "string" &&
    typeof o.suggestion === "object" &&
    o.suggestion !== null
  );
}

/* ----------------- Resolve a shop's primary inventory location ---------------- */

async function resolvePrimaryLocationId(
  sb: SupabaseClient<DB>,
  workOrderLineId: string,
): Promise<string | null> {
  const { data: line } = await sb
    .from("work_order_lines")
    .select("shop_id")
    .eq("id", workOrderLineId)
    .maybeSingle();

  if (!line?.shop_id) return null;

  const { data: locs } = await sb
    .from("inventory_locations")
    .select("id, is_primary")
    .eq("shop_id", line.shop_id)
    .order("is_primary", { ascending: false }) // primary first
    .limit(1);

  return locs?.[0]?.id ?? null;
}

/* ---------------------------------- Route ---------------------------------- */

export async function POST(req: Request) {
  try {
    const body: unknown = await req.json();
    if (!isBody(body)) {
      return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
    }

    const { workOrderLineId, suggestion } = body;

    // Env: server key only (non-null)
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey =
      (process.env.SUPABASE_SERVICE_ROLE_KEY ??
        process.env.SUPABASE_SERVICE_KEY)!;

    if (!supabaseUrl || !supabaseKey) {
      return NextResponse.json(
        {
          error: "Server misconfiguration — Supabase env missing",
          detail:
            "Check NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY (or SUPABASE_SERVICE_KEY).",
        },
        { status: 500 },
      );
    }

    const sb = createClient<DB>(supabaseUrl, supabaseKey);

    // Require an inventory location (prevents FK errors on allocations)
    const locationId = await resolvePrimaryLocationId(sb, workOrderLineId);
    if (!locationId) {
      return NextResponse.json(
        {
          error: "This shop has no inventory location configured.",
          detail: "Create a primary inventory location first.",
          code: "NO_LOCATION_CONFIGURED",
        },
        { status: 422 },
      );
    }

    const unmatched: { name: string; qty: number }[] = [];

    // Allocate each AI-suggested part to this line
    for (const { name, qty = 1 } of suggestion.parts ?? []) {
      const { data: found, error: pe } = await sb
        .from("parts")
        .select("id")
        // use % for ilike match; if you prefer exact, change to .eq("name", name)
        .ilike("name", `%${name}%`)
        .limit(1);

      if (pe) {
        unmatched.push({ name, qty });
        continue;
      }

      const match = found?.[0];
      if (!match) {
        unmatched.push({ name, qty });
        continue;
      }

      const alloc: DB["public"]["Tables"]["work_order_part_allocations"]["Insert"] =
        {
          work_order_line_id: workOrderLineId,
          part_id: match.id,
          qty,
          location_id: locationId, // required by FK; we resolved above
        };

      const { error: ae } = await sb
        .from("work_order_part_allocations")
        .insert(alloc);

      if (ae) {
        unmatched.push({ name, qty });
        continue;
      }
    }

    // Mark as "quoted" flow started (keep workflow status; set approval_state)
    const { error: updateErr } = await sb
      .from("work_order_lines")
      .update({ approval_state: "pending" })
      .eq("id", workOrderLineId);

    if (updateErr) {
      return NextResponse.json(
        { error: "Failed updating approval state", detail: updateErr.message },
        { status: 500 },
      );
    }

    // ------------------------ AI TRAINING: APPLIED QUOTE ------------------------
    try {
      const { data: line } = await sb
        .from("work_order_lines")
        .select("id, work_order_id, shop_id, description, complaint")
        .eq("id", workOrderLineId)
        .maybeSingle();

      if (line?.shop_id) {
        await recordQuoteTraining({
          quoteId: workOrderLineId, // treat the line as the "quote" record
          shopId: line.shop_id,
          workOrderId: line.work_order_id ?? null,
          workOrderLineId,
          vehicleYmm: null, // TODO: hydrate via vehicles table
          payload: {
            complaint: line.complaint,
            description: line.description,
            suggestion,
            unmatched,
          },
        });
      }
    } catch (trainErr) {
      // Never block user flow on training errors
      // eslint-disable-next-line no-console
      console.warn("AI training for apply-ai quote failed:", trainErr);
    }

    return NextResponse.json({ ok: true, unmatched });
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error("apply-ai Quote Error 👉", e);
    return NextResponse.json(
      { error: "Failed applying AI quote" },
      { status: 500 },
    );
  }
}

/* =============================== */
/* FILE: app/api/menu-items/upsert-from-line/route.ts */
/* =============================== */

import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;

/*
-- Suggested table
create table if not exists saved_menu_items (
  id uuid primary key default gen_random_uuid(),
  make text not null,
  model text not null,
  year_bucket text not null, -- e.g. "2015-2018" or "2019-2021"
  title text not null,       -- normalized job title
  labor_time numeric,        -- default hours
  parts jsonb not null default '[]',  -- [{part_id, qty}]
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create unique index if not exists saved_menu_items_uq
  on saved_menu_items(make, model, year_bucket, title);
*/

interface Body {
  workOrderLineId: string;
}

function isBody(x: unknown): x is Body {
  if (typeof x !== "object" || x === null) return false;
  const o = x as Record<string, unknown>;
  return typeof o.workOrderLineId === "string";
}

function yearBucket(y?: number | null): string {
  if (!y || Number.isNaN(y)) return "unknown";
  // e.g. 2015-2018, 2019-2021, etc. (3-year buckets)
  const start = y - ((y - 1) % 3);
  const end = start + 2;
  return `${start}-${end}`;
}

export async function POST(req: Request) {
  try {
    const bUnknown: unknown = await req.json();
    if (!isBody(bUnknown)) {
      return NextResponse.json({ error: "Invalid body" }, { status: 400 });
    }
    const { workOrderLineId } = bUnknown;

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const serviceKey =
      process.env.SUPABASE_SERVICE_ROLE_KEY ?? process.env.SUPABASE_SERVICE_KEY;
    if (!supabaseUrl || !serviceKey) {
      return NextResponse.json({ error: "Server not configured" }, { status: 500 });
    }
    const sb = createClient<DB>(supabaseUrl, serviceKey);

    // Line
    const { data: line, error: le } = await sb
      .from("work_order_lines").select("*")
      .eq("id", workOrderLineId)
      .maybeSingle<DB["public"]["Tables"]["work_order_lines"]["Row"]>();
    if (le || !line) {
      return NextResponse.json({ error: le?.message ?? "Line not found" }, { status: 404 });
    }

    // Parent WO => vehicle
    const { data: wo } = await sb
      .from("work_orders").select("*")
      .eq("id", line.work_order_id)
      .maybeSingle<DB["public"]["Tables"]["work_orders"]["Row"]>();
    const { data: vehicle } = wo?.vehicle_id
      ? await sb.from("vehicles").select("*").eq("id", wo.vehicle_id)
          .maybeSingle<DB["public"]["Tables"]["vehicles"]["Row"]>()
      : { data: null };

    const make = (vehicle?.make ?? "").trim();
    const model = (vehicle?.model ?? "").trim();
    const year = typeof vehicle?.year === "number"
      ? vehicle?.year
      : Number((vehicle?.year as unknown as string) ?? NaN);
    const yBucket = yearBucket(year);

    // Sanity: “fully quoted” = has labor_time OR has at least one allocation
    const { data: allocs } = await sb
      .from("work_order_part_allocations")
      .select("part_id, qty")
      .eq("work_order_line_id", workOrderLineId);

    const fullyQuoted = (line.labor_time !== null && line.labor_time !== undefined)
      || ((allocs ?? []).length > 0);

    if (!make || !model || !fullyQuoted) {
      return NextResponse.json({ error: "Line not fully quoted or vehicle missing" }, { status: 400 });
    }

    // Normalize a job title
    const rawTitle = (line.description ?? line.complaint ?? "Repair").trim();
    const title = rawTitle.replace(/\s+/g, " ").replace(/\.$/, "");

    // Upsert saved_menu_items
    const partsJson = (allocs ?? []).map(a => ({ part_id: a.part_id, qty: a.qty }));
    const insert = {
      make,
      model,
      year_bucket: yBucket,
      title,
      labor_time: line.labor_time ?? null,
      parts: partsJson as unknown as NonNullable<DB["public"]["Tables"]["saved_menu_items"]["Row"]["parts"]>,
      updated_at: new Date().toISOString(),
    };

    // NOTE: upsert based on the unique index (make, model, year_bucket, title)
    const { data, error } = await sb
      .from("saved_menu_items")
      .upsert(insert, { onConflict: "make,model,year_bucket,title" })
      .select("id")
      .single();

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ id: data?.id ?? null, ok: true });
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Unknown error";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/work-orders/add-line/route.ts */
/* =============================== */

import { NextResponse } from "next/server";
import { createClient, type PostgrestError } from "@supabase/supabase-js";

type PartLine = { name: string; qty?: number; cost?: number; notes?: string };

type AISuggestion = {
  parts: PartLine[];
  laborHours: number;
  laborRate?: number;
  summary: string;
  confidence?: "low" | "medium" | "high";
  price?: number;
  notes?: string;
  title?: string;
};

type LineStatus =
  | "awaiting"
  | "queued"
  | "in_progress"
  | "on_hold"
  | "paused"
  | "completed"
  | "assigned"
  | "unassigned"
  | "awaiting_approval"   // ✅ now supported in DB CHECK
  | "declined";           // ✅ now supported in DB CHECK

type ApprovalState = "pending" | "approved" | "declined" | null;

type JobType =
  | "diagnosis"
  | "inspection"
  | "maintenance"
  | "repair"
  | "tech-suggested"
  | null;

interface InsertWorkOrderLine {
  work_order_id: string;
  description: string;
  job_type: JobType;
  status: LineStatus;
  approval_state: ApprovalState;
  notes: string | null;
  labor_time: number | null;
}

interface AddLineRequestBody {
  workOrderId: string;
  description: string;
  section?: string;
  status?: "recommend" | "fail";
  suggestion: AISuggestion;
  jobType?: "inspection" | "repair" | "maintenance" | "diagnosis" | "tech-suggested";
}

function isValidBody(b: unknown): b is AddLineRequestBody {
  if (typeof b !== "object" || b === null) return false;
  const o = b as Record<string, unknown>;
  return (
    typeof o.workOrderId === "string" &&
    typeof o.description === "string" &&
    typeof o.suggestion === "object" &&
    o.suggestion !== null
  );
}

export async function POST(req: Request) {
  try {
    const bodyUnknown: unknown = await req.json();

    if (!isValidBody(bodyUnknown)) {
      return NextResponse.json(
        { error: "Invalid body: require workOrderId, description, suggestion" },
        { status: 400 }
      );
    }

    const {
      workOrderId,
      description,
      section,
      status,     // "recommend" | "fail" from inspection
      suggestion,
      jobType = "inspection",
    } = bodyUnknown;

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const serviceKey =
      process.env.SUPABASE_SERVICE_ROLE_KEY ?? process.env.SUPABASE_SERVICE_KEY;

    if (!supabaseUrl || !serviceKey) {
      return NextResponse.json(
        { error: "Server not configured for Supabase" },
        { status: 500 }
      );
    }

    const supabase = createClient(supabaseUrl, serviceKey);

    // Build compact notes (extra context for advisors)
    const notesParts: string[] = [];
    if (section) notesParts.push(`Section: ${section}`);
    if (status) notesParts.push(`From inspection: ${status.toUpperCase()}`);
    if (suggestion.summary?.trim()) notesParts.push(`AI: ${suggestion.summary.trim()}`);
    const notes: string | null = notesParts.length ? notesParts.join(" • ") : null;

    const laborTime: number | null =
      typeof suggestion.laborHours === "number" ? suggestion.laborHours : null;

    // ✅ Create as a quote line:
    // - status: awaiting_approval (non-punchable)
    // - approval_state: pending
    const insertPayload: InsertWorkOrderLine = {
      work_order_id: workOrderId,
      description,
      job_type: (jobType as JobType) ?? "inspection",
      status: "awaiting_approval",
      approval_state: "pending",
      notes,
      labor_time: laborTime,
    };

    const { data, error } = await supabase
      .from("work_order_lines")
      .insert(insertPayload)
      .select("id")
      .single();

    if (error) {
      const e = error as PostgrestError;
      return NextResponse.json(
        { error: e.message, details: e.details, hint: e.hint, code: e.code },
        { status: 500 }
      );
    }

    return NextResponse.json({ id: (data as { id: string }).id });
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Unknown error";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/work-orders/quotes/[id]/mark-quoted/route.ts */
/* =============================== */

// app/api/work-orders/quotes/[id]/mark-quoted/route.ts
import "server-only";
import { NextResponse, type NextRequest } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

export const runtime = "nodejs";

type DB = Database;

export async function PATCH(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    // Extract `[id]` from the pathname .../quotes/<id>/mark-quoted
    const segments = req.nextUrl.pathname.split("/").filter(Boolean);
    const id = segments[segments.length - 2]; // segment before "mark-quoted"

    if (!id) {
      return NextResponse.json({ error: "Missing quote line id" }, { status: 400 });
    }

    // Mark the quote line as quoted
    const { error: updErr } = await supabase
      .from("work_order_quote_lines")
      .update({ status: "quoted", updated_at: new Date().toISOString() })
      .eq("id", id);

    if (updErr) {
      return NextResponse.json({ error: updErr.message }, { status: 500 });
    }

    return NextResponse.json({ ok: true });
  } catch {
    return NextResponse.json({ error: "Failed to mark as quoted" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/work-orders/quotes/[id]/authorize/route.ts */
/* =============================== */

// app/api/work-orders/quotes/[id]/authorize/route.ts
import "server-only";
import { NextResponse, type NextRequest } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database, TablesInsert } from "@shared/types/types/supabase";

export const runtime = "nodejs";

type DB = Database;
type WorkOrderLineInsert = TablesInsert<"work_order_lines">;

export async function POST(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    // Extract `[id]` from the pathname .../quotes/<id>/authorize
    const segments = req.nextUrl.pathname.split("/").filter(Boolean);
    const id = segments[segments.length - 2]; // the segment before "authorize"

    if (!id) {
      return NextResponse.json({ error: "Missing quote line id" }, { status: 400 });
    }

    // 1) Load the quote line we’re authorizing
    const { data: q, error: qErr } = await supabase
      .from("work_order_quote_lines")
      .select("*")
      .eq("id", id)
      .single();

    if (qErr || !q) {
      return NextResponse.json({ error: "Quote line not found" }, { status: 404 });
    }

    // 2) Turn it into a punchable job line
    const newLine: WorkOrderLineInsert = {
      work_order_id: q.work_order_id,
      vehicle_id: q.vehicle_id,
      description: q.description,
      job_type: q.job_type ?? "repair",
      status: "queued",
      labor_time: q.est_labor_hours ?? null,
      complaint: q.ai_complaint ?? q.description,
      cause: q.ai_cause ?? null,
      correction: q.ai_correction ?? null,
    };

    const { data: inserted, error: insErr } = await supabase
      .from("work_order_lines")
      .insert(newLine)
      .select("id")
      .single();

    if (insErr) {
      return NextResponse.json({ error: insErr.message }, { status: 500 });
    }

    // 3) Mark quote line as converted
    const { error: updErr } = await supabase
      .from("work_order_quote_lines")
      .update({ status: "converted", updated_at: new Date().toISOString() })
      .eq("id", id);

    if (updErr) {
      return NextResponse.json({ error: updErr.message }, { status: 500 });
    }

    return NextResponse.json({ ok: true, jobLineId: inserted?.id ?? null });
  } catch {
    return NextResponse.json({ error: "Failed to authorize" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/work-orders/quotes/add/route.ts */
/* =============================== */

import "server-only";
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;

export async function POST(req: Request) {
  const supabase = createServerComponentClient<DB>({ cookies });
  try {
    const { workOrderId, vehicleId, items } = await req.json() as {
      workOrderId: string;
      vehicleId?: string | null;
      items: Array<{
        description: string;
        jobType?: "diagnosis"|"repair"|"maintenance"|"tech-suggested";
        estLaborHours?: number;
        notes?: string;
        aiComplaint?: string;
        aiCause?: string;
        aiCorrection?: string;
      }>;
    };

    if (!workOrderId || !Array.isArray(items) || items.length === 0) {
      return NextResponse.json({ error: "Missing workOrderId or items" }, { status: 400 });
    }

    const { data: { user } } = await supabase.auth.getUser();
    const suggested_by = user?.id ?? null;

    const rows = items.map(i => ({
      work_order_id: workOrderId,
      vehicle_id: vehicleId ?? null,
      suggested_by,
      description: i.description,
      job_type: i.jobType ?? "tech-suggested",
      est_labor_hours: i.estLaborHours ?? null,
      notes: i.notes ?? null,
      status: "pending_parts",
      ai_complaint: i.aiComplaint ?? null,
      ai_cause: i.aiCause ?? null,
      ai_correction: i.aiCorrection ?? null,
    }));

    const { error } = await supabase.from("work_order_quote_lines").insert(rows);
    if (error) return NextResponse.json({ error: error.message }, { status: 500 });

    return NextResponse.json({ ok: true });
  } catch {
    return NextResponse.json({ error: "Failed to add quote items" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/work-orders/[id]/Client.tsx */
/* =============================== */

"use client";

import React, { useCallback, useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { useParams } from "next/navigation";
import { format } from "date-fns";
import { toast } from "sonner";
import dynamic from "next/dynamic";

import { supabaseBrowser as supabase } from "@/features/shared/lib/supabase/client";
import type { Database } from "@shared/types/types/supabase";

import PreviousPageButton from "@shared/components/ui/PreviousPageButton";
import VehiclePhotoUploader from "@parts/components/VehiclePhotoUploader";
import VehiclePhotoGallery from "@parts/components/VehiclePhotoGallery";
import FocusedJobModal from "@/features/work-orders/components/workorders/FocusedJobModal";
import { UsePartButton } from "@work-orders/components/UsePartButton";
import VoiceContextSetter from "@/features/shared/voice/VoiceContextSetter";
import VoiceButton from "@/features/shared/voice/VoiceButton";
import { useTabState } from "@/features/shared/hooks/useTabState";
import PartsDrawer from "@/features/parts/components/PartsDrawer";

// assign-mechanic modal
import AssignTechModal from "@/features/work-orders/components/workorders/extras/AssignTechModal";

// inspection modal
const InspectionModal = dynamic(
  () => import("@/features/inspections/components/InspectionModal"),
  { ssr: false }
);

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];
type Customer = DB["public"]["Tables"]["customers"]["Row"];
type Profile = DB["public"]["Tables"]["profiles"]["Row"];
type AllocationRow =
  DB["public"]["Tables"]["work_order_part_allocations"]["Row"] & {
    parts?: { name: string | null } | null;
  };
type LineTechRow =
  DB["public"]["Tables"]["work_order_line_technicians"]["Row"];

const looksLikeUuid = (s: string) => s.includes("-") && s.length >= 36;

function splitCustomId(raw: string): { prefix: string; n: number | null } {
  const m = raw.toUpperCase().match(/^([A-Z]+)\s*0*?(\d+)?$/);
  if (!m) return { prefix: raw.toUpperCase(), n: null };
  const n = m[2] ? parseInt(m[2], 10) : null;
  return { prefix: m[1], n: Number.isFinite(n!) ? n : null };
}

/* ---------------------------- Badges & Row Tints ---------------------------- */

type KnownStatus =
  | "awaiting_approval"
  | "awaiting"
  | "queued"
  | "in_progress"
  | "on_hold"
  | "planned"
  | "new"
  | "completed"
  | "ready_to_invoice"
  | "invoiced";

const BASE_BADGE =
  "inline-flex items-center whitespace-nowrap rounded border px-2 py-0.5 text-xs font-medium";

const BADGE: Record<KnownStatus, string> = {
  awaiting_approval: "bg-blue-900/20 border-blue-500/40 text-blue-300",
  awaiting: "bg-sky-900/20  border-sky-500/40  text-sky-300",
  queued: "bg-indigo-900/20 border-indigo-500/40 text-indigo-300",
  in_progress: "bg-orange-900/20 border-orange-500/40 text-orange-300",
  on_hold: "bg-amber-900/20  border-amber-500/40  text-amber-300",
  planned: "bg-purple-900/20 border-purple-500/40 text-purple-300",
  new: "bg-neutral-800   border-neutral-600   text-neutral-200",
  completed: "bg-green-900/20  border-green-500/40 text-green-300",
  ready_to_invoice: "bg-emerald-900/20 border-emerald-500/40 text-emerald-300",
  invoiced: "bg-teal-900/20    border-teal-500/40    text-teal-300",
};

const chip = (s: string | null | undefined): string => {
  const key = (s ?? "awaiting").toLowerCase().replaceAll(" ", "_") as KnownStatus;
  return `${BASE_BADGE} ${BADGE[key] ?? BADGE.awaiting}`;
};

const statusBorder: Record<string, string> = {
  awaiting: "border-l-4 border-slate-400",
  queued: "border-l-4 border-indigo-400",
  in_progress: "border-l-4 border-orange-500",
  on_hold: "border-l-4 border-amber-500",
  completed: "border-l-4 border-green-500",
  awaiting_approval: "border-l-4 border-blue-500",
  planned: "border-l-4 border-purple-500",
  new: "border-l-4 border-gray-400",
};

const statusRowTint: Record<string, string> = {
  awaiting: "bg-neutral-950",
  queued: "bg-neutral-950",
  in_progress: "bg-neutral-950",
  on_hold: "bg-amber-900/30",
  completed: "bg-green-900/30",
  awaiting_approval: "bg-neutral-950",
  planned: "bg-neutral-950",
  new: "bg-neutral-950",
};

// roles allowed to assign
const ASSIGN_ROLES = new Set(["owner", "admin", "manager", "advisor"]);

/* ------------------------------------------------------------------------- */

export default function WorkOrderIdClient(): JSX.Element {
  const params = useParams();
  const routeId = (params?.id as string) || "";

  const [wo, setWo] = useTabState<WorkOrder | null>("wo:id:wo", null);
  const [lines, setLines] = useTabState<WorkOrderLine[]>("wo:id:lines", []);
  const [vehicle, setVehicle] = useTabState<Vehicle | null>("wo:id:veh", null);
  const [customer, setCustomer] = useTabState<Customer | null>("wo:id:cust", null);

  const [allocsByLine, setAllocsByLine] = useState<Record<string, AllocationRow[]>>({});
  const [loading, setLoading] = useState<boolean>(false);
  const [viewError, setViewError] = useState<string | null>(null);

  const [currentUserId, setCurrentUserId] = useTabState<string | null>("wo:id:uid", null);
  const [, setUserId] = useTabState<string | null>("wo:id:effectiveUid", null);
  const [currentUserRole, setCurrentUserRole] = useState<string | null>(null);

  const [showDetails, setShowDetails] = useTabState<boolean>("wo:showDetails", true);
  const [focusedJobId, setFocusedJobId] = useState<string | null>(null);
  const [focusedOpen, setFocusedOpen] = useState(false);
  const [warnedMissing, setWarnedMissing] = useState(false);

  // parts
  const [partsLineId, setPartsLineId] = useState<string | null>(null);
  const [bulkQueue, setBulkQueue] = useState<string[]>([]);
  const [bulkActive, setBulkActive] = useState<boolean>(false);

  // inspection
  const [inspectionOpen, setInspectionOpen] = useState(false);
  const [inspectionSrc, setInspectionSrc] = useState<string | null>(null);

  // assign mechanic
  const [assignOpen, setAssignOpen] = useState(false);
  const [assignLineId, setAssignLineId] = useState<string | null>(null);
  const [assignables, setAssignables] = useState<
    Array<Pick<Profile, "id" | "full_name" | "role">>
  >([]);

  // per-line technicians
  const [lineTechsByLine, setLineTechsByLine] = useState<Record<string, string[]>>({});

  /* ---------------------- AUTH + assignables ---------------------- */
  useEffect(() => {
    let mounted = true;

    const waitForSession = async () => {
      let {
        data: { session },
      } = await supabase.auth.getSession();

      if (!session) {
        for (let i = 0; i < 8; i++) {
          await new Promise((r) => setTimeout(r, 150 * (i + 1)));
          const res = await supabase.auth.getSession();
          session = res.data.session;
          if (session) break;
        }
      }

      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!mounted) return;

      const uid = user?.id ?? null;
      setCurrentUserId(uid);
      setUserId(uid);

      if (uid) {
        const { data: prof } = await supabase
          .from("profiles")
          .select("role")
          .eq("id", uid)
          .maybeSingle();
        setCurrentUserRole(prof?.role ?? null);
      }

      try {
        const res = await fetch("/api/assignables");
        const json = await res.json();
        if (res.ok && Array.isArray(json.data)) {
          setAssignables(json.data);
        }
      } catch {
        // ignore
      }

      if (!uid) setLoading(false);
    };

    void waitForSession();

    const { data: sub } = supabase.auth.onAuthStateChange((_evt, s) => {
      if (s?.user) void waitForSession();
      else {
        setCurrentUserId(null);
        setUserId(null);
        setLoading(false);
      }
    });

    return () => {
      mounted = false;
      sub?.subscription?.unsubscribe?.();
    };
  }, [supabase, routeId, setCurrentUserId, setUserId]);

  /* ---------------------- FETCH ---------------------- */
  const fetchAll = useCallback(
    async (retry = 0) => {
      if (!routeId) return;
      setLoading(true);
      setViewError(null);

      try {
        let woRow: WorkOrder | null = null;

        // by UUID
        if (looksLikeUuid(routeId)) {
          const { data, error } = await supabase
            .from("work_orders")
            .select("*")
            .eq("id", routeId)
            .maybeSingle();
          if (!error) woRow = (data as WorkOrder | null) ?? null;
        }

        // by custom_id
        if (!woRow) {
          const eqRes = await supabase
            .from("work_orders")
            .select("*")
            .eq("custom_id", routeId)
            .maybeSingle();
          woRow = (eqRes.data as WorkOrder | null) ?? null;

          if (!woRow) {
            const ilikeRes = await supabase
              .from("work_orders")
              .select("*")
              .ilike("custom_id", routeId.toUpperCase())
              .maybeSingle();
            woRow = (ilikeRes.data as WorkOrder | null) ?? null;
          }

          if (!woRow) {
            const { prefix, n } = splitCustomId(routeId);
            if (n !== null) {
              const { data: cands } = await supabase
                .from("work_orders")
                .select("*")
                .ilike("custom_id", `${prefix}%`)
                .limit(50);
              const wanted = `${prefix}${n}`;
              const match = (cands ?? []).find(
                (r) =>
                  (r.custom_id ?? "")
                    .toUpperCase()
                    .replace(/^([A-Z]+)0+/, "$1") === wanted
              );
              if (match) woRow = match as WorkOrder;
            }
          }
        }

        if (!woRow) {
          if (retry < 2) {
            await new Promise((r) => setTimeout(r, 200 * Math.pow(2, retry)));
            return fetchAll(retry + 1);
          }
          setViewError("Work order not visible / not found.");
          setWo(null);
          setLines([]);
          setVehicle(null);
          setCustomer(null);
          setAllocsByLine({});
          setLineTechsByLine({});
          setLoading(false);
          return;
        }

        setWo(woRow);

        if (!warnedMissing && (!woRow.vehicle_id || !woRow.customer_id)) {
          toast.error(
            "This work order is missing vehicle and/or customer. Open the Create form to set them."
          );
          setWarnedMissing(true);
        }

        const [linesRes, vehRes, custRes] = await Promise.all([
          supabase
            .from("work_order_lines")
            .select("*")
            .eq("work_order_id", woRow.id)
            .order("created_at", { ascending: true }),
          woRow.vehicle_id
            ? supabase
                .from("vehicles")
                .select("*")
                .eq("id", woRow.vehicle_id)
                .maybeSingle()
            : Promise.resolve({ data: null, error: null } as const),
          woRow.customer_id
            ? supabase
                .from("customers")
                .select("*")
                .eq("id", woRow.customer_id)
                .maybeSingle()
            : Promise.resolve({ data: null, error: null } as const),
        ]);

        if (linesRes.error) throw linesRes.error;
        const lineRows = (linesRes.data ?? []) as WorkOrderLine[];
        setLines(lineRows);

        if (vehRes?.error) throw vehRes.error;
        setVehicle((vehRes?.data as Vehicle | null) ?? null);

        if (custRes?.error) throw custRes.error;
        setCustomer((custRes?.data as Customer | null) ?? null);

        // allocations + line techs
        if (lineRows.length) {
          const [allocsQuery, lineTechsQuery] = await Promise.all([
            supabase
              .from("work_order_part_allocations")
              .select("*, parts(name)")
              .in(
                "work_order_line_id",
                lineRows.map((l) => l.id)
              ),
            supabase
              .from("work_order_line_technicians")
              .select("work_order_line_id, technician_id")
              .in(
                "work_order_line_id",
                lineRows.map((l) => l.id)
              ),
          ]);

          const byLine: Record<string, AllocationRow[]> = {};
          (allocsQuery.data ?? []).forEach((a) => {
            const key = (a as AllocationRow).work_order_line_id;
            if (!byLine[key]) byLine[key] = [];
            byLine[key].push(a as AllocationRow);
          });
          setAllocsByLine(byLine);

          const techMap: Record<string, string[]> = {};
          (lineTechsQuery.data as LineTechRow[] | null)?.forEach((lt) => {
            const lnId = lt.work_order_line_id;
            const techId = lt.technician_id;
            if (!techMap[lnId]) techMap[lnId] = [];
            if (!techMap[lnId].includes(techId)) {
              techMap[lnId].push(techId);
            }
          });
          setLineTechsByLine(techMap);
        } else {
          setAllocsByLine({});
          setLineTechsByLine({});
        }
      } catch (e: unknown) {
        const msg =
          e instanceof Error ? e.message : "Failed to load work order.";
        setViewError(msg);
        console.error("[WO id page] load error:", e);
      } finally {
        setLoading(false);
      }
    },
    [
      supabase,
      routeId,
      warnedMissing,
      setWo,
      setLines,
      setVehicle,
      setCustomer,
    ]
  );

  useEffect(() => {
    if (!routeId || !currentUserId) return;
    void fetchAll();
  }, [fetchAll, routeId, currentUserId]);

  /* ---------------------- REALTIME ---------------------- */
  useEffect(() => {
    if (!wo?.id) return;

    const ch = supabase
      .channel(`wo:${wo.id}`)
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "work_orders", filter: `id=eq.${wo.id}` },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_lines",
          filter: `work_order_id=eq.${wo.id}`,
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_part_allocations",
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_line_technicians",
        },
        () => fetchAll()
      )
      .subscribe();

    const local = () => fetchAll();
    window.addEventListener("wo:parts-used", local);

    return () => {
      try {
        supabase.removeChannel(ch);
      } catch {}
      window.removeEventListener("wo:parts-used", local);
    };
  }, [supabase, wo?.id, fetchAll]);

  // ---------- listen for inspection finish ----------
  useEffect(() => {
    interface InspectionCompletedEventDetail {
      workOrderLineId?: string;
      cause?: string;
      correction?: string;
    }

    const handler = (ev: CustomEvent<InspectionCompletedEventDetail>) => {
      const d = ev.detail || {};
      const lineId = d.workOrderLineId;
      if (!lineId) return;

      setFocusedJobId(lineId);
      setFocusedOpen(true);

      window.dispatchEvent(
        new CustomEvent("wo:prefill-cause-correction", {
          detail: {
            lineId,
            cause: d.cause ?? "",
            correction: d.correction ?? "",
          },
        })
      );
    };

    window.addEventListener("inspection:completed", handler as EventListener);
    return () => {
      window.removeEventListener("inspection:completed", handler as EventListener);
    };
  }, []);

  // 🔁 refresh this page when a parts request is submitted from the focused modal
  useEffect(() => {
    const handler = () => {
      void fetchAll();
    };
    window.addEventListener("parts-request:submitted", handler);
    return () => window.removeEventListener("parts-request:submitted", handler);
  }, [fetchAll]);

  /* ----------------------- Derived data ----------------------- */
  const approvalPending = useMemo(
    () => lines.filter((l) => (l.approval_state ?? null) === "pending"),
    [lines]
  );

  const activeJobLines = useMemo(
    () => lines.filter((l) => (l.approval_state ?? null) !== "pending"),
    [lines]
  );

  const sortedLines = useMemo(() => {
    const pr: Record<string, number> = {
      diagnosis: 1,
      inspection: 2,
      maintenance: 3,
      repair: 4,
    };
    return [...activeJobLines].sort((a, b) => {
      const pa = pr[String(a.job_type ?? "repair")] ?? 999;
      const pb = pr[String(b.job_type ?? "repair")] ?? 999;
      if (pa !== pb) return pa - pb;
      const ta = a.created_at ? new Date(a.created_at).getTime() : 0;
      const tb = b.created_at ? new Date(b.created_at).getTime() : 0;
      return ta - tb;
    });
  }, [activeJobLines]);

  const createdAt = wo?.created_at ? new Date(wo.created_at) : null;
  const createdAtText =
    createdAt && !isNaN(createdAt.getTime())
      ? format(createdAt, "PPpp")
      : "—";

  const canAssign = currentUserRole ? ASSIGN_ROLES.has(currentUserRole) : false;

  const assignablesById = useMemo(() => {
    const m: Record<string, { full_name: string | null; role: string | null }> = {};
    assignables.forEach((a) => {
      m[a.id] = { full_name: a.full_name, role: a.role };
    });
    return m;
  }, [assignables]);

  /* ----------------------- line actions ----------------------- */

  const approveLine = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          approval_state: "approved",
          status: "queued",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      toast.success("Line approved");
      void fetchAll();
    },
    [supabase, fetchAll]
  );

  const declineLine = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          approval_state: "declined",
          status: "awaiting",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      toast.success("Line declined");
      void fetchAll();
    },
    [supabase, fetchAll]
  );

  const sendToParts = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          status: "on_hold",
          hold_reason: "Awaiting parts quote",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      setPartsLineId(lineId);
      toast.success("Sent to parts for quoting");
    },
    [supabase]
  );

  const sendAllPendingToParts = useCallback(async () => {
    if (!approvalPending.length) return;
    const ids = approvalPending.map((l) => l.id);
    const { error } = await supabase
      .from("work_order_lines")
      .update({
        status: "on_hold",
        hold_reason: "Awaiting parts quote",
      } as DB["public"]["Tables"]["work_order_lines"]["Update"])
      .in("id", ids);
    if (error) {
      toast.error(error.message);
      return;
    }
    setBulkQueue(ids);
    setBulkActive(true);
    setPartsLineId(ids[0] ?? null);
    toast.success("Queued all pending lines for parts quoting");
  }, [approvalPending, supabase]);

  // open inspection
  const openInspectionForLine = useCallback(
    async (ln: WorkOrderLine) => {
      if (!ln?.id) return;

      const desc = String(ln.description ?? "").toLowerCase();
      const isAir = /\bair\b|cvip|push\s*rod|air\s*brake/.test(desc);
      const isCustom = /\bcustom\b|\bbuilder\b|\bprompt\b|\bad[-\s]?hoc\b/.test(
        desc
      );

      let templateSlug = isAir ? "maintenance50-air" : "maintenance50";
      if (isCustom) {
        templateSlug = "custom:pending";
      }

      try {
        const res = await fetch("/api/inspections/session/create", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            workOrderId: wo?.id ?? null,
            workOrderLineId: ln.id,
            vehicleId: vehicle?.id ?? null,
            customerId: customer?.id ?? null,
            template: templateSlug,
          }),
        });

        const j = (await res.json().catch(() => null)) as
          | { sessionId?: string; error?: string }
          | null;

        if (!res.ok || !j?.sessionId) {
          throw new Error(j?.error || "Failed to create inspection session");
        }

        if (isCustom) {
          templateSlug = `custom:${j.sessionId}`;
        }

        const sp = new URLSearchParams();
        if (wo?.id) sp.set("workOrderId", wo.id);
        sp.set("workOrderLineId", ln.id);
        sp.set("inspectionId", j.sessionId);
        sp.set("template", templateSlug);
        sp.set("embed", "1");
        if (isCustom && ln.description)
          sp.set("seed", String(ln.description));

        const url = `/inspection/${templateSlug}?${sp.toString()}`;

        setInspectionSrc(url);
        setInspectionOpen(true);
        toast.success("Inspection opened");
      } catch (e) {
        const err = e as { message?: string };
        toast.error(err?.message ?? "Unable to open inspection");
      }
    },
    [wo?.id, vehicle?.id, customer?.id]
  );

  // parts drawer close / bulk
  useEffect(() => {
    if (!partsLineId) return;

    const evtName = `parts-drawer:closed:${partsLineId}`;

    const handler = () => {
      if (bulkActive && bulkQueue.length > 0) {
        const [, ...rest] = bulkQueue;
        setBulkQueue(rest);
        setPartsLineId(rest[0] ?? null);
        if (rest.length === 0) {
          setBulkActive(false);
          void fetchAll();
        }
      } else {
        setPartsLineId(null);
        void fetchAll();
      }
    };

    window.addEventListener(evtName, handler as EventListener);
    return () => window.removeEventListener(evtName, handler as EventListener);
  }, [partsLineId, bulkActive, bulkQueue, fetchAll]);

  /* -------------------------- UI -------------------------- */
  if (!routeId)
    return <div className="p-6 text-red-500">Missing work order id.</div>;

  const Skeleton = ({ className = "" }: { className?: string }) => (
    <div className={`animate-pulse rounded-lg bg-neutral-800/60 ${className}`} />
  );

  return (
    <div className="mx-auto max-w-6xl px-3 py-6 bg-background text-foreground">
      <VoiceContextSetter
        currentView="work_order_page"
        workOrderId={wo?.id}
        vehicleId={vehicle?.id}
        customerId={customer?.id}
        lineId={null}
      />

      <div className="mb-4 flex items-center justify-between gap-2">
        <PreviousPageButton to="/work-orders" />
        {wo?.custom_id && (
          <span className="rounded-full border border-neutral-800 bg-neutral-900/70 px-3 py-1 text-xs text-neutral-300">
            Internal ID: {wo.id.slice(0, 8)}
          </span>
        )}
      </div>

      {!currentUserId && (
        <div className="mb-4 rounded-lg border border-amber-500/30 bg-amber-900/10 p-3 text-sm text-amber-100">
          You appear signed out on this tab. If actions fail, open{" "}
          <Link href="/sign-in" className="underline hover:text-white">
            Sign In
          </Link>{" "}
          and return here.
        </div>
      )}

      {viewError && (
        <div className="mb-4 whitespace-pre-wrap rounded-lg border border-red-500/40 bg-red-950/60 p-3 text-sm text-red-200">
          {viewError}
        </div>
      )}

      {loading ? (
        <div className="mt-6 grid gap-4">
          <Skeleton className="h-24" />
          <Skeleton className="h-40" />
          <Skeleton className="h-56" />
        </div>
      ) : !wo ? (
        <div className="mt-6 text-sm text-red-400">Work order not found.</div>
      ) : (
        <div className="grid grid-cols-1 gap-6 lg:grid-cols-[minmax(0,1.7fr),minmax(0,1fr)]">
          {/* LEFT */}
          <div className="space-y-6">
            {/* Header */}
            <div className="rounded-xl border border-border bg-card/95 p-4 shadow-sm">
              <div className="flex flex-wrap items-center justify-between gap-3">
                <div className="space-y-1">
                  <div className="flex flex-wrap items-center gap-2">
                    <h1 className="text-xl font-semibold text-white sm:text-2xl">
                      Work Order{" "}
                      <span className="text-orange-400">
                        {wo.custom_id || `#${wo.id.slice(0, 8)}`}
                      </span>
                    </h1>
                    <span className={chip(wo.status)}>
                      {(wo.status ?? "awaiting").replaceAll("_", " ")}
                    </span>
                  </div>
                  <p className="text-xs text-neutral-400">
                    Created {createdAtText}
                  </p>
                </div>
              </div>

              <div className="mt-3 grid gap-3 text-xs text-neutral-300 sm:grid-cols-4">
                <div>
                  <div className="text-neutral-500">Created</div>
                  <div>{createdAtText}</div>
                </div>
                <div>
                  <div className="text-neutral-500">WO ID</div>
                  <div className="truncate font-mono text-[11px] text-neutral-200">
                    {wo.id}
                  </div>
                </div>
                <div>
                  <div className="text-neutral-500">Custom ID</div>
                  <div className="truncate">
                    {wo.custom_id ?? (
                      <span className="text-neutral-500">Not set</span>
                    )}
                  </div>
                </div>
                <div>
                  <div className="text-neutral-500">Status</div>
                  <div className="mt-0.5">
                    <span className={chip(wo.status)}>
                      {(wo.status ?? "awaiting").replaceAll("_", " ")}
                    </span>
                  </div>
                </div>
              </div>
            </div>

            {/* Vehicle & Customer */}
            <div className="rounded-xl border border-border bg-card/95 p-4">
              <div className="flex items-center justify-between gap-2">
                <h2 className="text-sm font-semibold text-white sm:text-base">
                  Vehicle &amp; Customer
                </h2>
                <button
                  type="button"
                  className="text-xs font-medium text-orange-400 hover:text-orange-300 hover:underline"
                  onClick={() => setShowDetails((v) => !v)}
                  aria-expanded={showDetails}
                >
                  {showDetails ? "Hide details" : "Show details"}
                </button>
              </div>

              {showDetails && (
                <div className="mt-3 grid gap-4 sm:grid-cols-2">
                  <div className="rounded-lg bg-neutral-950/60 p-3">
                    <h3 className="mb-1 text-xs font-semibold uppercase tracking-wide text-neutral-400">
                      Vehicle
                    </h3>
                    {vehicle ? (
                      <>
                        <p className="text-sm font-medium text-white">
                          {(vehicle.year ?? "").toString()}{" "}
                          {vehicle.make ?? ""} {vehicle.model ?? ""}
                        </p>
                        <p className="mt-1 text-xs text-neutral-400">
                          VIN:{" "}
                          <span className="font-mono">
                            {vehicle.vin ?? "—"}
                          </span>
                          <br />
                          Plate:{" "}
                          {vehicle.license_plate ?? (
                            <span className="text-neutral-500">—</span>
                          )}
                        </p>
                      </>
                    ) : (
                      <p className="text-sm text-neutral-500">
                        No vehicle linked yet.
                      </p>
                    )}
                  </div>

                  <div className="rounded-lg bg-neutral-950/60 p-3">
                    <h3 className="mb-1 text-xs font-semibold uppercase tracking-wide text-neutral-400">
                      Customer
                    </h3>
                    {customer ? (
                      <>
                        <p className="text-sm font-medium text-white">
                          {[
                            customer.first_name ?? "",
                            customer.last_name ?? "",
                          ]
                            .filter(Boolean)
                            .join(" ") || "—"}
                        </p>
                        <p className="mt-1 text-xs text-neutral-400">
                          {customer.phone ?? "—"}{" "}
                          {customer.email ? (
                            <>
                              <span className="mx-1 text-neutral-600">•</span>
                              {customer.email}
                            </>
                          ) : null}
                        </p>
                        {customer.id && (
                          <Link
                            href={`/customers/${customer.id}`}
                            className="mt-2 inline-flex text-[11px] font-medium text-orange-400 hover:text-orange-300 hover:underline"
                            title="Open customer profile"
                          >
                            View customer profile →
                          </Link>
                        )}
                      </>
                    ) : (
                      <p className="text-sm text-neutral-500">
                        No customer linked yet.
                      </p>
                    )}
                  </div>
                </div>
              )}
            </div>

            {/* Awaiting Customer Approval */}
            <div className="rounded-xl border border-blue-900/60 bg-gradient-to-b from-slate-950 to-slate-950/90 p-4">
              <div className="mb-3 flex items-center justify-between gap-2">
                <h2 className="text-sm font-semibold text-blue-200 sm:text-base">
                  Awaiting customer approval
                </h2>
                {approvalPending.length > 1 && (
                  <button
                    type="button"
                    className="rounded-md bg-blue-600 px-3 py-1.5 text-xs font-semibold text-white shadow-sm hover:bg-blue-500"
                    onClick={sendAllPendingToParts}
                    title="Queue all lines for parts quoting"
                  >
                    Quote all pending lines
                  </button>
                )}
              </div>

              {approvalPending.length === 0 ? (
                <p className="text-xs text-neutral-400">
                  No lines waiting for approval.
                </p>
              ) : (
                <div className="space-y-2">
                  {approvalPending.map((ln, idx) => {
                    const isAwaitingParts =
                      (ln.status === "on_hold" &&
                        (ln.hold_reason ?? "")
                          .toLowerCase()
                          .includes("part")) ||
                      (ln.hold_reason ?? "")
                        .toLowerCase()
                        .includes("quote");

                    return (
                      <div
                        key={ln.id}
                        className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3"
                      >
                        <div className="flex items-start justify-between gap-3">
                          <div className="min-w-0">
                            <div className="truncate text-sm font-medium text-white">
                              {idx + 1}.{" "}
                              {ln.description || ln.complaint || "Untitled job"}
                            </div>
                            <div className="mt-0.5 text-[11px] text-neutral-400">
                              {String(ln.job_type ?? "job").replaceAll("_", " ")}{" "}
                              •{" "}
                              {typeof ln.labor_time === "number"
                                ? `${ln.labor_time}h`
                                : "—"}{" "}
                              • Status:{" "}
                              {(ln.status ?? "awaiting").replaceAll("_", " ")}{" "}
                              • Approval:{" "}
                              {(ln.approval_state ?? "pending").replaceAll(
                                "_",
                                " "
                              )}
                            </div>
                            {ln.notes && (
                              <div className="mt-1 text-[11px] text-neutral-400">
                                Notes: {ln.notes}
                              </div>
                            )}
                          </div>

                          <div className="flex shrink-0 flex-wrap items-center gap-2">
                            <button
                              type="button"
                              className="rounded-md border border-green-700 px-2 py-1 text-[11px] font-medium text-green-200 hover:bg-green-900/25"
                              onClick={() => approveLine(ln.id)}
                            >
                              Approve
                            </button>
                            <button
                              type="button"
                              className="rounded-md border border-red-700 px-2 py-1 text-[11px] font-medium text-red-200 hover:bg-red-900/30"
                              onClick={() => declineLine(ln.id)}
                            >
                              Decline
                            </button>

                            {isAwaitingParts ? (
                              <button
                                type="button"
                                disabled
                                className="cursor-not-allowed rounded-md border border-neutral-700 px-2 py-1 text-[11px] text-neutral-400"
                              >
                                Sent to parts
                              </button>
                            ) : (
                              <button
                                type="button"
                                className="rounded-md border border-blue-700 px-2 py-1 text-[11px] font-medium text-blue-200 hover:bg-blue-900/25"
                                onClick={() => sendToParts(ln.id)}
                                title="Send to parts for quoting"
                              >
                                Send to parts
                              </button>
                            )}
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>

            {/* Jobs list */}
            <div className="rounded-xl border border-border bg-card/95 p-4">
              <div className="mb-3 flex items-center justify-between gap-2">
                <div>
                  <h2 className="text-sm font-semibold text-white sm:text-base">
                    Jobs in this work order
                  </h2>
                  <p className="text-[11px] text-neutral-500">
                    Tap a job to open the focused panel with full controls.
                  </p>
                </div>
              </div>

              {sortedLines.length === 0 ? (
                <p className="text-sm text-neutral-400">No lines yet.</p>
              ) : (
                <div className="space-y-2">
                  {sortedLines.map((ln, idx) => {
                    const statusKey = (ln.status ?? "awaiting")
                      .toLowerCase()
                      .replaceAll(" ", "_");
                    const borderCls =
                      statusBorder[statusKey] ||
                      "border-l-4 border-gray-400";
                    const tintCls =
                      statusRowTint[statusKey] || "bg-neutral-950";
                    const punchedIn =
                      !!ln.punched_in_at && !ln.punched_out_at;

                    const partsForLine = allocsByLine[ln.id] ?? [];

                    const lineTechIds = lineTechsByLine[ln.id] ?? [];
                    const primaryId =
                      typeof ln.assigned_to === "string"
                        ? (ln.assigned_to as string)
                        : null;

                    const orderedTechIds: string[] = [];
                    if (primaryId) orderedTechIds.push(primaryId);
                    lineTechIds.forEach((tid) => {
                      if (!orderedTechIds.includes(tid)) {
                        orderedTechIds.push(tid);
                      }
                    });

                    return (
                      <div
                        key={ln.id}
                        className={`group rounded-lg border border-neutral-800 ${tintCls} p-3 transition hover:border-orange-500/70 hover:bg-neutral-900/80 ${borderCls} ${
                          punchedIn ? "ring-2 ring-orange-500/80" : ""
                        }`}
                        title="Open focused job"
                        onClick={() => {
                          setFocusedJobId(ln.id);
                          setFocusedOpen(true);
                        }}
                      >
                        <div className="flex items-start justify-between gap-3">
                          <div className="min-w-0">
                            <div className="flex flex-wrap items-center gap-2">
                              <div className="truncate text-sm font-medium text-white">
                                {idx + 1}.{" "}
                                {ln.description ||
                                  ln.complaint ||
                                  "Untitled job"}
                              </div>
                              {ln.job_type === "inspection" && (
                                <button
                                  type="button"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    void openInspectionForLine(ln);
                                  }}
                                  className={`rounded-md border px-2 py-0.5 text-[11px] font-medium ${
                                    ln.status === "completed"
                                      ? "border-green-400 text-green-200"
                                      : "border-orange-400 text-orange-200 hover:bg-orange-500/10"
                                  }`}
                                >
                                  {ln.status === "completed"
                                    ? "View inspection"
                                    : "Open inspection"}
                                </button>
                              )}
                              {canAssign && (
                                <button
                                  type="button"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setAssignLineId(ln.id);
                                    setAssignOpen(true);
                                  }}
                                  className="rounded-md border border-sky-500/70 px-2 py-0.5 text-[11px] font-medium text-sky-200 hover:bg-sky-900/25"
                                  title="Assign mechanic to this line"
                                >
                                  Assign mechanic
                                </button>
                              )}
                            </div>
                            <div className="mt-0.5 text-[11px] text-neutral-400">
                              {String(ln.job_type ?? "job").replaceAll("_", " ")}{" "}
                              •{" "}
                              {typeof ln.labor_time === "number"
                                ? `${ln.labor_time}h`
                                : "—"}{" "}
                              • Status:{" "}
                              {(ln.status ?? "awaiting").replaceAll("_", " ")}
                            </div>

                            {orderedTechIds.length > 0 && (
                              <div className="mt-1 flex flex-wrap gap-1">
                                {orderedTechIds.map((tid) => {
                                  const info = assignablesById[tid];
                                  const label = info?.full_name ?? "Mechanic";
                                  return (
                                    <span
                                      key={tid}
                                      className="inline-flex items-center gap-1 rounded-full bg-sky-900/40 px-2 py-0.5 text-[10px] text-sky-100"
                                    >
                                      <span className="h-1.5 w-1.5 rounded-full bg-sky-300" />
                                      {label}
                                    </span>
                                  );
                                })}
                              </div>
                            )}

                            {(ln.complaint || ln.cause || ln.correction) && (
                              <div className="mt-1 flex flex-wrap items-center gap-2 text-[11px] text-neutral-400">
                                {ln.complaint ? (
                                  <span>Cmpl: {ln.complaint}</span>
                                ) : null}
                                {ln.cause ? (
                                  <span>| Cause: {ln.cause}</span>
                                ) : null}
                                {ln.correction ? (
                                  <span>| Corr: {ln.correction}</span>
                                ) : null}
                              </div>
                            )}

                            {/* Parts used */}
                            <div className="mt-2 rounded-lg border border-neutral-800 bg-neutral-950/80 p-2">
                              <div className="mb-1 flex items-center justify-between gap-2">
                                <div className="text-[11px] font-semibold uppercase tracking-wide text-neutral-300">
                                  Parts used
                                </div>
                                <div className="shrink-0">
                                  <UsePartButton
                                    workOrderLineId={ln.id}
                                    onApplied={() =>
                                      window.dispatchEvent(
                                        new CustomEvent("wo:parts-used")
                                      )
                                    }
                                    label="Add part"
                                  />
                                </div>
                              </div>
                              {partsForLine.length ? (
                                <ul className="mt-1 divide-y divide-neutral-800 rounded border border-neutral-800 text-sm">
                                  {partsForLine.map((a) => (
                                    <li
                                      key={a.id}
                                      className="flex items-center justify-between bg-neutral-900/70 p-2"
                                    >
                                      <div className="min-w-0">
                                        <div className="truncate text-sm text-white">
                                          {a.parts?.name ?? "Part"}
                                        </div>
                                        <div className="text-[11px] text-neutral-500">
                                          loc {String(a.location_id).slice(0, 6)}
                                          …
                                        </div>
                                      </div>
                                      <div className="pl-3 text-sm font-semibold text-neutral-100">
                                        × {a.qty}
                                      </div>
                                    </li>
                                  ))}
                                </ul>
                              ) : (
                                <div className="mt-1 text-[11px] text-neutral-500">
                                  No parts used yet.
                                </div>
                              )}
                            </div>
                          </div>

                          <span className={chip(ln.status)}>
                            {(ln.status ?? "awaiting").replaceAll("_", " ")}
                          </span>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          </div>

          {/* RIGHT rail */}
          <aside className="space-y-4 lg:space-y-6">
            <div className="rounded-xl border border-border bg-card/95 p-4 text-sm text-neutral-300">
              <p>
                Select a job card on the left to open the focused job panel with
                full editing, punch and inspection controls.
              </p>
            </div>
          </aside>
        </div>
      )}

      {/* Vehicle photos */}
      {vehicle?.id && (
        <div className="mt-8 space-y-4">
          <h2 className="text-lg font-semibold text-white sm:text-xl">
            Vehicle photos
          </h2>
          <VehiclePhotoUploader vehicleId={vehicle.id} />
          <VehiclePhotoGallery
            vehicleId={vehicle.id}
            currentUserId={currentUserId || "anon"}
          />
        </div>
      )}

      {/* Focused job modal */}
      {focusedOpen && focusedJobId && (
        <FocusedJobModal
          isOpen={focusedOpen}
          onClose={() => setFocusedOpen(false)}
          workOrderLineId={focusedJobId}
          onChanged={fetchAll}
          mode="tech"
        />
      )}

      {/* Parts Drawer */}
      {partsLineId && wo?.id && (
        <PartsDrawer
          open={!!partsLineId}
          workOrderId={wo.id}
          workOrderLineId={partsLineId}
          vehicleSummary={
            vehicle
              ? {
                  year: (
                    vehicle.year as string | number | null
                  )?.toString() ?? null,
                  make: vehicle.make ?? null,
                  model: vehicle.model ?? null,
                }
              : null
          }
          jobDescription={
            lines.find((l) => l.id === partsLineId)?.description ??
            lines.find((l) => l.id === partsLineId)?.complaint ??
            null
          }
          jobNotes={
            lines.find((l) => l.id === partsLineId)?.notes ?? null
          }
          closeEventName={`parts-drawer:closed:${partsLineId}`}
        />
      )}

      {/* Inspection modal */}
      {inspectionOpen && inspectionSrc && (
        <InspectionModal
          open={inspectionOpen}
          src={inspectionSrc}
          title="Inspection"
          onClose={() => setInspectionOpen(false)}
        />
      )}

      {/* Assign mechanic modal */}
      {assignOpen && assignLineId && (
        <AssignTechModal
          isOpen={assignOpen}
          onClose={() => setAssignOpen(false)}
          workOrderLineId={assignLineId}
          mechanics={assignables}
          onAssigned={async () => {
            await fetchAll();
          }}
        />
      )}

      <VoiceButton />
    </div>
  );
}

/* =============================== */
/* FILE: app/work-orders/[id]/approve/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import SignaturePad, { openSignaturePad } from "@/features/shared/signaturePad/controller";
import LegalTerms from "@/features/shared/components/LegalTerms";
import { uploadSignatureImage } from "@/features/shared/lib/utils/uploadSignature";

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type Line = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Shop = DB["public"]["Tables"]["shops"]["Row"];

/* ------------------------------ helpers ---------------------------------- */
const getStr = (obj: unknown, key: string): string | null => {
  if (obj && typeof obj === "object") {
    const v = (obj as Record<string, unknown>)[key];
    if (typeof v === "string") return v.trim() || null;
  }
  return null;
};
const getNum = (obj: unknown, key: string): number | null => {
  if (obj && typeof obj === "object") {
    const v = (obj as Record<string, unknown>)[key];
    if (typeof v === "number" && Number.isFinite(v)) return v;
    if (typeof v === "string") {
      const n = Number(v);
      if (Number.isFinite(n)) return n;
    }
  }
  return null;
};
/* ------------------------------------------------------------------------- */

export default function ApproveWorkOrderPage() {
  const params = useParams<{ id: string }>();
  const id = Array.isArray(params?.id) ? params.id[0] : params?.id;
  const router = useRouter();
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);

  const [wo, setWo] = useState<WorkOrder | null>(null);
  const [shop, setShop] = useState<Shop | null>(null);
  const [lines, setLines] = useState<Line[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [err, setErr] = useState<string | null>(null);

  const [approved, setApproved] = useState<Set<string>>(new Set());
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [savedSigUrl, setSavedSigUrl] = useState<string | null>(null);
  const [agreed, setAgreed] = useState<boolean>(false);

  useEffect(() => {
    (async () => {
      if (!id) return;
      setLoading(true);
      setErr(null);
      try {
        const [{ data: woRow, error: woErr }, { data: lineRows, error: liErr }] = await Promise.all([
          supabase.from("work_orders").select("*").eq("id", id).maybeSingle(),
          supabase
            .from("work_order_lines")
            .select("*")
            .eq("work_order_id", id)
            .neq("status", "completed")
            .order("created_at", { ascending: true }),
        ]);

        if (woErr) throw woErr;
        if (liErr) throw liErr;

        setWo(woRow ?? null);
        setLines(lineRows ?? []);
        setApproved(new Set((lineRows ?? []).map((l) => l.id)));

        if (woRow?.shop_id) {
          const { data: shopRow, error: sErr } = await supabase
            .from("shops")
            .select("*")
            .eq("id", woRow.shop_id)
            .maybeSingle();
          if (sErr) throw sErr;
          setShop(shopRow ?? null);
        } else {
          setShop(null);
        }
      } catch (e) {
        const msg = e instanceof Error ? e.message : "Failed to load work order.";
        setErr(msg);
      } finally {
        setLoading(false);
      }
    })();
  }, [id, supabase]);

  const toggle = (lineId: string) =>
    setApproved((prev) => {
      const next = new Set(prev);
      if (next.has(lineId)) next.delete(lineId);
      else next.add(lineId);
      return next;
    });

  /* ---- Pricing helpers (mirrors Quote Review) --------------------------- */
  const hourlyRate: number =
    getNum(wo, "hourly_rate") ??
    getNum(shop, "hourly_rate") ??
    120;

  const currencyCode = (getStr(shop, "currency") ?? "USD").toUpperCase();
  const fmt = useMemo(
    () => new Intl.NumberFormat("en-US", { style: "currency", currency: currencyCode }),
    [currencyCode]
  );

  const approvedLines = lines.filter((l) => approved.has(l.id));
  const hours = approvedLines.reduce<number>(
    (sum, l) => sum + (typeof l.labor_time === "number" ? l.labor_time : 0),
    0
  );
  const laborTotal = hours * hourlyRate;

  // if your line rows don’t include parts_total, this stays 0
  const partsTotal = approvedLines.reduce<number>(
    (sum, l) => sum + (getNum(l, "parts_total") ?? 0),
    0
  );
  const grandTotal = laborTotal + partsTotal;

  const totals = { hours: hours.toFixed(1) };
  /* ---------------------------------------------------------------------- */

  async function handleSubmit(signatureDataUrl?: string) {
    if (!id) return;
    setSubmitting(true);
    try {
      let signatureUrl: string | null = savedSigUrl;
      if (signatureDataUrl) {
        const uploaded = await uploadSignatureImage(signatureDataUrl, id);
        signatureUrl = uploaded;
        setSavedSigUrl(uploaded);
      }

      const approvedLineIds: string[] = Array.from(approved);
      const declinedLineIds: string[] = lines.map((l) => l.id).filter((x) => !approved.has(x));

      const res = await fetch("/work-orders/approval-webhook", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          workOrderId: id,
          shopId: wo?.shop_id ?? null,
          customerId: wo?.customer_id ?? null,
          approvedLineIds,
          declinedLineIds,
          declineUnchecked: true,
          approverId: null,
          signatureUrl,
        }),
      });

      const j = (await res.json().catch(() => null)) as { error?: string } | null;
      if (!res.ok) {
        throw new Error(j?.error ?? "Failed to submit approval");
      }

      router.replace(`/work-orders/confirm?woId=${id}`);
    } catch (e) {
      setErr(e instanceof Error ? e.message : "Approval failed");
    } finally {
      setSubmitting(false);
    }
  }

  if (loading) {
    return (
      <div className="mx-auto max-w-2xl p-6 text-white">
        <div className="mb-4 h-8 w-48 animate-pulse rounded bg-neutral-800" />
        <div className="h-24 animate-pulse rounded bg-neutral-800" />
      </div>
    );
  }

  if (!wo) {
    return <div className="mx-auto max-w-2xl p-6 text-red-400">Work order not found.</div>;
  }

  return (
    <div className="mx-auto max-w-3xl p-4 text-white sm:p-6">
      <h1 className="text-2xl font-semibold">
        {shop?.name ? `${shop.name} — Customer Approval` : "Approve Work Order"}
      </h1>
      <p className="mt-1 text-neutral-300">
        {wo.custom_id ? `#${wo.custom_id}` : `#${wo.id.slice(0, 8)}`}
      </p>

      {err && <div className="mt-3 rounded border border-red-500/40 bg-red-500/10 p-3">{err}</div>}

      {/* Items */}
      <div className="mt-4 rounded border border-neutral-800 bg-neutral-900">
        <div className="border-b border-neutral-800 p-3 font-semibold">Items</div>
        <div className="divide-y divide-neutral-800">
          {lines.map((l) => (
            <label
              key={l.id}
              className="flex cursor-pointer items-start gap-3 p-3 hover:bg-neutral-900/60"
            >
              <input
                type="checkbox"
                className="mt-1 h-4 w-4"
                checked={approved.has(l.id)}
                onChange={() => toggle(l.id)}
              />
              <div className="min-w-0">
                <div className="truncate font-medium">
                  {l.description || l.complaint || "Untitled item"}
                </div>
                <div className="text-xs text-neutral-400">
                  {(l.job_type ?? "job").replaceAll("_", " ")} •{" "}
                  {typeof l.labor_time === "number" ? `${l.labor_time.toFixed(1)}h` : "—"}
                </div>
                {(l.cause || l.correction) && (
                  <div className="mt-1 text-xs text-neutral-500">
                    {l.cause ? `Cause: ${l.cause}  ` : ""}
                    {l.correction ? `| Corr: ${l.correction}` : ""}
                  </div>
                )}
              </div>
            </label>
          ))}
          {lines.length === 0 && (
            <div className="p-3 text-sm text-neutral-400">No items to approve.</div>
          )}
        </div>
        <div className="border-t border-neutral-800 p-3 text-sm text-neutral-300">
          Total labor (approved):{" "}
          <span className="font-semibold text-white">{totals.hours}h</span>
        </div>
      </div>

      {/* Totals (like Quote Review) */}
      <div className="mt-4 rounded border border-neutral-800 bg-neutral-900">
        <div className="border-b border-neutral-800 p-3 font-semibold">Totals</div>
        <div className="p-3 text-sm">
          <div className="flex items-center justify-between py-1">
            <div>Labor ({hours.toFixed(1)}h @ {fmt.format(hourlyRate)}/hr)</div>
            <div className="font-medium">{fmt.format(laborTotal)}</div>
          </div>
          <div className="flex items-center justify-between py-1">
            <div>Parts</div>
            <div className="font-medium">{fmt.format(partsTotal)}</div>
          </div>
          <div className="mt-2 border-t border-neutral-800 pt-2 flex items-center justify-between">
            <div className="font-semibold">Total</div>
            <div className="font-semibold">{fmt.format(grandTotal)}</div>
          </div>
        </div>
      </div>

      {/* Terms */}
      <LegalTerms onAgreeChange={setAgreed} defaultOpen />

      {/* Actions */}
      <div className="mt-4 flex flex-wrap gap-2">
        <button
          className="rounded bg-green-600 px-4 py-2 font-semibold text-white hover:bg-green-700 disabled:opacity-60"
          onClick={async () => {
            const base64: string | null = await openSignaturePad({ shopName: shop?.name || "" });
            if (base64) await handleSubmit(base64);
          }}
          disabled={submitting || !agreed}
          title={!agreed ? "Please agree to the Terms & Conditions" : "Sign & Submit"}
        >
          {submitting ? "Submitting…" : "Sign & Submit"}
        </button>

        <button
          className="rounded border border-neutral-700 px-4 py-2 hover:border-orange-500 disabled:opacity-60"
          onClick={() => void handleSubmit()}
          disabled={submitting || !agreed}
        >
          Submit without Signature
        </button>
      </div>

      {/* Mount the modal host once */}
      <SignaturePad />
    </div>
  );
}

/* =============================== */
/* FILE: app/work-orders/components/WorkOrderPreview.tsx */
/* =============================== */

"use client";

import { useEffect, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database, Tables } from "@shared/types/types/supabase";

type Props = { woId: string | null };

type WO = Pick<
  Tables<"work_orders">,
  | "id" | "status" | "type" | "created_at" | "updated_at" | "notes"
  | "customer_id" | "vehicle_id"
  | "invoice_total" | "labor_total" | "parts_total"
  | "quote_url" | "invoice_url"
>;

type Customer = Pick<Tables<"customers">, "name" | "email" | "phone" | "first_name" | "last_name">;
type Vehicle  = Pick<Tables<"vehicles">, "year" | "make" | "model" | "license_plate" | "vin" | "color" | "mileage" | "unit_number">;

type WOLine = Pick<
  Tables<"work_order_lines">,
  | "id" | "description" | "job_type" | "labor_time" | "notes"
  | "complaint" | "cause" | "correction" | "status"
  | "created_at" | "updated_at"
>;

export function WorkOrderPreview({ woId }: Props) {
  const supabase = createClientComponentClient<Database>();
  const [wo, setWO] = useState<WO | null>(null);
  const [customer, setCustomer] = useState<Customer | null>(null);
  const [vehicle, setVehicle] = useState<Vehicle | null>(null);
  const [lines, setLines] = useState<WOLine[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    let active = true;
    async function load() {
      if (!woId) {
        setWO(null);
        setCustomer(null);
        setVehicle(null);
        setLines([]);
        setLoading(false);
        return;
      }
      setLoading(true);
      setError(null);
      try {
        const { data: woData, error: woErr } = await supabase
          .from("work_orders")
          .select("id,status,type,created_at,updated_at,notes,customer_id,vehicle_id,invoice_total,labor_total,parts_total,quote_url,invoice_url")
          .eq("id", woId)
          .single<WO>();
        if (woErr || !woData) throw new Error(woErr?.message || "Work order not found");
        if (!active) return;
        setWO(woData);

        if (woData.customer_id) {
          const { data: c } = await supabase
            .from("customers")
            .select("name,email,phone,first_name,last_name")
            .eq("id", woData.customer_id)
            .single<Customer>();
          if (!active) return;
          setCustomer(c ?? null);
        } else {
          setCustomer(null);
        }

        if (woData.vehicle_id) {
          const { data: v } = await supabase
            .from("vehicles")
            .select("year,make,model,license_plate,vin,color,mileage,unit_number")
            .eq("id", woData.vehicle_id)
            .single<Vehicle>();
          if (!active) return;
          setVehicle(v ?? null);
        } else {
          setVehicle(null);
        }

        const { data: linesRaw } = await supabase
          .from("work_order_lines")
          .select("id,description,job_type,labor_time,notes,complaint,cause,correction,status,created_at,updated_at")
          .eq("work_order_id", woId)
          .order("created_at", { ascending: true })
          .returns<WOLine[]>();

        if (!active) return;
        setLines(linesRaw ?? []);
      } catch (e) {
        if (!active) return;
        setError(e instanceof Error ? e.message : String(e));
      } finally {
        if (active) setLoading(false);
      }
    }
    load();
    return () => { active = false; };
  }, [supabase, woId]);

  if (!woId) {
    return <div className="text-neutral-400 text-sm">No work order id provided yet.</div>;
  }

  if (loading) {
    return (
      <div className="rounded-lg border bg-neutral-950 p-5 text-neutral-300" style={{ borderColor: "#f97316" }}>
        Loading work order…
      </div>
    );
  }

  if (error || !wo) {
    return (
      <div className="text-red-400 text-sm">
        Failed to load work order{error ? `: ${error}` : ""}.
      </div>
    );
  }

  const customerName =
    customer?.name ??
    ([customer?.first_name, customer?.last_name].filter(Boolean).join(" ") || "—");

  const vehicleLabel = [vehicle?.year, vehicle?.make, vehicle?.model].filter(Boolean).join(" ");
  const plateOrVin = vehicle?.license_plate ?? vehicle?.vin ?? "—";

  return (
    <div className="rounded-lg border bg-neutral-950 p-5 shadow-xl" style={{ borderColor: "#f97316" }}>
      <div className="flex items-start justify-between gap-4">
        <h3 className="text-xl text-orange-400" style={{ fontFamily: "'Black Ops One', system-ui, sans-serif" }}>
          Work Order #{String(wo.id).slice(0, 8)}
        </h3>
        <span className="text-[11px] px-2 py-1 rounded bg-neutral-900 text-neutral-300 border border-neutral-800">
          {wo.status ?? "unknown"}
        </span>
      </div>

      <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4 text-sm" style={{ fontFamily: "'Roboto', system-ui, sans-serif" }}>
        <section className="space-y-1">
          <div className="text-neutral-400">Customer</div>
          <div className="text-neutral-100">{customerName}</div>
          <div className="text-neutral-300">{customer?.email || "—"}</div>
          <div className="text-neutral-300">{customer?.phone || "—"}</div>
        </section>

        <section className="space-y-1">
          <div className="text-neutral-400">Vehicle</div>
          <div className="text-neutral-100">{vehicleLabel || "—"}</div>
          <div className="text-neutral-300">Plate/VIN: {plateOrVin}</div>
          <div className="text-neutral-300">
            Color: {vehicle?.color || "—"} · Mileage: {vehicle?.mileage ?? "—"} · Unit: {vehicle?.unit_number || "—"}
          </div>
        </section>
      </div>

      <div className="mt-5 border-t border-neutral-800 pt-4">
        <div className="text-sm text-neutral-400 mb-2" style={{ fontFamily: "'Roboto', system-ui, sans-serif" }}>
          Lines
        </div>
        {lines.length === 0 ? (
          <div className="text-neutral-500 text-sm">No lines yet.</div>
        ) : (
          <ul className="space-y-3">
            {lines.map((l) => (
              <li key={l.id} className="rounded border border-neutral-800 bg-neutral-900 p-3">
                <div className="flex items-center justify-between">
                  <div className="text-neutral-100">{l.description || "(no description)"}</div>
                  <span className="text-[11px] px-2 py-0.5 rounded bg-neutral-950 text-neutral-300 border border-neutral-800">
                    {l.job_type || "—"}
                  </span>
                </div>
                <div className="mt-1 text-xs text-neutral-400">
                  Labor time: {l.labor_time ?? 0} · Status: {l.status || "—"}
                </div>
                {(l.complaint || l.cause || l.correction) && (
                  <div className="mt-2 grid grid-cols-1 md:grid-cols-3 gap-2 text-xs">
                    <div className="bg-neutral-950/60 rounded p-2 border border-neutral-800">
                      <div className="text-neutral-400 mb-1">Complaint</div>
                      <div className="text-neutral-200">{l.complaint || "—"}</div>
                    </div>
                    <div className="bg-neutral-950/60 rounded p-2 border border-neutral-800">
                      <div className="text-neutral-400 mb-1">Cause</div>
                      <div className="text-neutral-200">{l.cause || "—"}</div>
                    </div>
                    <div className="bg-neutral-950/60 rounded p-2 border border-neutral-800">
                      <div className="text-neutral-400 mb-1">Correction</div>
                      <div className="text-neutral-200">{l.correction || "—"}</div>
                    </div>
                  </div>
                )}
                {l.notes && <div className="mt-2 text-xs text-neutral-300">Notes: {l.notes}</div>}
              </li>
            ))}
          </ul>
        )}
      </div>

      <div className="mt-5 border-t border-neutral-800 pt-4 grid grid-cols-1 md:grid-cols-3 gap-3 text-sm">
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="text-neutral-400">Parts Total</div>
          <div className="text-neutral-100">${(wo.parts_total ?? 0).toFixed(2)}</div>
        </div>
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="text-neutral-400">Labor Total</div>
          <div className="text-neutral-100">${(wo.labor_total ?? 0).toFixed(2)}</div>
        </div>
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="text-neutral-400">Invoice Total</div>
          <div className="text-neutral-100">${(wo.invoice_total ?? 0).toFixed(2)}</div>
        </div>
      </div>

      {(wo.quote_url || wo.invoice_url) && (
        <div className="mt-4 flex gap-2">
          {wo.quote_url && (
            <a href={wo.quote_url} target="_blank" rel="noreferrer" className="text-xs underline text-orange-400 hover:text-orange-300">
              Open Quote
            </a>
          )}
          {wo.invoice_url && (
            <a href={wo.invoice_url} target="_blank" rel="noreferrer" className="text-xs underline text-orange-400 hover:text-orange-300">
              Open Invoice
            </a>
          )}
        </div>
      )}

      {wo.notes && (
        <div className="mt-4 text-sm text-neutral-200">
          <div className="text-neutral-400 mb-1">Notes</div>
          <p className="whitespace-pre-wrap">{wo.notes}</p>
        </div>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: app/work-orders/approval-webhook/route.ts */
/* =============================== */

// app/work-orders/approval-webhook/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type Json = Record<string, unknown>;

type Body = {
  workOrderId?: string;
  approvedLineIds?: string[];
  declinedLineIds?: string[];
  declineUnchecked?: boolean;
  approverId?: string | null;    // reserved for later use
  signatureUrl?: string | null;
};

const isString = (v: unknown): v is string => typeof v === "string";
const strArray = (v: unknown): string[] =>
  Array.isArray(v) ? v.filter(isString) : [];

export async function POST(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  // --- read & validate body ---
  let body: Body;
  try {
    body = (await req.json()) as Body;
  } catch {
    return NextResponse.json(
      { error: "Invalid JSON body" } satisfies Json,
      { status: 400 }
    );
  }

  const workOrderId = isString(body.workOrderId) ? body.workOrderId : "";
  const approvedLineIds = strArray(body.approvedLineIds);
  const declinedLineIds = strArray(body.declinedLineIds);
  const declineUnchecked = body.declineUnchecked ?? true;
  const signatureUrl = isString(body.signatureUrl) ? body.signatureUrl : null;

  if (!workOrderId) {
    return NextResponse.json(
      { error: "Missing workOrderId" } satisfies Json,
      { status: 400 }
    );
  }

  try {
    // 1) Mark approved items
    if (approvedLineIds.length > 0) {
      const { error } = await supabase
        .from("work_order_lines")
        .update({ approval_state: "approved" })
        .in("id", approvedLineIds)
        .eq("work_order_id", workOrderId);
      if (error) throw new Error(error.message);
    }

    // 2) Mark declined items (only if asked to decline unchecked)
    if (declineUnchecked && declinedLineIds.length > 0) {
      const { error } = await supabase
        .from("work_order_lines")
        .update({ approval_state: "declined" })
        .in("id", declinedLineIds)
        .eq("work_order_id", workOrderId);
      if (error) throw new Error(error.message);
    }

    // 3) Store signature + approval timestamp on the WO
    //    Also reflect the decision at the WO level so Quote Review hides it
    const { error: woErr } = await supabase
      .from("work_orders")
      .update({
        customer_approval_at: new Date().toISOString(),
        customer_approval_signature_path: signatureUrl,
        // ensure this WO drops out of quote-review and shows in normal flow
        approval_state: "approved",
        status: "queued",
      })
      .eq("id", workOrderId);
    if (woErr) throw new Error(woErr.message);

    return NextResponse.json(
      {
        success: true,
        workOrderId,
        approvedLineIds,
        declinedLineIds,
      } satisfies Json,
      { status: 200 }
    );
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Internal error";
    return NextResponse.json({ error: msg } satisfies Json, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/work-orders/history/WorkOrdersHistoryClient.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState, useCallback } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import Link from "next/link";
import { format } from "date-fns";

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type Customer = DB["public"]["Tables"]["customers"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];

type Row = WorkOrder & {
  customers: Pick<
    Customer,
    "first_name" | "last_name" | "email" | "phone"
  > | null;
  vehicles: Pick<
    Vehicle,
    "year" | "make" | "model" | "license_plate" | "vin"
  > | null;
};

export default function WorkOrdersHistoryClient(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);

  const [shopId, setShopId] = useState<string | null>(null);
  const [rows, setRows] = useState<Row[]>([]);
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState<string | null>(null);

  const [q, setQ] = useState("");
  const [from, setFrom] = useState<string>("");
  const [to, setTo] = useState<string>("");

  // ---- Load current user's shop ----
  useEffect(() => {
    (async () => {
      setLoading(true);
      setErr(null);

      const {
        data: { user },
        error: userErr,
      } = await supabase.auth.getUser();

      if (userErr || !user) {
        setErr("You must be signed in to view work order history.");
        setLoading(false);
        return;
      }

      const { data: profile, error: profErr } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("id", user.id)
        .maybeSingle();

      if (profErr) {
        setErr(profErr.message);
        setLoading(false);
        return;
      }

      if (!profile?.shop_id) {
        setErr("No shop is linked to your profile yet.");
        setLoading(false);
        return;
      }

      setShopId(profile.shop_id);
      setLoading(false);
    })();
  }, [supabase]);

  // ---- Load completed work orders for this shop ----
  const load = useCallback(async () => {
    if (!shopId) return;

    setLoading(true);
    setErr(null);

    let query = supabase
      .from("work_orders")
      .select(
        `
        *,
        customers:customers(first_name,last_name,email,phone),
        vehicles:vehicles(year,make,model,license_plate,vin)
      `
      )
      .eq("shop_id", shopId)
      .eq("status", "completed")
      .order("updated_at", { ascending: false })
      .limit(300);

    if (from) {
      query = query.gte("updated_at", new Date(from + "T00:00:00Z").toISOString());
    }
    if (to) {
      const toEnd = new Date(to);
      toEnd.setHours(23, 59, 59, 999);
      query = query.lte("updated_at", toEnd.toISOString());
    }

    const { data, error } = await query;

    if (error) {
      setErr(error.message);
      setRows([]);
      setLoading(false);
      return;
    }

    const list = (data ?? []) as Row[];

    const qlc = q.trim().toLowerCase();
    const filtered = qlc
      ? list.filter((r) => {
          const name = [r.customers?.first_name ?? "", r.customers?.last_name ?? ""]
            .filter(Boolean)
            .join(" ")
            .toLowerCase();
          const plate = r.vehicles?.license_plate?.toLowerCase() ?? "";
          const vin = r.vehicles?.vin?.toLowerCase() ?? "";
          const ymm = [
            r.vehicles?.year ?? "",
            r.vehicles?.make ?? "",
            r.vehicles?.model ?? "",
          ]
            .join(" ")
            .toLowerCase();
          const cid = (r.custom_id ?? "").toLowerCase();
          return (
            r.id.toLowerCase().includes(qlc) ||
            cid.includes(qlc) ||
            name.includes(qlc) ||
            plate.includes(qlc) ||
            vin.includes(qlc) ||
            ymm.includes(qlc)
          );
        })
      : list;

    setRows(filtered);
    setLoading(false);
  }, [supabase, shopId, from, to, q]);

  // Initial load + reload when filters change via Apply button
  useEffect(() => {
    if (!shopId) return;
    void load();
  }, [load, shopId]);

  function exportCSV() {
    const header = [
      "WO ID",
      "Custom ID",
      "Updated",
      "Customer",
      "Email",
      "Phone",
      "Vehicle",
      "Plate",
      "VIN",
      "Invoice URL",
    ];
    const lines = rows.map((r) => {
      const customer = [r.customers?.first_name ?? "", r.customers?.last_name ?? ""]
        .filter(Boolean)
        .join(" ");
      const vehicle = r.vehicles
        ? `${r.vehicles.year ?? ""} ${r.vehicles.make ?? ""} ${
            r.vehicles.model ?? ""
          }`.trim()
        : "";
      const updated = r.updated_at
        ? format(new Date(r.updated_at), "yyyy-MM-dd HH:mm")
        : "";
      return [
        r.id,
        r.custom_id ?? "",
        updated,
        customer,
        r.customers?.email ?? "",
        r.customers?.phone ?? "",
        vehicle,
        r.vehicles?.license_plate ?? "",
        r.vehicles?.vin ?? "",
        r.invoice_url ?? r.quote_url ?? "",
      ]
        .map((x) => `"${String(x ?? "").replace(/"/g, '""')}"`)
        .join(",");
    });

    const blob = new Blob([header.join(",") + "\n" + lines.join("\n")], {
      type: "text/csv;charset=utf-8",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `work-order-history-${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  return (
    <div className="mx-auto max-w-6xl p-6 bg-background text-foreground">
      {/* Header */}
      <div className="mb-4 flex flex-wrap items-center gap-3">
        <div>
          <h1 className="text-2xl font-blackops text-orange-500">
            Work Order History
          </h1>
          <p className="text-xs text-muted-foreground">
            Completed work orders for your shop. Search, filter by date, export for
            reporting.
          </p>
        </div>

        <div className="ml-auto text-right text-xs text-muted-foreground">
          <div>
            <span className="font-semibold text-orange-400">
              {rows.length}
            </span>{" "}
            completed work orders
          </div>
          {from || to ? (
            <div className="mt-0.5">
              Range:{" "}
              <span className="font-mono">
                {from || "…"} → {to || "…"}
              </span>
            </div>
          ) : (
            <div className="mt-0.5">Showing last {rows.length} records loaded</div>
          )}
        </div>
      </div>

      {/* Filters bar */}
      <div className="mb-4 rounded-xl border border-border bg-card/80 p-3 shadow-sm">
        <div className="flex flex-wrap items-end gap-3">
          <div className="flex-1 min-w-[220px]">
            <label className="mb-1 block text-[11px] font-medium uppercase tracking-[0.12em] text-muted-foreground">
              Search
            </label>
            <input
              value={q}
              onChange={(e) => setQ(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && load()}
              placeholder="ID, custom ID, name, VIN, plate, YMM…"
              className="w-full rounded-md border border-border bg-background px-3 py-1.5 text-sm outline-none focus:border-orange-400 focus:ring-1 focus:ring-orange-500"
            />
          </div>

          <div>
            <label className="mb-1 block text-[11px] uppercase tracking-[0.12em] text-muted-foreground">
              From
            </label>
            <input
              type="date"
              value={from}
              onChange={(e) => setFrom(e.target.value)}
              className="rounded-md border border-border bg-background px-3 py-1.5 text-sm focus:border-orange-400 focus:ring-1 focus:ring-orange-500"
              aria-label="From date"
            />
          </div>
          <div>
            <label className="mb-1 block text-[11px] uppercase tracking-[0.12em] text-muted-foreground">
              To
            </label>
            <input
              type="date"
              value={to}
              onChange={(e) => setTo(e.target.value)}
              className="rounded-md border border-border bg-background px-3 py-1.5 text-sm focus:border-orange-400 focus:ring-1 focus:ring-orange-500"
              aria-label="To date"
            />
          </div>

          <div className="flex flex-wrap gap-2">
            <button
              onClick={load}
              className="rounded-md border border-border bg-muted/60 px-3 py-1.5 text-sm hover:bg-muted/90"
            >
              Apply
            </button>
            <button
              onClick={() => window.print()}
              className="rounded-md border border-border bg-neutral-900 px-3 py-1.5 text-sm hover:bg-neutral-800"
            >
              Print
            </button>
            <button
              onClick={exportCSV}
              className="rounded-md bg-purple-600 px-3 py-1.5 text-sm font-semibold text-white hover:bg-purple-500"
            >
              Export CSV
            </button>
          </div>
        </div>
      </div>

      {/* Error */}
      {err && (
        <div className="mb-3 rounded border border-red-500/40 bg-red-500/10 p-2 text-sm text-red-400">
          {err}
        </div>
      )}

      {/* Content */}
      {loading ? (
        <div className="rounded border border-dashed border-border bg-card/60 p-6 text-sm text-muted-foreground">
          Loading completed work orders…
        </div>
      ) : rows.length === 0 ? (
        <div className="rounded border border-dashed border-border bg-card/60 p-6 text-sm text-muted-foreground">
          No completed work orders found for this shop and date range.
        </div>
      ) : (
        <div className="divide-y divide-border rounded-xl border border-border bg-card">
          {rows.map((r) => {
            const updated = r.updated_at
              ? format(new Date(r.updated_at), "PPpp")
              : "—";
            const customer = r.customers
              ? [r.customers.first_name ?? "", r.customers.last_name ?? ""]
                  .filter(Boolean)
                  .join(" ")
              : "—";
            const vehicle = r.vehicles
              ? `${r.vehicles.year ?? ""} ${r.vehicles.make ?? ""} ${
                  r.vehicles.model ?? ""
                }`.trim()
              : "—";
            const plate = r.vehicles?.license_plate
              ? `(${r.vehicles.license_plate})`
              : "";
            const vin = r.vehicles?.vin ? `VIN: ${r.vehicles.vin}` : "";

            return (
              <div
                key={r.id}
                className="flex flex-col gap-2 p-3 sm:flex-row sm:items-center"
              >
                <div className="min-w-0 flex-1">
                  <div className="flex flex-wrap items-center gap-2">
                    <Link
                      href={`/work-orders/${r.id}`}
                      className="font-medium text-orange-400 underline decoration-transparent underline-offset-2 hover:decoration-orange-400"
                    >
                      {r.custom_id ? r.custom_id : `#${r.id.slice(0, 8)}`}
                    </Link>
                    {r.custom_id && (
                      <span className="text-[10px] rounded border border-border px-1 py-0.5 font-mono text-muted-foreground">
                        #{r.id.slice(0, 6)}
                      </span>
                    )}
                    <span className="inline-flex items-center rounded-full border border-emerald-400/40 bg-emerald-500/10 px-2 py-0.5 text-[11px] font-medium uppercase tracking-wide text-emerald-300">
                      Completed
                    </span>
                    <span className="text-xs text-muted-foreground">
                      {updated}
                    </span>
                  </div>
                  <div className="truncate text-sm text-muted-foreground">
                    {customer} • {vehicle} {plate} {vin && `• ${vin}`}
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  {r.invoice_url ? (
                    <a
                      href={r.invoice_url}
                      target="_blank"
                      rel="noreferrer"
                      className="rounded-md border border-border px-2 py-1 text-xs hover:bg-muted"
                    >
                      Open invoice
                    </a>
                  ) : r.quote_url ? (
                    <a
                      href={r.quote_url}
                      target="_blank"
                      rel="noreferrer"
                      className="rounded-md border border-border px-2 py-1 text-xs hover:bg-muted"
                    >
                      Open quote
                    </a>
                  ) : (
                    <span className="text-[11px] text-muted-foreground">
                      No invoice
                    </span>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: app/work-orders/page.tsx */
/* =============================== */

// app/work-orders/page.tsx
export const dynamic = "force-dynamic";
export const revalidate = 0;

import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import type { Role } from "@shared/components/RoleHubTiles/tiles";
import { TILES } from "@shared/components/RoleHubTiles/tiles";
import Link from "next/link";
import PageShell from "@/features/shared/components/PageShell";

type DB = Database;

async function getUserRole(): Promise<Role | null> {
  const supabase = createServerComponentClient<DB>({ cookies });
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return null;

  const { data: profile } = await supabase
    .from("profiles")
    .select("role")
    .eq("id", user.id)
    .maybeSingle();

  return (profile?.role as Role | null) ?? null;
}

export default async function WorkOrdersHome() {
  const role = await getUserRole();

  // only show tiles that are work_orders scope and role-allowed
  const workOrderTiles = TILES.filter((tile) => {
    const forWorkOrders = tile.scopes.includes("work_orders") || tile.scopes.includes("all");
    const roleAllowed = role ? tile.roles.includes(role) : false;
    return forWorkOrders && roleAllowed;
  });

  return (
    <PageShell
      title="Work Orders"
      description="Create, view, and manage jobs, quotes, and invoices."
    >
      {workOrderTiles.length === 0 ? (
        <div className="rounded border border-neutral-800 bg-neutral-950/60 p-4 text-sm text-neutral-300">
          No work-order actions available for your role.
        </div>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {workOrderTiles.map((tile) => (
            <Link
              key={tile.href}
              href={tile.href}
              className="group rounded-lg border border-neutral-800 bg-neutral-950/60 px-4 py-4 transition hover:border-orange-400 hover:bg-neutral-900"
            >
              <div className="flex items-center justify-between gap-2">
                <h2 className="text-base font-semibold text-neutral-100">{tile.title}</h2>
                <span className="text-xs text-neutral-500 group-hover:text-orange-300">
                  {tile.cta ?? "→"}
                </span>
              </div>
              {tile.subtitle ? (
                <p className="mt-1 text-sm text-neutral-400">{tile.subtitle}</p>
              ) : null}
            </Link>
          ))}
        </div>
      )}
    </PageShell>
  );
}

/* =============================== */
/* FILE: app/work-orders/quote-review/page.tsx */
/* =============================== */

export const dynamic = "force-dynamic";
export const revalidate = 0;

export { default } from "@/features/work-orders/app/work-orders/quote-review/page";


/* =============================== */
/* FILE: app/compare-plans/page.tsx */
/* =============================== */

"use client";

import Link from "next/link";
import React from "react";
import { FaCheck, FaTimes } from "react-icons/fa";

export default function ComparePlansPage() {
  const features = [
    "AI Diagnosis (limited or full)",
    "Inspection System",
    "Work Orders",
    "Voice-Controlled Inspections",
    "Photo-to-Quote",
    "PDF Export",
    "Custom Inspection Creation",
    "Shop Setup & Team Roles",
    "User Limit",
    "Priority Support",
  ];

  const plans = [
    {
      name: "Free",
      price: "$0",
      description: "Get started with limited AI features",
      values: [
        "5 uses/month",
        <FaTimes key="free-1" className="text-red-500 mx-auto" />,
        <FaTimes key="free-2" className="text-red-500 mx-auto" />,
        <FaTimes key="free-3" className="text-red-500 mx-auto" />,
        <FaTimes key="free-4" className="text-red-500 mx-auto" />,
        <FaTimes key="free-5" className="text-red-500 mx-auto" />,
        <FaTimes key="free-6" className="text-red-500 mx-auto" />,
        <FaTimes key="free-7" className="text-red-500 mx-auto" />,
        "1 user",
        <FaTimes key="free-8" className="text-red-500 mx-auto" />,
      ],
    },
    {
      name: "DIY",
      price: "$9",
      description: "Basic access for home users",
      values: [
        "Basic AI diagnosis",
        <FaCheck key="diy-1" className="text-green-400 mx-auto" />,
        <FaTimes key="diy-2" className="text-red-500 mx-auto" />,
        <FaTimes key="diy-3" className="text-red-500 mx-auto" />,
        <FaTimes key="diy-4" className="text-red-500 mx-auto" />,
        <FaCheck key="diy-5" className="text-green-400 mx-auto" />,
        <FaTimes key="diy-6" className="text-red-500 mx-auto" />,
        <FaTimes key="diy-7" className="text-red-500 mx-auto" />,
        "1 user",
        <FaTimes key="diy-8" className="text-red-500 mx-auto" />,
      ],
    },
    {
      name: "Pro",
      price: "$49",
      description: "Solo pros with full inspections and work orders",
      values: [
        "Unlimited AI",
        <FaCheck key="pro-1" className="text-green-400 mx-auto" />,
        <FaCheck key="pro-2" className="text-green-400 mx-auto" />,
        <FaCheck key="pro-3" className="text-green-400 mx-auto" />,
        <FaCheck key="pro-4" className="text-green-400 mx-auto" />,
        <FaCheck key="pro-5" className="text-green-400 mx-auto" />,
        "Limited",
        <FaTimes key="pro-6" className="text-red-500 mx-auto" />,
        "1 user",
        "Standard",
      ],
    },
    {
      name: "Pro+",
      price: "$99",
      description: "Shops & teams with full automation",
      values: [
        "Unlimited AI",
        <FaCheck key="proplus-1" className="text-green-400 mx-auto" />,
        <FaCheck key="proplus-2" className="text-green-400 mx-auto" />,
        <FaCheck key="proplus-3" className="text-green-400 mx-auto" />,
        <FaCheck key="proplus-4" className="text-green-400 mx-auto" />,
        <FaCheck key="proplus-5" className="text-green-400 mx-auto" />,
        "Unlimited",
        "✔ Admin, Manager, Mechanic",
        "5 users (expandable)",
        "Priority",
      ],
    },
  ];

  return (
    <div className="min-h-screen bg-black text-white px-4 py-12">
      <div className="max-w-7xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <h1 className="text-4xl font-blackops text-orange-500">
            Compare Plans
          </h1>
          <Link
            href="/"
            className="px-4 py-2 bg-orange-500 hover:bg-orange-600 rounded text-black font-blackops"
          >
            Home
          </Link>
        </div>

        <div className="overflow-x-auto">
          <table className="w-full border border-orange-500 text-sm text-left">
            <thead className="bg-neutral-800 text-orange-400">
              <tr>
                <th className="px-4 py-3 border border-orange-500">Features</th>
                {plans.map((plan) => (
                  <th
                    key={plan.name}
                    className="px-4 py-3 border border-orange-500 text-center"
                  >
                    <div className="text-lg font-blackops text-white">
                      {plan.name}
                    </div>
                    <div className="text-orange-400">{plan.price}/mo</div>
                    <div className="text-gray-400 text-xs mt-1">
                      {plan.description}
                    </div>
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {features.map((feature, i) => (
                <tr
                  key={feature}
                  className={i % 2 === 0 ? "bg-neutral-900" : "bg-neutral-950"}
                >
                  <td className="px-4 py-3 border border-orange-500 font-medium">
                    {feature}
                  </td>
                  {plans.map((plan) => (
                    <td
                      key={plan.name + "-" + i}
                      className="px-4 py-3 border border-orange-500 text-center"
                    >
                      {plan.values[i]}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        <div className="mt-12 text-center">
          <Link
            href="/subscribe"
            className="inline-block px-6 py-3 bg-orange-500 hover:bg-orange-600 text-white font-blackops rounded-lg text-lg"
          >
            Choose Your Plan
          </Link>
        </div>
      </div>
    </div>
  );
}


/* =============================== */
/* FILE: features/dashboard/app/dashboard/owner/settings/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";

import type { Database } from "@shared/types/types/supabase";
import { Input } from "@shared/components/ui/input";
import { Button } from "@shared/components/ui/Button";
import OwnerPinModal from "@shared/components/OwnerPinModal";
import OwnerPinBadge from "@shared/components/OwnerPinBadge";
import ShopPublicProfileSection from "@/features/shops/components/ShopPublicProfileSection";
import ReviewsList from "@shared/components/reviews/ReviewsList";

type HourRow = {
  weekday: number;
  open_time: string;
  close_time: string;
  closed?: boolean;
};
type TimeOffRow = {
  id: string;
  starts_at: string;
  ends_at: string;
  reason: string | null;
};

const WEEKDAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

export default function OwnerSettingsPage() {
  const supabase = useMemo(
    () => createClientComponentClient<Database>(),
    [],
  );

  const [loading, setLoading] = useState(true);
  const [shopId, setShopId] = useState<string | null>(null);

  // PIN modal + timer
  const [pinModalOpen, setPinModalOpen] = useState(false);
  const [pinExpiresAt, setPinExpiresAt] = useState<string | undefined>();
  const [now, setNow] = useState<number>(() => Date.now());

  // Shop fields
  const [shopName, setShopName] = useState("");
  const [address, setAddress] = useState("");
  const [city, setCity] = useState("");
  const [province, setProvince] = useState("");
  const [postalCode, setPostalCode] = useState("");
  const [phone, setPhone] = useState("");
  const [email, setEmail] = useState("");
  const [logoUrl, setLogoUrl] = useState("");

  // Money / defaults
  const [laborRate, setLaborRate] = useState("");
  const [suppliesPercent, setSuppliesPercent] = useState("");
  const [diagnosticFee, setDiagnosticFee] = useState("");
  const [taxRate, setTaxRate] = useState("");

  // Workflow flags
  const [useAi, setUseAi] = useState(false);
  const [requireCauseCorrection, setRequireCauseCorrection] = useState(false);
  const [requireAuthorization, setRequireAuthorization] = useState(false);

  // Communication
  const [invoiceTerms, setInvoiceTerms] = useState("");
  const [invoiceFooter, setInvoiceFooter] = useState("");
  const [emailOnComplete, setEmailOnComplete] = useState(false);

  // Automation
  const [autoGeneratePdf, setAutoGeneratePdf] = useState(false);
  const [autoSendQuoteEmail, setAutoSendQuoteEmail] = useState(false);

  // Hours + time off
  const [hours, setHours] = useState<HourRow[]>(
    Array.from({ length: 7 }, (_, i) => ({
      weekday: i,
      open_time: "08:00",
      close_time: "17:00",
      closed: i === 0 || i === 6, // default: closed on weekend
    })),
  );
  const [timeOff, setTimeOff] = useState<TimeOffRow[]>([]);
  const [newOffStart, setNewOffStart] = useState("");
  const [newOffEnd, setNewOffEnd] = useState("");
  const [newOffReason, setNewOffReason] = useState("");

  // heartbeat to re-evaluate unlock
  useEffect(() => {
    const id = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(id);
  }, []);

  const isUnlocked = useMemo(() => {
    if (!pinExpiresAt) return false;
    return new Date(pinExpiresAt).getTime() > now;
  }, [pinExpiresAt, now]);

  // initial load
  useEffect(() => {
    const fetchSettings = async () => {
      const {
        data: { user },
      } = await supabase.auth.getUser();

      if (!user) {
        setLoading(false);
        return;
      }

      const { data: profile, error: profErr } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("id", user.id)
        .maybeSingle();

      if (profErr) {
        toast.error(profErr.message);
        setLoading(false);
        return;
      }

      if (!profile?.shop_id) {
        setLoading(false);
        return;
      }

      const sid = profile.shop_id;
      setShopId(sid);

      // core shop row
      const { data: shop, error } = await supabase
        .from("shops")
        .select("*")
        .eq("id", sid)
        .maybeSingle();

      if (error) toast.error(error.message);

      if (shop) {
        setShopName(shop.name || "");
        setAddress(shop.address || "");
        setCity(shop.city || "");
        setProvince(shop.province || "");
        setPostalCode(shop.postal_code || "");
        setPhone(shop.phone_number || "");
        setEmail(shop.email || "");
        setLogoUrl(shop.logo_url || "");

        setLaborRate(shop.labor_rate?.toString() || "");
        setSuppliesPercent(shop.supplies_percent?.toString() || "");
        setDiagnosticFee(shop.diagnostic_fee?.toString() || "");
        setTaxRate(shop.tax_rate?.toString() || "");

        setUseAi(!!shop.use_ai);
        setRequireCauseCorrection(!!shop.require_cause_correction);
        setRequireAuthorization(!!shop.require_authorization);

        setInvoiceTerms(shop.invoice_terms || "");
        setInvoiceFooter(shop.invoice_footer || "");
        setEmailOnComplete(!!shop.email_on_complete);

        setAutoGeneratePdf(!!shop.auto_generate_pdf);
        setAutoSendQuoteEmail(!!shop.auto_send_quote_email);
      }

      // hours (from shop_hours)
      try {
        const res = await fetch(`/api/settings/hours?shopId=${sid}`, {
          cache: "no-store",
        });
        if (res.ok) {
          const j = await res.json();
          if (Array.isArray(j?.hours)) {
            const byDay = new Map<number, HourRow>();
            (j.hours as HourRow[]).forEach((h) =>
              byDay.set(h.weekday, { ...h, closed: false }),
            );
            const normalized = Array.from({ length: 7 }, (_, i) => {
              const existing = byDay.get(i);
              if (existing) return existing;
              // no row in DB ⇒ treat as closed by default
              return {
                weekday: i,
                open_time: "08:00",
                close_time: "17:00",
                closed: true,
              };
            });
            setHours(normalized);
          }
        }
      } catch {
        // ignore
      }

      // time off
      try {
        const res = await fetch(`/api/settings/time-off?shopId=${sid}`, {
          cache: "no-store",
        });
        if (res.ok) {
          const j = await res.json();
          if (Array.isArray(j?.items)) setTimeOff(j.items);
        }
      } catch {
        // ignore
      }

      setLoading(false);
    };

    void fetchSettings();
  }, [supabase]);

  const guardUnlock = () => {
    if (!isUnlocked) {
      toast.warning("Unlock with Owner PIN first.");
      setPinModalOpen(true);
      return false;
    }
    return true;
  };

  // save core shop
  const handleSave = async () => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    const payload = {
      shopId,
      update: {
        name: shopName,
        address,
        city,
        province,
        postal_code: postalCode,
        phone_number: phone,
        email,
        logo_url: logoUrl,
        labor_rate: laborRate ? parseFloat(laborRate) : null,
        supplies_percent: suppliesPercent ? parseFloat(suppliesPercent) : null,
        diagnostic_fee: diagnosticFee ? parseFloat(diagnosticFee) : null,
        tax_rate: taxRate ? parseFloat(taxRate) : null,
        use_ai: useAi,
        require_cause_correction: requireCauseCorrection,
        require_authorization: requireAuthorization,
        invoice_terms: invoiceTerms,
        invoice_footer: invoiceFooter,
        email_on_complete: emailOnComplete,
        auto_generate_pdf: autoGeneratePdf,
        auto_send_quote_email: autoSendQuoteEmail,
      },
    };

    const res = await fetch("/api/settings/update", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!res.ok) {
      const j = await res.json().catch(() => ({}));
      toast.error(j?.error || "Failed to save settings");
      return;
    }

    toast.success("Settings saved.");
  };

  const handleLogoUpload = async (
    e: React.ChangeEvent<HTMLInputElement>,
  ) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const filePath = `logos/${crypto.randomUUID()}-${file.name}`;
    const { error } = await supabase.storage
      .from("logos")
      .upload(filePath, file, { upsert: true });

    if (error) {
      toast.error(error.message);
      return;
    }

    const { data } = supabase.storage.from("logos").getPublicUrl(filePath);
    setLogoUrl(data.publicUrl);
    toast.success("Logo uploaded.");
  };

  const handleGenerateLogo = () => {
    toast.info("AI Logo generation coming soon…");
  };

  // save hours → /api/settings/hours → shop_hours
  const saveHours = async () => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    // only send OPEN days to the API; closed days are omitted
    const openDays = hours.filter((h) => !h.closed);

    const res = await fetch("/api/settings/hours", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ shopId, hours: openDays }),
    });

    if (!res.ok) {
      const j = await res.json().catch(() => ({}));
      toast.error(j?.error || "Failed to save hours");
      return;
    }
    toast.success("Hours updated.");
  };

  // add time off
  const addTimeOff = async () => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    if (!newOffStart || !newOffEnd) {
      toast.warning("Select start and end time.");
      return;
    }

    const res = await fetch("/api/settings/time-off", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        shopId,
        range: {
          starts_at: newOffStart,
          ends_at: newOffEnd,
          reason: newOffReason || null,
        },
      }),
    });

    const j = await res.json().catch(() => ({}));
    if (!res.ok) {
      toast.error(j?.error || "Failed to add time off");
      return;
    }

    setNewOffStart("");
    setNewOffEnd("");
    setNewOffReason("");

    try {
      const r = await fetch(`/api/settings/time-off?shopId=${shopId}`, {
        cache: "no-store",
      });
      if (r.ok) {
        const jj = await r.json();
        setTimeOff(jj.items || []);
      }
    } catch {
      // ignore
    }

    toast.success("Time off added.");
  };

  const deleteTimeOff = async (id: string) => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    const res = await fetch("/api/settings/time-off", {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ shopId, id }),
    });

    const j = await res.json().catch(() => ({}));
    if (!res.ok) {
      toast.error(j?.error || "Failed to remove time off");
      return;
    }

    setTimeOff((prev) => prev.filter((t) => t.id !== id));
    toast.success("Removed.");
  };

  if (loading) {
    return (
      <div className="p-6 text-muted-foreground">
        Loading shop settings…
      </div>
    );
  }

  return (
    <div className="mx-auto flex max-w-6xl flex-col gap-6 p-6 text-foreground">
      {/* top header */}
      <div className="flex flex-wrap items-center justify-between gap-3 rounded-xl border border-border bg-card px-4 py-3">
        <div>
          <h1 className="text-2xl font-blackops text-orange-400">
            Shop Settings
          </h1>
          <p className="text-xs text-neutral-400">
            Manage your shop profile, billing defaults, and scheduling.
          </p>
        </div>
        <div className="flex items-center gap-2">
          <OwnerPinBadge expiresAt={pinExpiresAt} />
          <Button size="sm" onClick={() => setPinModalOpen(true)}>
            {isUnlocked ? "Re-unlock" : "Unlock"}
          </Button>
          <Button size="sm" onClick={handleSave} disabled={!isUnlocked}>
            {isUnlocked ? "Save all" : "Unlock to save"}
          </Button>
        </div>
      </div>

      {/* main layout */}
      <div className="flex flex-col gap-6 lg:flex-row">
        {/* LEFT COLUMN */}
        <div className="flex-1 space-y-6">
          {/* Shop info */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Shop info
            </h2>
            <div className="space-y-2 text-sm">
              <Input
                value={shopName}
                onChange={(e) => setShopName(e.target.value)}
                placeholder="Shop name"
                disabled={!isUnlocked}
              />
              <Input
                value={address}
                onChange={(e) => setAddress(e.target.value)}
                placeholder="Street address"
                disabled={!isUnlocked}
              />
              <div className="grid gap-2 md:grid-cols-3">
                <Input
                  value={city}
                  onChange={(e) => setCity(e.target.value)}
                  placeholder="City"
                  disabled={!isUnlocked}
                />
                <Input
                  value={province}
                  onChange={(e) => setProvince(e.target.value)}
                  placeholder="Province / State"
                  disabled={!isUnlocked}
                />
                <Input
                  value={postalCode}
                  onChange={(e) => setPostalCode(e.target.value)}
                  placeholder="Postal code"
                  disabled={!isUnlocked}
                />
              </div>
              <div className="grid gap-2 md:grid-cols-2">
                <Input
                  value={phone}
                  onChange={(e) => setPhone(e.target.value)}
                  placeholder="Phone number"
                  disabled={!isUnlocked}
                />
                <Input
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="Email"
                  disabled={!isUnlocked}
                />
              </div>
              <div className="grid gap-2 md:grid-cols-2">
                <Input
                  value={logoUrl}
                  onChange={(e) => setLogoUrl(e.target.value)}
                  placeholder="Logo URL"
                  disabled={!isUnlocked}
                />
                <Input
                  type="file"
                  accept="image/*"
                  onChange={handleLogoUpload}
                  disabled={!isUnlocked}
                />
              </div>
              <Button
                onClick={handleGenerateLogo}
                variant="secondary"
                className="mt-1"
                disabled={!isUnlocked}
              >
                Generate logo with AI
              </Button>
              {logoUrl && (
                <img
                  src={logoUrl}
                  alt="Logo"
                  className="mt-2 h-20 w-32 rounded bg-white p-1 object-contain"
                />
              )}
            </div>
          </section>

          {/* Billing + workflow */}
          <div className="grid gap-6 md:grid-cols-2">
            <section className="space-y-3 rounded-xl border border-border bg-card p-4">
              <h2 className="text-sm font-semibold text-neutral-50">
                Billing defaults
              </h2>
              <div className="grid gap-2 md:grid-cols-2 text-sm">
                <Input
                  value={laborRate}
                  onChange={(e) => setLaborRate(e.target.value)}
                  placeholder="Labor rate ($/hr)"
                  disabled={!isUnlocked}
                />
                <Input
                  value={suppliesPercent}
                  onChange={(e) => setSuppliesPercent(e.target.value)}
                  placeholder="Shop supplies (%)"
                  disabled={!isUnlocked}
                />
                <Input
                  value={diagnosticFee}
                  onChange={(e) => setDiagnosticFee(e.target.value)}
                  placeholder="Diagnostic fee ($)"
                  disabled={!isUnlocked}
                />
                <Input
                  value={taxRate}
                  onChange={(e) => setTaxRate(e.target.value)}
                  placeholder="Tax rate (%)"
                  disabled={!isUnlocked}
                />
              </div>
            </section>

            <section className="space-y-3 rounded-xl border border-border bg-card p-4">
              <h2 className="text-sm font-semibold text-neutral-50">
                Workflow
              </h2>
              <label className="flex items-center gap-2 text-sm text-neutral-200">
                <input
                  type="checkbox"
                  checked={useAi}
                  onChange={(e) => setUseAi(e.target.checked)}
                  disabled={!isUnlocked}
                />
                Use AI features
              </label>
              <label className="flex items-center gap-2 text-sm text-neutral-200">
                <input
                  type="checkbox"
                  checked={requireCauseCorrection}
                  onChange={(e) =>
                    setRequireCauseCorrection(e.target.checked)
                  }
                  disabled={!isUnlocked}
                />
                Require cause / correction on lines
              </label>
              <label className="flex items-center gap-2 text-sm text-neutral-200">
                <input
                  type="checkbox"
                  checked={requireAuthorization}
                  onChange={(e) =>
                    setRequireAuthorization(e.target.checked)
                  }
                  disabled={!isUnlocked}
                />
                Require customer authorization
              </label>
            </section>
          </div>

          {/* Communication */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Communication & branding
            </h2>
            <Input
              value={invoiceTerms}
              onChange={(e) => setInvoiceTerms(e.target.value)}
              placeholder="Invoice terms"
              disabled={!isUnlocked}
            />
            <Input
              value={invoiceFooter}
              onChange={(e) => setInvoiceFooter(e.target.value)}
              placeholder="Invoice footer note"
              disabled={!isUnlocked}
            />
            <label className="flex items-center gap-2 text-sm text-neutral-200">
              <input
                type="checkbox"
                checked={emailOnComplete}
                onChange={(e) => setEmailOnComplete(e.target.checked)}
                disabled={!isUnlocked}
              />
              Email customer when job is complete
            </label>
          </section>

          {/* Automation */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Automation
            </h2>
            <label className="flex items-center gap-2 text-sm text-neutral-200">
              <input
                type="checkbox"
                checked={autoGeneratePdf}
                onChange={(e) => setAutoGeneratePdf(e.target.checked)}
                disabled={!isUnlocked}
              />
              Auto-generate quote PDF
            </label>
            <label className="flex items-center gap-2 text-sm text-neutral-200">
              <input
                type="checkbox"
                checked={autoSendQuoteEmail}
                onChange={(e) => setAutoSendQuoteEmail(e.target.checked)}
                disabled={!isUnlocked}
              />
              Auto-send quote email
            </label>
          </section>

          {/* Hours */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <div className="flex items-center justify-between gap-3">
              <h2 className="text-sm font-semibold text-neutral-50">
                Hours (controls public booking slots)
              </h2>
              <Button onClick={saveHours} disabled={!isUnlocked} size="sm">
                Save hours
              </Button>
            </div>

            <div className="grid gap-2 md:grid-cols-7">
              {hours.map((row, idx) => {
                const closed = !!row.closed;
                return (
                  <div
                    key={row.weekday}
                    className="rounded border border-neutral-800 bg-neutral-900 p-2 text-xs"
                  >
                    <div className="mb-1 flex items-center justify-between text-[11px] font-semibold text-orange-300">
                      <span>{WEEKDAYS[row.weekday]}</span>
                      <label className="flex items-center gap-1 text-[10px] text-neutral-300">
                        <input
                          type="checkbox"
                          checked={closed}
                          onChange={(e) => {
                            const isClosed = e.target.checked;
                            setHours((prev) => {
                              const copy = [...prev];
                              copy[idx] = { ...copy[idx], closed: isClosed };
                              return copy;
                            });
                          }}
                          disabled={!isUnlocked}
                        />
                        Closed
                      </label>
                    </div>
                    <label className="mb-1 block text-[10px] text-neutral-400">
                      Open
                    </label>
                    <input
                      type="time"
                      className="mb-2 w-full rounded bg-neutral-950 px-2 py-1 text-xs disabled:opacity-40"
                      value={row.open_time}
                      onChange={(e) => {
                        const v = e.target.value;
                        setHours((prev) => {
                          const copy = [...prev];
                          copy[idx] = { ...copy[idx], open_time: v };
                          return copy;
                        });
                      }}
                      disabled={!isUnlocked || closed}
                    />
                    <label className="mb-1 block text-[10px] text-neutral-400">
                      Close
                    </label>
                    <input
                      type="time"
                      className="w-full rounded bg-neutral-950 px-2 py-1 text-xs disabled:opacity-40"
                      value={row.close_time}
                      onChange={(e) => {
                        const v = e.target.value;
                        setHours((prev) => {
                          const copy = [...prev];
                          copy[idx] = { ...copy[idx], close_time: v };
                          return copy;
                        });
                      }}
                      disabled={!isUnlocked || closed}
                    />
                  </div>
                );
              })}
            </div>
          </section>

          {/* Time off */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Time off / blackouts
            </h2>

            <div className="grid gap-2 md:grid-cols-4">
              <input
                type="datetime-local"
                className="rounded bg-neutral-900 px-3 py-2 text-sm"
                value={newOffStart}
                onChange={(e) => setNewOffStart(e.target.value)}
                disabled={!isUnlocked}
              />
              <input
                type="datetime-local"
                className="rounded bg-neutral-900 px-3 py-2 text-sm"
                value={newOffEnd}
                onChange={(e) => setNewOffEnd(e.target.value)}
                disabled={!isUnlocked}
              />
              <Input
                placeholder="Reason (optional)"
                value={newOffReason}
                onChange={(e) => setNewOffReason(e.target.value)}
                disabled={!isUnlocked}
              />
              <Button onClick={addTimeOff} disabled={!isUnlocked}>
                Add
              </Button>
            </div>

            {timeOff.length === 0 ? (
              <p className="text-xs text-neutral-500">
                No time-off entries.
              </p>
            ) : (
              <ul className="space-y-2">
                {timeOff.map((t) => {
                  const start = new Date(t.starts_at);
                  const end = new Date(t.ends_at);
                  return (
                    <li
                      key={t.id}
                      className="flex items-center justify-between rounded border border-neutral-800 bg-neutral-900 px-3 py-2 text-sm"
                    >
                      <div>
                        <div className="text-neutral-100">
                          {start.toLocaleString()} → {end.toLocaleString()}
                        </div>
                        {t.reason && (
                          <div className="text-xs text-neutral-400">
                            Reason: {t.reason}
                          </div>
                        )}
                      </div>
                      <Button
                        variant="secondary"
                        size="sm"
                        onClick={() => void deleteTimeOff(t.id)}
                        disabled={!isUnlocked}
                      >
                        Remove
                      </Button>
                    </li>
                  );
                })}
              </ul>
            )}
          </section>
        </div>

        {/* RIGHT COLUMN */}
        <div className="w-full space-y-6 lg:w-80">
          {shopId && (
            <ShopPublicProfileSection
              shopId={shopId}
              isUnlocked={isUnlocked}
            />
          )}

          {/* Invoice preview */}
          <section className="space-y-2 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Invoice preview
            </h2>
            <div className="space-y-2 rounded bg-white p-3 text-xs text-black shadow">
              {logoUrl && (
                <img
                  src={logoUrl}
                  alt="Logo"
                  className="h-12 object-contain"
                />
              )}
              <div className="font-semibold">
                {shopName || "Your shop name"}
              </div>
              <div>
                {address}
                {address && ","} {city} {province} {postalCode}
              </div>
              <div>
                {phone} {phone && email && "•"} {email}
              </div>
              <hr className="my-2" />
              <div className="font-semibold text-black">Invoice terms</div>
              <p>{invoiceTerms || "—"}</p>
              <div className="font-semibold text-black">Footer</div>
              <p>{invoiceFooter || "—"}</p>
            </div>
          </section>

          {shopId && (
            <section className="space-y-3 rounded-xl border border-border bg-card p-4">
              <h2 className="text-sm font-semibold text-neutral-50">
                Customer reviews
              </h2>
              <p className="text-[11px] text-neutral-400">
                Recent reviews for your shop. Owners/admins/managers can reply
                directly.
              </p>
              <ReviewsList shopId={shopId} />
            </section>
          )}
        </div>
      </div>

      <OwnerPinModal
        shopId={shopId}
        open={pinModalOpen}
        onClose={() => setPinModalOpen(false)}
        onVerified={(iso: string | undefined) => setPinExpiresAt(iso)}
      />
    </div>
  );
}

/* =============================== */
/* FILE: features/dashboard/app/dashboard/advisor/page.tsx */
/* =============================== */

"use client"

import Link from "next/link";

type TileProps = { href: string; title: string; subtitle?: string; cta?: string };

function Tile({ href, title, subtitle, cta }: TileProps) {
  return (
    <Link
      href={href}
      className="block rounded-lg border border-white/10 bg-neutral-900 p-4 transition hover:-translate-y-0.5 hover:border-orange-500 hover:shadow-lg hover:shadow-orange-500/10"
      aria-label={title}
    >
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-white">{title}</h2>
        {cta ? <span className="rounded bg-orange-500 px-3 py-1 text-sm font-semibold text-black">{cta}</span> : null}
      </div>
      {subtitle ? <p className="mt-1 text-sm text-white/70">{subtitle}</p> : null}
    </Link>
  );
}

export default function AdvisorDashboardPage() {
  return (
    <div className="mx-auto max-w-5xl px-4 py-8 text-white">
      <h1 className="mb-6 text-3xl font-bold text-orange-400">Advisor Dashboard</h1>

      {/* Work Orders */}
      <h2 className="mb-3 text-xl font-semibold">Work Orders</h2>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
        <Tile href="/work-orders/create" title="Create Work Order" subtitle="Start a new job for a vehicle" cta="+" />
        <Tile href="/work-orders/customer" title="Customer Work Order Request" subtitle="Capture a customer request" />
        <Tile href="/work-orders/queue" title="Job Queue" subtitle="Active, paused, and in-progress jobs" />
        <Tile href="/work-orders/quote-review" title="Quote Review" subtitle="Review and send estimates" />
        <Tile href="/work-orders" title="View Work Orders" subtitle="Find & open specific work orders" />
        <Tile href="/work-orders" title="Open Work Order by ID" subtitle="Use list to select a specific ID" />
      </div>

      {/* Inspections */}
      <h2 className="mt-8 mb-3 text-xl font-semibold">Inspections</h2>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
        <Tile href="/inspections/templates" title="Templates" subtitle="Browse inspection templates" />
        <Tile href="/inspections/custom-inspection" title="Custom Inspection" subtitle="Build a custom checklist" />
        <Tile href="/inspections/created" title="Recently Created" subtitle="Newly started inspections" />
        <Tile href="/inspections/saved" title="Saved" subtitle="Draft inspections in progress" />
        <Tile href="/inspections/summary" title="Summaries" subtitle="Review inspection summaries" />
        <Tile href="/inspections/customer-vehicle" title="Customer & Vehicle" subtitle="Start from basic info" />
        <Tile href="/inspections" title="Open Inspection by ID" subtitle="Use list to select a specific ID" />
      </div>

      {/* Booking */}
      <h2 className="mt-8 mb-3 text-xl font-semibold">Booking</h2>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
        <Tile href="/dashboard/advisor/bookings" title="Bookings" subtitle="View & manage appointments" />
      </div>
    </div>
  );
}



/* =============================== */
/* FILE: features/ai/api/chatbot/route.ts */
/* =============================== */

// app/api/chatbot/route.ts
import { NextResponse } from "next/server";
import { openai } from "lib/server/openai";

type Variant = "marketing" | "full";
type ChatMessage = { role: "system" | "user" | "assistant"; content: string };

function guardrailSystem(variant: Variant): string {
  if (variant === "marketing") {
    return `You are TechBot for ProFixIQ on the public landing page.
Answer ONLY questions about ProFixIQ: features, pricing, plans, roles, onboarding, and how the app works.
Refuse anything about private data, diagnostics for a specific car, or taking actions inside the product.
Keep answers brief and helpful.`;
  }
  return `You are TechBot for ProFixIQ inside the app.
Help with diagnostics, inspections, work orders, quotes, parts, and app navigation.
When relevant, suggest the next action within the app. Keep answers clear and mechanic-friendly.`;
}

export async function POST(req: Request) {
  try {
    const body = (await req.json()) as { messages?: ChatMessage[]; variant?: Variant };

    // ✅ Only allow the marketing bot to use this endpoint
    const variant: Variant = body?.variant === "marketing" ? "marketing" : "full";
    if (variant !== "marketing") {
      return NextResponse.json({ error: "This assistant is only available on the landing page." }, { status: 403 });
    }

    const messages = Array.isArray(body?.messages) ? body.messages : [];
    const safeMsgs: ChatMessage[] = [
      { role: "system", content: guardrailSystem("marketing") },
      ...messages.filter(m => m && typeof m.content === "string").map(m => ({ role: m.role, content: m.content })),
    ];

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: safeMsgs,
      temperature: 0.4,
      max_tokens: 600,
    });

    const reply = completion.choices?.[0]?.message?.content?.trim() || "Sorry, I couldn't generate a response.";
    return NextResponse.json({ reply });
  } catch {
    return NextResponse.json({ error: "The assistant is not available right now." }, { status: 500 });
  }
}

export const runtime = "nodejs";

/* =============================== */
/* FILE: features/ai/components/Chatbot.tsx */
/* =============================== */

"use client";

import { useEffect, useRef, useState } from "react";
import { FaPaperPlane, FaRobot } from "react-icons/fa";
import Image from "next/image";
import Link from "next/link";

type Variant = "marketing" | "full";

function systemPromptFor(variant: Variant) {
  if (variant === "marketing") {
    return `You are TechBot for ProFixIQ on the public landing page.
Answer ONLY questions about ProFixIQ: features, pricing, plans, roles, onboarding, and how the app works.
Do NOT discuss private user data, shop workflows, or take actions. Keep answers brief and helpful.`;
  }
  return `You are TechBot for ProFixIQ inside the app.
Help with diagnostics, inspections, work orders, quotes, parts, and app navigation.
When relevant, suggest next actions in the product. Keep answers clear and mechanic-friendly.`;
}

export default function Chatbot({ variant = "full" }: { variant?: Variant }) {
  const [open, setOpen] = useState(false);
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState([
    { role: "system", content: systemPromptFor(variant) },
  ]);
  const [loading, setLoading] = useState(false);
  const bottomRef = useRef<HTMLDivElement | null>(null);

  // allow external “Ask AI” buttons to open this modal
  useEffect(() => {
    const handler = () => setOpen(true);
    window.addEventListener("open-chatbot", handler as EventListener);
    return () => window.removeEventListener("open-chatbot", handler as EventListener);
  }, []);

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  useEffect(() => {
    setMessages([{ role: "system", content: systemPromptFor(variant) }]);
  }, [variant]);

  const sendMessage = async () => {
    if (!input.trim()) return;
    const updated = [...messages, { role: "user", content: input }];
    setMessages(updated);
    setInput("");
    setLoading(true);

    try {
      const res = await fetch("/api/chatbot", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messages: updated, variant }),
      });
      const data = await res.json();
      setMessages([
        ...updated,
        { role: "assistant", content: data.reply || "Sorry, something went wrong." },
      ]);
    } catch {
      setMessages([
        ...updated,
        { role: "assistant", content: "Connection error. Please try again." },
      ]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <button
        id="chatbot-button"
        onClick={() => setOpen((o) => !o)}
        title="Ask TechBot"
        className="fixed bottom-6 right-6 bg-orange-600 hover:bg-orange-700 text-white p-3 rounded-full shadow-lg z-50"
      >
        <FaRobot size={20} />
      </button>

      {open && (
        <div className="fixed bottom-20 right-6 w-80 bg-black border border-neutral-700 text-white rounded-lg shadow-xl flex flex-col z-50">
          <div className="flex items-center gap-2 p-3 border-b border-neutral-700 bg-neutral-900 rounded-t">
            <Link href="/" title="Go to Home">
              <Image src="/logo.png" alt="ProFixIQ" width={28} height={28} priority />
            </Link>
            <span className="font-bold text-orange-400">
              {variant === "marketing" ? "TechBot (About ProFixIQ)" : "TechBot Assistant"}
            </span>
          </div>

          <div className="flex-1 overflow-y-auto p-3 space-y-2 max-h-96 text-sm">
            {messages.slice(1).map((m, i) => (
              <div
                key={i}
                className={`p-2 rounded whitespace-pre-wrap ${
                  m.role === "user"
                    ? "bg-orange-600 text-black self-end ml-auto"
                    : "bg-neutral-800 text-white self-start mr-auto"
                }`}
              >
                {m.content}
              </div>
            ))}
            <div ref={bottomRef} />
          </div>

          <form
            onSubmit={(e) => {
              e.preventDefault();
              void sendMessage();
            }}
            className="flex items-center border-t border-neutral-700 p-2 bg-neutral-900"
          >
            <input
              type="text"
              className="flex-1 bg-transparent outline-none px-2 text-white placeholder-gray-400"
              placeholder={variant === "marketing" ? "Ask about ProFixIQ…" : "Ask TechBot…"}
              value={input}
              onChange={(e) => setInput(e.target.value)}
              disabled={loading}
            />
            <button
              type="submit"
              className="text-orange-500 hover:text-orange-400 disabled:opacity-50"
              disabled={loading}
            >
              <FaPaperPlane />
            </button>
          </form>
        </div>
      )}
    </>
  );
}

/* =============================== */
/* FILE: features/admin/components/AdminQuickPanel.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

// ---- Lite shapes (kept independent from exact DB types) ----
type ActivityLog = {
  id: string;
  event?: string | null;
  actor_id?: string | null;
  created_at?: string | null;
  details?: string | null;
};

type Certification = {
  id: string;
  name?: string | null;
  user_id?: string | null;
  expires_at?: string | null;
};

type Profile = {
  id: string;
  full_name?: string | null;
  role?: string | null;
  created_at?: string | null;
};

type WorkOrder = {
  id: string;
  status?: string | null;
  created_at?: string | null;
  customer_id?: string | null;
  quote_url?: string | null;
};

type WorkOrderLine = {
  id: string;
  work_order_id?: string | null;
  status?: string | null;
  job_type?: string | null;
  assigned_to?: string | null;
  created_at?: string | null;
  hold_reason?: string | null;
  punched_in_at?: string | null;
  punched_out_at?: string | null;
};

type PartsRequest = {
  id: string;
  status?: string | null;
  created_at?: string | null;
  needed_by?: string | null;
  work_order_id?: string | null;
};

type EmailLog = {
  id: string;
  created_at?: string | null;
  recipient?: string | null;
  subject?: string | null;
  error?: string | null;
};

type Shop = {
  id: string;
  name?: string | null;
  active_user_count?: number | null;
  user_limit?: number | null;
  phone_number?: string | null;
  email?: string | null;
  address?: string | null;
  city?: string | null;
  province?: string | null;
  postal_code?: string | null;
  geo_lat?: number | null;
  geo_lng?: number | null;
  timezone?: string | null;
};

type Vehicle = {
  id: string;
  customer_id?: string | null;
  vin?: string | null;
  year?: number | null;
  make?: string | null;
  model?: string | null;
  created_at?: string | null;
};

type VehiclePhoto = {
  id: string;
  vehicle_id?: string | null;
  created_at?: string | null;
  uploaded_by?: string | null;
  reviewed?: boolean | null;
};

// ---- helpers ----
const fmtDate = (iso?: string | null) => {
  if (!iso) return "—";
  const d = new Date(iso);
  return Number.isNaN(d.getTime())
    ? "—"
    : d.toLocaleDateString(undefined, { month: "short", day: "numeric" });
};

export default function AdminQuickPanel() {
  const supabase = useMemo(() => createClientComponentClient<Database>(), []);

  // state for cards
  const [activity, setActivity] = useState<ActivityLog[] | null>(null);
  const [expiringCerts, setExpiringCerts] = useState<Certification[] | null>(null);
  const [profilesNeedingRole, setProfilesNeedingRole] = useState<Profile[] | null>(null);

  const [openHolds24h, setOpenHolds24h] = useState<WorkOrderLine[] | null>(null);
  const [unassignedJobs, setUnassignedJobs] = useState<WorkOrderLine[] | null>(null);
  const [punchAnomalies, setPunchAnomalies] = useState<WorkOrderLine[] | null>(null);

  const [pendingQuotes, setPendingQuotes] = useState<WorkOrder[] | null>(null);
  const [openPartsRequests] = useState<PartsRequest[] | null>(null);
  const [emailFailures, setEmailFailures] = useState<EmailLog[] | null>(null);

  const [shopUtil, setShopUtil] = useState<Shop | null>(null);
  const [shopMissingFields, setShopMissingFields] = useState<string[] | null>(null);

  const [vehiclesMissingVin, setVehiclesMissingVin] = useState<Vehicle[] | null>(null);
  const [unreviewedPhotos, setUnreviewedPhotos] = useState<VehiclePhoto[] | null>(null);

  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let cancelled = false;

    (async () => {
      setLoading(true);

      // Run everything we can in parallel
      const now = new Date();
      const in30 = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
      const last7 = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

      const [
        activityRes,
        certsRes,
        rolesRes,
        holdsRes,
        unassignedRes,
        punchedRes,
        woRes,
        emailsRes,
        shopRes,
        vehiclesRes,
        photosRes,
      ] = await Promise.allSettled([
        supabase
          .from("activity_logs")
          .select("id,event,actor_id,created_at,details")
          .order("created_at", { ascending: false })
          .limit(5),

        supabase
          .from("certifications")
          .select("id,name,user_id,expires_at")
          .gte("expires_at", now.toISOString())
          .lte("expires_at", in30.toISOString())
          .order("expires_at", { ascending: true })
          .limit(5),

        supabase
          .from("profiles")
          .select("id,full_name,role,created_at")
          .is("role", null)
          .order("created_at", { ascending: false })
          .limit(5),

        supabase
          .from("work_order_lines")
          .select("id,work_order_id,status,hold_reason,created_at")
          .eq("status", "on_hold")
          .gte("created_at", last7.toISOString())
          .order("created_at", { ascending: false })
          .limit(20),

        supabase
          .from("work_order_lines")
          .select("id,work_order_id,status,job_type,assigned_to,created_at")
          .in("status", ["awaiting", "in_progress"])
          .is("assigned_to", null)
          .order("created_at", { ascending: false })
          .limit(10),

        supabase
          .from("work_order_lines")
          .select("id,work_order_id,status,job_type,created_at,punched_in_at,punched_out_at")
          .not("punched_in_at", "is", null)
          .is("punched_out_at", null)
          .order("punched_in_at", { ascending: false })
          .limit(25),

        supabase
          .from("work_orders")
          .select("id,status,created_at,quote_url")
          .is("quote_url", null)
          .order("created_at", { ascending: false })
          .limit(15),

        supabase
          .from("parts_requests")
          .select("id,status,created_at,needed_by,work_order_id")
          .neq("status", "fulfilled")
          .order("created_at", { ascending: false })
          .limit(5),

        supabase
          .from("email_logs")
          .select("id,created_at,recipient,subject,error")
          .not("error", "is", null)
          .order("created_at", { ascending: false })
          .limit(10),

        supabase
          .from("shops")
          .select(
            "id,name,active_user_count,user_limit,phone_number,email,address,city,province,postal_code,geo_lat,geo_lng,timezone"
          )
          .limit(1)
          .single(),

        supabase
          .from("vehicles")
          .select("id,customer_id,vin,year,make,model,created_at")
          .is("vin", null)
          .order("created_at", { ascending: false })
          .limit(5),

        supabase
          .from("vehicle_photos")
          .select("id,vehicle_id,created_at,uploaded_by,reviewed")
          .or("reviewed.is.null,reviewed.eq.false")
          .order("created_at", { ascending: false })
          .limit(6),
      ]);

      if (cancelled) return;

      const get = <T,>(r: PromiseSettledResult<{ data: any }>) =>
        r.status === "fulfilled" ? ((r.value.data as unknown as T[]) ?? []) : [];

      // Simple lists
      setActivity(get<ActivityLog>(activityRes));
      setExpiringCerts(get<Certification>(certsRes));
      setProfilesNeedingRole(get<Profile>(rolesRes));
      setUnassignedJobs(get<WorkOrderLine>(unassignedRes));
      setEmailFailures(get<EmailLog>(emailsRes));
      setVehiclesMissingVin(get<Vehicle>(vehiclesRes));
      setUnreviewedPhotos(get<VehiclePhoto>(photosRes));

      // Holds > 24h
      const holds = get<WorkOrderLine>(holdsRes);
      const dayAgoMs = Date.now() - 24 * 60 * 60 * 1000;
      setOpenHolds24h(
        holds.filter((j) => j.created_at && new Date(j.created_at).getTime() < dayAgoMs)
      );

      // Punch anomalies > 8h
      const punched = get<WorkOrderLine>(punchedRes);
      const eightHours = 8 * 60 * 60 * 1000;
      setPunchAnomalies(
        punched.filter((j) => {
          const pi = j.punched_in_at ? new Date(j.punched_in_at).getTime() : 0;
          return pi && Date.now() - pi > eightHours;
        })
      );

      // Shop utilization + missing pieces
      if (shopRes.status === "fulfilled" && shopRes.value.data) {
        const s = (shopRes.value.data as unknown as Shop) ?? null;
        setShopUtil(s);
        if (s) {
          const missing: string[] = [];
          if (!s.phone_number) missing.push("phone");
          if (!s.email) missing.push("email");
          if (!s.address || !s.city || !s.province || !s.postal_code) missing.push("address");
          if (s.geo_lat == null || s.geo_lng == null) missing.push("map coords");
          if (!s.timezone) missing.push("timezone");
          setShopMissingFields(missing.length ? missing : null);
        } else {
          setShopMissingFields(null);
        }
      } else {
        setShopUtil(null);
        setShopMissingFields(null);
      }

      // Pending quotes = WOs with no quote_url AND at least one tech-suggested job
      const candidateWOs = get<WorkOrder>(woRes);
      const withSuggestions: WorkOrder[] = [];
      for (const w of candidateWOs) {
        // Stop once we have 5 to keep it light
        if (withSuggestions.length >= 5) break;
        const { data: lines } = await supabase
          .from("work_order_lines")
          .select("id")
          .eq("work_order_id", w.id)
          .eq("job_type", "tech-suggested")
          .limit(1);
        if ((lines as any[])?.length) withSuggestions.push(w);
      }
      setPendingQuotes(withSuggestions);

      setLoading(false);
    })();

    return () => {
      cancelled = true;
    };
  }, [supabase]);

  // ---- skeleton ----
  if (loading) {
    return (
      <div className="grid grid-cols-1 gap-4 lg:grid-cols-3">
        {Array.from({ length: 6 }).map((_, i) => (
          <div
            key={i}
            className="rounded-xl border border-neutral-800 bg-neutral-900 p-4 animate-pulse"
          >
            <div className="h-5 w-40 bg-neutral-800 rounded mb-3" />
            <div className="space-y-2">
              <div className="h-4 w-full bg-neutral-800 rounded" />
              <div className="h-4 w-5/6 bg-neutral-800 rounded" />
              <div className="h-4 w-4/6 bg-neutral-800 rounded" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  const cards: JSX.Element[] = [];

  // Recent activity
  if (activity?.length) {
    cards.push(
      <div key="activity" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Recent Activity</h3>
          <Link href="/dashboard/admin/audit" className="text-xs text-orange-400 underline">
            View all
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {activity.map((a) => (
            <li key={a.id} className="flex items-start gap-2">
              <span className="mt-0.5 h-1.5 w-1.5 rounded-full bg-orange-500" />
              <div>
                <div className="text-white">{a.event ?? "Activity"}</div>
                <div className="text-xs text-neutral-400">{fmtDate(a.created_at)}</div>
              </div>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Cert expirations
  if (expiringCerts?.length) {
    cards.push(
      <div key="certs" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">
            Certifications Expiring (30 days)
          </h3>
          <Link href="/dashboard/admin/certifications" className="text-xs text-orange-400 underline">
            Manage
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {expiringCerts.map((c) => (
            <li key={c.id} className="flex items-center justify-between gap-2">
              <div className="text-white">{c.name ?? "Certification"}</div>
              <div className="text-xs text-red-400">{fmtDate(c.expires_at)}</div>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Users needing role
  if (profilesNeedingRole?.length) {
    cards.push(
      <div key="roles" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Users Need Role Assignment</h3>
          <Link href="/dashboard/admin/roles" className="text-xs text-orange-400 underline">
            Assign
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {profilesNeedingRole.map((p) => (
            <li key={p.id} className="flex items-center justify-between gap-2">
              <div className="text-white">{p.full_name || p.id.slice(0, 8)}</div>
              <div className="text-xs text-neutral-400">{fmtDate(p.created_at)}</div>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // On-hold > 24h
  if (openHolds24h?.length) {
    cards.push(
      <div key="holds" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Jobs on Hold &gt; 24h</h3>
          <Link href="/work-orders/queue" className="text-xs text-orange-400 underline">
            Queue
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {openHolds24h.map((j) => (
            <li key={j.id} className="flex items-center justify-between gap-2">
              <span className="text-white">#{j.work_order_id?.slice(0, 8) ?? "—"}</span>
              <span className="text-xs text-neutral-400">{j.hold_reason || "On hold"}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Unassigned jobs
  if (unassignedJobs?.length) {
    cards.push(
      <div key="unassigned" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Unassigned Jobs</h3>
          <Link href="/dashboard/manager" className="text-xs text-orange-400 underline">
            Assign
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {unassignedJobs.map((j) => (
            <li key={j.id} className="flex items-center justify-between gap-2">
              <span className="text-white">#{j.work_order_id?.slice(0, 8) ?? "—"}</span>
              <span className="text-xs text-neutral-400">{j.job_type || "job"}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Punch anomalies > 8h
  if (punchAnomalies?.length) {
    cards.push(
      <div key="punch" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Punched In &gt; 8h (Check)</h3>
          <Link href="/tech/queue" className="text-xs text-orange-400 underline">
            View
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {punchAnomalies.map((j) => (
            <li key={j.id} className="flex items-center justify-between gap-2">
              <span className="text-white">#{j.work_order_id?.slice(0, 8) ?? "—"}</span>
              <span className="text-xs text-neutral-400">{j.job_type || "job"}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Pending quotes
  if (pendingQuotes?.length) {
    cards.push(
      <div key="quotes" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Quotes To Generate</h3>
          <Link href="/work-orders/queue" className="text-xs text-orange-400 underline">
            Queue
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {pendingQuotes.map((w) => (
            <li key={w.id} className="flex items-center justify-between gap-2">
              <span className="text-white">WO #{w.id.slice(0, 8)}</span>
              <span className="text-xs text-neutral-400">{fmtDate(w.created_at)}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Parts requests
  if (openPartsRequests?.length) {
    cards.push(
      <div key="parts" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Open Parts Requests</h3>
          <Link href="/parts" className="text-xs text-orange-400 underline">
            Parts
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {openPartsRequests.map((pr) => (
            <li key={pr.id} className="flex items-center justify-between gap-2">
              <span className="text-white">WO #{pr.work_order_id?.slice(0, 8) ?? "—"}</span>
              <span className="text-xs text-neutral-400">{pr.status || "open"}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Email failures
  if (emailFailures?.length) {
    cards.push(
      <div key="email" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Email Delivery Issues</h3>
          <Link href="/dashboard/admin/audit" className="text-xs text-orange-400 underline">
            Logs
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {emailFailures.slice(0, 5).map((e) => (
            <li key={e.id} className="flex items-center justify-between gap-2">
              <span className="text-white">{e.recipient || "recipient"}</span>
              <span className="text-xs text-red-400">{fmtDate(e.created_at)}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Shop utilization + setup completeness
  if (shopUtil) {
    const used = shopUtil.active_user_count ?? 0;
    const cap = shopUtil.user_limit ?? 0;
    const pct = cap ? Math.min(100, Math.round((used / cap) * 100)) : 0;

    cards.push(
      <div key="shop" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">
            {shopUtil.name || "Shop"} Utilization
          </h3>
        </div>
        <div className="text-sm">
          Users {used}/{cap || "—"} {cap ? `(${pct}%)` : ""}
        </div>
        {shopMissingFields?.length ? (
          <div className="mt-2 text-xs text-yellow-400">
            Missing: {shopMissingFields.join(", ")}
          </div>
        ) : null}
        <div className="mt-2">
          <Link href="/dashboard/owner/settings" className="text-xs text-orange-400 underline">
            Settings
          </Link>
        </div>
      </div>
    );
  }

  // Vehicles missing VIN
  if (vehiclesMissingVin?.length) {
    cards.push(
      <div key="vin" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Vehicles Missing VIN</h3>
          <Link href="/portal/vehicles" className="text-xs text-orange-400 underline">
            Fix
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {vehiclesMissingVin.map((v) => (
            <li key={v.id} className="flex items-center justify-between gap-2">
              <span className="text-white">
                {[v.year, v.make, v.model].filter(Boolean).join(" ") || v.id.slice(0, 8)}
              </span>
              <span className="text-xs text-neutral-400">No VIN</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Unreviewed vehicle photos
  if (unreviewedPhotos?.length) {
    cards.push(
      <div key="photos" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Unreviewed Vehicle Photos</h3>
          <Link href="/parts" className="text-xs text-orange-400 underline">
            Gallery
          </Link>
        </div>
        <div className="text-sm text-neutral-300">
          {unreviewedPhotos.length} photo{unreviewedPhotos.length === 1 ? "" : "s"} need review
        </div>
      </div>
    );
  }

  if (!cards.length) {
    return (
      <div className="rounded-xl border border-neutral-800 bg-neutral-900 p-6 text-sm text-neutral-400">
        Nothing to review right now.
      </div>
    );
  }

  return <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-3">{cards}</div>;
}

/* =============================== */
/* FILE: features/inspections/lib/inspection/matchToMenuItem.ts */
/* =============================== */

// features/inspections/lib/inspection/matchToMenuItem.ts
import type {
  InspectionSession,
  InspectionItem,
  QuoteLineItem,
} from "./types";
import { serviceMenu } from "@shared/lib/menuItems";
import { v4 as uuidv4 } from "uuid";

export default function matchToMenuItem(
  session: InspectionSession,
  item: InspectionItem,
): InspectionSession {
  // Only create quote lines for actionable statuses
  if (!item || !item.status || !["fail", "recommend"].includes(item.status)) {
    return session;
  }

  const newQuoteLines: QuoteLineItem[] = [];

  // Try the primary name + any recommended follow-ups
  const namesToMatch = [item.name, ...(item.recommend ?? [])];

  namesToMatch.forEach((term) => {
    if (!term) return;

    const match = serviceMenu.find((menuItem) =>
      term.toLowerCase().includes(menuItem.name.toLowerCase()),
    );

    if (match) {
      // Guard the status to the allowed set
      const statusSafe: QuoteLineItem["status"] =
        item.status === "ok" ||
        item.status === "fail" ||
        item.status === "na" ||
        item.status === "recommend"
          ? item.status
          : "ok";

      const quoteLine: QuoteLineItem = {
        id: uuidv4(),
        // display + identifiers
        item: match.name,
        name: "", // optional helper field in some UIs
        description: match.name,

        // status/notes
        status: statusSafe,
        notes: item.notes ?? "",

        // pricing (total can be computed elsewhere; keep price present)
        price: 0,
        laborTime: match.laborHours || 1,
        parts: [
          {
            name: match.name,
            price: match.partCost || 0,
          },
        ],
        totalCost:
          (match.partCost ?? 0) + (match.laborHours ?? 1) * 120,

        // provenance + misc helpers used around the app
        source: "inspection",
        partName: "",
      };

      newQuoteLines.push(quoteLine);
    }
  });

  return {
    ...session,
    quote: [...(session.quote ?? []), ...newQuoteLines],
  };
}

/* =============================== */
/* FILE: features/inspections/lib/inspection/types.ts */
/* =============================== */

/** ---------- Item / Section ---------- */
export type InspectionItemStatus = "ok" | "fail" | "na" | "recommend";
export type BrakeType = "air" | "hydraulic";

export interface InspectionItem {
  /** Primary label. Some code uses `item`, some uses `name` — support both. */
  item?: string;
  name?: string;

  status?: InspectionItemStatus;
  notes?: string;
  /** Some AI/normalizers use singular `note`. */
  note?: string;

  value?: string | number | null;
  unit?: string | null;

  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionCategory {
  title: string;
  items: InspectionItem[];
}

/** Many places import `InspectionSection`; keep it as an alias. */
export type InspectionSection = InspectionCategory;

/** ---------- Parsed voice/AI commands (support both shapes) ---------- */
/** Older, name-based command shape used by dispatchCommand/interpreter */
export type ParsedCommandNameBased =
  | { type: "status"; section: string; item: string; status: InspectionItemStatus }
  | { type: "add"; section: string; item: string; note: string }
  | { type: "recommend"; section: string; item: string; note: string }
  | {
      type: "measurement";
      section: string;
      item: string;
      value: number | string;
      unit?: string;
    };

/** Newer, index-based command shape used by convertParsedCommands.ts */
export type ParsedCommandIndexed = {
  command:
    | "update_status"
    | "update_value"
    | "add_note"
    | "recommend"
    | "complete_item"
    | "skip_item"
    | "pause_inspection"
    | "finish_inspection";
  sectionIndex?: number;
  itemIndex?: number;
  status?: InspectionItemStatus;
  value?: string | number;
  unit?: string;
  notes?: string;
  recommend?: string;
};

/** Unified ParsedCommand covering both shapes */
export type ParsedCommand = ParsedCommandNameBased | ParsedCommandIndexed;

/**
 * Commands consumed by dispatchCommand (older name-based shape),
 * plus a simple "pause" variant used in a few places.
 */
export type InspectionCommand =
  | ParsedCommandNameBased
  | { type: "pause"; section?: string; item?: string };

/** ---------- Runtime command objects (AI → actions) ---------- */
export type Command =
  | {
      type: "update_status";
      sectionIndex: number;
      itemIndex: number;
      status: InspectionItemStatus;
    }
  | {
      type: "update_value";
      sectionIndex: number;
      itemIndex: number;
      value: string | number;
      unit?: string;
    }
  | {
      type: "add_note";
      sectionIndex: number;
      itemIndex: number;
      notes: string;
    }
  | {
      type: "recommend";
      sectionIndex: number;
      itemIndex: number;
      recommendation: string;
    }
  | {
      type: "complete";
      sectionIndex: number;
      itemIndex: number;
    }
  | {
      type: "skip";
      sectionIndex: number;
      itemIndex: number;
    }
  | { type: "pause" }
  | { type: "finish" };

/** ---------- Quote shapes ---------- */
/** Rich source descriptor for where a line came from. */
export type QuoteSource = "inspection" | "manual" | string;

/**
 * Lightweight line produced by AI generators / costing flows.
 * Extended to include fields your costing + menu matching code writes.
 */
export interface QuoteLine {
  /** Core */
  description: string;

  /** IDs / provenance */
  id?: string;
  source?: QuoteSource;

  /** Names used across flows */
  item?: string;             // selected service/menu name
  name?: string;             // occasional alias
  inspectionItem?: string;   // originating inspection item text

  /** Status / notes */
  status?: InspectionItemStatus;
  notes?: string;

  /** Time & rates */
  hours?: number;
  rate?: number;
  total?: number;
  laborHours?: number | null;
  laborTime?: number;        // alias used on some screens
  laborRate?: number;

  /** Parts */
  parts?: Array<{ name?: string; number?: string; price?: number; type?: string }>;
  partNumber?: string | null;
  partName?: string;
  unitPrice?: number | null;

  /** Roll-up / pricing */
  qty?: number;
  price?: number;            // some code writes final line price here
  totalCost?: number;
}

/** Detailed line used by PDF/store. */
export interface QuoteLineItem {
  id: string;

  /** Some places map description into both `item` and `name`. */
  item?: string;
  name?: string;
  description: string;

  status: InspectionItemStatus;
  notes?: string;

  /** Unified commercial fields */
  price: number; // line price/total
  laborHours?: number;
  /** Additional variants used in some flows */
  laborTime?: number; // alias used on some pages
  laborRate?: number;

  /** Item-level measurement value (rare) */
  value?: string | number | null;

  /** Parts can be object or split fields */
  part?: { name: string; price: number };
  partName?: string;
  partPrice?: number | null;

  /** Old-style fields occasionally present */
  qty?: number;
  unitPrice?: number | null;

  /** Misc UI helpers */
  photoUrls?: string[];
  editable?: boolean;
  source?: QuoteSource;

  /** Collections used by some UIs */
  parts?: Array<{ name?: string; number?: string; price?: number }>;
  totalCost?: number;

  /** Optional back-reference to the inspection item */
  inspectionItem?: string;

  /** Optional AI suggestion metadata */
  ai?: {
    summary: string;
    confidence?: string;
    parts?: { name: string; qty?: number; cost?: number; notes?: string }[];
  };

  /** UI-only: track AI enrichment progress for this line */
  aiState?: "idle" | "loading" | "done" | "error";
}

/** ---------- Inspection Summary ---------- */
export interface SummaryItem {
  section: string;
  item: string;
  status: InspectionItemStatus;
  note?: string;
  value?: string | number | null;
  unit?: string | null;
  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionSummary {
  templateName?: string | null;
  date: string;
  items: SummaryItem[];
  summaryText: string;
}

/** ---------- Session (customer/vehicle) ---------- */
export interface SessionCustomer {
  first_name: string | null;
  last_name: string | null;
  phone: string | null;
  email: string | null;
  address: string | null;
  city: string | null;
  province: string | null;
  postal_code: string | null;
}

export interface SessionVehicle {
  year: string | null;
  make: string | null;
  model: string | null;
  vin: string | null;
  license_plate: string | null;
  mileage: string | null;
  color: string | null;
  /** Added for your form */
  unit_number?: string | null;
  engine_hours?: string | null;
}

/** ---------- Session status ---------- */
export type InspectionStatus = "not_started" | "in_progress" | "paused" | "completed";

/** ---------- Full session ---------- */
export interface InspectionSession {
  id?: string;

  /** Links to other records */
  customerId?: string | null;
  vehicleId?: string | null;
  workOrderId?: string | null;

  /** Template meta */
  templateId?: string | null;
  templateName?: string | null;
  /** Legacy alias still used by some pages */
  templateitem?: string | null;

  /** Selected brake system for rendering/units */
  brakeType?: BrakeType;

  location?: string | null;

  /** Progress */
  currentSectionIndex: number;
  currentItemIndex: number;

  /** Voice */
  transcript?: string;
  isListening: boolean;

  /** Lifecycle */
  status: InspectionStatus;
  started: boolean;
  completed: boolean;
  isPaused: boolean;

  /** Audit */
  lastUpdated?: string;

  /** Entities */
  customer?: SessionCustomer | null;
  vehicle?: SessionVehicle | null;

  /** Content */
  sections: InspectionCategory[];

  /** Quotes can be DB-sourced or UI-generated — accept both */
  quote?: Array<QuoteLine | QuoteLineItem>;
}

/* =============================== */
/* FILE: features/inspections/lib/inspection/inspectionState.ts */
/* =============================== */

import {
  InspectionSession,
  InspectionItemStatus,
  QuoteLine,
} from "@inspections/lib/inspection/types";

export function updateItemStatus(
  session: InspectionSession,
  sectionIndex: number,
  itemIndex: number,
  status: InspectionItemStatus,
): InspectionSession {
  const updated = { ...session };
  updated.sections = [...session.sections];
  const section = { ...updated.sections[sectionIndex] };
  const item = { ...section.items[itemIndex], status };

  // Reset photoUrls and note if status changes
  if (status !== "fail" && status !== "recommend") {
    item.photoUrls = [];
    item.notes = "";
  }

  section.items = [...section.items];
  section.items[itemIndex] = item;
  updated.sections[sectionIndex] = section;
  return updated;
}
export function updateItemValue(
  session: InspectionSession,
  sectionIndex: number,
  itemIndex: number,
  value: number | string,
): InspectionSession {
  const updated = { ...session };
  const sections = [...updated.sections];
  const section = { ...sections[sectionIndex] };
  const item = { ...section.items[itemIndex], value };

  section.items[itemIndex] = item;
  sections[sectionIndex] = section;

  return { ...updated, sections };
}

export function updateItemNote(
  session: InspectionSession,
  sectionIndex: number,
  itemIndex: number,
  note: string,
): InspectionSession {
  const updated = { ...session };
  updated.sections = [...session.sections];
  const section = { ...updated.sections[sectionIndex] };
  const item = { ...section.items[itemIndex], note };
  section.items = [...section.items];
  section.items[itemIndex] = item;
  updated.sections[sectionIndex] = section;
  return updated;
}

export function addPhotoUrl(
  session: InspectionSession,
  sectionIndex: number,
  itemIndex: number,
  photoUrl: string,
): InspectionSession {
  const updated = { ...session };
  updated.sections = [...session.sections];
  const section = { ...updated.sections[sectionIndex] };
  const item = { ...section.items[itemIndex] };

  item.photoUrls = [...(item.photoUrls || []), photoUrl];

  section.items = [...section.items];
  section.items[itemIndex] = item;
  updated.sections[sectionIndex] = section;
  return updated;
}

export function updateQuoteLines(
  session: InspectionSession,
  quoteLines: QuoteLine[],
): InspectionSession {
  return { ...session, quote: quoteLines };
}


/* =============================== */
/* FILE: features/inspections/lib/inspection/aiQuote.ts */
/* =============================== */

// features/inspections/lib/inspection/aiQuote.ts
export type AISuggestion = {
  parts: { name: string; qty?: number; cost?: number; notes?: string }[];
  laborHours: number;
  laborRate?: number;
  summary: string;
  confidence?: "low" | "medium" | "high";
  price?: number;
  notes?: string;
  title?: string;
};

export async function requestQuoteSuggestion(args: {
  item: string;
  notes?: string;
  section: string;
  status: string;
  value?: string;
  unit?: string;
  vehicle?: Record<string, any>;
}): Promise<AISuggestion | null> {
  try {
    const res = await fetch("/api/ai/quote-suggest", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(args),
    });
    if (!res.ok) return null;
    const data = await res.json();
    return (data?.suggestion ?? null) as AISuggestion | null;
  } catch (e) {
    console.error("requestQuoteSuggestion error:", e);
    return null;
  }
}

/* =============================== */
/* FILE: features/inspections/api/inspection/submit/route.ts */
/* =============================== */

// app/api/inspections/submit/route.ts
import { NextRequest, NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";

import { generateQuoteFromInspection } from "@quotes/lib/quote/generateQuoteFromInspection";
import { generateQuotePDFBytes } from "@work-orders/lib/work-orders/generateQuotePdf";
import { sendQuoteEmail } from "@shared/lib/email/email/sendQuoteEmail";
import { generateInspectionSummary } from "@inspections/lib/inspection/generateInspectionSummary";

import type { Database } from "@shared/types/types/supabase";
import type {
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

export const runtime = "nodejs";

export async function POST(req: NextRequest) {
  const body = await req.json();
  const {
    inspectionSession,
    workOrderId,
    customerEmail,
  }: {
    inspectionSession: InspectionSession;
    workOrderId: string;
    customerEmail: string;
  } = body;

  if (!inspectionSession || !workOrderId || !customerEmail) {
    return NextResponse.json({ error: "Missing input" }, { status: 400 });
  }

  try {
    const supabase = createRouteHandlerClient<Database>({ cookies });

    // 1) Structured inspection summary
    const summary = generateInspectionSummary(inspectionSession);
    const summaryText =
      typeof summary === "string" ? summary : summary?.summaryText ?? "";

    // 2) Flatten inspection items and create a quote (new lightweight shape)
    const allItems = inspectionSession.sections.flatMap((s) => s.items);
    const { quote } = await generateQuoteFromInspection(allItems);

    // 3) Normalize new QuoteLine -> QuoteLineItem for PDF generation
    const quoteItems: QuoteLineItem[] = quote.map((line, index) => ({
      id: `${index}-${line.description}`,
      item: line.description,
      name: line.description,
      description: line.description,
      status: "fail",
      notes: "",
      laborHours: line.hours,
      price: line.hours * line.rate,
      part: undefined,
      partName: "",
      partPrice: null,
      photoUrls: [],
    }));

    // 4) Generate PDF bytes
    const pdfBytes = await generateQuotePDFBytes(quoteItems, summaryText);

    // 5) Upload to Supabase storage
    const fileName = `quotes/${workOrderId}-${Date.now()}.pdf`;
    const { error: uploadError } = await supabase.storage
      .from("quotes")
      .upload(fileName, pdfBytes, {
        contentType: "application/pdf",
        upsert: true,
      });

    if (uploadError) {
      throw new Error("PDF upload failed: " + uploadError.message);
    }

    const { data } = supabase.storage.from("quotes").getPublicUrl(fileName);
    const publicUrl = data?.publicUrl ?? null;

    // 6) Email the quote (URL + attachment)
    await sendQuoteEmail({
      to: customerEmail,
      workOrderId,
      pdfBuffer: Buffer.from(pdfBytes).toString("base64"),
      pdfUrl: publicUrl ?? undefined,
    });

    return NextResponse.json({ success: true, quoteUrl: publicUrl });
  } catch (error) {
    console.error("🚨 Error generating and sending quote:", error);
    return NextResponse.json(
      { error: "Failed to generate and send quote" },
      { status: 500 },
    );
  }
}

/* =============================== */
/* FILE: features/inspections/screens/Maintenance50Screen.tsx */
/* =============================== */

"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/lib/inspection/ui/CornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* ---------- Props for screen usage (modal + page) ---------- */
type ScreenProps = {
  embed?: boolean;
  template?: string;
  params?: Record<string, string | number | boolean | null | undefined>;
};

/* ---------- Sections ---------- */
function buildHydraulicMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Hydraulic)",
    items: [
      { item: "LF Tire Pressure", unit: "psi", value: "" },
      { item: "RF Tire Pressure", unit: "psi", value: "" },
      { item: "LR Tire Pressure", unit: "psi", value: "" },
      { item: "RR Tire Pressure", unit: "psi", value: "" },
      { item: "LF Tire Tread", unit: "mm", value: "" },
      { item: "RF Tire Tread", unit: "mm", value: "" },
      { item: "LR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "LR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "LF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "LR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "Wheel Torque (after road test)", unit: "ft·lb", value: "" },
    ],
  };
}
function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}
function buildBrakesSection(): InspectionSection {
  return {
    title: "Brakes",
    items: [
      { item: "Front brake pads" },
      { item: "Rear brake pads" },
      { item: "Brake fluid level" },
      { item: "Brake lines and hoses" },
      { item: "ABS wiring / sensors" },
      { item: "Brake warning lights" },
    ],
  };
}
function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
    ],
  };
}
function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "CV shafts / joints" },
      { item: "Transmission leaks / mounts" },
      { item: "Transfer case leaks / mounts" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* ---------- Units helpers ---------- */
function unitForHydraulic(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tire tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad thickness")) return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}
function applyUnitsHydraulic(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    if ((s.title || "").toLowerCase().includes("measurements")) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForHydraulic(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }
    return s;
  });
}

/* ---------- Screen (component) ---------- */
export default function Maintenance50Screen(props: ScreenProps): JSX.Element {
  const searchParams = useSearchParams();
  const p = props.params ?? {};
  const rootRef = useRef<HTMLDivElement | null>(null);

  const get = (k: string): string => {
    const v = p[k];
    if (v !== undefined && v !== null) return String(v);
    return searchParams.get(k) ?? "";
  };

  // 🔸 only mobile companion gets voice
  const isMobileView =
    (get("view") || "").toLowerCase() === "mobile";

  const isEmbed =
    !!props.embed ||
    ["1", "true", "yes"].includes(
      (get("embed") || get("compact")).toLowerCase()
    );

  const workOrderLineId = get("workOrderLineId") || null;
  const workOrderId = get("workOrderId") || null;
  const inspectionId = useMemo<string>(
    () => get("inspectionId") || uuidv4(),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string = props.template || get("template") || "Maintenance 50";

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      sections: [],
    }),
    [inspectionId, templateName]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  // ---- AI submit guarding ----
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // ---- boot/restore ----
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // persist
  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        localStorage.setItem(key, JSON.stringify(session ?? initialSession));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // build sections once
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;
    const next: InspectionSection[] = [
      buildHydraulicMeasurementsSection(),
      buildLightsSection(),
      buildBrakesSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsHydraulic(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  // re-apply units
  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsHydraulic(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  // transcript → commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // speech
  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };
  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  /* 🧹 embed-safe scrubber (remove full-screen / overflow locks) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  /* 🔐 focus trap while embedded (keep Tab inside) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-sm text-neutral-300">Loading inspection…</div>;
  }

  const isMeasurements = (t?: string): boolean =>
    (t || "").toLowerCase().includes("measurements");

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const Body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Maintenance 50"}
          </div>
        </div>
      </div>

      {/* Controls */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              try {
                recognitionRef.current?.stop();
              } catch {}
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              recognitionRef.current = startVoiceRecognition(handleTranscript);
            }}
            recognitionInstance={
              recognitionRef.current as unknown as SpeechRecognition | null
            }
            onTranscript={handleTranscript}
            setRecognitionRef={(instance: SpeechRecognition | null): void => {
              (
                recognitionRef as React.MutableRefObject<SpeechRecognition | null>
              ).current = instance ?? null;
            }}
          />
        )}

        {/* Unit toggle on all views */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      {/* Sections */}
      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isMeasurements(section.title) && (
              <span className={hint}>
                {unit === "metric"
                  ? "Enter mm / kPa / N·m"
                  : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className="mt-4">
              {isMeasurements(section.title) ? (
                <CornerGrid sectionIndex={sectionIndex} items={section.items} />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes
                  showPhotos
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(
                    secIdx: number,
                    itemIdx: number,
                    note: string
                  ): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(
                    photoUrl: string,
                    secIdx: number,
                    itemIdx: number
                  ): void => {
                    const prev =
                      session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, {
                      photoUrls: [...prev, photoUrl],
                    });
                  }}
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) =>
                    void submitAIForItem(secIdx, itemIdx)
                  }
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      {/* Footer */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Maintenance 50"}
      description="Quick 50-point hydraulic brake maintenance inspection."
    >
      {Body}
    </PageShell>
  );
}

/* =============================== */
/* FILE: features/inspections/screens/GenericInspectionScreen.tsx */
/* =============================== */

"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import AxlesCornerGrid from "@inspections/lib/inspection/ui/AxlesCornerGrid";

import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* -------------------------- helpers -------------------------- */

function toHeaderCustomer(c?: SessionCustomer | null) {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}
function toHeaderVehicle(v?: SessionVehicle | null) {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/** Try to give a sensible unit hint for common labels */
function unitHintGeneric(label: string, mode: "metric" | "imperial"): string {
  const l = (label || "").toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad") || l.includes("lining") || l.includes("shoe"))
    return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor") || l.includes("drum")) return mode === "metric" ? "mm" : "in";
  if (l.includes("push rod")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  if (l.includes("leak rate")) return mode === "metric" ? "kPa/min" : "psi/min";
  if (l.includes("gov cut") || l.includes("warning")) return mode === "metric" ? "kPa" : "psi";
  return "";
}

/** Safe reader for sessionStorage JSON */
function readStaged<T>(key: string): T | null {
  try {
    if (typeof window === "undefined") return null;
    const raw = sessionStorage.getItem(key);
    return raw ? (JSON.parse(raw) as T) : null;
  } catch {
    return null;
  }
}

/** Normalize + merge sections (copy name→item; merge same titles; dedupe items) */
function normalizeSections(input: unknown): InspectionSection[] {
  try {
    const arr = Array.isArray(input) ? input : [];
    const byTitle = new Map<string, InspectionSection>();

    for (const s of arr as any[]) {
      const title = String(s?.title ?? "").trim();
      if (!title) continue;

      const itemsRaw = Array.isArray(s?.items) ? s.items : [];
      const items = itemsRaw
        .map((it: any) => {
          const label = String(it?.item ?? it?.name ?? "").trim();
          if (!label) return null;
          return {
            ...it,
            item: label,
            unit: it?.unit ?? null,
          };
        })
        .filter(Boolean);

      if (!byTitle.has(title)) byTitle.set(title, { title, items: [] });
      const bucket = byTitle.get(title)!;
      const seen = new Set((bucket.items ?? []).map((x) => (x.item ?? "").toLowerCase()));
      for (const it of items as any[]) {
        const key = (it.item ?? "").toLowerCase();
        if (!seen.has(key)) {
          bucket.items = [...(bucket.items ?? []), it];
          seen.add(key);
        }
      }
    }

    return Array.from(byTitle.values()).filter((s) => (s.items?.length ?? 0) > 0);
  } catch {
    return [];
  }
}

/* -------- smarter corner-grid detector -------- */

const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const HYD_FULL_RE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

function shouldRenderCornerGrid(
  title: string | undefined,
  items: { item?: string | null }[] = []
): boolean {
  const t = (title || "").toLowerCase();

  if (
    t.includes("corner grid") ||
    t.includes("tires & brakes — truck") ||
    t.includes("tires & brakes — air") ||
    t.includes("axle grid")
  ) {
    return true;
  }

  if (!items || items.length < 4) return false;

  const hasStrongPattern = items.some((it) => {
    const label = it.item ?? "";
    return AIR_RE.test(label) || HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label);
  });

  const measurementKeywords = [
    "tread",
    "pressure",
    "lining",
    "shoe",
    "drum",
    "rotor",
    "push rod",
    "pad",
    "torque",
  ];
  const measurementLikeCount = items.reduce((count, it) => {
    const label = (it.item || "").toLowerCase();
    const isMeasurement = measurementKeywords.some((kw) => label.includes(kw));
    return count + (isMeasurement ? 1 : 0);
  }, 0);

  const enoughMeasurements = measurementLikeCount >= Math.floor(items.length / 2);

  const titleSuggestsMeasurement =
    t.includes("tire") ||
    t.includes("tires") ||
    t.includes("brake") ||
    t.includes("measurement") ||
    t.includes("axle");

  return hasStrongPattern || (titleSuggestsMeasurement && enoughMeasurements);
}

/* -------------------------------------------------------------------- */
/* Component                                                            */
/* -------------------------------------------------------------------- */

export default function GenericInspectionScreen(): JSX.Element {
  const sp = useSearchParams();
  const rootRef = useRef<HTMLDivElement | null>(null);

  // 🔸 only the mobile companion should use voice
  const isMobileView =
    (sp.get("view") || "").toLowerCase() === "mobile";

  // Embed for iframe/modal
  const isEmbed = useMemo(
    () =>
      ["1", "true", "yes"].includes(
        (sp.get("embed") || sp.get("compact") || "").toLowerCase()
      ),
    [sp]
  );

  const workOrderId = sp.get("workOrderId") || null;
  const workOrderLineId = sp.get("workOrderLineId") || "";
  const templateName =
    (typeof window !== "undefined" ? sessionStorage.getItem("inspection:title") : null) ||
    (sp.get("template") || "Inspection");

  const customer: SessionCustomer = {
    first_name: sp.get("first_name") || "",
    last_name: sp.get("last_name") || "",
    phone: sp.get("phone") || "",
    email: sp.get("email") || "",
    address: sp.get("address") || "",
    city: sp.get("city") || "",
    province: sp.get("province") || "",
    postal_code: sp.get("postal_code") || "",
  };
  const vehicle: SessionVehicle = {
    year: sp.get("year") || "",
    make: sp.get("make") || "",
    model: sp.get("model") || "",
    vin: sp.get("vin") || "",
    license_plate: sp.get("license_plate") || "",
    mileage: sp.get("mileage") || "",
    color: sp.get("color") || "",
    unit_number: sp.get("unit_number") || "",
    engine_hours: sp.get("engine_hours") || "",
  };

  const bootSections = useMemo<InspectionSection[]>(() => {
    const staged = readStaged<InspectionSection[]>("inspection:sections");
    if (Array.isArray(staged) && staged.length) return normalizeSections(staged);

    try {
      const legacy =
        typeof window !== "undefined"
          ? sessionStorage.getItem("customInspection:sections")
          : null;
      if (legacy) {
        const parsed = JSON.parse(legacy) as InspectionSection[];
        const norm = normalizeSections(parsed);
        return norm;
      }
    } catch {}

    return [
      {
        title: "General",
        items: [{ item: "Visual walkaround" }, { item: "Record warning lights" }],
      },
    ];
  }, [sp]);

  const inspectionId = useMemo(
    () => sp.get("inspectionId") || uuidv4(),
    [sp]
  );

  // 🔸 try to hydrate from localStorage
  const persistedSession = useMemo(() => {
    if (typeof window === "undefined") return null;
    const raw = localStorage.getItem(`inspection-${inspectionId}`);
    if (!raw) return null;
    try {
      return JSON.parse(raw) as InspectionSession;
    } catch {
      return null;
    }
  }, [inspectionId]);

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState(false);
  const [isPaused, setIsPaused] = useState(false);

  // 🔴 wake-word state
  const [wakeActive, setWakeActive] = useState(false);
  const wakeTimeoutRef = useRef<number | null>(null);

  // openai realtime refs
  const wsRef = useRef<WebSocket | null>(null);
  const mediaRef = useRef<MediaStream | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(persistedSession ?? initialSession);

  // start
  useEffect(() => {
    if (persistedSession) {
      startSession(persistedSession);
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [persistedSession]);
  useEffect(() => {
    if (session && (session.sections?.length ?? 0) === 0) {
      updateInspection({ sections: bootSections });
    }
  }, [session, bootSections, updateInspection]);

  // persist
  useEffect(() => {
    if (!session) return;
    const key = `inspection-${inspectionId}`;
    localStorage.setItem(key, JSON.stringify(session));
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // 🔸 turn final text into inspection commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess = session;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // 🔔 wake-word helper
  function maybeHandleWakeWord(raw: string): string | null {
    const lower = raw.toLowerCase().trim();
    const WAKE_WORDS = ["hey techy", "hey techie", "hey teki", "hey tekky"];

    if (!wakeActive) {
      const hit = WAKE_WORDS.find((w) => lower.startsWith(w));
      if (hit) {
        setWakeActive(true);
        if (wakeTimeoutRef.current) window.clearTimeout(wakeTimeoutRef.current);
        wakeTimeoutRef.current = window.setTimeout(() => {
          setWakeActive(false);
        }, 8000);
        return lower.slice(hit.length).trim();
      }
      return null;
    }

    if (wakeTimeoutRef.current) window.clearTimeout(wakeTimeoutRef.current);
    wakeTimeoutRef.current = window.setTimeout(() => {
      setWakeActive(false);
    }, 8000);

    return raw;
  }

  // 🔊 openai realtime start (used only when mobile buttons are visible)
  const startListening = async (): Promise<void> => {
    if (isListening) return;
    try {
      const res = await fetch("/api/openai/realtime-token");
      const { apiKey } = (await res.json()) as { apiKey: string };
      if (!apiKey) throw new Error("Missing OpenAI key");

      const ws = new WebSocket("wss://api.openai.com/v1/realtime?intent=transcription");
      wsRef.current = ws;

      ws.onopen = async () => {
        ws.send(
          JSON.stringify({
            type: "authorization",
            authorization: `Bearer ${apiKey}`,
          })
        );

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRef.current = stream;

        const mr = new MediaRecorder(stream, { mimeType: "audio/webm" });
        mediaRecorderRef.current = mr;
        mr.ondataavailable = (evt) => {
          if (evt.data.size > 0 && ws.readyState === WebSocket.OPEN) {
            ws.send(evt.data);
          }
        };
        mr.start(250);

        setIsListening(true);
      };

      ws.onmessage = async (evt) => {
        if (typeof evt.data !== "string") return;
        try {
          const msg = JSON.parse(evt.data);
          const text: string =
            msg.text || msg.transcript || msg.output || msg.content || "";
          if (!text) return;

          const maybeText = maybeHandleWakeWord(text);
          if (!maybeText) return;

          const lower = maybeText.toLowerCase();
          if (lower === "stop listening" || lower === "go to sleep") {
            setWakeActive(false);
            return;
          }

          await handleTranscript(maybeText);
        } catch {
          // ignore parse errors
        }
      };

      ws.onerror = (err) => {
        console.error("realtime ws error", err);
        toast.error("Voice connection error");
        stopListening();
      };

      ws.onclose = () => {
        stopListening();
      };
    } catch (e: any) {
      console.error(e);
      toast.error(e?.message || "Unable to start voice");
      stopListening();
    }
  };

  const stopListening = (): void => {
    mediaRecorderRef.current?.stop();
    mediaRecorderRef.current = null;

    mediaRef.current?.getTracks().forEach((t) => t.stop());
    mediaRef.current = null;

    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.close();
    }
    wsRef.current = null;
    setIsListening(false);
    setWakeActive(false);
    if (wakeTimeoutRef.current) {
      window.clearTimeout(wakeTimeoutRef.current);
      wakeTimeoutRef.current = null;
    }
  };

  useEffect(() => {
    return () => {
      stopListening();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // AI submit flow
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? (it as any).name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // 🧹 embed-safe scrubber (for iframe / modal host)
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child as HTMLElement);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  // 🔐 Focus trap so Tab stays inside the inspection when embedded in modal
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      // If focus is already outside the root, jump to first
      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        // Shift+Tab: if we're on first, loop to last
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        // Tab forward: if we're on last, loop to first
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return (
      <div className="p-4 text-sm text-neutral-300">
        Loading inspection…
      </div>
    );
  }

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header card */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Inspection"}
          </div>
        </div>

        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      {/* Controls row */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {/* Voice only in mobile companion */}
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              stopListening();
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              void startListening();
            }}
            recognitionInstance={null}
            onTranscript={handleTranscript}
            setRecognitionRef={(): void => {
              /* noop – using OpenAI now */
            }}
          />
        )}

        {/* Unit toggle stays on both desktop + mobile */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => {
          const itemsWithHints = section.items.map((it) => ({
            ...it,
            unit: it.unit || unitHintGeneric(it.item ?? "", unit),
          }));

          const useGrid = shouldRenderCornerGrid(section.title, itemsWithHints);

          return (
            <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
              <h2 className={sectionTitle}>{section.title}</h2>
              {useGrid && (
                <span className={hint}>
                  {unit === "metric"
                    ? "Enter mm / kPa / N·m"
                    : "Enter in / psi / ft·lb"}
                </span>
              )}

              <div className="mt-4">
                {useGrid ? (
                  <AxlesCornerGrid
                    sectionIndex={sectionIndex}
                    items={itemsWithHints}
                  />
                ) : (
                  <SectionDisplay
                    title=""
                    section={{ ...section, items: itemsWithHints }}
                    sectionIndex={sectionIndex}
                    showNotes
                    showPhotos
                    onUpdateStatus={(
                      secIdx: number,
                      itemIdx: number,
                      status: InspectionItemStatus
                    ) => {
                      updateItem(secIdx, itemIdx, { status });
                    }}
                    onUpdateNote={(secIdx, itemIdx, note) => {
                      updateItem(secIdx, itemIdx, { notes: note });
                    }}
                    onUpload={(photoUrl, secIdx, itemIdx) => {
                      const prev =
                        session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                      updateItem(secIdx, itemIdx, {
                        photoUrls: [...prev, photoUrl],
                      });
                    }}
                    requireNoteForAI
                    onSubmitAI={(secIdx, itemIdx) => {
                      void submitAIForItem(secIdx, itemIdx);
                    }}
                    isSubmittingAI={isSubmittingAI}
                  />
                )}
              </div>
            </div>
          );
        })}
      </InspectionFormCtx.Provider>

      {/* Footer actions */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton session={session} workOrderLineId={workOrderLineId} />
          <FinishInspectionButton session={session} workOrderLineId={workOrderLineId} />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Inspection"}
      description="Run guided inspections, capture notes, and push items into work orders."
    >
      {body}
    </PageShell>
  );
}

/* =============================== */
/* FILE: features/inspections/screens/Maintenance50AirScreen.tsx */
/* =============================== */

"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/lib/inspection/ui/CornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* ---------- Props for screen usage (modal + page) ---------- */
type ScreenProps = {
  embed?: boolean;
  template?: string;
  params?: Record<string, string | number | boolean | null | undefined>;
};

/* ---------- Sections ---------- */
function buildHydraulicMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Hydraulic)",
    items: [
      { item: "LF Tire Pressure", unit: "psi", value: "" },
      { item: "RF Tire Pressure", unit: "psi", value: "" },
      { item: "LR Tire Pressure", unit: "psi", value: "" },
      { item: "RR Tire Pressure", unit: "psi", value: "" },
      { item: "LF Tire Tread", unit: "mm", value: "" },
      { item: "RF Tire Tread", unit: "mm", value: "" },
      { item: "LR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "LR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "LF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "LR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "Wheel Torque (after road test)", unit: "ft·lb", value: "" },
    ],
  };
}
function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}
function buildBrakesSection(): InspectionSection {
  return {
    title: "Brakes",
    items: [
      { item: "Front brake pads" },
      { item: "Rear brake pads" },
      { item: "Brake fluid level" },
      { item: "Brake lines and hoses" },
      { item: "ABS wiring / sensors" },
      { item: "Brake warning lights" },
    ],
  };
}
function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
    ],
  };
}
function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "CV shafts / joints" },
      { item: "Transmission leaks / mounts" },
      { item: "Transfer case leaks / mounts" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* ---------- Units helpers ---------- */
function unitForHydraulic(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tire tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad thickness")) return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}
function applyUnitsHydraulic(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    if ((s.title || "").toLowerCase().includes("measurements")) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForHydraulic(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }
    return s;
  });
}

/* ---------- Screen (component) ---------- */
export default function Maintenance50Screen(props: ScreenProps): JSX.Element {
  const searchParams = useSearchParams();
  const p = props.params ?? {};
  const rootRef = useRef<HTMLDivElement | null>(null);

  const get = (k: string): string => {
    const v = p[k];
    if (v !== undefined && v !== null) return String(v);
    return searchParams.get(k) ?? "";
  };

  // 🔸 only mobile companion gets voice
  const isMobileView =
    (get("view") || "").toLowerCase() === "mobile";

  const isEmbed =
    !!props.embed ||
    ["1", "true", "yes"].includes(
      (get("embed") || get("compact")).toLowerCase()
    );

  const workOrderLineId = get("workOrderLineId") || null;
  const workOrderId = get("workOrderId") || null;
  const inspectionId = useMemo<string>(
    () => get("inspectionId") || uuidv4(),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string = props.template || get("template") || "Maintenance 50";

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      sections: [],
    }),
    [inspectionId, templateName]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  // ---- AI submit guarding ----
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // ---- boot/restore ----
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // persist
  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        localStorage.setItem(key, JSON.stringify(session ?? initialSession));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // build sections once
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;
    const next: InspectionSection[] = [
      buildHydraulicMeasurementsSection(),
      buildLightsSection(),
      buildBrakesSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsHydraulic(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  // re-apply units
  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsHydraulic(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  // transcript → commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // speech
  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };
  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  /* 🧹 embed-safe scrubber (remove full-screen / overflow locks) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  /* 🔐 focus trap while embedded (keep Tab inside) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-sm text-neutral-300">Loading inspection…</div>;
  }

  const isMeasurements = (t?: string): boolean =>
    (t || "").toLowerCase().includes("measurements");

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const Body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Maintenance 50"}
          </div>
        </div>
      </div>

      {/* Controls */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              try {
                recognitionRef.current?.stop();
              } catch {}
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              recognitionRef.current = startVoiceRecognition(handleTranscript);
            }}
            recognitionInstance={
              recognitionRef.current as unknown as SpeechRecognition | null
            }
            onTranscript={handleTranscript}
            setRecognitionRef={(instance: SpeechRecognition | null): void => {
              (
                recognitionRef as React.MutableRefObject<SpeechRecognition | null>
              ).current = instance ?? null;
            }}
          />
        )}

        {/* Unit toggle on all views */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      {/* Sections */}
      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isMeasurements(section.title) && (
              <span className={hint}>
                {unit === "metric"
                  ? "Enter mm / kPa / N·m"
                  : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className="mt-4">
              {isMeasurements(section.title) ? (
                <CornerGrid sectionIndex={sectionIndex} items={section.items} />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes
                  showPhotos
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(
                    secIdx: number,
                    itemIdx: number,
                    note: string
                  ): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(
                    photoUrl: string,
                    secIdx: number,
                    itemIdx: number
                  ): void => {
                    const prev =
                      session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, {
                      photoUrls: [...prev, photoUrl],
                    });
                  }}
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) =>
                    void submitAIForItem(secIdx, itemIdx)
                  }
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      {/* Footer */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Maintenance 50"}
      description="Quick 50-point hydraulic brake maintenance inspection."
    >
      {Body}
    </PageShell>
  );
}

/* =============================== */
/* FILE: features/inspections/app/inspection/summary/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";

import type { Database } from "@shared/types/types/supabase";
import { Button } from "@shared/components/ui/Button";

import useInspectionSession from "@inspections/hooks/useInspectionSession";
import { generateInspectionPDF } from "@inspections/lib/inspection/pdf";
import { generateQuoteFromInspection } from "@quotes/lib/quote/generateQuoteFromInspection";

import QuoteViewer from "@quotes/components/QuoteViewer";
import PreviousPageButton from "@shared/components/ui/PreviousPageButton";
import HomeButton from "@shared/components/ui/HomeButton";

import type {
  InspectionItem,
  InspectionSection,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";
import type { QuoteLine } from "@quotes/lib/quote/generateQuoteFromInspection";

export default function SummaryPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = useMemo(() => createClientComponentClient<Database>(), []);

  const inspectionId = searchParams.get("inspectionId");
  const workOrderIdFromUrl = searchParams.get("workOrderId");
  const mode = searchParams.get("mode");
  const isCustomerView = mode === "customer";

  const { session, updateItem, updateQuoteLines } = useInspectionSession();

  const [quoteLines, setQuoteLines] = useState<QuoteLine[]>([]);
  const [summaryText, setSummaryText] = useState("");
  const [workOrderId, setWorkOrderId] = useState<string | null>(
    workOrderIdFromUrl || null,
  );
  const [isAddingToWorkOrder, setIsAddingToWorkOrder] = useState(false);
  const [downloading, setDownloading] = useState(false);
  const [aiError, setAiError] = useState<string | null>(null);

  const didGenRef = useRef(false);

  // ---- Derived flags ----
  const hasSections = session.sections && session.sections.length > 0;

  const hasFailedItems = hasSections
    ? session.sections.some((section: InspectionSection) =>
        section.items.some(
          (item: InspectionItem) =>
            item.status === "fail" || item.status === "recommend",
        ),
      )
    : false;

  // ---- AI quote generation on first load with data ----
  useEffect(() => {
    if (didGenRef.current) return;
    if (!hasSections) return;
    didGenRef.current = true;

    (async () => {
      try {
        const allItems: InspectionItem[] = session.sections.flatMap(
          (s: InspectionSection) => s.items,
        );

        const { summary, quote } = await generateQuoteFromInspection(allItems);

        setSummaryText(summary);
        setQuoteLines(quote);

        // Push quote lines into inspection session so they’re editable later
        updateQuoteLines(
          quote.map(
            (line): QuoteLineItem => ({
              id: uuidv4(),
              name: line.description,
              description: line.description,
              notes: "",
              status: "fail",
              laborHours: line.hours ?? 0,
              price: line.total ?? 0,
              part: { name: "", price: 0 },
              photoUrls: [],
            }),
          ),
        );

        // Persist AI output into inspections row if we have an ID
        if (inspectionId) {
          await supabase
            .from("inspections")
            .update({ quote, summary })
            .eq("id", inspectionId);
        }
      } catch (err: any) {
        console.error("Quote generation failed:", err);
        setAiError(
          isCustomerView
            ? "We were unable to generate smart suggestions for this inspection. The results below still reflect the technician’s findings."
            : err?.message
            ? `AI quote generation error: ${err.message}`
            : "AI quote generation is unavailable (likely missing API key). You can still review and submit the inspection.",
        );
      }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [hasSections, inspectionId, isCustomerView]);

  // ---- Field updates (tech/owner only) ----
  const handleFieldChange = (
    sectionIndex: number,
    itemIndex: number,
    field: keyof InspectionItem,
    value: string,
  ) => {
    if (isCustomerView) return; // no edits in customer mode

    if (field === "status") {
      updateItem(sectionIndex, itemIndex, {
        status: value as InspectionItem["status"],
      });
    } else if (field === "notes") {
      updateItem(sectionIndex, itemIndex, { notes: value });
    } else if (field === "value") {
      updateItem(sectionIndex, itemIndex, { value });
    } else if (field === "unit") {
      updateItem(sectionIndex, itemIndex, { unit: value });
    }
  };

  // ---- Work order helpers (internal only) ----
  const createWorkOrderIfNoneExists = async (): Promise<string | null> => {
    if (isCustomerView) return null; // customers never create WOs
    if (workOrderId) return workOrderId;

    const newId = uuidv4();

    const { error } = await supabase
      .from("work_orders")
      .insert([
        {
          id: newId,
          vehicle_id: session.vehicleId ?? null,
          inspection_id: inspectionId ?? null,
          status: "queued",
        } as Database["public"]["Tables"]["work_orders"]["Insert"],
      ]);

    if (error) {
      console.error("Error creating work order:", error);
      toast.error("Failed to create work order.");
      return null;
    }

    setWorkOrderId(newId);
    return newId;
  };

  const handleAddToWorkOrder = async () => {
    if (isCustomerView) return;
    setIsAddingToWorkOrder(true);
    try {
      const id = await createWorkOrderIfNoneExists();
      if (!id || !inspectionId) {
        toast.error("Missing work order or inspection ID.");
        return;
      }

      const response = await fetch("/api/work-orders/from-inspection", {
        method: "POST",
        body: JSON.stringify({
          inspectionId,
          workOrderId: id,
          vehicleId: session.vehicleId,
        }),
      });

      if (!response.ok) throw new Error("Failed to add jobs to work order.");

      window.dispatchEvent(new CustomEvent("wo:line-added"));
      toast.success("Jobs added to work order.");
    } catch (e) {
      console.error(e);
      toast.error(
        e instanceof Error ? e.message : "Failed to add jobs to work order.",
      );
    } finally {
      setIsAddingToWorkOrder(false);
    }
  };

  // ---- Submit / PDF ----
  const handleSubmit = async () => {
    try {
      setDownloading(true);
      const pdfBytes: Uint8Array = await generateInspectionPDF(session);
      const blob = new Blob([pdfBytes as BlobPart], {
        type: "application/pdf",
      });

      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "inspection_summary.pdf";
      link.click();
      URL.revokeObjectURL(url);

      if (!isCustomerView) {
        // internal flow → clear local storage + return to menu
        localStorage.removeItem("inspectionCustomer");
        localStorage.removeItem("inspectionVehicle");
        router.push("/inspection/menu");
      }
    } catch (error) {
      console.error("Submission error:", error);
      toast.error("Failed to generate inspection PDF.");
    } finally {
      setDownloading(false);
    }
  };

  const customer = (session as any).customer;
  const vehicle = (session as any).vehicle;

  return (
    <div
      className={`min-h-screen px-4 pb-24 pt-4 ${
        isCustomerView
          ? "bg-slate-950 text-slate-50"
          : "bg-background text-foreground"
      }`}
    >
      {/* Top nav (hidden for customer view) */}
      {!isCustomerView && (
        <div className="mb-4 flex justify-between gap-2">
          <PreviousPageButton to="/inspection/menu" />
          <HomeButton />
        </div>
      )}

      {/* AI banner */}
      {aiError && (
        <div className="mb-4 rounded-lg border border-amber-500/60 bg-amber-500/10 px-3 py-2 text-sm text-amber-100">
          {aiError}
        </div>
      )}

      {/* Summary header card */}
      <div className="mb-4 rounded-xl border border-border bg-card/80 px-4 py-3">
        <div className="flex flex-wrap items-center justify-between gap-3">
          <div>
            <h1 className="text-lg font-semibold text-orange-400">
              {isCustomerView
                ? "Inspection Report"
                : "Inspection Summary"}
            </h1>
            <p className="text-xs text-muted-foreground">
              {isCustomerView
                ? "Here’s a summary of the inspection our technician performed on your vehicle."
                : "Review results, photos, and AI-generated quote before sending to the customer."}
            </p>
          </div>
          {hasFailedItems && (
            <div className="rounded-full border border-red-500/40 bg-red-500/10 px-3 py-1 text-xs text-red-200">
              {isCustomerView
                ? "Some items need attention"
                : "Issues found — work order recommended"}
            </div>
          )}
        </div>
      </div>

      {/* Customer & Vehicle info */}
      <div className="mb-6 grid gap-4 rounded-xl border border-border bg-card p-4 md:grid-cols-2">
        <div>
          <h2 className="mb-2 text-sm font-semibold text-neutral-50">
            Customer
          </h2>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Name:{" "}
            </span>
            {customer
              ? `${customer.first_name ?? ""} ${customer.last_name ?? ""}`
              : "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Phone:{" "}
            </span>
            {customer?.phone || "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Email:{" "}
            </span>
            {customer?.email || "—"}
          </p>
        </div>

        <div>
          <h2 className="mb-2 text-sm font-semibold text-neutral-50">
            Vehicle
          </h2>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Year / Make / Model:{" "}
            </span>
            {vehicle
              ? `${vehicle.year ?? ""} ${vehicle.make ?? ""} ${
                  vehicle.model ?? ""
                }`
              : "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              VIN:{" "}
            </span>
            {vehicle?.vin || "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Plate:{" "}
            </span>
            {vehicle?.license_plate || "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Mileage:{" "}
            </span>
            {vehicle?.mileage || "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Color:{" "}
            </span>
            {vehicle?.color || "—"}
          </p>
        </div>
      </div>

      {/* Sections & items */}
      {hasSections ? (
        session.sections.map(
          (section: InspectionSection, sectionIndex: number) => (
            <div
              key={sectionIndex}
              className="mb-6 overflow-hidden rounded-xl border border-border bg-card"
            >
              <div className="bg-muted px-4 py-2 text-sm font-semibold text-neutral-100">
                {section.title}
              </div>
              <div className="space-y-6 p-4">
                {section.items.map(
                  (item: InspectionItem, itemIndex: number) => {
                    const status = item.status ?? "";
                    const statusClass =
                      status === "ok"
                        ? "bg-emerald-500/10 text-emerald-300 border border-emerald-500/40"
                        : status === "fail"
                        ? "bg-red-500/10 text-red-300 border border-red-500/40"
                        : status === "recommend"
                        ? "bg-amber-500/10 text-amber-200 border border-amber-500/40"
                        : "bg-slate-500/10 text-slate-200 border border-slate-500/40";

                    return (
                      <div
                        key={itemIndex}
                        className="space-y-3 border-b border-border/40 pb-4 last:border-b-0 last:pb-0"
                      >
                        <div className="flex items-center justify-between gap-2">
                          <div className="font-semibold">
                            {item.item ?? (item as any).name}
                          </div>
                          {status && (
                            <span
                              className={`rounded-full px-2 py-0.5 text-[11px] uppercase tracking-wide ${statusClass}`}
                            >
                              {status.toUpperCase()}
                            </span>
                          )}
                        </div>

                        {isCustomerView ? (
                          // CUSTOMER READ-ONLY LAYOUT
                          <div className="space-y-1 text-xs md:text-sm text-muted-foreground">
                            {item.notes && (
                              <p>
                                <span className="font-semibold text-foreground">
                                  Notes:{" "}
                                </span>
                                {item.notes}
                              </p>
                            )}
                            {(item.value || item.unit) && (
                              <p>
                                <span className="font-semibold text-foreground">
                                  Measurement:{" "}
                                </span>
                                {item.value ?? "—"}{" "}
                                {item.unit ? item.unit : ""}
                              </p>
                            )}
                          </div>
                        ) : (
                          // INTERNAL EDITABLE LAYOUT
                          <div className="grid grid-cols-1 gap-4 md:grid-cols-4">
                            <label className="flex flex-col gap-1 text-xs md:text-sm">
                              Status
                              <select
                                className="rounded border border-border bg-background px-2 py-1 text-sm"
                                value={item?.status ?? ""}
                                onChange={(e) =>
                                  handleFieldChange(
                                    sectionIndex,
                                    itemIndex,
                                    "status",
                                    e.target.value,
                                  )
                                }
                              >
                                <option value="">Select</option>
                                <option value="ok">OK</option>
                                <option value="fail">Fail</option>
                                <option value="na">N/A</option>
                                <option value="recommend">
                                  Recommend
                                </option>
                              </select>
                            </label>

                            <label className="flex flex-col gap-1 text-xs md:text-sm">
                              Note
                              <input
                                className="rounded border border-border bg-background px-2 py-1 text-sm"
                                value={item?.notes || ""}
                                onChange={(e) =>
                                  handleFieldChange(
                                    sectionIndex,
                                    itemIndex,
                                    "notes",
                                    e.target.value,
                                  )
                                }
                              />
                            </label>

                            <label className="flex flex-col gap-1 text-xs md:text-sm">
                              Value
                              <input
                                className="rounded border border-border bg-background px-2 py-1 text-sm"
                                value={(item?.value as string) || ""}
                                onChange={(e) =>
                                  handleFieldChange(
                                    sectionIndex,
                                    itemIndex,
                                    "value",
                                    e.target.value,
                                  )
                                }
                              />
                            </label>

                            <label className="flex flex-col gap-1 text-xs md:text-sm">
                              Unit
                              <input
                                className="rounded border border-border bg-background px-2 py-1 text-sm"
                                value={item?.unit || ""}
                                onChange={(e) =>
                                  handleFieldChange(
                                    sectionIndex,
                                    itemIndex,
                                    "unit",
                                    e.target.value,
                                  )
                                }
                              />
                            </label>
                          </div>
                        )}

                        {Array.isArray(item?.photoUrls) &&
                          item.photoUrls.length > 0 && (
                            <div className="mt-2 flex flex-wrap gap-2">
                              {item.photoUrls.map(
                                (url: string, i: number) => (
                                  <img
                                    key={i}
                                    src={url}
                                    alt="Uploaded"
                                    className="max-h-32 rounded border border-border/60 object-cover"
                                  />
                                ),
                              )}
                            </div>
                          )}
                      </div>
                    );
                  },
                )}
              </div>
            </div>
          ),
        )
      ) : (
        <div className="mb-6 rounded-xl border border-dashed border-border bg-card/60 p-4 text-sm text-muted-foreground">
          No inspection sections found in this session. Go back and start an
          inspection again.
        </div>
      )}

      {/* Quote viewer */}
      {quoteLines.length > 0 && (
        <div className="my-6 rounded-xl border border-border bg-card p-4">
          <QuoteViewer summary={summaryText} quote={quoteLines} />
        </div>
      )}

      {/* Sticky footer actions */}
      <div className="fixed inset-x-0 bottom-0 border-t border-border bg-background/95 px-4 py-3 backdrop-blur">
        <div className="mx-auto flex max-w-3xl flex-col gap-2 sm:flex-row">
          {!isCustomerView && hasFailedItems && (
            <Button
              variant="default"
              className="w-full bg-orange-600 hover:bg-orange-500"
              onClick={handleAddToWorkOrder}
              disabled={!hasFailedItems || isAddingToWorkOrder}
            >
              {isAddingToWorkOrder
                ? "Adding to work order…"
                : "Add failed items to work order"}
            </Button>
          )}

          <Button
            variant={isCustomerView ? "default" : "outline"}
            className={`w-full ${
              isCustomerView
                ? "bg-green-600 text-white hover:bg-green-500"
                : "border-emerald-500/60 text-emerald-300 hover:bg-emerald-500/10"
            }`}
            onClick={handleSubmit}
            disabled={downloading}
          >
            {downloading
              ? "Preparing PDF…"
              : isCustomerView
              ? "Download inspection PDF"
              : "Submit inspection & download PDF"}
          </Button>
        </div>
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/inspections/app/inspection/maintenance50/page.tsx */
/* =============================== */

// features/inspections/app/inspection/maintenance50/page.tsx
"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/lib/inspection/ui/CornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";

import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import toast from "react-hot-toast";

/* Header adapters */
type HeaderCustomer = {
  first_name: string;
  last_name: string;
  phone: string;
  email: string;
  address: string;
  city: string;
  province: string;
  postal_code: string;
};

type HeaderVehicle = {
  year: string;
  make: string;
  model: string;
  vin: string;
  license_plate: string;
  mileage: string;
  color: string;
  unit_number: string;
  engine_hours: string;
};

function toHeaderCustomer(c?: SessionCustomer | null): HeaderCustomer {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}

function toHeaderVehicle(v?: SessionVehicle | null): HeaderVehicle {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/* Sections */
function buildHydraulicMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Hydraulic)",
    items: [
      { item: "LF Tire Pressure", unit: "psi", value: "" },
      { item: "RF Tire Pressure", unit: "psi", value: "" },
      { item: "LR Tire Pressure", unit: "psi", value: "" },
      { item: "RR Tire Pressure", unit: "psi", value: "" },
      { item: "LF Tire Tread", unit: "mm", value: "" },
      { item: "RF Tire Tread", unit: "mm", value: "" },
      { item: "LR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "LR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "LF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "LR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "Wheel Torque (after road test)", unit: "ft·lb", value: "" },
    ],
  };
}
function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}
function buildBrakesSection(): InspectionSection {
  return {
    title: "Brakes",
    items: [
      { item: "Front brake pads" },
      { item: "Rear brake pads" },
      { item: "Brake fluid level" },
      { item: "Brake lines and hoses" },
      { item: "ABS wiring / sensors" },
      { item: "Brake warning lights" },
    ],
  };
}
function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
    ],
  };
}
function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "CV shafts / joints" },
      { item: "Transmission leaks / mounts" },
      { item: "Transfer case leaks / mounts" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* Units helpers */
function unitForHydraulic(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tire tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad thickness")) return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}
function applyUnitsHydraulic(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    if ((s.title || "").toLowerCase().includes("measurements")) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForHydraulic(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }
    return s;
  });
}

/* Page */
export default function Maintenance50HydraulicPage(): JSX.Element {
  const searchParams = useSearchParams();

  // embed mode in iframe
  const isEmbed = useMemo(
    () =>
      ["1", "true", "yes"].includes(
        (searchParams.get("embed") || searchParams.get("compact") || "").toLowerCase()
      ),
    [searchParams]
  );

  const workOrderLineId = searchParams.get("workOrderLineId") || null;
  const workOrderId = searchParams.get("workOrderId") || null;
  const inspectionId = useMemo<string>(
    () => searchParams.get("inspectionId") || uuidv4(),
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string =
    searchParams.get("template") || "Maintenance 50 (Hydraulic)";

  const customer: SessionCustomer = {
    first_name: searchParams.get("first_name") || "",
    last_name: searchParams.get("last_name") || "",
    phone: searchParams.get("phone") || "",
    email: searchParams.get("email") || "",
    address: searchParams.get("address") || "",
    city: searchParams.get("city") || "",
    province: searchParams.get("province") || "",
    postal_code: searchParams.get("postal_code") || "",
  };

  const vehicle: SessionVehicle = {
    year: searchParams.get("year") || "",
    make: searchParams.get("make") || "",
    model: searchParams.get("model") || "",
    vin: searchParams.get("vin") || "",
    license_plate: searchParams.get("license_plate") || "",
    mileage: searchParams.get("mileage") || "",
    color: searchParams.get("color") || "",
    unit_number: searchParams.get("unit_number") || "",
    engine_hours: searchParams.get("engine_hours") || "",
  };

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  // prevent duplicate AI submits
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      // 1) placeholder for local quote UI
      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      // 2) AI suggestion with vehicle context
      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      // 3) Persist to WO (awaiting approval)
      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // Boot / restore
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Persist session
  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  // Persist on unload/visibility
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // Build sections on first load
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;
    const next: InspectionSection[] = [
      buildHydraulicMeasurementsSection(),
      buildLightsSection(),
      buildBrakesSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsHydraulic(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  // Apply units when toggled
  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsHydraulic(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  // Header backfill via API when launched from FocusedJobModal
  useEffect(() => {
    (async () => {
      if (!session || !workOrderId) return;
      const haveName =
        (session.customer?.first_name || session.customer?.last_name || "").trim().length > 0;
      const haveVehicle =
        (session.vehicle?.make || session.vehicle?.model || "").trim().length > 0;
      if (haveName && haveVehicle) return;

      try {
        const res = await fetch(`/api/work-orders/header?id=${workOrderId}`);
        if (!res.ok) return;

        const j = (await res.json()) as {
          customer?: Partial<SessionCustomer>;
          vehicle?: Partial<SessionVehicle>;
        };

        const nextCust: Partial<SessionCustomer> = {
          ...(session.customer ?? {}),
          ...(j.customer ?? {}),
        };
        const nextVeh: Partial<SessionVehicle> = {
          ...(session.vehicle ?? {}),
          ...(j.vehicle ?? {}),
        };

        updateInspection({
          customer: nextCust,
          vehicle: nextVeh,
        } as Partial<InspectionSession>);
      } catch {
        // silent fail
      }
    })();
  }, [session, workOrderId, updateInspection]);

  // Transcript handler
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;

    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // Start listening
  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };

  // stop on unmount
  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-white">Loading inspection…</div>;
  }

  const isMeasurements = (t?: string): boolean =>
    (t || "").toLowerCase().includes("measurements");

  // ------- Bare embed: NO app chrome when isEmbed -------
  const shell = isEmbed ? "mx-auto max-w-[1100px] px-3 pb-8" : "px-4 pb-14";
  const controlsGap = "mb-4 grid grid-cols-3 gap-2";
  const card =
    "rounded-lg border border-zinc-800 bg-zinc-900 " +
    (isEmbed ? "p-3 mb-6" : "p-4 mb-8");
  const sectionTitle = "text-xl font-semibold text-orange-400 text-center";
  const hint = "text-xs text-zinc-400" + (isEmbed ? " mt-1 block text-center" : "");

  // ----- BODY -----
  const Body = (
    <div className={shell}>
      {/* Hide global chrome if embedded */}
      {isEmbed && (
        <>
          {/* Add marker classes + robust, persistent chrome hider */}
          <script
            dangerouslySetInnerHTML={{
              __html: `
                (function(){
                  var html = document.documentElement;
                  var body = document.body || document.getElementsByTagName('body')[0];
                  html && html.classList.add('inspection-embed');
                  body && body.classList.add('inspection-embed');

                  var CSS = \`
                    html.inspection-embed, body.inspection-embed { background:#000 !important; overflow:auto !important; }

                    /* Hide common app chrome */
                    .inspection-embed header,
                    .inspection-embed nav,
                    .inspection-embed aside,
                    .inspection-embed footer,
                    .inspection-embed [data-app-chrome],
                    .inspection-embed [data-app-header],
                    .inspection-embed [data-app-nav],
                    .inspection-embed [data-app-sidebar],
                    .inspection-embed [data-app-footer],
                    .inspection-embed .app-shell,
                    .inspection-embed .app-shell-nav,
                    .inspection-embed .app-shell-header,
                    .inspection-embed .app-shell-footer,
                    .inspection-embed .app-sidebar,
                    .inspection-embed .app-topbar,
                    .inspection-embed .nav-tabs,
                    .inspection-embed .tabs-bar,
                    .inspection-embed .dashboard-tabs,
                    .inspection-embed .global-nav,
                    .inspection-embed .global-header,
                    .inspection-embed .global-footer {
                      display: none !important;
                      visibility: hidden !important;
                    }

                    /* Let the page content expand edge-to-edge */
                    .inspection-embed main,
                    .inspection-embed [data-app-content],
                    .inspection-embed .app-content,
                    .inspection-embed #__next > *:not(main) {
                      margin: 0 !important;
                      padding: 0 !important;
                      width: 100% !important;
                      max-width: none !important;
                    }

                    /* Guard against fixed headers/footers */
                    .inspection-embed *[style*="position: fixed"],
                    .inspection-embed *[style*="position:sticky"] {
                      display: none !important;
                    }
                  \`;

                  var s = document.createElement('style');
                  s.setAttribute('data-inspection-embed-style','1');
                  s.type = 'text/css';
                  s.appendChild(document.createTextNode(CSS));
                  document.head.appendChild(s);

                  /* MutationObserver to re-hide chrome if layouts mount late */
                  var targets = [
                    document.body,
                    document.querySelector('#__next'),
                    document.documentElement
                  ].filter(Boolean);

                  var again = function() {
                    if (!document.querySelector('style[data-inspection-embed-style]')) {
                      var s2 = document.createElement('style');
                      s2.setAttribute('data-inspection-embed-style','1');
                      s2.type = 'text/css';
                      s2.appendChild(document.createTextNode(CSS));
                      document.head.appendChild(s2);
                    }
                  };

                  var mo = new MutationObserver(function() { again(); });
                  targets.forEach(function(t){
                    try { mo.observe(t, { childList: true, subtree: true, attributes: true }); } catch(e){}
                  });
                })();
              `,
            }}
          />
        </>
      )}

      <div className={card}>
        <div className="text-center text-lg font-semibold text-orange-400">
          {templateName}
        </div>
        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      <div className={controlsGap}>
        <StartListeningButton
          isListening={isListening}
          setIsListening={setIsListening}
          onStart={startListening}
        />
        <PauseResumeButton
          isPaused={isPaused}
          isListening={isListening}
          setIsListening={setIsListening}
          onPause={(): void => {
            setIsPaused(true);
            pauseSession();
            try {
              recognitionRef.current?.stop();
            } catch {}
          }}
          onResume={(): void => {
            setIsPaused(false);
            resumeSession();
            recognitionRef.current = startVoiceRecognition(handleTranscript);
          }}
          recognitionInstance={recognitionRef.current as unknown as SpeechRecognition | null}
          onTranscript={handleTranscript}
          setRecognitionRef={(instance: SpeechRecognition | null): void => {
            (recognitionRef as React.MutableRefObject<SpeechRecognition | null>).current =
              instance ?? null;
          }}
        />
        <button
          onClick={(): void => setUnit(unit === "metric" ? "imperial" : "metric")}
          className="w-full rounded bg-zinc-700 py-2 text-white hover:bg-zinc-600"
        >
          Unit: {unit === "metric" ? "Metric" : "Imperial"}
        </button>
      </div>

      <ProgressTracker
        currentItem={session.currentItemIndex}
        currentSection={session.currentSectionIndex}
        totalSections={session.sections.length}
        totalItems={session.sections[session.currentSectionIndex]?.items.length || 0}
      />

      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={card}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isMeasurements(section.title) && (
              <span className={hint}>
                {unit === "metric" ? "Enter mm / kPa / N·m" : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className={isEmbed ? "mt-3" : "mt-4"}>
              {isMeasurements(section.title) ? (
                <CornerGrid sectionIndex={sectionIndex} items={section.items} />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes={true}
                  showPhotos={true}
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    // Only update status here — AI flow moved to explicit Submit
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(secIdx: number, itemIdx: number, note: string): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(photoUrl: string, secIdx: number, itemIdx: number): void => {
                    const prev = session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, { photoUrls: [...prev, photoUrl] });
                  }}
                  /* require note + explicit submit to run AI */
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) => {
                    void submitAIForItem(secIdx, itemIdx);
                  }}
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      <div
        className={
          "flex items-center justify-between gap-4 " + (isEmbed ? "mt-6" : "mt-8")
        }
      >
        {/* Pass workOrderLineId down; disable when missing */}
        <div className="flex items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
        </div>

        {!workOrderLineId && (
          <div className="text-xs text-red-400">
            Missing <code>workOrderLineId</code> in URL — save/finish will be blocked.
          </div>
        )}

        <div className="ml-auto text-xs text-zinc-400">
          P = PASS, F = FAIL, NA = Not Applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;
  return Body;
}

/* =============================== */
/* FILE: features/inspections/app/inspection/maintenance50-air/page.tsx */
/* =============================== */

"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import AirCornerGrid from "@inspections/lib/inspection/ui/AirCornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";

import { buildAirAxleItems } from "@inspections/lib/inspection/builders/addAxleHelpers";
import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* ------------------------------ Header adapters ------------------------------ */
type HeaderCustomer = {
  first_name: string;
  last_name: string;
  phone: string;
  email: string;
  address: string;
  city: string;
  province: string;
  postal_code: string;
};

type HeaderVehicle = {
  year: string;
  make: string;
  model: string;
  vin: string;
  license_plate: string;
  mileage: string;
  color: string;
  unit_number: string;
  engine_hours: string;
};

function toHeaderCustomer(c?: SessionCustomer | null): HeaderCustomer {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}

function toHeaderVehicle(v?: SessionVehicle | null): HeaderVehicle {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/* ------------------------------ Section builders (AIR) ------------------------------ */
function buildAirCornerMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Air – Corner Checks)",
    items: [
      { item: "Steer 1 Left Tire Pressure", unit: "psi", value: "" },
      { item: "Steer 1 Right Tire Pressure", unit: "psi", value: "" },

      { item: "Steer 1 Left Tread Depth", unit: "mm", value: "" },
      { item: "Steer 1 Right Tread Depth", unit: "mm", value: "" },

      { item: "Steer 1 Left Lining/Shoe Thickness", unit: "mm", value: "" },
      { item: "Steer 1 Right Lining/Shoe Thickness", unit: "mm", value: "" },

      { item: "Steer 1 Left Drum/Rotor Condition", unit: "", value: "" },
      { item: "Steer 1 Right Drum/Rotor Condition", unit: "", value: "" },

      { item: "Steer 1 Left Push Rod Travel", unit: "in", value: "" },
      { item: "Steer 1 Right Push Rod Travel", unit: "in", value: "" },
    ],
  };
}

function buildAirSystemMeasurementsSection(): InspectionSection {
  return {
    title: "Air System Measurements",
    items: [
      { item: "Air Build Time (90→120)", unit: "sec", value: "" },
      { item: "Gov Cut-In", unit: "psi", value: "" },
      { item: "Gov Cut-Out", unit: "psi", value: "" },
      { item: "Leak Rate @ Cut-Out", unit: "psi/min", value: "" },
      { item: "Low Air Warning Activates", unit: "psi", value: "" },
      { item: "Compressor Cut-Out Ref", unit: "psi", value: "" },
      { item: "Torque Reference", unit: "ft·lb", value: "" },
    ],
  };
}

function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}

function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension / Steering",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
      { item: "Tie-rods / drag link / steering gear leaks" },
    ],
  };
}

function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline / Axles",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* ------------------------------ Units helpers (AIR) ------------------------------ */
function unitForAir(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("tire pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("lining") || l.includes("shoe")) return mode === "metric" ? "mm" : "in";
  if (l.includes("drum") || l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("push rod")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}

function applyUnitsAir(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    const isCorner = (s.title || "").toLowerCase().includes("corner");
    const isAirMeas = (s.title || "").toLowerCase().includes("air system");

    if (isCorner) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForAir(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }

    if (isAirMeas) {
      const items = s.items.map((it) => {
        const label = (it.item ?? "").toLowerCase();
        if (label.includes("build time")) return { ...it, unit: "sec" };
        if (label.includes("leak"))
          return { ...it, unit: mode === "metric" ? "kPa/min" : "psi/min" };
        if (label.includes("gov") || label.includes("warning") || label.includes("compressor"))
          return { ...it, unit: mode === "metric" ? "kPa" : "psi" };
        if (label.includes("torque")) return { ...it, unit: mode === "metric" ? "N·m" : "ft·lb" };
        return it;
      });
      return { ...s, items };
    }

    return s;
  });
}

/* ------------------------------ Page (Screen) ------------------------------ */
export default function Maintenance50AirPage(): JSX.Element {
  const searchParams = useSearchParams();
  const rootRef = useRef<HTMLDivElement | null>(null);

  // 🔸 voice only on mobile companion
  const isMobileView =
    (searchParams.get("view") || "").toLowerCase() === "mobile";

  const isEmbed = useMemo(() => {
    const flag =
      ["1", "true", "yes"].includes(
        (searchParams.get("embed") || searchParams.get("compact") || "").toLowerCase()
      );
    const inIframe =
      typeof window !== "undefined" && window.self !== window.top;
    return flag || inIframe;
  }, [searchParams]);

  const workOrderLineId = searchParams.get("workOrderLineId") || null;
  const workOrderId = searchParams.get("workOrderId") || null;

  const inspectionId = useMemo<string>(
    () => searchParams.get("inspectionId") || uuidv4(),
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string =
    searchParams.get("template") || "Maintenance 50 (Air Brake CVIP)";

  const customer: SessionCustomer = {
    first_name: searchParams.get("first_name") || "",
    last_name: searchParams.get("last_name") || "",
    phone: searchParams.get("phone") || "",
    email: searchParams.get("email") || "",
    address: searchParams.get("address") || "",
    city: searchParams.get("city") || "",
    province: searchParams.get("province") || "",
    postal_code: searchParams.get("postal_code") || "",
  };

  const vehicle: SessionVehicle = {
    year: searchParams.get("year") || "",
    make: searchParams.get("make") || "",
    model: searchParams.get("model") || "",
    vin: searchParams.get("vin") || "",
    license_plate: searchParams.get("license_plate") || "",
    mileage: searchParams.get("mileage") || "",
    color: searchParams.get("color") || "",
    unit_number: searchParams.get("unit_number") || "",
    engine_hours: searchParams.get("engine_hours") || "",
  };

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  /* ---------- AI submit flow ---------- */
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  /* ---------- hydrate / persist ---------- */
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };

    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };

    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);

    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  /* ---------- sections + unit toggle ---------- */
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;

    const next: InspectionSection[] = [
      buildAirCornerMeasurementsSection(),
      buildAirSystemMeasurementsSection(),
      buildLightsSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsAir(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsAir(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  /* ---------- speech → commands ---------- */
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;

    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };

  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  /* 🧹 embed-safe scrubber */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  /* 🔐 focus trap when embedded */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-white">Loading inspection…</div>;
  }

  const isCorner = (t?: string): boolean =>
    (t || "").toLowerCase().includes("corner");

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const Body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Maintenance 50 – Air Brake CVIP"}
          </div>
        </div>
        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      {/* Controls */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              try {
                recognitionRef.current?.stop();
              } catch {}
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              recognitionRef.current = startVoiceRecognition(handleTranscript);
            }}
            recognitionInstance={
              recognitionRef.current as unknown as SpeechRecognition | null
            }
            onTranscript={handleTranscript}
            setRecognitionRef={(instance: SpeechRecognition | null): void => {
              (
                recognitionRef as React.MutableRefObject<SpeechRecognition | null>
              ).current = instance ?? null;
            }}
          />
        )}

        {/* Unit toggle always available */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      {/* Sections */}
      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isCorner(section.title) && (
              <span className={hint}>
                {unit === "metric"
                  ? "Enter mm / kPa / N·m"
                  : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className="mt-4">
              {isCorner(section.title) ? (
                <AirCornerGrid
                  sectionIndex={sectionIndex}
                  items={section.items}
                  unitHint={(label: string) => unitForAir(label, unit)}
                  onAddAxle={(axleLabel: string) => {
                    const extra = buildAirAxleItems(axleLabel);
                    updateSection(sectionIndex, {
                      items: [...section.items, ...extra],
                    });
                  }}
                />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes
                  showPhotos
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(
                    secIdx: number,
                    itemIdx: number,
                    note: string
                  ): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(
                    photoUrl: string,
                    secIdx: number,
                    itemIdx: number
                  ): void => {
                    const prev =
                      session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, {
                      photoUrls: [...prev, photoUrl],
                    });
                  }}
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) => {
                    void submitAIForItem(secIdx, itemIdx);
                  }}
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      {/* Footer */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Maintenance 50 – Air Brake CVIP"}
      description="Air-brake CVIP multi-axle inspection."
    >
      {Body}
    </PageShell>
  );
}

/* =============================== */
/* FILE: features/inspections/components/inspection/FinishInspectionButton.tsx */
/* =============================== */

// features/inspections/components/inspection/FinishInspectionButton.tsx
"use client";

import React, { useState } from "react";
import { toast } from "sonner";
import { Button } from "@shared/components/ui/Button";

type Props = {
  session: any;
  workOrderLineId?: string | null;
};

export default function FinishInspectionButton({
  session,
  workOrderLineId,
}: Props) {
  const [busy, setBusy] = useState(false);

  function buildCorrectionFromSession(s: any): {
    cause: string;
    correction: string;
  } {
    const raw = s?.quote;
    const items: any[] = Array.isArray(raw) ? raw : raw ? [raw] : [];

    const failed = items.filter(
      (i) => (i?.status ?? "").toLowerCase() === "fail",
    );
    const recommended = items.filter(
      (i) => (i?.status ?? "").toLowerCase() === "recommend",
    );

    if (failed.length === 0 && recommended.length === 0) {
      return {
        cause: "Inspection completed.",
        correction:
          "Inspection completed. No failed or recommended items were recorded.",
      };
    }

    const parts: string[] = [];

    if (failed.length) {
      parts.push(
        `Failed items: ${failed
          .map((f) => f?.description || f?.notes || "Item")
          .join("; ")}.`,
      );
    }

    if (recommended.length) {
      parts.push(
        `Recommended items: ${recommended
          .map((r) => r?.description || r?.notes || "Item")
          .join("; ")}.`,
      );
    }

    return {
      cause: "Inspection found items requiring attention.",
      correction: parts.join(" "),
    };
  }

  const handleFinish = async () => {
    if (!workOrderLineId) {
      toast.error("Missing work order line id — can’t finish.");
      return;
    }
    if (busy) return;
    setBusy(true);

    const { cause, correction } = buildCorrectionFromSession(session);

    try {
      const res = await fetch(
        `/api/work-orders/lines/${workOrderLineId}/finish`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ cause, correction }),
        },
      );

      const json = await res.json().catch(() => null);
      if (!res.ok) {
        throw new Error(json?.error || "Failed to finish inspection");
      }

      if (typeof window !== "undefined") {
        window.dispatchEvent(
          new CustomEvent("inspection:completed", {
            detail: {
              workOrderLineId,
              cause,
              correction,
            },
          }),
        );
      }

      toast.success("Inspection finished.");
    } catch (e: any) {
      toast.error(e?.message ?? "Unable to finish inspection");
    } finally {
      setBusy(false);
    }
  };

  return (
    <Button
      onClick={handleFinish}
      disabled={busy}
      variant="orange"
      size="md"
      type="button"
      className="font-semibold"
    >
      {busy ? "Finishing…" : "Finish inspection"}
    </Button>
  );
}

/* =============================== */
/* FILE: features/inspections/components/inspection/quote.ts */
/* =============================== */

// lib/inspection/quote.ts

export type InspectionItemStatus = "ok" | "fail" | "na" | "recommend";

export interface QuoteLine {
  id: string;
  inspectionItemId?: string;
  sectionId?: string;
  status?: InspectionItemStatus;
  description?: string;
  note?: string;
  notes?: string;
  laborTime?: number; // in hours
  laborRate?: number; // shop-configured or default
  parts?: {
    name: string;
    price: number;
  }[];
  type?: "economy" | "premium" | "oem" | "custom";
  price?: number;
  totalCost?: number;
  editable?: boolean;
}


/* =============================== */
/* FILE: features/inspections/hooks/useInspectionSession.ts */
/* =============================== */

"use client";

import { useState } from "react";
import {
  InspectionItem,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,      // ⬅️ use only QuoteLineItem here
  BrakeType,
} from "@inspections/lib/inspection/types";

type AxleLayoutConfig = { axleCount: number; brakeType: BrakeType };

function generateAxleSections({ axleCount, brakeType }: AxleLayoutConfig): InspectionSection[] {
  const sections: InspectionSection[] = [];

  for (let i = 1; i <= axleCount; i++) {
    const title = `Axle ${i}`;
    const items: InspectionItem[] = [
      { item: "Left Tread Depth",  name: "Left Tread Depth",  value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Right Tread Depth", name: "Right Tread Depth", value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Left Tire Pressure",  name: "Left Tire Pressure",  value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Right Tire Pressure", name: "Right Tire Pressure", value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Left Lining Thickness",  name: "Left Lining Thickness",  value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Right Lining Thickness", name: "Right Lining Thickness", value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Wheel Torque", name: "Wheel Torque", value: null, unit: "ft lbs", notes: "", photoUrls: [] },
    ];

    if (brakeType === "air") {
      items.push(
        { item: "Left Push Rod Travel",  name: "Left Push Rod Travel",  value: null, unit: "in", notes: "", photoUrls: [] },
        { item: "Right Push Rod Travel", name: "Right Push Rod Travel", value: null, unit: "in", notes: "", photoUrls: [] },
      );
    }

    sections.push({ title, items });
  }

  return sections;
}

export default function useInspectionSession(initialSession?: Partial<InspectionSession>) {
  const [session, setSession] = useState<InspectionSession>(() => ({
    id: "",
    vehicleId: "",
    customerId: "",
    workOrderId: "",
    templateId: "",
    templateName: "",
    location: "",
    currentSectionIndex: 0,
    currentItemIndex: 0,
    transcript: "",
    status: "not_started",
    started: false,
    completed: false,
    isListening: false,
    isPaused: false,
    quote: [],                                 // ⬅️ QuoteLineItem[]
    lastUpdated: new Date().toISOString(),
    customer: {
      first_name: "",
      last_name: "",
      phone: "",
      email: "",
      address: "",
      city: "",
      province: "",
      postal_code: "",
    },
    vehicle: {
      year: "",
      make: "",
      model: "",
      vin: "",
      license_plate: "",
      mileage: "",
      color: "",
    },
    sections: [],
    ...initialSession,
  }));

  const stamp = () => ({ lastUpdated: new Date().toISOString() });

  const updateInspection = (updates: Partial<InspectionSession>) =>
    setSession(prev => ({ ...prev, ...updates, ...stamp() }));

  const updateSection = (sectionIndex: number, updates: Partial<InspectionSection>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      sections[sectionIndex] = { ...sections[sectionIndex], ...updates };
      return { ...prev, sections, ...stamp() };
    });

  const updateItem = (sectionIndex: number, itemIndex: number, updates: Partial<InspectionItem>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      const items = [...sections[sectionIndex].items];
      items[itemIndex] = { ...items[itemIndex], ...updates };
      sections[sectionIndex] = { ...sections[sectionIndex], items };
      return { ...prev, sections, ...stamp() };
    });

  // ✅ strictly QuoteLineItem (the normalized/store+PDF shape)
  const addQuoteLine = (line: QuoteLineItem) =>
    setSession(prev => ({ ...prev, quote: [...(prev.quote ?? []), line], ...stamp() }));

  const updateQuoteLines = (lines: QuoteLineItem[]) =>
    setSession(prev => ({ ...prev, quote: lines, ...stamp() }));

  // ✅ targeted updater for enriching a single line (AI merge, edits, etc.)
  const updateQuoteLine = (id: string, patch: Partial<QuoteLineItem>) =>
    setSession(prev => ({
      ...prev,
      quote: (prev.quote ?? []).map((l) => (l.id === id ? { ...l, ...patch } : l)),
      ...stamp(),
    }));

  const startSession = (sessionData: Partial<InspectionSession> & { axleConfig?: AxleLayoutConfig }) => {
    const { axleConfig, ...rest } = sessionData;
    const newSections =
      axleConfig?.axleCount && axleConfig?.brakeType
        ? generateAxleSections(axleConfig)
        : sessionData.sections || session.sections;

    setSession(prev => ({
      ...prev,
      ...rest,
      sections: newSections,
      currentSectionIndex: 0,
      currentItemIndex: 0,
      transcript: "",
      started: true,
      completed: false,
      status: "in_progress",
      isPaused: false,
      ...stamp(),
    }));
  };

  const pauseSession  = () => updateInspection({ isPaused: true,  status: "paused" });
  const resumeSession = () => updateInspection({ isPaused: false, status: "in_progress" });
  const finishSession = () => updateInspection({ completed: true, status: "completed", isPaused: false });
  const setIsListening = (value: boolean) => updateInspection({ isListening: value });

  return {
    session,
    updateInspection,
    updateSection,
    updateItem,
    addQuoteLine,
    updateQuoteLines,
    updateQuoteLine,   // ⬅️ expose the targeted updater
    startSession,
    pauseSession,
    resumeSession,
    finishSession,
    setIsListening,
    isPaused: session.isPaused,
  };
}

/* =============================== */
/* FILE: features/shared/config/tiles.ts */
/* =============================== */

// features/shared/config/tiles.ts
export type Role =
  | "owner"
  | "admin"
  | "manager"
  | "advisor"
  | "mechanic"
  | "parts";

export type Scope =
  | "work_orders"
  | "inspections"
  | "parts"
  | "tech"
  | "management"
  | "settings"
  | "appointments"
  | "all";

export type Tile = {
  href: string;
  title: string;
  subtitle?: string;
  cta?: string;
  roles: Role[];
  scopes: Scope[];
  section?: string; // for sidebar grouping, e.g. "Operations"
};

export const TILES: Tile[] = [
  // --- Work Orders ---
  {
    href: "/work-orders/create?autostart=1",
    title: "Create Work Order",
    subtitle: "Start a new job",
    cta: "+",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/work-orders/view",
    title: "View Work Orders",
    subtitle: "Browse & manage",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/work-orders/queue",
    title: "Job Queue",
    subtitle: "Active & in-progress",
    roles: ["mechanic", "manager", "owner", "admin"],
    scopes: ["work_orders", "tech", "all"],
    section: "Operations",
  },
  {
    href: "/work-orders/quote-review",
    title: "Quote Review",
    subtitle: "Review & send estimates",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/menu",
    title: "Service Menu",
    subtitle: "Saved services & presets",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/work-orders/history",
    title: "History",
    subtitle: "Completed work",
    roles: ["owner", "admin", "manager", "advisor", "mechanic"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/billing",
    title: "Billing",
    subtitle: "Ready to invoice",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },

  // --- Appointments (new admin page you wanted) ---
  {
    href: "/dashboard/admin/appointments",
    title: "Appointments",
    subtitle: "Schedule & manage",
    roles: ["owner", "admin", "manager", "advisor"],
    scopes: ["appointments", "management", "all"],
    section: "Operations",
  },

  // --- Inspections ---
  {
    href: "/inspections/maintenance50",
    title: "Maintenance 50",
    subtitle: "Quick checklist",
    roles: ["advisor", "manager", "owner", "admin", "mechanic"],
    scopes: ["inspections", "all"],
    section: "Inspections",
  },
  {
    href: "/inspections/maintenance50-air",
    title: "Maintenance 50 – Air",
    subtitle: "CVIP-style",
    roles: ["advisor", "manager", "owner", "admin", "mechanic"],
    scopes: ["inspections", "all"],
    section: "Inspections",
  },
  {
    href: "/inspections/custom-inspection",
    title: "Custom Builder",
    subtitle: "Design your own",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
    section: "Inspections",
  },
  {
    href: "/inspections/saved",
    title: "Saved Inspections",
    subtitle: "Recent & drafts",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
    section: "Inspections",
  },

  // --- Parts ---
  {
    href: "/parts",
    title: "Parts Dashboard",
    subtitle: "Orders & receiving",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
    section: "Parts",
  },
  {
    href: "/parts/requests",
    title: "Requests",
    subtitle: "View requests",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
    section: "Parts",
  },
  {
    href: "/parts/inventory",
    title: "Inventory",
    subtitle: "On-hand stock",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
    section: "Parts",
  },
  {
    href: "/parts/po",
    title: "Purchase Orders",
    subtitle: "Create & manage POs",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
    section: "Parts",
  },
  {
    href: "/parts/vendors",
    title: "Vendor Integrations",
    subtitle: "API keys for suppliers",
    roles: ["owner", "admin", "manager", "parts"],
    scopes: ["parts", "settings", "all"],
    section: "Parts",
  },

  // --- Admin / Management ---
  {
    href: "/dashboard/owner/create-user",
    title: "Create User",
    subtitle: "Add team members",
    roles: ["owner", "admin"],
    scopes: ["management", "all"],
    section: "Admin",
  },
  {
    href: "/dashboard/admin/scheduling",
    title: "Scheduling",
    subtitle: "Calendar & bookings",
    roles: ["owner", "admin", "manager", "advisor"],
    scopes: ["management", "all"],
    section: "Admin",
  },
  {
    href: "/dashboard/admin/shops",
    title: "Shops",
    subtitle: "Locations & hours",
    roles: ["owner", "admin"],
    scopes: ["management", "all"],
    section: "Admin",
  },
  {
    href: "/dashboard/admin/billing",
    title: "Billing",
    subtitle: "Subscriptions",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
    section: "Admin",
  },
  {
    href: "/dashboard/admin/audit",
    title: "Audit Logs",
    subtitle: "Security",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
    section: "Admin",
  },
  {
    href: "/ai/assistant",
    title: "AI Assistant",
    subtitle: "Help & automation",
    roles: ["owner", "admin", "manager", "advisor", "mechanic", "parts"],
    scopes: ["tech", "all"],
    section: "Tools",
  },
];

/* =============================== */
/* FILE: features/shared/lib/email/email/sendQuoteEmail.ts */
/* =============================== */

// @shared/lib/email/email/sendQuoteEmail.ts
import { createClient } from "@supabase/supabase-js";

/**
 * NOTE: keep this module server-only. Do not import it in client components.
 */
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!, // server-only key
);

export type SendQuoteEmailParams = {
  to: string;
  workOrderId: string;
  /** Base64-encoded PDF bytes (optional). */
  pdfBuffer?: string;
  /** Public URL to the PDF (optional). */
  pdfUrl?: string | null;
};

export async function sendQuoteEmail({
  to,
  workOrderId,
  pdfBuffer,
  pdfUrl,
}: SendQuoteEmailParams): Promise<void> {
  const subject = `Inspection Summary & Quote – Work Order ${workOrderId}`;

  const linkLine = pdfUrl ? `\n\nView your quote online: ${pdfUrl}` : "";
  const text =
    `Attached is your inspection summary and quote for Work Order ${workOrderId}.` +
    (pdfBuffer ? "" : "\n\n(No attachment was included.)") +
    linkLine;

  // Build the payload conditionally
  const body: Record<string, unknown> = {
    to,
    subject,
    text,
  };

  if (pdfBuffer) {
    body.attachments = [
      {
        filename: `Inspection_Summary_${workOrderId}.pdf`,
        content: pdfBuffer, // base64 string
      },
    ];
  }

  const { error } = await supabase.functions.invoke("send-email", { body });

  if (error) {
    console.error("Failed to send quote email:", error);
    throw error;
  }
}

/* =============================== */
/* FILE: features/shared/lib/plan/features.ts */
/* =============================== */

// Types for access control by plan
export type FeatureAccess = {
  diy: boolean;
  pro: boolean;
  proPlus: boolean;
  addOnAvailable?: boolean;
};

export type FeatureKey =
  | "ai_diagnosis"
  | "inspection_flow"
  | "photo_to_quote"
  | "work_orders"
  | "chatbot"
  | "smart_scheduling"
  | "customer_portal"
  | "voice_input"
  | "parts_lookup"
  | "deferred_work_tracking";

export type Feature = {
  key: FeatureKey;
  title: string;
  description: string;
  access: FeatureAccess;
};

// Full feature config list
export const features: Feature[] = [
  {
    key: "ai_diagnosis",
    title: "AI Diagnosis",
    description:
      "Use image and text to identify mechanical problems automatically.",
    access: { diy: false, pro: true, proPlus: true, addOnAvailable: true },
  },
  {
    key: "inspection_flow",
    title: "Inspection Flow",
    description:
      "Voice-guided inspections, summary review, and quote generation.",
    access: { diy: false, pro: true, proPlus: true, addOnAvailable: true },
  },
  {
    key: "photo_to_quote",
    title: "Photo to Quote",
    description: "Take photos and let the AI generate repair quotes.",
    access: { diy: false, pro: true, proPlus: true, addOnAvailable: true },
  },
  {
    key: "work_orders",
    title: "Work Orders",
    description: "Create, track, and complete work orders in real time.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "chatbot",
    title: "AI Chatbot",
    description:
      "Talk to an AI mechanic assistant for help diagnosing and learning.",
    access: { diy: false, pro: true, proPlus: true, addOnAvailable: true },
  },
  {
    key: "smart_scheduling",
    title: "Smart Scheduling",
    description:
      "Optimize your shop’s schedule with AI-based job priority logic.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "customer_portal",
    title: "Customer Portal",
    description: "Let customers view quotes, photos, and approve work online.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "voice_input",
    title: "Voice Input",
    description:
      "Add repairs, inspections, and job notes hands-free using voice.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "parts_lookup",
    title: "Parts Lookup",
    description:
      "Search and price parts in real time through connected suppliers.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "deferred_work_tracking",
    title: "Deferred Tracking",
    description: "Automatically track declined work for follow-up.",
    access: { diy: false, pro: true, proPlus: true },
  },
];

// Optional: key-to-feature lookup
export const featureMap = Object.fromEntries(
  features.map((f) => [f.key, f]),
) as { [k in FeatureKey]: Feature };


/* =============================== */
/* FILE: features/shared/lib/routeMeta.ts */
/* =============================== */

// src/routeMeta.ts

export type UserRole = "owner" | "admin" | "service" | "tech" | "viewer";

export type PersistMeta = {
  scroll?: boolean;          // remember scroll position
  inputs?: boolean;          // remember input/textarea/select values
  keyParams?: string[];      // dynamic params to scope storage key (e.g., ["id"])
};

export type RouteMeta = {
  title: (href: string) => string;
  icon?: string;
  showInTabs?: boolean;      // default true
  persist?: PersistMeta;     // optional overrides (defaults applied globally)
  roles?: UserRole[];        // NEW: restrict visibility by role
};

// ---- Global defaults: APPLY TO ALL ROUTES (opt-out per route) ----
const PERSIST_DEFAULTS: PersistMeta = { scroll: true, inputs: true };

// If you want a global default role set (i.e., everyone can see unless specified)
// leave undefined to mean "all roles"
const ALL_ROLES: UserRole[] | undefined = undefined;

// Define only titles/icons and any per-route overrides or opt-outs.
export const ROUTE_META: Record<string, RouteMeta> = {
  "/dashboard": { title: () => "Dashboard", icon: "🏠", roles: ALL_ROLES },

  // Work Orders
  "/work-orders":              { title: () => "Work Orders",       icon: "📋", roles: ["owner", "admin", "service", "tech"] },
  "/work-orders/view":         { title: () => "View Work Orders",  icon: "📋", roles: ["owner", "admin", "service"] },
  "/work-orders/create":       { title: () => "New Work Order",    icon: "➕", roles: ["owner", "admin", "service"] },
  "/work-orders/queue":        { title: () => "Job Queue",         icon: "🧰", roles: ["owner", "admin", "service", "tech"] },
  "/work-orders/editor":       { title: () => "Work Order Editor", icon: "✍️", roles: ["owner", "admin", "service"] },
  "/work-orders/quote-review": { title: () => "Quote Review",      icon: "✅", roles: ["owner", "admin", "service"] },

  // Per-WO tab (plural): scope persistence by id
  "/work-orders/[id]": {
    title: (href) => `WO #${href.split("/").pop()?.slice(0, 8) ?? "…"}`,
    icon: "🔧",
    persist: { keyParams: ["id"] },
    roles: ["owner", "admin", "service", "tech"],
  },

  // OPTIONAL (singular) detail route you mentioned:
  // If you created /work-order/view/[id], include it too. Hidden from tabs.
  "/work-orders/view/[id]": {
    title: (href) => `Work Order ${href.split("/").pop()?.slice(0, 8) ?? "…"}`,
    icon: "🔧",
    showInTabs: false,
    persist: { keyParams: ["id"] },
    roles: ["owner", "admin", "service", "tech"],
  },

  // Inspections
  "/inspection":                   { title: () => "Inspection Menu",      icon: "📝", roles: ["owner", "admin", "service", "tech"] },
  "/maintenance50":                { title: () => "Maintenance 50",       icon: "🧰", roles: ["owner", "admin", "service", "tech"] },
  // NEW: Maintenance 50 (Air)
  "/maintenance50-air": { title: () => "Maintenance 50 (Air)", icon: "🧰", roles: ["owner", "admin", "service", "tech"] },

  "/inspection/custom-inspection": { title: () => "Custom Builder",       icon: "🧩", roles: ["owner", "admin", "service", "tech"] },
  "/inspection/saved":             { title: () => "Saved Inspections",    icon: "💾", roles: ["owner", "admin", "service", "tech"] },
  "/inspection/templates":         { title: () => "Templates",            icon: "🗂️", roles: ["owner", "admin", "service", "tech"] },
  "/inspection/created":           { title: () => "Created Inspections",  icon: "📤", roles: ["owner", "admin", "service", "tech"] },
  "/inspection/summaries":         { title: () => "Inspection Summaries", icon: "📊", roles: ["owner", "admin", "service"] },

  // Parts
  "/parts":            { title: () => "Parts Dashboard", icon: "📦", roles: ["owner", "admin", "service"] },
  "/parts/inventory":  { title: () => "Inventory",       icon: "📦", roles: ["owner", "admin", "service"] },
  "/parts/returns":    { title: () => "Returns",         icon: "↩️", roles: ["owner", "admin", "service"] },
  "/parts/warranties": { title: () => "Warranties",      icon: "🛡️", roles: ["owner", "admin", "service"] },

  // Management / Settings
  "/dashboard/owner/create-user": { title: () => "Create User",    icon: "➕", roles: ["owner"] },
  "/dashboard/owner/reports":     { title: () => "Reports",        icon: "📈", roles: ["owner"] },
  "/dashboard/owner/settings":    { title: () => "Owner Settings", icon: "⚙️", roles: ["owner"] },

  // Scheduling (Admin)
  "/dashboard/admin/scheduling":  { title: () => "Scheduling",     icon: "📅", roles: ["owner", "admin"] },

  // AI & Messaging
  "/ai/assistant": { title: () => "AI Assistant", icon: "🤖", roles: ["owner", "admin", "service", "tech"] },
  "/chat":         { title: () => "Team Chat",    icon: "💬", roles: ["owner", "admin", "service", "tech"] },

  // ----- Hide these from Tabs (but they still persist unless you override persist) -----
  "/":            { title: () => "Home",        showInTabs: false, roles: ALL_ROLES },
  "/sign-in":     { title: () => "Sign In",     showInTabs: false, persist: { scroll: false, inputs: false }, roles: ALL_ROLES },
  "/signup":      { title: () => "Sign Up",     showInTabs: false, persist: { scroll: false, inputs: false }, roles: ALL_ROLES },
  "/onboarding":  { title: () => "Onboarding",  showInTabs: false, roles: ["owner", "admin"] },
  "/subscribe":   { title: () => "Plans",       showInTabs: false, roles: ["owner"] },
  "/compare":     { title: () => "Compare",     showInTabs: false, roles: ALL_ROLES },

  // Leave visible if you want it in tabs
  "/compare-plans": { title: () => "Plan & Billing", icon: "💳", roles: ["owner"] },
};

// Utility to merge defaults for any route (and for unknown routes)
// NOTE: now accepts `role` to filter visibility
export function metaFor(
  href: string,
  _params?: Record<string, string>,
  role?: UserRole
): { title: string; icon?: string; show: boolean; persist: PersistMeta } {
  const keys = Object.keys(ROUTE_META).sort((a, b) => b.length - a.length);
  for (const key of keys) {
    const isDyn = key.includes("[");
    const keyPrefix = key.replace(/\[.*?\]/g, "");
    if ((isDyn && href.startsWith(keyPrefix)) || (!isDyn && href === key)) {
      const m = ROUTE_META[key];

      // role check
      const allowed =
        !m.roles || m.roles.length === 0 || role === undefined || m.roles.includes(role);

      return {
        title: m.title(href),
        icon: m.icon,
        show: allowed && (m.showInTabs !== false),
        persist: { ...PERSIST_DEFAULTS, ...(m.persist ?? {}) },
      };
    }
  }
  // Fallback for routes not listed: show in tabs + apply global defaults
  const last = href.split("?")[0].split("/").filter(Boolean).pop() ?? href;
  const nice = last.replace(/[-_]+/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
  return {
    title: nice || "Page",
    icon: "📄",
    show: true,
    persist: { ...PERSIST_DEFAULTS },
  };
}

/* =============================== */
/* FILE: features/shared/components/RoleHubTiles/tiles.ts */
/* =============================== */

export type Role =
  | "owner"
  | "admin"
  | "manager"
  | "advisor"
  | "mechanic"
  | "parts";

export type Scope =
  | "work_orders"
  | "inspections"
  | "parts"
  | "tech"
  | "management"
  | "settings"
  | "all";

export type Tile = {
  href: string;
  title: string;
  subtitle?: string;
  cta?: string;
  roles: Role[];
  scopes: Scope[];
};

export const TILES: Tile[] = [
  // --- Work Orders ---
  {
    href: "/work-orders/create?autostart=1", // ✅ auto-start work order draft
    title: "Create Work Order",
    subtitle: "Start a new job",
    cta: "+",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/work-orders/view",
    title: "View Work Orders",
    subtitle: "Browse & manage",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/work-orders/queue",
    title: "Job Queue",
    subtitle: "Active & in-progress",
    roles: ["mechanic", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/work-orders/quote-review",
    title: "Quote Review",
    subtitle: "Review & send estimates",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/menu",
    title: "Service Menu",
    subtitle: "Saved services & presets",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/work-orders/history",
    title: "History",
    subtitle: "Completed Work Orders & Invoices",
    roles: ["owner", "admin", "manager", "advisor", "mechanic"],
    scopes: ["work_orders", "all"],
  },
  // NEW: Billing (Ready to invoice)
  {
    href: "/billing",
    title: "Billing",
    subtitle: "Ready to invoice",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },

  // --- Inspections ---
  {
    href: "/inspections/maintenance50",
    title: "Maintenance 50",
    subtitle: "Quick checklist",
    roles: ["advisor", "manager", "owner", "admin", "mechanic"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/maintenance50-air",
    title: "Maintenance 50 – Air",
    subtitle: "CVIP-style (air brakes)",
    roles: ["advisor", "manager", "owner", "admin", "mechanic"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/custom-inspection",
    title: "Custom Builder",
    subtitle: "Design your own",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/saved",
    title: "Saved Inspections",
    subtitle: "Recent & drafts",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/templates",
    title: "Templates",
    subtitle: "Reusable inspection sets",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/summary",
    title: "Inspection Summaries",
    subtitle: "Overview & results",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
  },

  // --- Parts ---
  {
    href: "/parts",
    title: "Parts Dashboard",
    subtitle: "Orders & receiving",
    roles: ["parts", "manager", "owner", "admin" ],
    scopes: ["parts", "all"],
  },
  {
    href: "/parts/requests",
    title: "Requests",
    subtitle: "View requests",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  {
    href: "/parts/inventory",
    title: "Inventory",
    subtitle: "On-hand stock",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  // NEW: Purchase Orders list
  {
    href: "/parts/po",
    title: "Purchase Orders",
    subtitle: "Create & manage POs",
    cta: "+",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  // NEW: Scan-to-Receive entry
  {
    href: "/parts/receive",
    title: "Scan to Receive",
    subtitle: "Camera or manual entry",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  // Optional: vendor API keys / integrations page
  {
    href: "/parts/vendors",
    title: "Vendor Integrations",
    subtitle: "API keys for suppliers",
    roles: ["owner", "admin", "manager", "parts"],
    scopes: ["parts", "settings", "all"],
  },
  {
    href: "/parts/returns",
    title: "Returns",
    subtitle: "Manage RMAs",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  {
    href: "/parts/warranties",
    title: "Warranties",
    subtitle: "Track claims",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },

  // --- Management ---
  {
    href: "/dashboard/owner/create-user",
    title: "Create User",
    subtitle: "Add team members",
    roles: ["owner", "admin"],
    scopes: ["management", "all"],
  },
  {
    href: "/dashboard/admin/scheduling",
    title: "Scheduling",
    subtitle: "Calendar & bookings",
    roles: ["owner", "admin", "manager", "advisor"],
    scopes: ["management", "all"],
  },
  {
    href: "/portal/appointments",
    title: "Appointments",
    subtitle: "Customer bookings calendar",
    roles: ["owner", "admin", "manager", "advisor"],
    scopes: ["management", "all"],
  },

  // --- Settings & Reports ---
  {
    href: "/dashboard/owner/reports",
    title: "Reports",
    subtitle: "Business insights",
    roles: ["owner", "admin", "manager"],
    scopes: ["settings", "all"],
  },
  {
    href: "/dashboard/owner/settings",
    title: "Settings",
    subtitle: "Account & shop settings",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
  },
  {
    href: "/dashboard/owner/import-customers",
    title: "Import Customers",
    subtitle: "CSV import",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
  },
  {
    href: "/compare-plans",
    title: "Plan & Billing",
    subtitle: "Subscription",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
  },

  // --- AI & Tech ---
  {
    href: "/tech/queue",
    title: "Tech Job Queue",
    subtitle: "My assigned work",
    roles: ["mechanic", "manager", "owner", "admin"],
    scopes: ["tech", "all"],
  },
];

/* =============================== */
/* FILE: features/shared/components/ui/WhySection.tsx */
/* =============================== */

"use client";

import Section from "./Section";

export default function WhySection() {
  return (
    <Section id="why" className="bg-neutral-950 text-white">
      <div className="max-w-5xl mx-auto text-center">
        <h2 className="text-3xl font-blackops text-orange-400 mb-6 drop-shadow">
          Why ProFixIQ?
        </h2>

        <p className="text-lg text-gray-300 leading-relaxed mb-8">
          ProFixIQ was built by a technician who lived shop life — not by a
          committee. The goal is simple: <em>less screen time, faster answers,
          cleaner documentation</em>. From AI-assisted diagnostics to shareable
          quotes and role-based work management, ProFixIQ removes the friction
          that slows techs and advisors down.
        </p>

        <div className="grid gap-4 sm:grid-cols-2 text-left">
          {[
            "Cut diagnostic guesswork with AI suggestions and symptom guides.",
            "Speed up inspections with reusable templates, photos, and voice notes.",
            "Turn findings into quotes and work orders with accurate labor estimates.",
            "Keep everyone on the same page with roles, permissions, and status.",
          ].map((line, i) => (
            <div
              key={i}
              className="rounded border border-neutral-800 bg-black/40 p-4"
            >
              <span className="text-orange-400 mr-2">✓</span>
              <span className="text-gray-200">{line}</span>
            </div>
          ))}
        </div>
      </div>
    </Section>
  );
}

/* =============================== */
/* FILE: features/shared/components/ui/QuoteViewer.tsx */
/* =============================== */

"use client";

import React from "react";

interface QuoteLine {
  description: string;
  parts: { name: string; price: number }[];
  laborHours: number;
  laborCost: number;
  shopSupplies: number;
  total: number;
  category: string;
}

interface QuoteViewerProps {
  quote: QuoteLine[];
}

export default function QuoteViewer({ quote }: QuoteViewerProps) {
  if (!quote || quote.length === 0) {
    return (
      <div className="text-center text-sm text-gray-400">
        No quote items available.
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {quote.map((line, index) => (
        <div
          key={index}
          className="rounded-xl bg-black/30 p-6 shadow-md border border-white/10 backdrop-blur-md transition hover:shadow-xl"
        >
          <h3 className="text-lg font-blackopsone text-orange-400 mb-1 capitalize">
            {line.category}
          </h3>
          <p className="text-sm text-white/90 italic mb-2">
            {line.description}
          </p>

          {line.parts.length > 0 && (
            <div className="text-sm text-white/80 mb-2">
              <span className="font-semibold text-orange-300">Parts:</span>
              <ul className="list-disc ml-5 mt-1 space-y-1">
                {line.parts.map((part, i) => (
                  <li key={i}>
                    {part.name} – ${part.price.toFixed(2)}
                  </li>
                ))}
              </ul>
            </div>
          )}

          <div className="text-sm text-white/80 space-y-1 mt-3">
            <p>
              <span className="font-semibold">Labor:</span> {line.laborHours}{" "}
              hrs – ${line.laborCost.toFixed(2)}
            </p>
            <p>
              <span className="font-semibold">Shop Supplies:</span> $
              {line.shopSupplies.toFixed(2)}
            </p>
          </div>

          <div className="text-md font-bold text-green-400 mt-4 border-t border-white/10 pt-3">
            Total: ${line.total.toFixed(2)}
          </div>
        </div>
      ))}
    </div>
  );
}


/* =============================== */
/* FILE: features/shared/components/ui/FeaturesSection.tsx */
/* =============================== */

"use client";

import FeatureCard from "@shared/components/ui/FeatureCard";

type FeaturesSectionProps = {
  showHeading?: boolean;
};

export default function FeaturesSection({ showHeading = false }: FeaturesSectionProps) {
  return (
    <div>
      {showHeading && (
        <h2
          className="text-center text-4xl md:text-5xl text-orange-400 mb-10"
          style={{ fontFamily: "var(--font-blackops)" }}
        >
          Powerful Features
        </h2>
      )}

      <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
        <FeatureCard
          title="AI-Powered Diagnostics"
          description="Narrow down likely causes before you touch a tool. Ask follow-ups to confirm symptoms and next steps."
          available
        />
        <FeatureCard
          title="Inspections Your Way"
          description="Photo capture, notes, voice input, tags—everything techs need to document and share clearly."
          available
        />
        <FeatureCard
          title="Work Orders & Quotes"
          description="Estimate labor, parts, and taxes; assign jobs; generate shareable quotes and invoices in a click."
          available
        />
        <FeatureCard
          title="Voice + Photos"
          description="Add line items by voice, markup images, and keep evidence tidy for customers and insurance."
          available
        />
        <FeatureCard
          title="Team & Roles"
          description="Owner, Admin, Manager, Advisor, Parts, Tech. Give each role the tools (and permissions) they need."
          available
        />
        <FeatureCard
          title="Priority Support"
          description="Pro+ adds priority help and optional extra seats as your shop grows."
          available
        />
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/shared/types/types/supabase.ts */
/* =============================== */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "12.2.3 (519615d)"
  }
  public: {
    Tables: {
      activity_logs: {
        Row: {
          action: string | null
          context: Json | null
          id: string
          target_id: string | null
          target_table: string | null
          timestamp: string | null
          user_id: string | null
        }
        Insert: {
          action?: string | null
          context?: Json | null
          id?: string
          target_id?: string | null
          target_table?: string | null
          timestamp?: string | null
          user_id?: string | null
        }
        Update: {
          action?: string | null
          context?: Json | null
          id?: string
          target_id?: string | null
          target_table?: string | null
          timestamp?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      agent_attachments: {
        Row: {
          agent_request_id: string
          caption: string | null
          created_at: string
          created_by: string
          id: string
          kind: string
          public_url: string
          storage_path: string
        }
        Insert: {
          agent_request_id: string
          caption?: string | null
          created_at?: string
          created_by: string
          id?: string
          kind?: string
          public_url: string
          storage_path: string
        }
        Update: {
          agent_request_id?: string
          caption?: string | null
          created_at?: string
          created_by?: string
          id?: string
          kind?: string
          public_url?: string
          storage_path?: string
        }
        Relationships: [
          {
            foreignKeyName: "agent_attachments_agent_request_id_fkey"
            columns: ["agent_request_id"]
            isOneToOne: false
            referencedRelation: "agent_requests"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "agent_attachments_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      agent_events: {
        Row: {
          content: Json
          created_at: string
          id: string
          kind: string
          run_id: string
          step: number
        }
        Insert: {
          content: Json
          created_at?: string
          id?: string
          kind: string
          run_id: string
          step: number
        }
        Update: {
          content?: Json
          created_at?: string
          id?: string
          kind?: string
          run_id?: string
          step?: number
        }
        Relationships: [
          {
            foreignKeyName: "agent_events_run_id_fkey"
            columns: ["run_id"]
            isOneToOne: false
            referencedRelation: "agent_runs"
            referencedColumns: ["id"]
          },
        ]
      }
      agent_knowledge: {
        Row: {
          body: string
          created_at: string
          created_by: string
          id: string
          shop_id: string | null
          slug: string
          tags: string[] | null
          title: string
        }
        Insert: {
          body: string
          created_at?: string
          created_by: string
          id?: string
          shop_id?: string | null
          slug: string
          tags?: string[] | null
          title: string
        }
        Update: {
          body?: string
          created_at?: string
          created_by?: string
          id?: string
          shop_id?: string | null
          slug?: string
          tags?: string[] | null
          title?: string
        }
        Relationships: [
          {
            foreignKeyName: "agent_knowledge_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      agent_requests: {
        Row: {
          created_at: string
          description: string
          github_branch: string | null
          github_commit_sha: string | null
          github_issue_number: number | null
          github_issue_url: string | null
          github_pr_number: number | null
          github_pr_url: string | null
          id: string
          intent: Database["public"]["Enums"]["agent_request_intent"] | null
          llm_confidence: number | null
          llm_model: string | null
          llm_notes: string | null
          normalized_json: Json | null
          reporter_id: string | null
          reporter_role: string | null
          run_id: string | null
          shop_id: string | null
          status: Database["public"]["Enums"]["agent_request_status"]
          updated_at: string
        }
        Insert: {
          created_at?: string
          description: string
          github_branch?: string | null
          github_commit_sha?: string | null
          github_issue_number?: number | null
          github_issue_url?: string | null
          github_pr_number?: number | null
          github_pr_url?: string | null
          id?: string
          intent?: Database["public"]["Enums"]["agent_request_intent"] | null
          llm_confidence?: number | null
          llm_model?: string | null
          llm_notes?: string | null
          normalized_json?: Json | null
          reporter_id?: string | null
          reporter_role?: string | null
          run_id?: string | null
          shop_id?: string | null
          status?: Database["public"]["Enums"]["agent_request_status"]
          updated_at?: string
        }
        Update: {
          created_at?: string
          description?: string
          github_branch?: string | null
          github_commit_sha?: string | null
          github_issue_number?: number | null
          github_issue_url?: string | null
          github_pr_number?: number | null
          github_pr_url?: string | null
          id?: string
          intent?: Database["public"]["Enums"]["agent_request_intent"] | null
          llm_confidence?: number | null
          llm_model?: string | null
          llm_notes?: string | null
          normalized_json?: Json | null
          reporter_id?: string | null
          reporter_role?: string | null
          run_id?: string | null
          shop_id?: string | null
          status?: Database["public"]["Enums"]["agent_request_status"]
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "agent_requests_reporter_id_fkey"
            columns: ["reporter_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "agent_requests_run_id_fkey"
            columns: ["run_id"]
            isOneToOne: false
            referencedRelation: "agent_runs"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "agent_requests_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "agent_requests_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      agent_runs: {
        Row: {
          created_at: string
          goal: string
          id: string
          idempotency_key: string | null
          shop_id: string
          status: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          goal: string
          id?: string
          idempotency_key?: string | null
          shop_id: string
          status: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          goal?: string
          id?: string
          idempotency_key?: string | null
          shop_id?: string
          status?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      ai_events: {
        Row: {
          created_at: string
          entity_id: string | null
          entity_table: string | null
          event_type: string
          id: string
          payload: Json
          shop_id: string | null
          source_id: string | null
          training_source:
            | Database["public"]["Enums"]["ai_training_source"]
            | null
          user_id: string | null
          vehicle_ymm: string | null
        }
        Insert: {
          created_at?: string
          entity_id?: string | null
          entity_table?: string | null
          event_type: string
          id?: string
          payload: Json
          shop_id?: string | null
          source_id?: string | null
          training_source?:
            | Database["public"]["Enums"]["ai_training_source"]
            | null
          user_id?: string | null
          vehicle_ymm?: string | null
        }
        Update: {
          created_at?: string
          entity_id?: string | null
          entity_table?: string | null
          event_type?: string
          id?: string
          payload?: Json
          shop_id?: string | null
          source_id?: string | null
          training_source?:
            | Database["public"]["Enums"]["ai_training_source"]
            | null
          user_id?: string | null
          vehicle_ymm?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_events_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_events_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      ai_requests: {
        Row: {
          created_at: string | null
          id: string
          prompt: string | null
          response: string | null
          tool_used: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          prompt?: string | null
          response?: string | null
          tool_used?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          prompt?: string | null
          response?: string | null
          tool_used?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_requests_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_requests_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      ai_training_data: {
        Row: {
          content: string
          created_at: string
          embedding: string | null
          id: string
          shop_id: string | null
          source_event_id: string | null
        }
        Insert: {
          content: string
          created_at?: string
          embedding?: string | null
          id?: string
          shop_id?: string | null
          source_event_id?: string | null
        }
        Update: {
          content?: string
          created_at?: string
          embedding?: string | null
          id?: string
          shop_id?: string | null
          source_event_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_training_data_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_training_data_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_training_data_source_event_id_fkey"
            columns: ["source_event_id"]
            isOneToOne: false
            referencedRelation: "ai_events"
            referencedColumns: ["id"]
          },
        ]
      }
      ai_training_events: {
        Row: {
          created_at: string
          id: string
          payload: Json
          shop_id: string
          source: string
          vehicle_ymm: string | null
        }
        Insert: {
          created_at?: string
          id?: string
          payload?: Json
          shop_id: string
          source: string
          vehicle_ymm?: string | null
        }
        Update: {
          created_at?: string
          id?: string
          payload?: Json
          shop_id?: string
          source?: string
          vehicle_ymm?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_training_events_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_training_events_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      api_keys: {
        Row: {
          api_key: string | null
          created_at: string | null
          id: string
          label: string | null
          user_id: string | null
        }
        Insert: {
          api_key?: string | null
          created_at?: string | null
          id?: string
          label?: string | null
          user_id?: string | null
        }
        Update: {
          api_key?: string | null
          created_at?: string | null
          id?: string
          label?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      apps: {
        Row: {
          default_route: string
          icon_url: string | null
          id: string
          is_enabled: boolean
          name: string
          slug: string
        }
        Insert: {
          default_route: string
          icon_url?: string | null
          id?: string
          is_enabled?: boolean
          name: string
          slug: string
        }
        Update: {
          default_route?: string
          icon_url?: string | null
          id?: string
          is_enabled?: boolean
          name?: string
          slug?: string
        }
        Relationships: []
      }
      audit_logs: {
        Row: {
          action: string
          actor_id: string | null
          created_at: string
          id: string
          metadata: Json | null
          target: string | null
        }
        Insert: {
          action: string
          actor_id?: string | null
          created_at?: string
          id?: string
          metadata?: Json | null
          target?: string | null
        }
        Update: {
          action?: string
          actor_id?: string | null
          created_at?: string
          id?: string
          metadata?: Json | null
          target?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "audit_logs_actor_id_fkey"
            columns: ["actor_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      bookings: {
        Row: {
          created_at: string
          created_by: string | null
          customer_id: string | null
          ends_at: string
          id: string
          notes: string | null
          shop_id: string | null
          starts_at: string
          status: string
          vehicle_id: string | null
        }
        Insert: {
          created_at?: string
          created_by?: string | null
          customer_id?: string | null
          ends_at: string
          id?: string
          notes?: string | null
          shop_id?: string | null
          starts_at: string
          status?: string
          vehicle_id?: string | null
        }
        Update: {
          created_at?: string
          created_by?: string | null
          customer_id?: string | null
          ends_at?: string
          id?: string
          notes?: string | null
          shop_id?: string | null
          starts_at?: string
          status?: string
          vehicle_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "bookings_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      chat_participants: {
        Row: {
          chat_id: string | null
          id: string
          joined_at: string | null
          profile_id: string | null
          role: string | null
        }
        Insert: {
          chat_id?: string | null
          id?: string
          joined_at?: string | null
          profile_id?: string | null
          role?: string | null
        }
        Update: {
          chat_id?: string | null
          id?: string
          joined_at?: string | null
          profile_id?: string | null
          role?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "chat_participants_chat_id_fkey"
            columns: ["chat_id"]
            isOneToOne: false
            referencedRelation: "chats"
            referencedColumns: ["id"]
          },
        ]
      }
      chats: {
        Row: {
          context_id: string | null
          created_at: string | null
          created_by: string | null
          id: string
          title: string | null
          type: string
        }
        Insert: {
          context_id?: string | null
          created_at?: string | null
          created_by?: string | null
          id?: string
          title?: string | null
          type: string
        }
        Update: {
          context_id?: string | null
          created_at?: string | null
          created_by?: string | null
          id?: string
          title?: string | null
          type?: string
        }
        Relationships: []
      }
      conversation_participants: {
        Row: {
          added_at: string | null
          conversation_id: string | null
          id: string
          role: string | null
          user_id: string | null
        }
        Insert: {
          added_at?: string | null
          conversation_id?: string | null
          id?: string
          role?: string | null
          user_id?: string | null
        }
        Update: {
          added_at?: string | null
          conversation_id?: string | null
          id?: string
          role?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "conversation_participants_conversation_id_fkey"
            columns: ["conversation_id"]
            isOneToOne: false
            referencedRelation: "conversations"
            referencedColumns: ["id"]
          },
        ]
      }
      conversations: {
        Row: {
          context_id: string | null
          context_type: string | null
          created_at: string | null
          created_by: string | null
          id: string
          is_group: boolean | null
          title: string | null
        }
        Insert: {
          context_id?: string | null
          context_type?: string | null
          created_at?: string | null
          created_by?: string | null
          id?: string
          is_group?: boolean | null
          title?: string | null
        }
        Update: {
          context_id?: string | null
          context_type?: string | null
          created_at?: string | null
          created_by?: string | null
          id?: string
          is_group?: boolean | null
          title?: string | null
        }
        Relationships: []
      }
      customer_bookings: {
        Row: {
          created_at: string | null
          customer_email: string | null
          customer_name: string | null
          customer_phone: string | null
          id: string
          labor_hours_estimated: number | null
          preferred_date: string | null
          preferred_time: string | null
          selected_services: Json | null
          shop_id: string | null
          status: string | null
          vehicle_make: string | null
          vehicle_model: string | null
          vehicle_year: string | null
          vin: string | null
        }
        Insert: {
          created_at?: string | null
          customer_email?: string | null
          customer_name?: string | null
          customer_phone?: string | null
          id?: string
          labor_hours_estimated?: number | null
          preferred_date?: string | null
          preferred_time?: string | null
          selected_services?: Json | null
          shop_id?: string | null
          status?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: string | null
          vin?: string | null
        }
        Update: {
          created_at?: string | null
          customer_email?: string | null
          customer_name?: string | null
          customer_phone?: string | null
          id?: string
          labor_hours_estimated?: number | null
          preferred_date?: string | null
          preferred_time?: string | null
          selected_services?: Json | null
          shop_id?: string | null
          status?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: string | null
          vin?: string | null
        }
        Relationships: []
      }
      customer_portal_invites: {
        Row: {
          created_at: string | null
          customer_id: string
          email: string
          id: string
          token: string
        }
        Insert: {
          created_at?: string | null
          customer_id: string
          email: string
          id?: string
          token: string
        }
        Update: {
          created_at?: string | null
          customer_id?: string
          email?: string
          id?: string
          token?: string
        }
        Relationships: [
          {
            foreignKeyName: "customer_portal_invites_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
        ]
      }
      customer_quotes: {
        Row: {
          created_at: string | null
          customer_email: string | null
          customer_name: string | null
          estimated_total: number | null
          id: string
          preferred_date: string | null
          selected_services: Json | null
          shop_id: string | null
          vehicle_make: string | null
          vehicle_model: string | null
          vehicle_year: number | null
        }
        Insert: {
          created_at?: string | null
          customer_email?: string | null
          customer_name?: string | null
          estimated_total?: number | null
          id?: string
          preferred_date?: string | null
          selected_services?: Json | null
          shop_id?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: number | null
        }
        Update: {
          created_at?: string | null
          customer_email?: string | null
          customer_name?: string | null
          estimated_total?: number | null
          id?: string
          preferred_date?: string | null
          selected_services?: Json | null
          shop_id?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: number | null
        }
        Relationships: []
      }
      customer_settings: {
        Row: {
          comm_email_enabled: boolean
          comm_sms_enabled: boolean
          customer_id: string
          language: string | null
          marketing_opt_in: boolean
          preferred_contact: string | null
          timezone: string | null
          units: string | null
          updated_at: string
        }
        Insert: {
          comm_email_enabled?: boolean
          comm_sms_enabled?: boolean
          customer_id: string
          language?: string | null
          marketing_opt_in?: boolean
          preferred_contact?: string | null
          timezone?: string | null
          units?: string | null
          updated_at?: string
        }
        Update: {
          comm_email_enabled?: boolean
          comm_sms_enabled?: boolean
          customer_id?: string
          language?: string | null
          marketing_opt_in?: boolean
          preferred_contact?: string | null
          timezone?: string | null
          units?: string | null
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "customer_settings_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: true
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
        ]
      }
      customers: {
        Row: {
          address: string | null
          business_name: string | null
          city: string | null
          created_at: string | null
          email: string | null
          first_name: string | null
          id: string
          is_fleet: boolean
          last_name: string | null
          name: string | null
          notes: string | null
          phone: string | null
          phone_number: string | null
          postal_code: string | null
          province: string | null
          shop_id: string | null
          street: string | null
          user_id: string | null
          vehicle: string | null
        }
        Insert: {
          address?: string | null
          business_name?: string | null
          city?: string | null
          created_at?: string | null
          email?: string | null
          first_name?: string | null
          id?: string
          is_fleet?: boolean
          last_name?: string | null
          name?: string | null
          notes?: string | null
          phone?: string | null
          phone_number?: string | null
          postal_code?: string | null
          province?: string | null
          shop_id?: string | null
          street?: string | null
          user_id?: string | null
          vehicle?: string | null
        }
        Update: {
          address?: string | null
          business_name?: string | null
          city?: string | null
          created_at?: string | null
          email?: string | null
          first_name?: string | null
          id?: string
          is_fleet?: boolean
          last_name?: string | null
          name?: string | null
          notes?: string | null
          phone?: string | null
          phone_number?: string | null
          postal_code?: string | null
          province?: string | null
          shop_id?: string | null
          street?: string | null
          user_id?: string | null
          vehicle?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "customers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "customers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      decoded_vins: {
        Row: {
          created_at: string | null
          decoded: Json | null
          id: string
          user_id: string | null
          vin: string
        }
        Insert: {
          created_at?: string | null
          decoded?: Json | null
          id?: string
          user_id?: string | null
          vin: string
        }
        Update: {
          created_at?: string | null
          decoded?: Json | null
          id?: string
          user_id?: string | null
          vin?: string
        }
        Relationships: []
      }
      defective_parts: {
        Row: {
          id: string
          part_id: string | null
          quantity: number
          reason: string | null
          reported_at: string | null
          reported_by: string | null
          shop_id: string | null
        }
        Insert: {
          id?: string
          part_id?: string | null
          quantity?: number
          reason?: string | null
          reported_at?: string | null
          reported_by?: string | null
          shop_id?: string | null
        }
        Update: {
          id?: string
          part_id?: string | null
          quantity?: number
          reason?: string | null
          reported_at?: string | null
          reported_by?: string | null
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "defective_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "defective_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      dtc_logs: {
        Row: {
          created_at: string | null
          description: string | null
          dtc_code: string | null
          id: string
          severity: string | null
          user_id: string | null
          vehicle_id: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          dtc_code?: string | null
          id?: string
          severity?: string | null
          user_id?: string | null
          vehicle_id?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          dtc_code?: string | null
          id?: string
          severity?: string | null
          user_id?: string | null
          vehicle_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "dtc_logs_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      email_logs: {
        Row: {
          created_at: string | null
          email: string
          error: string | null
          event_type: string
          id: string
          sg_event_id: string | null
          status: string | null
          timestamp: string
        }
        Insert: {
          created_at?: string | null
          email: string
          error?: string | null
          event_type: string
          id?: string
          sg_event_id?: string | null
          status?: string | null
          timestamp: string
        }
        Update: {
          created_at?: string | null
          email?: string
          error?: string | null
          event_type?: string
          id?: string
          sg_event_id?: string | null
          status?: string | null
          timestamp?: string
        }
        Relationships: []
      }
      email_suppressions: {
        Row: {
          email: string
          reason: string | null
          suppressed: boolean | null
          updated_at: string | null
        }
        Insert: {
          email: string
          reason?: string | null
          suppressed?: boolean | null
          updated_at?: string | null
        }
        Update: {
          email?: string
          reason?: string | null
          suppressed?: boolean | null
          updated_at?: string | null
        }
        Relationships: []
      }
      employee_documents: {
        Row: {
          bucket_id: string
          doc_type: string
          expires_at: string | null
          file_path: string
          id: string
          shop_id: string
          status: string
          uploaded_at: string
          user_id: string
        }
        Insert: {
          bucket_id?: string
          doc_type: string
          expires_at?: string | null
          file_path: string
          id?: string
          shop_id: string
          status?: string
          uploaded_at?: string
          user_id: string
        }
        Update: {
          bucket_id?: string
          doc_type?: string
          expires_at?: string | null
          file_path?: string
          id?: string
          shop_id?: string
          status?: string
          uploaded_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "employee_documents_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employee_documents_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employee_documents_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      feature_reads: {
        Row: {
          feature_slug: string
          id: string
          last_read_at: string
          user_id: string
        }
        Insert: {
          feature_slug: string
          id?: string
          last_read_at?: string
          user_id: string
        }
        Update: {
          feature_slug?: string
          id?: string
          last_read_at?: string
          user_id?: string
        }
        Relationships: []
      }
      fleet_program_tasks: {
        Row: {
          created_at: string
          default_labor_hours: number | null
          description: string
          display_order: number
          id: string
          job_type: string
          program_id: string
          section_key: string | null
        }
        Insert: {
          created_at?: string
          default_labor_hours?: number | null
          description: string
          display_order?: number
          id?: string
          job_type?: string
          program_id: string
          section_key?: string | null
        }
        Update: {
          created_at?: string
          default_labor_hours?: number | null
          description?: string
          display_order?: number
          id?: string
          job_type?: string
          program_id?: string
          section_key?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fleet_program_tasks_program_id_fkey"
            columns: ["program_id"]
            isOneToOne: false
            referencedRelation: "fleet_programs"
            referencedColumns: ["id"]
          },
        ]
      }
      fleet_programs: {
        Row: {
          base_template_slug: string | null
          cadence: Database["public"]["Enums"]["fleet_program_cadence"]
          created_at: string
          fleet_id: string
          id: string
          include_custom_inspection: boolean
          interval_days: number | null
          interval_hours: number | null
          interval_km: number | null
          name: string
          notes: string | null
        }
        Insert: {
          base_template_slug?: string | null
          cadence: Database["public"]["Enums"]["fleet_program_cadence"]
          created_at?: string
          fleet_id: string
          id?: string
          include_custom_inspection?: boolean
          interval_days?: number | null
          interval_hours?: number | null
          interval_km?: number | null
          name: string
          notes?: string | null
        }
        Update: {
          base_template_slug?: string | null
          cadence?: Database["public"]["Enums"]["fleet_program_cadence"]
          created_at?: string
          fleet_id?: string
          id?: string
          include_custom_inspection?: boolean
          interval_days?: number | null
          interval_hours?: number | null
          interval_km?: number | null
          name?: string
          notes?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fleet_programs_fleet_id_fkey"
            columns: ["fleet_id"]
            isOneToOne: false
            referencedRelation: "fleets"
            referencedColumns: ["id"]
          },
        ]
      }
      fleet_vehicles: {
        Row: {
          active: boolean
          custom_interval_days: number | null
          custom_interval_hours: number | null
          custom_interval_km: number | null
          fleet_id: string
          nickname: string | null
          vehicle_id: string
        }
        Insert: {
          active?: boolean
          custom_interval_days?: number | null
          custom_interval_hours?: number | null
          custom_interval_km?: number | null
          fleet_id: string
          nickname?: string | null
          vehicle_id: string
        }
        Update: {
          active?: boolean
          custom_interval_days?: number | null
          custom_interval_hours?: number | null
          custom_interval_km?: number | null
          fleet_id?: string
          nickname?: string | null
          vehicle_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "fleet_vehicles_fleet_id_fkey"
            columns: ["fleet_id"]
            isOneToOne: false
            referencedRelation: "fleets"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fleet_vehicles_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      fleets: {
        Row: {
          contact_email: string | null
          contact_name: string | null
          created_at: string
          id: string
          name: string
          notes: string | null
          shop_id: string
        }
        Insert: {
          contact_email?: string | null
          contact_name?: string | null
          created_at?: string
          id?: string
          name: string
          notes?: string | null
          shop_id: string
        }
        Update: {
          contact_email?: string | null
          contact_name?: string | null
          created_at?: string
          id?: string
          name?: string
          notes?: string | null
          shop_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "fleets_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fleets_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      followups: {
        Row: {
          created_at: string | null
          customer_id: string | null
          feature: string | null
          id: string
          send_at: string | null
          sent: boolean | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          customer_id?: string | null
          feature?: string | null
          id?: string
          send_at?: string | null
          sent?: boolean | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          customer_id?: string | null
          feature?: string | null
          id?: string
          send_at?: string | null
          sent?: boolean | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "followups_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
        ]
      }
      history: {
        Row: {
          created_at: string | null
          customer_id: string
          description: string | null
          id: string
          notes: string | null
          service_date: string
          vehicle_id: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          customer_id: string
          description?: string | null
          id?: string
          notes?: string | null
          service_date?: string
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          customer_id?: string
          description?: string | null
          id?: string
          notes?: string | null
          service_date?: string
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "history_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "history_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "history_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_items: {
        Row: {
          created_at: string | null
          id: string
          inspection_id: string | null
          label: string | null
          notes: string | null
          section: string | null
          status: string | null
          value: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          inspection_id?: string | null
          label?: string | null
          notes?: string | null
          section?: string | null
          status?: string | null
          value?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          inspection_id?: string | null
          label?: string | null
          notes?: string | null
          section?: string | null
          status?: string | null
          value?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "inspection_items_inspection_id_fkey"
            columns: ["inspection_id"]
            isOneToOne: false
            referencedRelation: "inspections"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_photos: {
        Row: {
          created_at: string | null
          id: string
          image_url: string
          inspection_id: string | null
          item_name: string | null
          notes: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          image_url: string
          inspection_id?: string | null
          item_name?: string | null
          notes?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          image_url?: string
          inspection_id?: string | null
          item_name?: string | null
          notes?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      inspection_result_items: {
        Row: {
          created_at: string
          item_label: string | null
          notes: string | null
          photo_urls: Json | null
          result_id: string
          section_title: string | null
          status: Database["public"]["Enums"]["inspection_item_status"] | null
          unit: string | null
          value: string | null
        }
        Insert: {
          created_at?: string
          item_label?: string | null
          notes?: string | null
          photo_urls?: Json | null
          result_id: string
          section_title?: string | null
          status?: Database["public"]["Enums"]["inspection_item_status"] | null
          unit?: string | null
          value?: string | null
        }
        Update: {
          created_at?: string
          item_label?: string | null
          notes?: string | null
          photo_urls?: Json | null
          result_id?: string
          section_title?: string | null
          status?: Database["public"]["Enums"]["inspection_item_status"] | null
          unit?: string | null
          value?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "inspection_result_items_result_id_fkey"
            columns: ["result_id"]
            isOneToOne: false
            referencedRelation: "inspection_results"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_results: {
        Row: {
          created_at: string
          customer: Json | null
          finished_at: string
          id: string
          quote: Json | null
          sections: Json
          session_id: string
          template_name: string | null
          vehicle: Json | null
          work_order_line_id: string
        }
        Insert: {
          created_at?: string
          customer?: Json | null
          finished_at?: string
          id?: string
          quote?: Json | null
          sections: Json
          session_id: string
          template_name?: string | null
          vehicle?: Json | null
          work_order_line_id: string
        }
        Update: {
          created_at?: string
          customer?: Json | null
          finished_at?: string
          id?: string
          quote?: Json | null
          sections?: Json
          session_id?: string
          template_name?: string | null
          vehicle?: Json | null
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "inspection_results_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_session_payloads: {
        Row: {
          payload: Json
          session_id: string
          updated_at: string
        }
        Insert: {
          payload: Json
          session_id: string
          updated_at?: string
        }
        Update: {
          payload?: Json
          session_id?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "inspection_session_payloads_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: true
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_sessions: {
        Row: {
          completed_at: string | null
          created_by: string | null
          customer_id: string | null
          id: string
          state: Json | null
          status: string
          template: string | null
          updated_at: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_id: string | null
          work_order_line_id: string | null
        }
        Insert: {
          completed_at?: string | null
          created_by?: string | null
          customer_id?: string | null
          id?: string
          state?: Json | null
          status?: string
          template?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
          work_order_line_id?: string | null
        }
        Update: {
          completed_at?: string | null
          created_by?: string | null
          customer_id?: string | null
          id?: string
          state?: Json | null
          status?: string
          template?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
          work_order_line_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "inspection_sessions_created_by_fk"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_fk"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_line_fk"
            columns: ["work_order_line_id"]
            isOneToOne: true
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_line_fk"
            columns: ["work_order_line_id"]
            isOneToOne: true
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: true
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: true
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_templates: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          is_public: boolean | null
          labor_hours: number | null
          sections: Json
          tags: string[] | null
          template_name: string
          updated_at: string | null
          user_id: string | null
          vehicle_type: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          is_public?: boolean | null
          labor_hours?: number | null
          sections: Json
          tags?: string[] | null
          template_name: string
          updated_at?: string | null
          user_id?: string | null
          vehicle_type?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          is_public?: boolean | null
          labor_hours?: number | null
          sections?: Json
          tags?: string[] | null
          template_name?: string
          updated_at?: string | null
          user_id?: string | null
          vehicle_type?: string | null
        }
        Relationships: []
      }
      inspections: {
        Row: {
          ai_summary: string | null
          completed: boolean | null
          created_at: string | null
          id: string
          inspection_type: string | null
          is_draft: boolean | null
          location: string | null
          notes: string | null
          pdf_url: string | null
          photo_urls: string[] | null
          quote_id: string | null
          shop_id: string | null
          started_at: string | null
          status: string | null
          summary: Json | null
          template_id: string | null
          updated_at: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_id: string | null
        }
        Insert: {
          ai_summary?: string | null
          completed?: boolean | null
          created_at?: string | null
          id?: string
          inspection_type?: string | null
          is_draft?: boolean | null
          location?: string | null
          notes?: string | null
          pdf_url?: string | null
          photo_urls?: string[] | null
          quote_id?: string | null
          shop_id?: string | null
          started_at?: string | null
          status?: string | null
          summary?: Json | null
          template_id?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          ai_summary?: string | null
          completed?: boolean | null
          created_at?: string | null
          id?: string
          inspection_type?: string | null
          is_draft?: boolean | null
          location?: string | null
          notes?: string | null
          pdf_url?: string | null
          photo_urls?: string[] | null
          quote_id?: string | null
          shop_id?: string | null
          started_at?: string | null
          status?: string | null
          summary?: Json | null
          template_id?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "inspections_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "inspection_templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspections_user_fk"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspections_vehicle_fk"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspections_work_order_fk"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspections_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      integration_logs: {
        Row: {
          action: string
          created_at: string
          error_message: string | null
          id: string
          provider: string
          request: Json | null
          response: Json | null
          shop_id: string | null
          success: boolean
        }
        Insert: {
          action: string
          created_at?: string
          error_message?: string | null
          id?: string
          provider: string
          request?: Json | null
          response?: Json | null
          shop_id?: string | null
          success?: boolean
        }
        Update: {
          action?: string
          created_at?: string
          error_message?: string | null
          id?: string
          provider?: string
          request?: Json | null
          response?: Json | null
          shop_id?: string | null
          success?: boolean
        }
        Relationships: [
          {
            foreignKeyName: "integration_logs_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "integration_logs_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      integrations: {
        Row: {
          config: Json | null
          created_at: string
          id: string
          provider: string
          shop_id: string | null
          status: string
          updated_at: string
        }
        Insert: {
          config?: Json | null
          created_at?: string
          id?: string
          provider: string
          shop_id?: string | null
          status?: string
          updated_at?: string
        }
        Update: {
          config?: Json | null
          created_at?: string
          id?: string
          provider?: string
          shop_id?: string | null
          status?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "integrations_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "integrations_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      media_uploads: {
        Row: {
          analysis_summary: string | null
          audio_url: string | null
          created_at: string | null
          file_type: string | null
          file_url: string | null
          id: string
          inspection_id: string | null
          user_id: string | null
          work_order_id: string | null
        }
        Insert: {
          analysis_summary?: string | null
          audio_url?: string | null
          created_at?: string | null
          file_type?: string | null
          file_url?: string | null
          id?: string
          inspection_id?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          analysis_summary?: string | null
          audio_url?: string | null
          created_at?: string | null
          file_type?: string | null
          file_url?: string | null
          id?: string
          inspection_id?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "media_uploads_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      menu_item_parts: {
        Row: {
          created_at: string | null
          id: string
          menu_item_id: string
          name: string
          quantity: number
          unit_cost: number
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          menu_item_id: string
          name: string
          quantity?: number
          unit_cost?: number
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          menu_item_id?: string
          name?: string
          quantity?: number
          unit_cost?: number
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "menu_item_parts_menu_item_id_fkey"
            columns: ["menu_item_id"]
            isOneToOne: false
            referencedRelation: "menu_items"
            referencedColumns: ["id"]
          },
        ]
      }
      menu_items: {
        Row: {
          category: string | null
          cause: string | null
          complaint: string | null
          correction: string | null
          created_at: string | null
          description: string | null
          id: string
          inspection_template_id: string | null
          is_active: boolean | null
          labor_hours: number | null
          labor_time: number | null
          name: string | null
          part_cost: number | null
          shop_id: string | null
          tools: string | null
          total_price: number | null
          user_id: string | null
        }
        Insert: {
          category?: string | null
          cause?: string | null
          complaint?: string | null
          correction?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          inspection_template_id?: string | null
          is_active?: boolean | null
          labor_hours?: number | null
          labor_time?: number | null
          name?: string | null
          part_cost?: number | null
          shop_id?: string | null
          tools?: string | null
          total_price?: number | null
          user_id?: string | null
        }
        Update: {
          category?: string | null
          cause?: string | null
          complaint?: string | null
          correction?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          inspection_template_id?: string | null
          is_active?: boolean | null
          labor_hours?: number | null
          labor_time?: number | null
          name?: string | null
          part_cost?: number | null
          shop_id?: string | null
          tools?: string | null
          total_price?: number | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "menu_items_inspection_template_id_fkey"
            columns: ["inspection_template_id"]
            isOneToOne: false
            referencedRelation: "inspection_templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "menu_items_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "menu_items_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      menu_pricing: {
        Row: {
          created_at: string | null
          description: string | null
          estimated_labor_minutes: number | null
          id: string
          labor_rate: number | null
          part_cost: number | null
          service_name: string | null
          user_id: string | null
          vehicle_make: string | null
          vehicle_model: string | null
          vehicle_year: number | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          estimated_labor_minutes?: number | null
          id?: string
          labor_rate?: number | null
          part_cost?: number | null
          service_name?: string | null
          user_id?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: number | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          estimated_labor_minutes?: number | null
          id?: string
          labor_rate?: number | null
          part_cost?: number | null
          service_name?: string | null
          user_id?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: number | null
        }
        Relationships: []
      }
      message_reads: {
        Row: {
          conversation_id: string
          id: string
          last_read_at: string
          user_id: string
        }
        Insert: {
          conversation_id: string
          id?: string
          last_read_at?: string
          user_id: string
        }
        Update: {
          conversation_id?: string
          id?: string
          last_read_at?: string
          user_id?: string
        }
        Relationships: []
      }
      messages: {
        Row: {
          attachments: Json
          content: string
          conversation_id: string | null
          created_at: string
          deleted_at: string | null
          edited_at: string | null
          id: string
          metadata: Json
          recipients: string[]
          reply_to: string | null
          sender_id: string | null
          sent_at: string | null
        }
        Insert: {
          attachments?: Json
          content: string
          conversation_id?: string | null
          created_at?: string
          deleted_at?: string | null
          edited_at?: string | null
          id?: string
          metadata?: Json
          recipients?: string[]
          reply_to?: string | null
          sender_id?: string | null
          sent_at?: string | null
        }
        Update: {
          attachments?: Json
          content?: string
          conversation_id?: string | null
          created_at?: string
          deleted_at?: string | null
          edited_at?: string | null
          id?: string
          metadata?: Json
          recipients?: string[]
          reply_to?: string | null
          sender_id?: string | null
          sent_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "messages_conversation_id_fkey"
            columns: ["conversation_id"]
            isOneToOne: false
            referencedRelation: "conversations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_reply_to_fkey"
            columns: ["reply_to"]
            isOneToOne: false
            referencedRelation: "messages"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_reply_to_fkey"
            columns: ["reply_to"]
            isOneToOne: false
            referencedRelation: "v_my_messages"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_sender_id_fkey"
            columns: ["sender_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      notifications: {
        Row: {
          body: string | null
          created_at: string | null
          data: Json | null
          id: string
          is_read: boolean | null
          kind: string
          title: string
          user_id: string
        }
        Insert: {
          body?: string | null
          created_at?: string | null
          data?: Json | null
          id?: string
          is_read?: boolean | null
          kind: string
          title: string
          user_id: string
        }
        Update: {
          body?: string | null
          created_at?: string | null
          data?: Json | null
          id?: string
          is_read?: boolean | null
          kind?: string
          title?: string
          user_id?: string
        }
        Relationships: []
      }
      part_barcodes: {
        Row: {
          barcode: string
          id: string
          kind: string | null
          part_id: string
        }
        Insert: {
          barcode: string
          id?: string
          kind?: string | null
          part_id: string
        }
        Update: {
          barcode?: string
          id?: string
          kind?: string | null
          part_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "part_barcodes_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_barcodes_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      part_compatibility: {
        Row: {
          created_at: string | null
          id: string
          make: string
          model: string
          part_id: string | null
          shop_id: string | null
          year_range: unknown
        }
        Insert: {
          created_at?: string | null
          id?: string
          make: string
          model: string
          part_id?: string | null
          shop_id?: string | null
          year_range?: unknown
        }
        Update: {
          created_at?: string | null
          id?: string
          make?: string
          model?: string
          part_id?: string | null
          shop_id?: string | null
          year_range?: unknown
        }
        Relationships: [
          {
            foreignKeyName: "part_compatibility_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_compatibility_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      part_purchases: {
        Row: {
          id: string
          part_id: string | null
          purchase_price: number | null
          purchased_at: string | null
          quantity: number
          shop_id: string | null
          supplier_id: string | null
        }
        Insert: {
          id?: string
          part_id?: string | null
          purchase_price?: number | null
          purchased_at?: string | null
          quantity: number
          shop_id?: string | null
          supplier_id?: string | null
        }
        Update: {
          id?: string
          part_id?: string | null
          purchase_price?: number | null
          purchased_at?: string | null
          quantity?: number
          shop_id?: string | null
          supplier_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "part_purchases_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_purchases_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_purchases_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "part_suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      part_request_items: {
        Row: {
          approved: boolean
          description: string
          id: string
          markup_pct: number | null
          part_id: string | null
          qty: number
          quoted_price: number | null
          request_id: string
          vendor: string | null
          work_order_line_id: string | null
        }
        Insert: {
          approved?: boolean
          description: string
          id?: string
          markup_pct?: number | null
          part_id?: string | null
          qty: number
          quoted_price?: number | null
          request_id: string
          vendor?: string | null
          work_order_line_id?: string | null
        }
        Update: {
          approved?: boolean
          description?: string
          id?: string
          markup_pct?: number | null
          part_id?: string | null
          qty?: number
          quoted_price?: number | null
          request_id?: string
          vendor?: string | null
          work_order_line_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "part_request_items_request_id_fkey"
            columns: ["request_id"]
            isOneToOne: false
            referencedRelation: "part_requests"
            referencedColumns: ["id"]
          },
        ]
      }
      part_request_lines: {
        Row: {
          created_at: string
          id: string
          request_id: string
          work_order_line_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          request_id: string
          work_order_line_id: string
        }
        Update: {
          created_at?: string
          id?: string
          request_id?: string
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "part_request_lines_request_id_fkey"
            columns: ["request_id"]
            isOneToOne: false
            referencedRelation: "part_requests"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_request_lines_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_request_lines_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      part_requests: {
        Row: {
          assigned_to: string | null
          created_at: string
          id: string
          notes: string | null
          requested_by: string | null
          shop_id: string
          status: Database["public"]["Enums"]["part_request_status"]
          work_order_id: string | null
        }
        Insert: {
          assigned_to?: string | null
          created_at?: string
          id?: string
          notes?: string | null
          requested_by?: string | null
          shop_id: string
          status?: Database["public"]["Enums"]["part_request_status"]
          work_order_id?: string | null
        }
        Update: {
          assigned_to?: string | null
          created_at?: string
          id?: string
          notes?: string | null
          requested_by?: string | null
          shop_id?: string
          status?: Database["public"]["Enums"]["part_request_status"]
          work_order_id?: string | null
        }
        Relationships: []
      }
      part_returns: {
        Row: {
          id: string
          part_id: string | null
          quantity: number
          reason: string | null
          returned_at: string | null
          returned_by: string | null
          shop_id: string | null
        }
        Insert: {
          id?: string
          part_id?: string | null
          quantity?: number
          reason?: string | null
          returned_at?: string | null
          returned_by?: string | null
          shop_id?: string | null
        }
        Update: {
          id?: string
          part_id?: string | null
          quantity?: number
          reason?: string | null
          returned_at?: string | null
          returned_by?: string | null
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "part_returns_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_returns_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      part_stock: {
        Row: {
          id: string
          location_id: string
          part_id: string
          qty_on_hand: number
          qty_reserved: number
          reorder_point: number | null
          reorder_qty: number | null
        }
        Insert: {
          id?: string
          location_id: string
          part_id: string
          qty_on_hand?: number
          qty_reserved?: number
          reorder_point?: number | null
          reorder_qty?: number | null
        }
        Update: {
          id?: string
          location_id?: string
          part_id?: string
          qty_on_hand?: number
          qty_reserved?: number
          reorder_point?: number | null
          reorder_qty?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "part_stock_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_stock_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_stock_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      part_suppliers: {
        Row: {
          contact_info: string | null
          created_at: string | null
          id: string
          name: string
          shop_id: string | null
        }
        Insert: {
          contact_info?: string | null
          created_at?: string | null
          id?: string
          name: string
          shop_id?: string | null
        }
        Update: {
          contact_info?: string | null
          created_at?: string | null
          id?: string
          name?: string
          shop_id?: string | null
        }
        Relationships: []
      }
      part_warranties: {
        Row: {
          coverage_details: string | null
          created_at: string | null
          id: string
          part_id: string | null
          shop_id: string | null
          warranty_period_months: number | null
          warranty_provider: string | null
        }
        Insert: {
          coverage_details?: string | null
          created_at?: string | null
          id?: string
          part_id?: string | null
          shop_id?: string | null
          warranty_period_months?: number | null
          warranty_provider?: string | null
        }
        Update: {
          coverage_details?: string | null
          created_at?: string | null
          id?: string
          part_id?: string | null
          shop_id?: string | null
          warranty_period_months?: number | null
          warranty_provider?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "part_warranties_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_warranties_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      parts: {
        Row: {
          category: string | null
          cost: number | null
          created_at: string | null
          default_cost: number | null
          default_price: number | null
          description: string | null
          id: string
          low_stock_threshold: number | null
          name: string
          part_number: string | null
          price: number | null
          shop_id: string | null
          sku: string | null
          subcategory: string | null
          supplier: string | null
          taxable: boolean | null
          unit: string | null
          warranty_months: number | null
        }
        Insert: {
          category?: string | null
          cost?: number | null
          created_at?: string | null
          default_cost?: number | null
          default_price?: number | null
          description?: string | null
          id?: string
          low_stock_threshold?: number | null
          name: string
          part_number?: string | null
          price?: number | null
          shop_id?: string | null
          sku?: string | null
          subcategory?: string | null
          supplier?: string | null
          taxable?: boolean | null
          unit?: string | null
          warranty_months?: number | null
        }
        Update: {
          category?: string | null
          cost?: number | null
          created_at?: string | null
          default_cost?: number | null
          default_price?: number | null
          description?: string | null
          id?: string
          low_stock_threshold?: number | null
          name?: string
          part_number?: string | null
          price?: number | null
          shop_id?: string | null
          sku?: string | null
          subcategory?: string | null
          supplier?: string | null
          taxable?: boolean | null
          unit?: string | null
          warranty_months?: number | null
        }
        Relationships: []
      }
      parts_barcodes: {
        Row: {
          barcode: string
          code: string | null
          created_at: string
          id: string
          part_id: string
          shop_id: string
          supplier_id: string | null
        }
        Insert: {
          barcode: string
          code?: string | null
          created_at?: string
          id?: string
          part_id: string
          shop_id: string
          supplier_id?: string | null
        }
        Update: {
          barcode?: string
          code?: string | null
          created_at?: string
          id?: string
          part_id?: string
          shop_id?: string
          supplier_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_barcodes_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "parts_barcodes_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_barcodes_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_messages: {
        Row: {
          created_at: string | null
          id: string
          message: string
          recipient_role: string | null
          request_id: string | null
          sender_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          message: string
          recipient_role?: string | null
          request_id?: string | null
          sender_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          message?: string
          recipient_role?: string | null
          request_id?: string | null
          sender_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_messages_request_id_fkey"
            columns: ["request_id"]
            isOneToOne: false
            referencedRelation: "parts_requests"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_quote_requests: {
        Row: {
          created_at: string
          id: string
          notes: string | null
          requested_by: string | null
          status: Database["public"]["Enums"]["quote_request_status"]
          updated_at: string
          work_order_id: string
          work_order_line_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          notes?: string | null
          requested_by?: string | null
          status?: Database["public"]["Enums"]["quote_request_status"]
          updated_at?: string
          work_order_id: string
          work_order_line_id: string
        }
        Update: {
          created_at?: string
          id?: string
          notes?: string | null
          requested_by?: string | null
          status?: Database["public"]["Enums"]["quote_request_status"]
          updated_at?: string
          work_order_id?: string
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "parts_quote_requests_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_quote_requests_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_quote_requests_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_quotes: {
        Row: {
          created_at: string | null
          id: string
          part_name: string | null
          part_number: string | null
          price: number | null
          quantity: number | null
          source: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          part_name?: string | null
          part_number?: string | null
          price?: number | null
          quantity?: number | null
          source?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          part_name?: string | null
          part_number?: string | null
          price?: number | null
          quantity?: number | null
          source?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_quotes_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_request_messages: {
        Row: {
          created_at: string | null
          id: string
          message: string
          request_id: string | null
          sender_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          message: string
          request_id?: string | null
          sender_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          message?: string
          request_id?: string | null
          sender_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_request_messages_request_id_fkey"
            columns: ["request_id"]
            isOneToOne: false
            referencedRelation: "parts_requests"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_requests: {
        Row: {
          archived: boolean | null
          created_at: string | null
          fulfilled_at: string | null
          id: string
          job_id: string | null
          notes: string | null
          part_name: string
          photo_url: string | null
          photo_urls: string[] | null
          quantity: number
          requested_by: string | null
          sent_at: string | null
          urgency: string | null
          viewed: boolean | null
          viewed_at: string | null
          work_order_id: string | null
        }
        Insert: {
          archived?: boolean | null
          created_at?: string | null
          fulfilled_at?: string | null
          id?: string
          job_id?: string | null
          notes?: string | null
          part_name: string
          photo_url?: string | null
          photo_urls?: string[] | null
          quantity?: number
          requested_by?: string | null
          sent_at?: string | null
          urgency?: string | null
          viewed?: boolean | null
          viewed_at?: string | null
          work_order_id?: string | null
        }
        Update: {
          archived?: boolean | null
          created_at?: string | null
          fulfilled_at?: string | null
          id?: string
          job_id?: string | null
          notes?: string | null
          part_name?: string
          photo_url?: string | null
          photo_urls?: string[] | null
          quantity?: number
          requested_by?: string | null
          sent_at?: string | null
          urgency?: string | null
          viewed?: boolean | null
          viewed_at?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_requests_job_id_fkey"
            columns: ["job_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_requests_job_id_fkey"
            columns: ["job_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_requests_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_suppliers: {
        Row: {
          api_base_url: string | null
          api_key: string | null
          created_at: string | null
          id: string
          shop_id: string | null
          supplier_name: string
        }
        Insert: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          shop_id?: string | null
          supplier_name: string
        }
        Update: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          shop_id?: string | null
          supplier_name?: string
        }
        Relationships: [
          {
            foreignKeyName: "parts_suppliers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_suppliers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_deductions: {
        Row: {
          amount: number
          created_at: string | null
          deduction_type: string
          id: string
          timecard_id: string | null
        }
        Insert: {
          amount: number
          created_at?: string | null
          deduction_type: string
          id?: string
          timecard_id?: string | null
        }
        Update: {
          amount?: number
          created_at?: string | null
          deduction_type?: string
          id?: string
          timecard_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "payroll_deductions_timecard_id_fkey"
            columns: ["timecard_id"]
            isOneToOne: false
            referencedRelation: "payroll_timecards"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_export_log: {
        Row: {
          created_at: string | null
          id: string
          message: string | null
          pay_period_id: string | null
          provider_id: string | null
          status: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          message?: string | null
          pay_period_id?: string | null
          provider_id?: string | null
          status: string
        }
        Update: {
          created_at?: string | null
          id?: string
          message?: string | null
          pay_period_id?: string | null
          provider_id?: string | null
          status?: string
        }
        Relationships: [
          {
            foreignKeyName: "payroll_export_log_pay_period_id_fkey"
            columns: ["pay_period_id"]
            isOneToOne: false
            referencedRelation: "payroll_pay_periods"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_export_log_provider_id_fkey"
            columns: ["provider_id"]
            isOneToOne: false
            referencedRelation: "payroll_providers"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_pay_periods: {
        Row: {
          created_at: string | null
          end_date: string
          id: string
          processed: boolean | null
          shop_id: string | null
          start_date: string
        }
        Insert: {
          created_at?: string | null
          end_date: string
          id?: string
          processed?: boolean | null
          shop_id?: string | null
          start_date: string
        }
        Update: {
          created_at?: string | null
          end_date?: string
          id?: string
          processed?: boolean | null
          shop_id?: string | null
          start_date?: string
        }
        Relationships: [
          {
            foreignKeyName: "payroll_pay_periods_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_pay_periods_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_providers: {
        Row: {
          api_base_url: string | null
          api_key: string | null
          created_at: string | null
          id: string
          provider_name: string
          shop_id: string | null
        }
        Insert: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          provider_name: string
          shop_id?: string | null
        }
        Update: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          provider_name?: string
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "payroll_providers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_providers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_timecards: {
        Row: {
          clock_in: string
          clock_out: string | null
          created_at: string | null
          hours_worked: number | null
          id: string
          shop_id: string | null
          user_id: string | null
        }
        Insert: {
          clock_in: string
          clock_out?: string | null
          created_at?: string | null
          hours_worked?: number | null
          id?: string
          shop_id?: string | null
          user_id?: string | null
        }
        Update: {
          clock_in?: string
          clock_out?: string | null
          created_at?: string | null
          hours_worked?: number | null
          id?: string
          shop_id?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "payroll_timecards_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_timecards_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_timecards_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      profiles: {
        Row: {
          agent_role: string | null
          business_name: string | null
          city: string | null
          completed_onboarding: boolean
          created_at: string | null
          created_by: string | null
          email: string | null
          full_name: string | null
          id: string
          last_active_at: string | null
          must_change_password: boolean
          phone: string | null
          plan: Database["public"]["Enums"]["plan_t"] | null
          postal_code: string | null
          province: string | null
          role: string | null
          shop_id: string | null
          shop_name: string | null
          street: string | null
          updated_at: string | null
          user_id: string | null
          username: string | null
        }
        Insert: {
          agent_role?: string | null
          business_name?: string | null
          city?: string | null
          completed_onboarding?: boolean
          created_at?: string | null
          created_by?: string | null
          email?: string | null
          full_name?: string | null
          id: string
          last_active_at?: string | null
          must_change_password?: boolean
          phone?: string | null
          plan?: Database["public"]["Enums"]["plan_t"] | null
          postal_code?: string | null
          province?: string | null
          role?: string | null
          shop_id?: string | null
          shop_name?: string | null
          street?: string | null
          updated_at?: string | null
          user_id?: string | null
          username?: string | null
        }
        Update: {
          agent_role?: string | null
          business_name?: string | null
          city?: string | null
          completed_onboarding?: boolean
          created_at?: string | null
          created_by?: string | null
          email?: string | null
          full_name?: string | null
          id?: string
          last_active_at?: string | null
          must_change_password?: boolean
          phone?: string | null
          plan?: Database["public"]["Enums"]["plan_t"] | null
          postal_code?: string | null
          province?: string | null
          role?: string | null
          shop_id?: string | null
          shop_name?: string | null
          street?: string | null
          updated_at?: string | null
          user_id?: string | null
          username?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      punch_events: {
        Row: {
          created_at: string | null
          event_type: string
          id: string
          note: string | null
          profile_id: string | null
          shift_id: string | null
          timestamp: string
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          event_type: string
          id?: string
          note?: string | null
          profile_id?: string | null
          shift_id?: string | null
          timestamp?: string
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          event_type?: string
          id?: string
          note?: string | null
          profile_id?: string | null
          shift_id?: string | null
          timestamp?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "punch_events_shift_id_fkey"
            columns: ["shift_id"]
            isOneToOne: false
            referencedRelation: "tech_shifts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "punch_events_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      purchase_order_items: {
        Row: {
          description: string | null
          id: string
          location_id: string | null
          part_id: string
          po_id: string
          qty_ordered: number
          qty_received: number
          unit_cost: number
        }
        Insert: {
          description?: string | null
          id?: string
          location_id?: string | null
          part_id: string
          po_id: string
          qty_ordered: number
          qty_received?: number
          unit_cost?: number
        }
        Update: {
          description?: string | null
          id?: string
          location_id?: string | null
          part_id?: string
          po_id?: string
          qty_ordered?: number
          qty_received?: number
          unit_cost?: number
        }
        Relationships: [
          {
            foreignKeyName: "purchase_order_items_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "purchase_order_items_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "purchase_order_items_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "purchase_order_items_po_id_fkey"
            columns: ["po_id"]
            isOneToOne: false
            referencedRelation: "purchase_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      purchase_order_lines: {
        Row: {
          created_at: string
          description: string | null
          id: string
          location_id: string | null
          part_id: string | null
          po_id: string
          qty: number
          received_qty: number
          sku: string | null
          unit_cost: number | null
        }
        Insert: {
          created_at?: string
          description?: string | null
          id?: string
          location_id?: string | null
          part_id?: string | null
          po_id: string
          qty: number
          received_qty?: number
          sku?: string | null
          unit_cost?: number | null
        }
        Update: {
          created_at?: string
          description?: string | null
          id?: string
          location_id?: string | null
          part_id?: string | null
          po_id?: string
          qty?: number
          received_qty?: number
          sku?: string | null
          unit_cost?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "purchase_order_lines_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "purchase_order_lines_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "purchase_order_lines_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "purchase_order_lines_po_id_fkey"
            columns: ["po_id"]
            isOneToOne: false
            referencedRelation: "purchase_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      purchase_orders: {
        Row: {
          created_at: string
          created_by: string | null
          expected_at: string | null
          id: string
          ordered_at: string | null
          received_at: string | null
          shipping_total: number | null
          shop_id: string
          status: string
          subtotal: number | null
          supplier_id: string
          tax_total: number | null
          total: number | null
        }
        Insert: {
          created_at?: string
          created_by?: string | null
          expected_at?: string | null
          id?: string
          ordered_at?: string | null
          received_at?: string | null
          shipping_total?: number | null
          shop_id: string
          status?: string
          subtotal?: number | null
          supplier_id: string
          tax_total?: number | null
          total?: number | null
        }
        Update: {
          created_at?: string
          created_by?: string | null
          expected_at?: string | null
          id?: string
          ordered_at?: string | null
          received_at?: string | null
          shipping_total?: number | null
          shop_id?: string
          status?: string
          subtotal?: number | null
          supplier_id?: string
          tax_total?: number | null
          total?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "purchase_orders_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      quote_lines: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          item: string | null
          labor_rate: number | null
          labor_time: number | null
          name: string | null
          notes: string | null
          part: Json | null
          part_name: string | null
          part_price: number | null
          parts_cost: number | null
          photo_urls: string[] | null
          price: number | null
          quantity: number | null
          status: string | null
          title: string
          total: number | null
          updated_at: string | null
          user_id: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          item?: string | null
          labor_rate?: number | null
          labor_time?: number | null
          name?: string | null
          notes?: string | null
          part?: Json | null
          part_name?: string | null
          part_price?: number | null
          parts_cost?: number | null
          photo_urls?: string[] | null
          price?: number | null
          quantity?: number | null
          status?: string | null
          title: string
          total?: number | null
          updated_at?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          item?: string | null
          labor_rate?: number | null
          labor_time?: number | null
          name?: string | null
          notes?: string | null
          part?: Json | null
          part_name?: string | null
          part_price?: number | null
          parts_cost?: number | null
          photo_urls?: string[] | null
          price?: number | null
          quantity?: number | null
          status?: string | null
          title?: string
          total?: number | null
          updated_at?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "quote_lines_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      saved_menu_items: {
        Row: {
          created_at: string
          id: string
          labor_time: number | null
          make: string
          model: string
          parts: Json
          title: string
          updated_at: string
          year_bucket: string
        }
        Insert: {
          created_at?: string
          id?: string
          labor_time?: number | null
          make: string
          model: string
          parts?: Json
          title: string
          updated_at?: string
          year_bucket: string
        }
        Update: {
          created_at?: string
          id?: string
          labor_time?: number | null
          make?: string
          model?: string
          parts?: Json
          title?: string
          updated_at?: string
          year_bucket?: string
        }
        Relationships: []
      }
      shop_ai_profiles: {
        Row: {
          last_refreshed_at: string
          shop_id: string
          summary: Json
        }
        Insert: {
          last_refreshed_at?: string
          shop_id: string
          summary: Json
        }
        Update: {
          last_refreshed_at?: string
          shop_id?: string
          summary?: Json
        }
        Relationships: [
          {
            foreignKeyName: "shop_ai_profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: true
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_ai_profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: true
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_hours: {
        Row: {
          close_time: string
          id: string
          open_time: string
          shop_id: string | null
          weekday: number
        }
        Insert: {
          close_time: string
          id?: string
          open_time: string
          shop_id?: string | null
          weekday: number
        }
        Update: {
          close_time?: string
          id?: string
          open_time?: string
          shop_id?: string | null
          weekday?: number
        }
        Relationships: [
          {
            foreignKeyName: "shop_hours_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_hours_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_parts: {
        Row: {
          created_at: string | null
          id: string
          location: string | null
          part_id: string | null
          quantity: number
          restock_threshold: number | null
          shop_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          location?: string | null
          part_id?: string | null
          quantity?: number
          restock_threshold?: number | null
          shop_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          location?: string | null
          part_id?: string | null
          quantity?: number
          restock_threshold?: number | null
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "shop_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "shop_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_profiles: {
        Row: {
          address_line1: string | null
          address_line2: string | null
          city: string | null
          country: string | null
          created_at: string
          description: string | null
          email: string | null
          hours: Json | null
          images: string[] | null
          latitude: number | null
          longitude: number | null
          phone: string | null
          postal_code: string | null
          province: string | null
          shop_id: string
          tagline: string | null
          updated_at: string
          website: string | null
        }
        Insert: {
          address_line1?: string | null
          address_line2?: string | null
          city?: string | null
          country?: string | null
          created_at?: string
          description?: string | null
          email?: string | null
          hours?: Json | null
          images?: string[] | null
          latitude?: number | null
          longitude?: number | null
          phone?: string | null
          postal_code?: string | null
          province?: string | null
          shop_id: string
          tagline?: string | null
          updated_at?: string
          website?: string | null
        }
        Update: {
          address_line1?: string | null
          address_line2?: string | null
          city?: string | null
          country?: string | null
          created_at?: string
          description?: string | null
          email?: string | null
          hours?: Json | null
          images?: string[] | null
          latitude?: number | null
          longitude?: number | null
          phone?: string | null
          postal_code?: string | null
          province?: string | null
          shop_id?: string
          tagline?: string | null
          updated_at?: string
          website?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "shop_profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: true
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: true
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_ratings: {
        Row: {
          comment: string | null
          created_at: string
          customer_id: string
          id: string
          score: number
          shop_id: string
          updated_at: string
        }
        Insert: {
          comment?: string | null
          created_at?: string
          customer_id: string
          id?: string
          score: number
          shop_id: string
          updated_at?: string
        }
        Update: {
          comment?: string | null
          created_at?: string
          customer_id?: string
          id?: string
          score?: number
          shop_id?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "shop_ratings_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_ratings_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_ratings_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_reviews: {
        Row: {
          comment: string | null
          created_at: string
          customer_id: string | null
          id: string
          rating: number
          replied_at: string | null
          reviewer_user_id: string
          shop_id: string
          shop_owner_reply: string | null
          updated_at: string
        }
        Insert: {
          comment?: string | null
          created_at?: string
          customer_id?: string | null
          id?: string
          rating: number
          replied_at?: string | null
          reviewer_user_id: string
          shop_id: string
          shop_owner_reply?: string | null
          updated_at?: string
        }
        Update: {
          comment?: string | null
          created_at?: string
          customer_id?: string | null
          id?: string
          rating?: number
          replied_at?: string | null
          reviewer_user_id?: string
          shop_id?: string
          shop_owner_reply?: string | null
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "shop_reviews_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_reviews_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_reviews_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_schedules: {
        Row: {
          booked_by: string | null
          created_at: string | null
          date: string
          id: string
          is_booked: boolean | null
          shop_id: string | null
          time_slot: string
        }
        Insert: {
          booked_by?: string | null
          created_at?: string | null
          date: string
          id?: string
          is_booked?: boolean | null
          shop_id?: string | null
          time_slot: string
        }
        Update: {
          booked_by?: string | null
          created_at?: string | null
          date?: string
          id?: string
          is_booked?: boolean | null
          shop_id?: string | null
          time_slot?: string
        }
        Relationships: [
          {
            foreignKeyName: "shop_schedules_booked_by_fkey"
            columns: ["booked_by"]
            isOneToOne: false
            referencedRelation: "customer_bookings"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_settings: {
        Row: {
          allow_customer_quotes: boolean | null
          allow_self_booking: boolean | null
          created_at: string | null
          id: string
          province: string | null
          timezone: string | null
          user_id: string | null
        }
        Insert: {
          allow_customer_quotes?: boolean | null
          allow_self_booking?: boolean | null
          created_at?: string | null
          id?: string
          province?: string | null
          timezone?: string | null
          user_id?: string | null
        }
        Update: {
          allow_customer_quotes?: boolean | null
          allow_self_booking?: boolean | null
          created_at?: string | null
          id?: string
          province?: string | null
          timezone?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      shop_tax_overrides: {
        Row: {
          created_at: string | null
          id: string
          override_rate: number
          shop_id: string | null
          tax_rate_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          override_rate: number
          shop_id?: string | null
          tax_rate_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          override_rate?: number
          shop_id?: string | null
          tax_rate_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "shop_tax_overrides_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_tax_overrides_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_tax_overrides_tax_rate_id_fkey"
            columns: ["tax_rate_id"]
            isOneToOne: false
            referencedRelation: "tax_rates"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_time_off: {
        Row: {
          ends_at: string
          id: string
          reason: string | null
          shop_id: string | null
          starts_at: string
        }
        Insert: {
          ends_at: string
          id?: string
          reason?: string | null
          shop_id?: string | null
          starts_at: string
        }
        Update: {
          ends_at?: string
          id?: string
          reason?: string | null
          shop_id?: string | null
          starts_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "shop_time_off_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_time_off_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_time_slots: {
        Row: {
          created_at: string | null
          end_time: string
          id: string
          is_booked: boolean | null
          shop_id: string | null
          start_time: string
        }
        Insert: {
          created_at?: string | null
          end_time: string
          id?: string
          is_booked?: boolean | null
          shop_id?: string | null
          start_time: string
        }
        Update: {
          created_at?: string | null
          end_time?: string
          id?: string
          is_booked?: boolean | null
          shop_id?: string | null
          start_time?: string
        }
        Relationships: []
      }
      shops: {
        Row: {
          accepts_online_booking: boolean | null
          active_user_count: number | null
          address: string | null
          auto_generate_pdf: boolean | null
          auto_send_quote_email: boolean | null
          business_name: string | null
          city: string | null
          created_at: string | null
          created_by: string | null
          diagnostic_fee: number | null
          email: string | null
          email_on_complete: boolean | null
          geo_lat: number | null
          geo_lng: number | null
          id: string
          images: string[] | null
          invoice_footer: string | null
          invoice_terms: string | null
          labor_rate: number | null
          logo_url: string | null
          max_lead_days: number | null
          min_notice_minutes: number | null
          name: string | null
          owner_id: string
          owner_pin: string | null
          owner_pin_hash: string | null
          phone_number: string | null
          pin: string | null
          plan: string | null
          postal_code: string | null
          province: string | null
          rating: number | null
          require_authorization: boolean | null
          require_cause_correction: boolean | null
          shop_name: string | null
          slug: string | null
          street: string | null
          supplies_percent: number | null
          tax_rate: number | null
          timezone: string | null
          updated_at: string | null
          use_ai: boolean | null
          user_limit: number | null
        }
        Insert: {
          accepts_online_booking?: boolean | null
          active_user_count?: number | null
          address?: string | null
          auto_generate_pdf?: boolean | null
          auto_send_quote_email?: boolean | null
          business_name?: string | null
          city?: string | null
          created_at?: string | null
          created_by?: string | null
          diagnostic_fee?: number | null
          email?: string | null
          email_on_complete?: boolean | null
          geo_lat?: number | null
          geo_lng?: number | null
          id?: string
          images?: string[] | null
          invoice_footer?: string | null
          invoice_terms?: string | null
          labor_rate?: number | null
          logo_url?: string | null
          max_lead_days?: number | null
          min_notice_minutes?: number | null
          name?: string | null
          owner_id: string
          owner_pin?: string | null
          owner_pin_hash?: string | null
          phone_number?: string | null
          pin?: string | null
          plan?: string | null
          postal_code?: string | null
          province?: string | null
          rating?: number | null
          require_authorization?: boolean | null
          require_cause_correction?: boolean | null
          shop_name?: string | null
          slug?: string | null
          street?: string | null
          supplies_percent?: number | null
          tax_rate?: number | null
          timezone?: string | null
          updated_at?: string | null
          use_ai?: boolean | null
          user_limit?: number | null
        }
        Update: {
          accepts_online_booking?: boolean | null
          active_user_count?: number | null
          address?: string | null
          auto_generate_pdf?: boolean | null
          auto_send_quote_email?: boolean | null
          business_name?: string | null
          city?: string | null
          created_at?: string | null
          created_by?: string | null
          diagnostic_fee?: number | null
          email?: string | null
          email_on_complete?: boolean | null
          geo_lat?: number | null
          geo_lng?: number | null
          id?: string
          images?: string[] | null
          invoice_footer?: string | null
          invoice_terms?: string | null
          labor_rate?: number | null
          logo_url?: string | null
          max_lead_days?: number | null
          min_notice_minutes?: number | null
          name?: string | null
          owner_id?: string
          owner_pin?: string | null
          owner_pin_hash?: string | null
          phone_number?: string | null
          pin?: string | null
          plan?: string | null
          postal_code?: string | null
          province?: string | null
          rating?: number | null
          require_authorization?: boolean | null
          require_cause_correction?: boolean | null
          shop_name?: string | null
          slug?: string | null
          street?: string | null
          supplies_percent?: number | null
          tax_rate?: number | null
          timezone?: string | null
          updated_at?: string | null
          use_ai?: boolean | null
          user_limit?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "shops_owner_fk"
            columns: ["owner_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      stock_locations: {
        Row: {
          code: string
          id: string
          name: string
          shop_id: string
        }
        Insert: {
          code: string
          id?: string
          name: string
          shop_id: string
        }
        Update: {
          code?: string
          id?: string
          name?: string
          shop_id?: string
        }
        Relationships: []
      }
      stock_moves: {
        Row: {
          created_at: string
          created_by: string | null
          id: string
          location_id: string
          part_id: string
          qty_change: number
          reason: Database["public"]["Enums"]["stock_move_reason"]
          reference_id: string | null
          reference_kind: string | null
          shop_id: string
        }
        Insert: {
          created_at?: string
          created_by?: string | null
          id?: string
          location_id: string
          part_id: string
          qty_change: number
          reason: Database["public"]["Enums"]["stock_move_reason"]
          reference_id?: string | null
          reference_kind?: string | null
          shop_id: string
        }
        Update: {
          created_at?: string
          created_by?: string | null
          id?: string
          location_id?: string
          part_id?: string
          qty_change?: number
          reason?: Database["public"]["Enums"]["stock_move_reason"]
          reference_id?: string | null
          reference_kind?: string | null
          shop_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "stock_moves_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "stock_moves_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "stock_moves_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "stock_moves_shop_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "stock_moves_shop_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      supplier_catalog_items: {
        Row: {
          brand: string | null
          compatibility: Json | null
          cost: number | null
          description: string | null
          external_sku: string
          id: string
          price: number | null
          supplier_id: string | null
          updated_at: string | null
        }
        Insert: {
          brand?: string | null
          compatibility?: Json | null
          cost?: number | null
          description?: string | null
          external_sku: string
          id?: string
          price?: number | null
          supplier_id?: string | null
          updated_at?: string | null
        }
        Update: {
          brand?: string | null
          compatibility?: Json | null
          cost?: number | null
          description?: string | null
          external_sku?: string
          id?: string
          price?: number | null
          supplier_id?: string | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "supplier_catalog_items_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "parts_suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      supplier_orders: {
        Row: {
          created_at: string | null
          external_order_id: string | null
          id: string
          items: Json | null
          shop_id: string | null
          status: string
          supplier_id: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          external_order_id?: string | null
          id?: string
          items?: Json | null
          shop_id?: string | null
          status: string
          supplier_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          external_order_id?: string | null
          id?: string
          items?: Json | null
          shop_id?: string | null
          status?: string
          supplier_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "supplier_orders_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "supplier_orders_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "supplier_orders_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "parts_suppliers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "supplier_orders_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      supplier_price_history: {
        Row: {
          catalog_item_id: string | null
          changed_at: string | null
          id: string
          new_price: number | null
          old_price: number | null
        }
        Insert: {
          catalog_item_id?: string | null
          changed_at?: string | null
          id?: string
          new_price?: number | null
          old_price?: number | null
        }
        Update: {
          catalog_item_id?: string | null
          changed_at?: string | null
          id?: string
          new_price?: number | null
          old_price?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "supplier_price_history_catalog_item_id_fkey"
            columns: ["catalog_item_id"]
            isOneToOne: false
            referencedRelation: "supplier_catalog_items"
            referencedColumns: ["id"]
          },
        ]
      }
      suppliers: {
        Row: {
          account_no: string | null
          created_at: string
          created_by: string | null
          email: string | null
          id: string
          is_active: boolean
          name: string
          notes: string | null
          phone: string | null
          shop_id: string
        }
        Insert: {
          account_no?: string | null
          created_at?: string
          created_by?: string | null
          email?: string | null
          id?: string
          is_active?: boolean
          name: string
          notes?: string | null
          phone?: string | null
          shop_id: string
        }
        Update: {
          account_no?: string | null
          created_at?: string
          created_by?: string | null
          email?: string | null
          id?: string
          is_active?: boolean
          name?: string
          notes?: string | null
          phone?: string | null
          shop_id?: string
        }
        Relationships: []
      }
      tax_calculation_log: {
        Row: {
          breakdown: Json | null
          created_at: string | null
          gst: number | null
          hst: number | null
          id: string
          jurisdiction_id: string | null
          pst: number | null
          quote_id: string | null
          shop_id: string | null
          total_tax: number
          work_order_id: string | null
        }
        Insert: {
          breakdown?: Json | null
          created_at?: string | null
          gst?: number | null
          hst?: number | null
          id?: string
          jurisdiction_id?: string | null
          pst?: number | null
          quote_id?: string | null
          shop_id?: string | null
          total_tax: number
          work_order_id?: string | null
        }
        Update: {
          breakdown?: Json | null
          created_at?: string | null
          gst?: number | null
          hst?: number | null
          id?: string
          jurisdiction_id?: string | null
          pst?: number | null
          quote_id?: string | null
          shop_id?: string | null
          total_tax?: number
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "tax_calculation_log_jurisdiction_id_fkey"
            columns: ["jurisdiction_id"]
            isOneToOne: false
            referencedRelation: "tax_jurisdictions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_calculation_log_quote_id_fkey"
            columns: ["quote_id"]
            isOneToOne: false
            referencedRelation: "customer_quotes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_calculation_log_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_calculation_log_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_calculation_log_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      tax_jurisdictions: {
        Row: {
          code: string
          created_at: string | null
          id: string
          name: string
        }
        Insert: {
          code: string
          created_at?: string | null
          id?: string
          name: string
        }
        Update: {
          code?: string
          created_at?: string | null
          id?: string
          name?: string
        }
        Relationships: []
      }
      tax_providers: {
        Row: {
          api_base_url: string | null
          api_key: string | null
          created_at: string | null
          id: string
          provider_name: string
          shop_id: string | null
        }
        Insert: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          provider_name: string
          shop_id?: string | null
        }
        Update: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          provider_name?: string
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "tax_providers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_providers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      tax_rates: {
        Row: {
          created_at: string | null
          effective_from: string
          effective_to: string | null
          id: string
          jurisdiction_id: string | null
          rate: number
          tax_type: string
        }
        Insert: {
          created_at?: string | null
          effective_from: string
          effective_to?: string | null
          id?: string
          jurisdiction_id?: string | null
          rate: number
          tax_type: string
        }
        Update: {
          created_at?: string | null
          effective_from?: string
          effective_to?: string | null
          id?: string
          jurisdiction_id?: string | null
          rate?: number
          tax_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "tax_rates_jurisdiction_id_fkey"
            columns: ["jurisdiction_id"]
            isOneToOne: false
            referencedRelation: "tax_jurisdictions"
            referencedColumns: ["id"]
          },
        ]
      }
      tech_sessions: {
        Row: {
          ended_at: string | null
          id: string
          inspection_id: string | null
          started_at: string | null
          user_id: string | null
          work_order_id: string | null
        }
        Insert: {
          ended_at?: string | null
          id?: string
          inspection_id?: string | null
          started_at?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          ended_at?: string | null
          id?: string
          inspection_id?: string | null
          started_at?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "tech_sessions_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      tech_shifts: {
        Row: {
          created_at: string | null
          end_time: string | null
          id: string
          start_time: string
          status: string
          type: string
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          end_time?: string | null
          id?: string
          start_time?: string
          status?: string
          type?: string
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          end_time?: string | null
          id?: string
          start_time?: string
          status?: string
          type?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "tech_shifts_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      template_items: {
        Row: {
          id: string
          input_type: string | null
          label: string | null
          section: string | null
          template_id: string | null
        }
        Insert: {
          id?: string
          input_type?: string | null
          label?: string | null
          section?: string | null
          template_id?: string | null
        }
        Update: {
          id?: string
          input_type?: string | null
          label?: string | null
          section?: string | null
          template_id?: string | null
        }
        Relationships: []
      }
      usage_logs: {
        Row: {
          feature: string | null
          id: string
          used_at: string | null
          user_id: string | null
        }
        Insert: {
          feature?: string | null
          id?: string
          used_at?: string | null
          user_id?: string | null
        }
        Update: {
          feature?: string | null
          id?: string
          used_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      user_app_layouts: {
        Row: {
          id: string
          layout: Json
          updated_at: string | null
          user_id: string
          wallpaper: string | null
        }
        Insert: {
          id?: string
          layout: Json
          updated_at?: string | null
          user_id: string
          wallpaper?: string | null
        }
        Update: {
          id?: string
          layout?: Json
          updated_at?: string | null
          user_id?: string
          wallpaper?: string | null
        }
        Relationships: []
      }
      user_plans: {
        Row: {
          created_at: string | null
          features: Json | null
          id: string
          plan_name: string
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          features?: Json | null
          id?: string
          plan_name: string
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          features?: Json | null
          id?: string
          plan_name?: string
          user_id?: string | null
        }
        Relationships: []
      }
      user_widget_layouts: {
        Row: {
          id: string
          layout: Json
          updated_at: string | null
          user_id: string
        }
        Insert: {
          id?: string
          layout: Json
          updated_at?: string | null
          user_id: string
        }
        Update: {
          id?: string
          layout?: Json
          updated_at?: string | null
          user_id?: string
        }
        Relationships: []
      }
      vehicle_media: {
        Row: {
          created_at: string | null
          filename: string | null
          id: string
          shop_id: string | null
          storage_path: string
          type: string
          uploaded_by: string | null
          url: string | null
          vehicle_id: string | null
        }
        Insert: {
          created_at?: string | null
          filename?: string | null
          id?: string
          shop_id?: string | null
          storage_path: string
          type: string
          uploaded_by?: string | null
          url?: string | null
          vehicle_id?: string | null
        }
        Update: {
          created_at?: string | null
          filename?: string | null
          id?: string
          shop_id?: string | null
          storage_path?: string
          type?: string
          uploaded_by?: string | null
          url?: string | null
          vehicle_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "vehicle_media_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_media_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_media_uploaded_by_fkey"
            columns: ["uploaded_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_media_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      vehicle_photos: {
        Row: {
          caption: string | null
          created_at: string | null
          id: string
          shop_id: string | null
          uploaded_by: string | null
          url: string
          vehicle_id: string
        }
        Insert: {
          caption?: string | null
          created_at?: string | null
          id?: string
          shop_id?: string | null
          uploaded_by?: string | null
          url: string
          vehicle_id: string
        }
        Update: {
          caption?: string | null
          created_at?: string | null
          id?: string
          shop_id?: string | null
          uploaded_by?: string | null
          url?: string
          vehicle_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "vehicle_photos_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_photos_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_photos_uploaded_by_fkey"
            columns: ["uploaded_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_photos_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      vehicle_recalls: {
        Row: {
          campaign_number: string
          component: string | null
          consequence: string | null
          created_at: string
          id: string
          make: string | null
          manufacturer: string | null
          model: string | null
          model_year: string | null
          nhtsa_campaign: string | null
          notes: string | null
          remedy: string | null
          report_date: string | null
          report_received_date: string | null
          shop_id: string | null
          summary: string | null
          user_id: string | null
          vehicle_id: string | null
          vin: string
        }
        Insert: {
          campaign_number: string
          component?: string | null
          consequence?: string | null
          created_at?: string
          id?: string
          make?: string | null
          manufacturer?: string | null
          model?: string | null
          model_year?: string | null
          nhtsa_campaign?: string | null
          notes?: string | null
          remedy?: string | null
          report_date?: string | null
          report_received_date?: string | null
          shop_id?: string | null
          summary?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          vin: string
        }
        Update: {
          campaign_number?: string
          component?: string | null
          consequence?: string | null
          created_at?: string
          id?: string
          make?: string | null
          manufacturer?: string | null
          model?: string | null
          model_year?: string | null
          nhtsa_campaign?: string | null
          notes?: string | null
          remedy?: string | null
          report_date?: string | null
          report_received_date?: string | null
          shop_id?: string | null
          summary?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          vin?: string
        }
        Relationships: [
          {
            foreignKeyName: "vehicle_recalls_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_recalls_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_recalls_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      vehicles: {
        Row: {
          color: string | null
          created_at: string | null
          customer_id: string | null
          engine_hours: number | null
          id: string
          license_plate: string | null
          make: string | null
          mileage: string | null
          model: string | null
          shop_id: string | null
          unit_number: string | null
          user_id: string | null
          vin: string | null
          year: number | null
        }
        Insert: {
          color?: string | null
          created_at?: string | null
          customer_id?: string | null
          engine_hours?: number | null
          id?: string
          license_plate?: string | null
          make?: string | null
          mileage?: string | null
          model?: string | null
          shop_id?: string | null
          unit_number?: string | null
          user_id?: string | null
          vin?: string | null
          year?: number | null
        }
        Update: {
          color?: string | null
          created_at?: string | null
          customer_id?: string | null
          engine_hours?: number | null
          id?: string
          license_plate?: string | null
          make?: string | null
          mileage?: string | null
          model?: string | null
          shop_id?: string | null
          unit_number?: string | null
          user_id?: string | null
          vin?: string | null
          year?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "vehicles_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      vendor_part_numbers: {
        Row: {
          id: string
          part_id: string
          shop_id: string
          supplier_id: string | null
          vendor_sku: string
        }
        Insert: {
          id?: string
          part_id: string
          shop_id: string
          supplier_id?: string | null
          vendor_sku: string
        }
        Update: {
          id?: string
          part_id?: string
          shop_id?: string
          supplier_id?: string | null
          vendor_sku?: string
        }
        Relationships: [
          {
            foreignKeyName: "vendor_part_numbers_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "vendor_part_numbers_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vendor_part_numbers_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      vin_decodes: {
        Row: {
          created_at: string | null
          decoded_data: Json | null
          engine: string | null
          id: string
          make: string | null
          model: string | null
          trim: string | null
          user_id: string | null
          vin: string
          year: string | null
        }
        Insert: {
          created_at?: string | null
          decoded_data?: Json | null
          engine?: string | null
          id?: string
          make?: string | null
          model?: string | null
          trim?: string | null
          user_id?: string | null
          vin: string
          year?: string | null
        }
        Update: {
          created_at?: string | null
          decoded_data?: Json | null
          engine?: string | null
          id?: string
          make?: string | null
          model?: string | null
          trim?: string | null
          user_id?: string | null
          vin?: string
          year?: string | null
        }
        Relationships: []
      }
      warranties: {
        Row: {
          created_at: string
          customer_id: string | null
          expires_at: string
          id: string
          installed_at: string
          notes: string | null
          part_id: string
          shop_id: string
          supplier_id: string | null
          vehicle_id: string | null
          warranty_months: number
          work_order_id: string | null
          work_order_line_id: string | null
        }
        Insert: {
          created_at?: string
          customer_id?: string | null
          expires_at: string
          id: string
          installed_at: string
          notes?: string | null
          part_id: string
          shop_id: string
          supplier_id?: string | null
          vehicle_id?: string | null
          warranty_months?: number
          work_order_id?: string | null
          work_order_line_id?: string | null
        }
        Update: {
          created_at?: string
          customer_id?: string | null
          expires_at?: string
          id?: string
          installed_at?: string
          notes?: string | null
          part_id?: string
          shop_id?: string
          supplier_id?: string | null
          vehicle_id?: string | null
          warranty_months?: number
          work_order_id?: string | null
          work_order_line_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "warranties_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "warranties_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "suppliers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      warranty_claims: {
        Row: {
          created_at: string
          id: string
          notes: string | null
          opened_at: string
          status: string
          supplier_rma: string | null
          warranty_id: string
        }
        Insert: {
          created_at?: string
          id: string
          notes?: string | null
          opened_at?: string
          status: string
          supplier_rma?: string | null
          warranty_id: string
        }
        Update: {
          created_at?: string
          id?: string
          notes?: string | null
          opened_at?: string
          status?: string
          supplier_rma?: string | null
          warranty_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "warranty_claims_warranty_id_fkey"
            columns: ["warranty_id"]
            isOneToOne: false
            referencedRelation: "warranties"
            referencedColumns: ["id"]
          },
        ]
      }
      widget_instances: {
        Row: {
          config: Json
          created_at: string | null
          id: string
          user_id: string
          widget_slug: string
        }
        Insert: {
          config?: Json
          created_at?: string | null
          id?: string
          user_id: string
          widget_slug: string
        }
        Update: {
          config?: Json
          created_at?: string | null
          id?: string
          user_id?: string
          widget_slug?: string
        }
        Relationships: [
          {
            foreignKeyName: "widget_instances_widget_slug_fkey"
            columns: ["widget_slug"]
            isOneToOne: false
            referencedRelation: "widgets"
            referencedColumns: ["slug"]
          },
        ]
      }
      widgets: {
        Row: {
          allowed_sizes: string[]
          default_route: string
          default_size: string
          id: string
          name: string
          slug: string
        }
        Insert: {
          allowed_sizes?: string[]
          default_route: string
          default_size?: string
          id?: string
          name: string
          slug: string
        }
        Update: {
          allowed_sizes?: string[]
          default_route?: string
          default_size?: string
          id?: string
          name?: string
          slug?: string
        }
        Relationships: []
      }
      work_order_approvals: {
        Row: {
          approved_at: string | null
          approved_by: string | null
          id: string
          method: string | null
          work_order_id: string | null
        }
        Insert: {
          approved_at?: string | null
          approved_by?: string | null
          id?: string
          method?: string | null
          work_order_id?: string | null
        }
        Update: {
          approved_at?: string | null
          approved_by?: string | null
          id?: string
          method?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_order_approvals_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_line_history: {
        Row: {
          created_at: string
          id: string
          line_id: string | null
          reason: string
          snapshot: Json
          status: string | null
          work_order_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          line_id?: string | null
          reason?: string
          snapshot: Json
          status?: string | null
          work_order_id: string
        }
        Update: {
          created_at?: string
          id?: string
          line_id?: string | null
          reason?: string
          snapshot?: Json
          status?: string | null
          work_order_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "work_order_line_history_line_id_fkey"
            columns: ["line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_history_line_id_fkey"
            columns: ["line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_history_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_line_technicians: {
        Row: {
          assigned_at: string
          assigned_by: string | null
          id: string
          technician_id: string
          work_order_line_id: string
        }
        Insert: {
          assigned_at?: string
          assigned_by?: string | null
          id?: string
          technician_id: string
          work_order_line_id: string
        }
        Update: {
          assigned_at?: string
          assigned_by?: string | null
          id?: string
          technician_id?: string
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "work_order_line_technicians_assigned_by_fkey"
            columns: ["assigned_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_technicians_technician_id_fkey"
            columns: ["technician_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_technicians_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_technicians_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_lines: {
        Row: {
          approval_at: string | null
          approval_by: string | null
          approval_note: string | null
          approval_state: string | null
          assigned_tech_id: string | null
          assigned_to: string | null
          cause: string | null
          complaint: string | null
          correction: string | null
          created_at: string | null
          description: string | null
          hold_reason: string | null
          id: string
          inspection_session_id: string | null
          inspection_template_id: string | null
          job_type: string | null
          labor_time: number | null
          line_no: number | null
          line_status: string | null
          notes: string | null
          on_hold_since: string | null
          parts: string | null
          parts_needed: Json | null
          parts_received: Json | null
          parts_required: Json | null
          price_estimate: number | null
          priority: number | null
          punchable: boolean | null
          punched_in_at: string | null
          punched_out_at: string | null
          quoted_at: string | null
          shop_id: string | null
          status: string | null
          template_id: string | null
          tools: string | null
          updated_at: string | null
          urgency: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_id: string | null
        }
        Insert: {
          approval_at?: string | null
          approval_by?: string | null
          approval_note?: string | null
          approval_state?: string | null
          assigned_tech_id?: string | null
          assigned_to?: string | null
          cause?: string | null
          complaint?: string | null
          correction?: string | null
          created_at?: string | null
          description?: string | null
          hold_reason?: string | null
          id?: string
          inspection_session_id?: string | null
          inspection_template_id?: string | null
          job_type?: string | null
          labor_time?: number | null
          line_no?: number | null
          line_status?: string | null
          notes?: string | null
          on_hold_since?: string | null
          parts?: string | null
          parts_needed?: Json | null
          parts_received?: Json | null
          parts_required?: Json | null
          price_estimate?: number | null
          priority?: number | null
          punchable?: boolean | null
          punched_in_at?: string | null
          punched_out_at?: string | null
          quoted_at?: string | null
          shop_id?: string | null
          status?: string | null
          template_id?: string | null
          tools?: string | null
          updated_at?: string | null
          urgency?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          approval_at?: string | null
          approval_by?: string | null
          approval_note?: string | null
          approval_state?: string | null
          assigned_tech_id?: string | null
          assigned_to?: string | null
          cause?: string | null
          complaint?: string | null
          correction?: string | null
          created_at?: string | null
          description?: string | null
          hold_reason?: string | null
          id?: string
          inspection_session_id?: string | null
          inspection_template_id?: string | null
          job_type?: string | null
          labor_time?: number | null
          line_no?: number | null
          line_status?: string | null
          notes?: string | null
          on_hold_since?: string | null
          parts?: string | null
          parts_needed?: Json | null
          parts_received?: Json | null
          parts_required?: Json | null
          price_estimate?: number | null
          priority?: number | null
          punchable?: boolean | null
          punched_in_at?: string | null
          punched_out_at?: string | null
          quoted_at?: string | null
          shop_id?: string | null
          status?: string | null
          template_id?: string | null
          tools?: string | null
          updated_at?: string | null
          urgency?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_order_lines_assigned_tech_id_fkey"
            columns: ["assigned_tech_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_session_fk"
            columns: ["inspection_session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_session_id_fkey"
            columns: ["inspection_session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_template_id_fkey"
            columns: ["inspection_template_id"]
            isOneToOne: false
            referencedRelation: "inspection_templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_media: {
        Row: {
          created_at: string | null
          id: string
          kind: string | null
          shop_id: string
          url: string
          user_id: string | null
          work_order_id: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          kind?: string | null
          shop_id: string
          url: string
          user_id?: string | null
          work_order_id: string
        }
        Update: {
          created_at?: string | null
          id?: string
          kind?: string | null
          shop_id?: string
          url?: string
          user_id?: string | null
          work_order_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "work_order_media_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_media_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_media_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_part_allocations: {
        Row: {
          created_at: string
          id: string
          location_id: string
          part_id: string
          qty: number
          stock_move_id: string | null
          unit_cost: number
          work_order_id: string | null
          work_order_line_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          location_id: string
          part_id: string
          qty: number
          stock_move_id?: string | null
          unit_cost?: number
          work_order_id?: string | null
          work_order_line_id: string
        }
        Update: {
          created_at?: string
          id?: string
          location_id?: string
          part_id?: string
          qty?: number
          stock_move_id?: string | null
          unit_cost?: number
          work_order_id?: string | null
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "wopa_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_stock_move_id_fkey"
            columns: ["stock_move_id"]
            isOneToOne: false
            referencedRelation: "stock_moves"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_parts: {
        Row: {
          created_at: string | null
          id: string
          part_id: string | null
          quantity: number
          shop_id: string | null
          total_price: number | null
          unit_price: number | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          part_id?: string | null
          quantity?: number
          shop_id?: string | null
          total_price?: number | null
          unit_price?: number | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          part_id?: string | null
          quantity?: number
          shop_id?: string | null
          total_price?: number | null
          unit_price?: number | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_order_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "work_order_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_parts_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_orders: {
        Row: {
          approval_state: string | null
          assigned_tech: string | null
          created_at: string | null
          created_by: string | null
          custom_id: string | null
          customer_approval_at: string | null
          customer_approval_signature_path: string | null
          customer_approval_signature_url: string | null
          customer_approved_by: string | null
          customer_id: string | null
          customer_name: string | null
          id: string
          inspection_id: string | null
          inspection_pdf_url: string | null
          inspection_type: string | null
          invoice_total: number | null
          invoice_url: string | null
          labor_total: number | null
          notes: string | null
          parts_total: number | null
          priority: number | null
          quote: Json | null
          quote_url: string | null
          shop_id: string | null
          status: string | null
          type: string | null
          updated_at: string | null
          user_id: string | null
          vehicle_color: string | null
          vehicle_engine_hours: number | null
          vehicle_id: string | null
          vehicle_info: string | null
          vehicle_mileage: number | null
          vehicle_unit_number: string | null
        }
        Insert: {
          approval_state?: string | null
          assigned_tech?: string | null
          created_at?: string | null
          created_by?: string | null
          custom_id?: string | null
          customer_approval_at?: string | null
          customer_approval_signature_path?: string | null
          customer_approval_signature_url?: string | null
          customer_approved_by?: string | null
          customer_id?: string | null
          customer_name?: string | null
          id?: string
          inspection_id?: string | null
          inspection_pdf_url?: string | null
          inspection_type?: string | null
          invoice_total?: number | null
          invoice_url?: string | null
          labor_total?: number | null
          notes?: string | null
          parts_total?: number | null
          priority?: number | null
          quote?: Json | null
          quote_url?: string | null
          shop_id?: string | null
          status?: string | null
          type?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_color?: string | null
          vehicle_engine_hours?: number | null
          vehicle_id?: string | null
          vehicle_info?: string | null
          vehicle_mileage?: number | null
          vehicle_unit_number?: string | null
        }
        Update: {
          approval_state?: string | null
          assigned_tech?: string | null
          created_at?: string | null
          created_by?: string | null
          custom_id?: string | null
          customer_approval_at?: string | null
          customer_approval_signature_path?: string | null
          customer_approval_signature_url?: string | null
          customer_approved_by?: string | null
          customer_id?: string | null
          customer_name?: string | null
          id?: string
          inspection_id?: string | null
          inspection_pdf_url?: string | null
          inspection_type?: string | null
          invoice_total?: number | null
          invoice_url?: string | null
          labor_total?: number | null
          notes?: string | null
          parts_total?: number | null
          priority?: number | null
          quote?: Json | null
          quote_url?: string | null
          shop_id?: string | null
          status?: string | null
          type?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_color?: string | null
          vehicle_engine_hours?: number | null
          vehicle_id?: string | null
          vehicle_info?: string | null
          vehicle_mileage?: number | null
          vehicle_unit_number?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_orders_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      part_stock_summary: {
        Row: {
          category: string | null
          move_count: number | null
          name: string | null
          on_hand: number | null
          part_id: string | null
          price: number | null
          shop_id: string | null
          sku: string | null
        }
        Relationships: []
      }
      shop_public_profiles: {
        Row: {
          city: string | null
          geo_lat: number | null
          geo_lng: number | null
          id: string | null
          images: string[] | null
          logo_url: string | null
          name: string | null
          province: string | null
          rating: number | null
        }
        Insert: {
          city?: string | null
          geo_lat?: number | null
          geo_lng?: number | null
          id?: string | null
          images?: string[] | null
          logo_url?: string | null
          name?: string | null
          province?: string | null
          rating?: number | null
        }
        Update: {
          city?: string | null
          geo_lat?: number | null
          geo_lng?: number | null
          id?: string | null
          images?: string[] | null
          logo_url?: string | null
          name?: string | null
          province?: string | null
          rating?: number | null
        }
        Relationships: []
      }
      shop_reviews_public: {
        Row: {
          comment: string | null
          created_at: string | null
          id: string | null
          rating: number | null
          replied_at: string | null
          shop_id: string | null
          shop_owner_reply: string | null
        }
        Insert: {
          comment?: string | null
          created_at?: string | null
          id?: string | null
          rating?: number | null
          replied_at?: string | null
          shop_id?: string | null
          shop_owner_reply?: never
        }
        Update: {
          comment?: string | null
          created_at?: string | null
          id?: string | null
          rating?: number | null
          replied_at?: string | null
          shop_id?: string | null
          shop_owner_reply?: never
        }
        Relationships: [
          {
            foreignKeyName: "shop_reviews_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_reviews_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      stock_balances: {
        Row: {
          location_id: string | null
          on_hand: number | null
          part_id: string | null
        }
        Relationships: [
          {
            foreignKeyName: "stock_moves_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "stock_moves_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "stock_moves_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      v_my_conversation_ids: {
        Row: {
          conversation_id: string | null
        }
        Relationships: []
      }
      v_my_messages: {
        Row: {
          content: string | null
          conversation_id: string | null
          created_at: string | null
          id: string | null
          sender_id: string | null
          sent_at: string | null
        }
        Insert: {
          content?: string | null
          conversation_id?: string | null
          created_at?: string | null
          id?: string | null
          sender_id?: string | null
          sent_at?: string | null
        }
        Update: {
          content?: string | null
          conversation_id?: string | null
          created_at?: string | null
          id?: string | null
          sender_id?: string | null
          sent_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "messages_conversation_id_fkey"
            columns: ["conversation_id"]
            isOneToOne: false
            referencedRelation: "conversations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_sender_id_fkey"
            columns: ["sender_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      v_part_stock: {
        Row: {
          location_id: string | null
          part_id: string | null
          qty_available: number | null
          qty_on_hand: number | null
          qty_reserved: number | null
        }
        Insert: {
          location_id?: string | null
          part_id?: string | null
          qty_available?: never
          qty_on_hand?: number | null
          qty_reserved?: number | null
        }
        Update: {
          location_id?: string | null
          part_id?: string | null
          qty_available?: never
          qty_on_hand?: number | null
          qty_reserved?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "part_stock_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_stock_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_stock_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      v_quote_queue: {
        Row: {
          approval_at: string | null
          approval_by: string | null
          approval_note: string | null
          approval_state: string | null
          assigned_tech_id: string | null
          assigned_to: string | null
          cause: string | null
          complaint: string | null
          correction: string | null
          created_at: string | null
          description: string | null
          hold_reason: string | null
          id: string | null
          inspection_session_id: string | null
          job_type: string | null
          labor_time: number | null
          line_status: string | null
          notes: string | null
          on_hold_since: string | null
          parts: string | null
          parts_needed: Json | null
          parts_received: Json | null
          parts_required: Json | null
          price_estimate: number | null
          priority: number | null
          punched_in_at: string | null
          punched_out_at: string | null
          shop_id: string | null
          status: string | null
          template_id: string | null
          tools: string | null
          updated_at: string | null
          urgency: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_custom_id: string | null
          work_order_customer_id: string | null
          work_order_id: string | null
          work_order_vehicle_id: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_order_lines_assigned_tech_id_fkey"
            columns: ["assigned_tech_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_session_fk"
            columns: ["inspection_session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_session_id_fkey"
            columns: ["inspection_session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_customer_id_fkey"
            columns: ["work_order_customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_vehicle_id_fkey"
            columns: ["work_order_vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      v_shift_rollups: {
        Row: {
          shift_id: string | null
          user_id: string | null
          worked_seconds: number | null
        }
        Relationships: [
          {
            foreignKeyName: "punch_events_shift_id_fkey"
            columns: ["shift_id"]
            isOneToOne: false
            referencedRelation: "tech_shifts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "punch_events_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Functions: {
      _ensure_same_shop: { Args: { _wo: string }; Returns: boolean }
      agent_can_start: { Args: never; Returns: boolean }
      apply_stock_move: {
        Args: {
          p_loc: string
          p_part: string
          p_qty: number
          p_reason: string
          p_ref_id: string
          p_ref_kind: string
        }
        Returns: {
          created_at: string
          created_by: string | null
          id: string
          location_id: string
          part_id: string
          qty_change: number
          reason: Database["public"]["Enums"]["stock_move_reason"]
          reference_id: string | null
          reference_kind: string | null
          shop_id: string
        }
        SetofOptions: {
          from: "*"
          to: "stock_moves"
          isOneToOne: true
          isSetofReturn: false
        }
      }
      approve_lines: {
        Args: {
          _approved_ids: string[]
          _approver?: string
          _decline_unchecked?: boolean
          _declined_ids?: string[]
          _wo: string
        }
        Returns: undefined
      }
      assign_unassigned_lines: {
        Args: { tech_id: string; wo_id: string }
        Returns: undefined
      }
      can_manage_profile: {
        Args: { target_profile_id: string }
        Returns: boolean
      }
      chat_participants_key: {
        Args: { _recipients: string[]; _sender: string }
        Returns: string
      }
      chat_post_message: {
        Args: { _chat_id?: string; _content: string; _recipients: string[] }
        Returns: string
      }
      check_plan_limit: { Args: { _feature: string }; Returns: boolean }
      clear_auth: { Args: never; Returns: undefined }
      create_part_request: {
        Args: { p_items: Json; p_notes: string; p_work_order: string }
        Returns: string
      }
      current_shop_id: { Args: never; Returns: string }
      first_segment_uuid: { Args: { p: string }; Returns: string }
      has_column: { Args: { col: string; tab: unknown }; Returns: boolean }
      increment_user_limit: {
        Args: { increment_by?: number; input_shop_id: string }
        Returns: undefined
      }
      is_customer: { Args: { _customer: string }; Returns: boolean }
      is_shop_member: { Args: { p_shop: string }; Returns: boolean }
      is_staff_for_shop: { Args: { _shop: string }; Returns: boolean }
      mark_active: { Args: never; Returns: undefined }
      recompute_work_order_status: {
        Args: { p_wo: string }
        Returns: undefined
      }
      seed_default_hours: { Args: { shop_id: string }; Returns: undefined }
      send_for_approval: {
        Args: { _line_ids: string[]; _set_wo_status?: boolean; _wo: string }
        Returns: undefined
      }
      set_authenticated: { Args: { uid: string }; Returns: undefined }
      set_current_shop_id: { Args: { p_shop_id: string }; Returns: undefined }
      set_last_active_now: { Args: never; Returns: undefined }
      set_part_request_status: {
        Args: {
          p_request: string
          p_status: Database["public"]["Enums"]["part_request_status"]
        }
        Returns: undefined
      }
      shop_id_for: { Args: { uid: string }; Returns: string }
      show_limit: { Args: never; Returns: number }
      show_trgm: { Args: { "": string }; Returns: string[] }
      update_part_quote: {
        Args: {
          p_item: string
          p_price: number
          p_request: string
          p_vendor: string
        }
        Returns: undefined
      }
    }
    Enums: {
      agent_request_intent:
        | "feature_request"
        | "bug_report"
        | "inspection_catalog_add"
        | "service_catalog_add"
        | "refactor"
      agent_request_status:
        | "submitted"
        | "in_progress"
        | "awaiting_approval"
        | "approved"
        | "rejected"
        | "failed"
        | "merged"
      ai_training_source:
        | "quote"
        | "appointment"
        | "inspection"
        | "work_order"
        | "customer"
        | "vehicle"
      fleet_program_cadence:
        | "monthly"
        | "quarterly"
        | "mileage_based"
        | "hours_based"
      inspection_item_status: "ok" | "fail" | "na" | "recommend"
      inspection_status:
        | "new"
        | "in_progress"
        | "paused"
        | "completed"
        | "aborted"
      job_type_enum: "diagnosis" | "inspection" | "maintenance" | "repair"
      part_request_status:
        | "requested"
        | "quoted"
        | "approved"
        | "fulfilled"
        | "rejected"
        | "cancelled"
      plan_t: "free" | "diy" | "pro" | "pro_plus"
      punch_event_type:
        | "start"
        | "break_start"
        | "break_end"
        | "lunch_start"
        | "lunch_end"
        | "end"
      quote_request_status: "pending" | "in_progress" | "done"
      shift_status: "active" | "ended"
      stock_move_reason:
        | "receive"
        | "adjust"
        | "consume"
        | "return"
        | "transfer_out"
        | "transfer_in"
        | "wo_allocate"
        | "wo_release"
        | "seed"
      user_role_enum:
        | "owner"
        | "admin"
        | "manager"
        | "mechanic"
        | "advisor"
        | "parts"
        | "customer"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {
      agent_request_intent: [
        "feature_request",
        "bug_report",
        "inspection_catalog_add",
        "service_catalog_add",
        "refactor",
      ],
      agent_request_status: [
        "submitted",
        "in_progress",
        "awaiting_approval",
        "approved",
        "rejected",
        "failed",
        "merged",
      ],
      ai_training_source: [
        "quote",
        "appointment",
        "inspection",
        "work_order",
        "customer",
        "vehicle",
      ],
      fleet_program_cadence: [
        "monthly",
        "quarterly",
        "mileage_based",
        "hours_based",
      ],
      inspection_item_status: ["ok", "fail", "na", "recommend"],
      inspection_status: [
        "new",
        "in_progress",
        "paused",
        "completed",
        "aborted",
      ],
      job_type_enum: ["diagnosis", "inspection", "maintenance", "repair"],
      part_request_status: [
        "requested",
        "quoted",
        "approved",
        "fulfilled",
        "rejected",
        "cancelled",
      ],
      plan_t: ["free", "diy", "pro", "pro_plus"],
      punch_event_type: [
        "start",
        "break_start",
        "break_end",
        "lunch_start",
        "lunch_end",
        "end",
      ],
      quote_request_status: ["pending", "in_progress", "done"],
      shift_status: ["active", "ended"],
      stock_move_reason: [
        "receive",
        "adjust",
        "consume",
        "return",
        "transfer_out",
        "transfer_in",
        "wo_allocate",
        "wo_release",
        "seed",
      ],
      user_role_enum: [
        "owner",
        "admin",
        "manager",
        "mechanic",
        "advisor",
        "parts",
        "customer",
      ],
    },
  },
} as const


/* =============================== */
/* FILE: features/agent/tools/generateInvoiceHtml.ts */
/* =============================== */

import { z } from "zod";
import { getServerSupabase } from "../server/supabase";
import type { ToolDef } from "../lib/toolTypes";

const In = z.object({ workOrderId: z.string().uuid() });
export type GenerateInvoiceHtmlIn = z.infer<typeof In>;

const Out = z.object({ html: z.string() });
export type GenerateInvoiceHtmlOut = z.infer<typeof Out>;

type WorkOrderRow = { id: string; created_at: string | null; status: string | null; shop_id: string | null; vehicle_id: string | null; customer_id: string | null; };
type VehicleRow   = { year: number | null; make: string | null; model: string | null; vin: string | null; license_plate: string | null; };
type CustomerRow  = { name: string | null; email: string | null; };
type QuoteLineRow = { id: string; title: string | null; description: string | null; labor_rate: number | null; labor_time: number | null; parts_cost: number | null; quantity: number | null; total: number | null; part_price: number | null; name: string | null; };

function isWorkOrderRow(x: unknown): x is WorkOrderRow { return !!x && typeof (x as { id?: unknown }).id === "string"; }
function isVehicleRow(x: unknown): x is VehicleRow { return !!x && "vin" in (x as object); }
function isCustomerRow(x: unknown): x is CustomerRow { return !!x && ("name" in (x as object) || "email" in (x as object)); }
function isQuoteLineArray(x: unknown): x is QuoteLineRow[] { return Array.isArray(x); }
function fmtDate(iso: string | null): string { if (!iso) return ""; try { return new Date(iso).toLocaleString(); } catch { return ""; } }

export const toolGenerateInvoiceHtml: ToolDef<GenerateInvoiceHtmlIn, GenerateInvoiceHtmlOut> = {
  name: "generate_invoice_html",
  description: "Builds a styled HTML invoice for a work order from quote_lines.",
  inputSchema: In,
  outputSchema: Out,
  async run(input, ctx) {
    const supabase = getServerSupabase();

    const woRes = await supabase
      .from("work_orders")
      .select("id, created_at, status, shop_id, vehicle_id, customer_id")
      .eq("id", input.workOrderId)
      .eq("shop_id", ctx.shopId)
      .single();
    if (woRes.error || !isWorkOrderRow(woRes.data)) throw new Error(woRes.error?.message ?? "work order not found");
    const wo = woRes.data;

    let vehicle: VehicleRow | null = null;
    if (wo.vehicle_id) {
      const v = await supabase.from("vehicles").select("year, make, model, vin, license_plate").eq("id", wo.vehicle_id).maybeSingle();
      if (v.error) throw new Error(v.error.message);
      vehicle = v.data && isVehicleRow(v.data) ? v.data : null;
    }

    let customer: CustomerRow | null = null;
    if (wo.customer_id) {
      const c = await supabase.from("customers").select("name, email").eq("id", wo.customer_id).maybeSingle();
      if (c.error) throw new Error(c.error.message);
      customer = c.data && isCustomerRow(c.data) ? c.data : null;
    }

    const q = await supabase
      .from("quote_lines")
      .select("id, title, description, labor_rate, labor_time, parts_cost, quantity, total, part_price, name")
      .eq("work_order_id", wo.id)
      .order("created_at", { ascending: true });
    if (q.error) throw new Error(q.error.message);
    const lines: QuoteLineRow[] = isQuoteLineArray(q.data) ? q.data : [];

    const num = (x: number | null | undefined) => (typeof x === "number" ? x : 0);
    const rows = lines.map(l => {
      const labor = num(l.labor_rate) * num(l.labor_time);
      const parts = num(l.parts_cost) > 0 ? num(l.parts_cost) : num(l.part_price) * num(l.quantity);
      const total = typeof l.total === "number" ? l.total : labor + parts;
      return {
        title: l.title ?? l.name ?? "Line",
        description: l.description ?? "",
        laborHours: num(l.labor_time),
        laborRate: num(l.labor_rate),
        partsCost: parts,
        total
      };
    });

    const laborTotal = rows.reduce((s, r) => s + r.laborRate * r.laborHours, 0);
    const partsTotal = rows.reduce((s, r) => s + r.partsCost, 0);
    const grandTotal = rows.reduce((s, r) => s + r.total, 0) || (laborTotal + partsTotal);

    const woHeader = (fmtDate(wo.created_at) ? `Work Order: ${wo.id} • ${fmtDate(wo.created_at)}` : `Work Order: ${wo.id}`);
    const vehicleLine = `${vehicle?.year ?? ""} ${vehicle?.make ?? ""} ${vehicle?.model ?? ""}`.trim();

    const html =
      '<!doctype html>' +
      '<html><head><meta charset="utf-8" />' +
      `<title>Invoice #${wo.id}</title>` +
      '<style>' +
      'body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;padding:24px;background:#f6f7f9;}' +
      '.card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:24px;max-width:720px;margin:auto;}' +
      '.row{display:flex;gap:16px;flex-wrap:wrap}.muted{color:#6b7280;font-size:12px}' +
      'table{width:100%;border-collapse:collapse;margin-top:12px}th,td{border-bottom:1px solid #e5e7eb;padding:8px;text-align:left}.total{font-weight:700}' +
      '</style></head><body>' +
      '<div class="card">' +
      '<h2>Invoice</h2>' +
      `<div class="muted">${woHeader}</div>` +
      '<div class="row" style="margin-top:12px">' +
      `<div><strong>Customer</strong><br/>${customer?.name ?? ""}<br/>${customer?.email ?? ""}</div>` +
      `<div><strong>Vehicle</strong><br/>${vehicleLine}<br/>VIN: ${vehicle?.vin ?? ""} • Plate: ${vehicle?.license_plate ?? ""}</div>` +
      '</div>' +
      '<table><thead><tr><th>Description</th><th>Labor</th><th>Parts</th><th>Line Total</th></tr></thead><tbody>' +
      rows.map(l =>
        '<tr>' +
        `<td><div><strong>${l.title}</strong></div><div class="muted">${l.description}</div></td>` +
        `<td>${l.laborHours.toFixed(2)}h @ $${l.laborRate.toFixed(2)}/h = $${(l.laborRate*l.laborHours).toFixed(2)}</td>` +
        `<td>$${l.partsCost.toFixed(2)}</td>` +
        `<td>$${l.total.toFixed(2)}</td>` +
        '</tr>'
      ).join("") +
      '</tbody><tfoot>' +
      `<tr><td></td><td class="total">Labor</td><td></td><td class="total">$${laborTotal.toFixed(2)}</td></tr>` +
      `<tr><td></td><td class="total">Parts</td><td></td><td class="total">$${partsTotal.toFixed(2)}</td></tr>` +
      `<tr><td></td><td class="total">Total</td><td></td><td class="total">$${grandTotal.toFixed(2)}</td></tr>` +
      '</tfoot></table>' +
      `<p class="muted">Status: ${wo.status ?? ""}</p>` +
      '</div></body></html>';

    return { html };
  }
};


/* =============================== */
/* FILE: features/quotes/lib/quote/matchToMenuItem.ts */
/* =============================== */

import type { InspectionItem } from "@inspections/lib/inspection/types";
import { serviceMenu } from "@shared/lib/menuItems";
import { generateLaborTimeEstimate } from "@ai/lib/ai/generateLaborTimeEstimate";

/** Shape expected by QuoteViewer (summary page) */
export interface QuoteLine {
  description: string;
  hours: number;
  rate: number;
  total: number;
  job_type: "repair" | "maintenance";
}

/** Narrower filter to satisfy TS when collapsing optional strings */
const isNonEmptyString = (v: unknown): v is string =>
  typeof v === "string" && v.length > 0;

/**
 * Generate a quote and summary from inspection items
 */
export async function generateQuoteFromInspection(
  results: InspectionItem[],
): Promise<{ summary: string; quote: QuoteLine[] }> {
  const failed: InspectionItem[] = [];
  const recommended: InspectionItem[] = [];

  for (const item of results) {
    const status =
      item.status === "fail" || item.status === "recommend"
        ? item.status
        : "ok";

    if (status === "fail") {
      failed.push({ ...item, status });
    } else if (status === "recommend") {
      recommended.push({ ...item, status });
    }
  }

  const summary = [
    "Completed Vehicle Inspection.",
    failed.length > 0 ? `⚠️ Failed Items:\n` : undefined,
    ...failed.map(
      (item) => `- ${item.item}: ${item.notes || ""} *Requires attention*`,
    ),
    recommended.length > 0 ? `\n🟠 Recommended Items:\n` : undefined,
    ...recommended.map(
      (item) => `- ${item.item}: ${item.notes || ""} *Suggested repair*`,
    ),
  ]
    .filter(isNonEmptyString)
    .join("\n");

  const quote: QuoteLine[] = [];
  const RATE = 120;

  for (const itm of [...failed, ...recommended]) {
    const term = String(itm.item ?? itm.name ?? "");

    // 1) Try to match a known service menu item
    const menuMatch = serviceMenu.find((m) =>
      term.toLowerCase().includes(m.name.toLowerCase()),
    );

    if (menuMatch) {
      const hours = menuMatch.laborHours ?? 1;
      const partsCost = menuMatch.partCost ?? 0;
      const total = Number((hours * RATE + partsCost).toFixed(2));

      quote.push({
        description: menuMatch.name,
        hours,
        rate: RATE,
        total,
        job_type: "repair",
      });
      continue;
    }

    // 2) Fall back to AI labor estimate
    const labor = await generateLaborTimeEstimate(term, "repair");
    if (typeof labor === "number" && labor > 0) {
      quote.push({
        description: term,
        hours: labor,
        rate: RATE,
        total: Number((labor * RATE).toFixed(2)),
        job_type: "repair",
      });
    }
  }

  return { summary, quote };
}

/* =============================== */
/* FILE: features/quotes/lib/quote/generateQuoteFromInspection.ts */
/* =============================== */

import type { InspectionItem } from "@inspections/lib/inspection/types";
import { serviceMenu } from "@shared/lib/menuItems";
import { generateLaborTimeEstimate } from "@ai/lib/ai/generateLaborTimeEstimate";

/** Shape expected by QuoteViewer (summary page) */
export interface QuoteLine {
  description: string;
  hours: number;
  rate: number;
  total: number;
  job_type: "repair" | "maintenance";
}

/**
 * Generate a quote and summary from inspection items
 */
export async function generateQuoteFromInspection(
  results: InspectionItem[],
): Promise<{ summary: string; quote: QuoteLine[] }> {
  const failed: InspectionItem[] = [];
  const recommended: InspectionItem[] = [];

  for (const item of results) {
    const status =
      item.status === "fail" || item.status === "recommend"
        ? item.status
        : "ok";

    if (status === "fail") {
      failed.push({ ...item, status });
    } else if (status === "recommend") {
      recommended.push({ ...item, status });
    }
    // "ok" items are not included in the quote
  }

  const summary = [
    "Completed Vehicle Inspection.",
    failed.length > 0 ? `⚠️ Failed Items:\n` : null,
    ...failed.map(
      (item) => `- ${item.item}: ${item.notes || ""} *Requires attention*`,
    ),
    recommended.length > 0 ? `\n🟠 Recommended Items:\n` : null,
    ...recommended.map(
      (item) => `- ${item.item}: ${item.notes || ""} *Suggested repair*`,
    ),
  ]
    .filter(Boolean)
    .join("\n");

  const quote: QuoteLine[] = [];
  const RATE = 120;

  for (const itm of [...failed, ...recommended]) {
    const term = (itm.item ?? itm.name ?? "").toString();

    // 1) Try to match a known service menu item
    const menuMatch = serviceMenu.find((m) =>
      term.toLowerCase().includes(m.name.toLowerCase()),
    );

    if (menuMatch) {
      const hours = menuMatch.laborHours ?? 1;
      const partsCost = menuMatch.partCost ?? 0;
      const total = Number((hours * RATE + partsCost).toFixed(2));

      quote.push({
        description: menuMatch.name,
        hours,
        rate: RATE,
        total,
        job_type: "repair",
      });
      continue;
    }

    // 2) Fall back to AI labor estimate
    const labor = await generateLaborTimeEstimate(term, "repair");
    if (labor && labor > 0) {
      quote.push({
        description: term,
        hours: labor,
        rate: RATE,
        total: Number((labor * RATE).toFixed(2)),
        job_type: "repair",
      });
    }
  }

  return { summary, quote };
}

/* =============================== */
/* FILE: features/quotes/lib/quote/mapItemToQuote.ts */
/* =============================== */

// features/quotes/lib/quote/mapItemToQuote.ts
import type { InspectionItem, QuoteLineItem } from "@inspections/lib/inspection/types";

export function toQuoteLineItem(item: InspectionItem): QuoteLineItem {
  const name = item.item ?? item.name ?? "Inspection Item";
  return {
    id: crypto.randomUUID(),
    item: name,
    name,
    description: item.notes || name,
    status: (item.status ?? "fail"),
    notes: item.notes,
    price: 0,          // let UI or service lookup fill these
    laborHours: 0.5,
    photoUrls: item.photoUrls ?? [],
    part: { name: "", price: 0 },
    partName: "",
    partPrice: null,
  };
}

/* =============================== */
/* FILE: features/quotes/lib/quote/normalizeQuoteLine.ts */
/* =============================== */

import { QuoteLineItem } from "@inspections/lib/inspection/types";
import { QuoteLine } from "./generateQuoteFromInspection";
import { inferPartName } from "@ai/lib/ai/inferPartName";

/**
 * Normalize a QuoteLine into a QuoteLineItem with inferred part info.
 */
export async function normalizeQuoteLine(
  quote: QuoteLine,
): Promise<QuoteLineItem> {
  let partName: string | null = null;

  try {
    // Try to infer part name using AI based on the description
    partName = await inferPartName(quote.description);
  } catch (err) {
    console.warn("AI inference failed:", err);
  }

  const fallbackPartName = quote.description.toLowerCase().includes("brake")
    ? "Brake Pad"
    : quote.description.toLowerCase().includes("oil")
      ? "Oil Filter"
      : quote.description.toLowerCase().includes("battery")
        ? "Battery"
        : "General Replacement Part";

  const name = partName?.trim() || fallbackPartName;

  return {
    id: crypto.randomUUID(), // ✅ Required unique ID
    item: quote.description,
    name: quote.description,
    description: quote.description,
    status: "fail", // Default; override if needed
    price: quote.total,
    partName: name,
    partPrice: 0,
    part: {
      name,
      price: 0,
    },
    laborHours: quote.hours,
    photoUrls: [],
    notes: "",
  };
}


/* =============================== */
/* FILE: features/quotes/lib/quote/quoteMenu.ts */
/* =============================== */

export interface QuoteMenuItem {
  triggerPhrases: string[];
  parts: {
    name: string;
    sku?: string;
    supplier?: string;
    cost: number;
  }[];
  laborHours: number;
  category: "diagnose" | "repair" | "maintenance";
  notes?: string;
}

export const quoteMenu: QuoteMenuItem[] = [
  {
    triggerPhrases: [
      "front brakes worn",
      "brakes pads low",
      "brakes squealing",
      "brake pad thin",
      "brake pad fail",
      "brake pads 2mm",
    ],
    parts: [
      {
        name: "Front Brake Pads",
        sku: "FORD-BRKPAD5-F",
        supplier: "Ford OEM",
        cost: 85,
      },
    ],
    laborHours: 1.5,
    category: "repair",
    notes: "Typical replacement includes pads, rotor inspection.",
  },
  {
    triggerPhrases: [
      "check engine light",
      "CEL on",
      "engine light is on",
      "trouble code",
    ],
    parts: [],
    laborHours: 0.5,
    category: "diagnose",
    notes: "Initial scan and diagnosis of engine light causes.",
  },
  {
    triggerPhrases: ["oil change", "needs an oil change", "engine oil service"],
    parts: [
      {
        name: "5W-20 Synthetic Blend Oil",
        supplier: "Ford OEM",
        cost: 40,
      },
      {
        name: "Oil Filter",
        supplier: "Ford OEM",
        cost: 12,
      },
    ],
    laborHours: 0.3,
    category: "maintenance",
    notes: "Includes oil, filter, and disposal.",
  },
];


/* =============================== */
/* FILE: features/quotes/api/quote/route.ts */
/* =============================== */

// app/api/quote/route.ts
import { NextRequest, NextResponse } from "next/server";
import { generateQuoteFromInspection } from "@quotes/lib/quote/generateQuoteFromInspection";
import { InspectionItem } from "@inspections/lib/inspection/types";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const results: InspectionItem[] = body.results;

    if (!results || !Array.isArray(results)) {
      return NextResponse.json(
        { error: "Invalid or missing results." },
        { status: 400 },
      );
    }

    const { summary, quote } = await generateQuoteFromInspection(results);
    return NextResponse.json({ summary, quote });
  } catch (err) {
    console.error("Quote generation failed:", err);
    return NextResponse.json(
      { error: "Internal error generating quote." },
      { status: 500 },
    );
  }
}


/* =============================== */
/* FILE: features/quotes/components/QuoteViewer.tsx */
/* =============================== */

"use client";

import { useEffect, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { generateQuotePDFBytes } from "@work-orders/lib/work-orders/generateQuotePdf";
import type { QuoteLine } from "@quotes/lib/quote/generateQuoteFromInspection";
import type { QuoteLineItem as BaseQuoteLineItem } from "@inspections/lib/inspection/types";
import { searchPartsByKeyword } from "@parts/lib/parts/searchParts";
import { inferPartName } from "@ai/lib/ai/inferPartName";

/** What the UI edits; keep part compatible with your QuoteLineItem type */
type EditableQuoteLineItem = Omit<BaseQuoteLineItem, "part"> & {
  /** allow null while editing */
  part?: { name: string; price: number | null } | null;
  partName: string;
  partPrice?: number | null;
};

interface QuoteViewerProps {
  summary: string;
  quote: (QuoteLine | BaseQuoteLineItem)[];
}

const supabase = createClientComponentClient<Database>();

/** Minimal inline save; adjust table/columns if yours differ */
async function updateQuoteLine(item: EditableQuoteLineItem) {
  const { error } = await supabase
    .from("quote_lines")
    .upsert(
      {
        id: item.id,
        name: item.name ?? item.description ?? "",
        description: item.description ?? "",
        labor_hours: item.laborHours ?? 0,
        parts_cost: item.part?.price ?? item.partPrice ?? 0,
        total_price: item.price ?? 0,
        part_name: item.part?.name ?? item.partName,
        part_price: item.part?.price ?? item.partPrice ?? 0,
        created_at: new Date().toISOString(),
      },
      { onConflict: "id" },
    );

  if (error) throw error;
}

async function normalizeQuoteLine(
  line: QuoteLine | BaseQuoteLineItem,
): Promise<EditableQuoteLineItem> {
  if ("laborHours" in line && "price" in line && "part" in line) {
    const li = line as BaseQuoteLineItem;
    const ensuredName = li.part?.name ?? "";
    const ensuredPrice =
      typeof li.part?.price === "number" ? li.part!.price : li.part?.price ?? null;

    return {
      ...li,
      part: { name: ensuredName, price: ensuredPrice },
      partName: ensuredName,
      partPrice: ensuredPrice ?? 0,
    };
  }

  const legacy = line as QuoteLine;
  const inferred = (await inferPartName(legacy.description)) ?? "";

  return {
    id: crypto.randomUUID(),
    item: legacy.description,
    name: legacy.description,
    description: legacy.description,
    status: "fail",
    price: legacy.total,
    laborHours: legacy.hours,
    part: { name: inferred, price: 0 },
    partName: inferred,
    partPrice: 0,
    photoUrls: [],
    notes: "",
  };
}

export default function QuoteViewer({ summary, quote }: QuoteViewerProps) {
  const [quoteState, setQuoteState] = useState<EditableQuoteLineItem[]>([]);
  const [lookupResults, setLookupResults] = useState<Record<number, string[]>>({});

  useEffect(() => {
    (async () => {
      const result = await Promise.all(quote.map(normalizeQuoteLine));
      setQuoteState(result);
    })();
  }, [quote]);

  const handleChange = (
    idx: number,
    field: keyof EditableQuoteLineItem | "partName" | "partPrice",
    value: string | number,
  ) => {
    setQuoteState((prev) =>
      prev.map((item, i) => {
        if (i !== idx) return item;
        let next: EditableQuoteLineItem = { ...item, [field]: value as any };
        const ensurePart = () => next.part ?? { name: item.partName ?? "", price: null };

        if (field === "partName") {
          const name = String(value);
          next.partName = name;
          next.part = { ...ensurePart(), name };
        } else if (field === "partPrice") {
          const price = Number(value);
          const safe = Number.isFinite(price) ? price : 0;
          next.partPrice = safe;
          next.part = { ...ensurePart(), price: safe };
        }
        return next;
      }),
    );
  };

  const handlePhotoUpload = (idx: number, files: FileList | null) => {
    if (!files?.length) return;
    const urls = Array.from(files).map((file) => URL.createObjectURL(file));
    setQuoteState((prev) =>
      prev.map((item, i) =>
        i === idx
          ? { ...item, photoUrls: [...(item.photoUrls ?? []), ...urls] }
          : item,
      ),
    );
  };

  const handlePartSearch = async (idx: number, query: string) => {
    const results = await searchPartsByKeyword(query);
    setLookupResults((prev) => ({ ...prev, [idx]: results }));
  };

  const handleSave = async (item: EditableQuoteLineItem) => {
    try {
      await updateQuoteLine(item);
      alert("Quote line saved!");
    } catch (err) {
      console.error(err);
      alert("Error saving quote line.");
    }
  };

  const handleExportPDF = async () => {
    const bytes = await generateQuotePDFBytes(quoteState, summary);
    const blob = new Blob([bytes.buffer as ArrayBuffer], { type: "application/pdf" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "quote.pdf";
    link.click();
  };

  const grouped: Record<string, EditableQuoteLineItem[]> = {};
  for (const item of quoteState) {
    const key = item.status ?? "unknown";
    (grouped[key] ??= []).push(item);
  }

  return (
    <div className="bg-black/30 text-white rounded-lg p-6 shadow-xl backdrop-blur-lg border border-white/10">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl font-bold text-orange-400">Inspection Summary</h2>
        <button onClick={handleExportPDF} className="bg-blue-600 px-3 py-1 rounded text-sm">
          Export PDF
        </button>
      </div>

      <pre className="whitespace-pre-wrap text-white/80 mb-6">{summary}</pre>

      {Object.entries(grouped).map(([group, items]) => (
        <div key={group} className="mb-6">
          <h3 className="text-xl font-semibold capitalize text-white mb-2">
            {group} Items
          </h3>

          {items.map((item, idx) => {
            const labor = typeof item.price === "number" ? item.price : 0;
            const partPrice =
              typeof item.partPrice === "number"
                ? item.partPrice
                : typeof item.part?.price === "number"
                  ? item.part.price
                  : 0;

            return (
              <div key={item.id} className="border border-white/10 bg-white/5 p-4 rounded-md space-y-2">
                <div className="flex flex-col md:flex-row md:items-center gap-4">
                  <input
                    className="bg-black/20 text-white p-1 rounded w-full md:w-1/3"
                    value={item.description ?? ""}
                    onChange={(e) => handleChange(idx, "description", e.target.value)}
                    placeholder="Description"
                  />
                  <input
                    type="text"
                    className="bg-black/20 text-white p-1 rounded w-full md:w-1/4"
                    value={item.partName ?? item.part?.name ?? ""}
                    onChange={(e) => handleChange(idx, "partName", e.target.value)}
                    onBlur={() =>
                      handlePartSearch(idx, (item.partName ?? item.part?.name ?? "").toString())
                    }
                    placeholder="Part name"
                  />
                  <input
                    type="number"
                    className="bg-black/20 text-white p-1 rounded w-full md:w-1/6"
                    value={item.partPrice ?? item.part?.price ?? 0}
                    onChange={(e) => handleChange(idx, "partPrice", e.target.value)}
                    placeholder="Part cost"
                  />
                  <input
                    type="number"
                    className="bg-black/20 text-white p-1 rounded w-full md:w-1/6"
                    value={item.price ?? 0}
                    onChange={(e) => handleChange(idx, "price", parseFloat(e.target.value))}
                    placeholder="Labor price"
                  />
                </div>

                <textarea
                  className="bg-black/20 text-white p-1 rounded w-full"
                  value={item.notes ?? ""}
                  onChange={(e) => handleChange(idx, "notes", e.target.value)}
                  placeholder="Notes"
                />

                <p className="text-sm text-white/70">
                  Labor: ${labor.toFixed(2)} | Part: ${partPrice.toFixed(2)}
                </p>

                <div className="text-sm text-white/70 mt-2">
                  Suggested Parts:{" "}
                  {lookupResults[idx]?.length
                    ? lookupResults[idx].slice(0, 3).join(", ")
                    : "None yet"}
                </div>

                <input
                  type="file"
                  multiple
                  onChange={(e) => handlePhotoUpload(idx, e.target.files)}
                  className="text-sm"
                />

                <div className="flex flex-wrap gap-2 mt-2">
                  {item.photoUrls?.map((url, i) => (
                    <img
                      key={i}
                      src={url}
                      className="max-h-24 border border-white/20 rounded"
                      alt="Quote Attachment"
                    />
                  ))}
                </div>

                <div className="flex justify-end mt-2">
                  <button
                    onClick={() => handleSave(item)}
                    className="bg-green-600 px-4 py-1 rounded text-sm"
                  >
                    Save
                  </button>
                </div>
              </div>
            );
          })}
        </div>
      ))}

      <div className="border-t border-white/10 pt-4 text-right text-white font-semibold text-lg">
        Quote Total: $
        {quoteState
          .reduce((sum, i) => sum + (i.price || 0) + (i.part?.price || 0), 0)
          .toFixed(2)}
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/integrations/ai/index.ts */
/* =============================== */

import { openai } from "lib/server/openai";
import { createAdminSupabase } from "@/features/shared/lib/supabase/server";

/* ========================================================================== */
/*  QUOTE ENGINE – CENTRAL AI ENTRYPOINT                                      */
/* ========================================================================== */

export type QuoteEnginePart = {
  partId?: string | null;
  description: string;
  qty?: number;
  price?: number;
};

export type QuoteEngineSuggestion = {
  parts: QuoteEnginePart[];
  laborHours: number;
  confidence: number; // 0–1
};

type SuggestQuoteArgs = {
  shopId: string;
  vehicleYmm?: string | null;
  complaint: string;
};

export const ProFixAI = {
  /**
   * LLM-backed quote suggestion.
   * Returns null on any parsing / API failure so callers can fall back.
   */
  async suggestQuote(
    args: SuggestQuoteArgs,
  ): Promise<QuoteEngineSuggestion | null> {
    const { shopId, vehicleYmm, complaint } = args;

    const system = [
      "You are an auto repair quote assistant.",
      "Given a vehicle (Y/M/M) and a complaint, you must return JSON ONLY.",
      "The JSON must be an object with:",
      "- parts: array of { description, qty, price, partId },",
      "- laborHours: number (0.1–8),",
      "- confidence: number between 0 and 1.",
      "Keep parts realistic; at most 10 parts.",
      "Do not include any prose or markdown, only raw JSON.",
    ].join(" ");

    const userContext = [
      `Shop: ${shopId}`,
      `Vehicle: ${vehicleYmm ?? "Unknown vehicle"}`,
      `Complaint: ${complaint}`,
    ].join("\n");

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      temperature: 0.4,
      max_tokens: 600,
      messages: [
        { role: "system", content: system },
        { role: "user", content: userContext },
      ],
    });

    const raw = completion.choices[0]?.message?.content ?? "{}";

    let parsed: unknown;
    try {
      parsed = JSON.parse(raw);
    } catch {
      // Model gave non-JSON; let caller fall back.
      return null;
    }

    const out: QuoteEngineSuggestion = {
      parts: [],
      laborHours: 0.5,
      confidence: 0.4,
    };

    // --- parts ---
    const partsArr = Array.isArray((parsed as any)?.parts)
      ? (parsed as any).parts
      : [];

    const normalizedParts: QuoteEnginePart[] = [];
    for (const rawPart of partsArr) {
      if (typeof rawPart !== "object" || rawPart === null) continue;
      const p = rawPart as Record<string, unknown>;

      const description =
        typeof p.description === "string" && p.description.trim().length > 0
          ? p.description.trim()
          : null;
      if (!description) continue;

      const qtyRaw = p.qty;
      const qty =
        typeof qtyRaw === "number" && Number.isFinite(qtyRaw) && qtyRaw > 0
          ? qtyRaw
          : undefined;

      const priceRaw = p.price;
      const price =
        typeof priceRaw === "number" &&
        Number.isFinite(priceRaw) &&
        priceRaw >= 0
          ? priceRaw
          : undefined;

      const partIdRaw = p.partId;
      const partId =
        typeof partIdRaw === "string" && partIdRaw.trim().length > 0
          ? partIdRaw.trim()
          : null;

      const part: QuoteEnginePart = {
        description,
      };

      if (qty !== undefined) part.qty = qty;
      if (price !== undefined) part.price = price;
      if (partId !== null) part.partId = partId;

      normalizedParts.push(part);
    }

    out.parts = normalizedParts.slice(0, 10);

    // --- laborHours ---
    const lh = (parsed as any)?.laborHours;
    if (typeof lh === "number" && Number.isFinite(lh) && lh > 0 && lh <= 8) {
      out.laborHours = lh;
    }

    // --- confidence ---
    const c = (parsed as any)?.confidence;
    if (typeof c === "number" && Number.isFinite(c) && c >= 0 && c <= 1) {
      out.confidence = c;
    }

    return out;
  },
};

/* ========================================================================== */
/*  TRAINING EVENT LOGGING                                                    */
/* ========================================================================== */

/**
 * Narrow string sources so we don't end up with random ad-hoc values.
 * These map roughly to the things we care about training:
 * - apply_ai_quote: AI suggestion applied to a quote/line
 * - invoice_review: AI work-order / invoice review
 * - inspection_to_quote: inspection → quote pipeline
 * - menu_learning: future menu-learning events
 * - chat: future TechBot / InspectionBot chat turns
 */
export type AIRecordSource =
  | "apply_ai_quote"
  | "invoice_review"
  | "inspection_to_quote"
  | "menu_learning"
  | "chat";

/**
 * Minimal, DB-agnostic training event shape that callers work with.
 */
export interface AITrainingEvent {
  id?: string;
  source: AIRecordSource;
  shopId: string;
  vehicleYmm?: string | null;
  payload: Record<string, unknown>;
  createdAt?: string;
}

async function insertTrainingEvent(event: AITrainingEvent): Promise<void> {
  const supabase = createAdminSupabase();

  const { id, source, shopId, vehicleYmm, payload, createdAt } = event;

  const { error } = await supabase.from("ai_training_events").insert({
    id,
    source,
    shop_id: shopId,
    vehicle_ymm: vehicleYmm ?? null,
    payload,
    created_at: createdAt ?? new Date().toISOString(),
  } as any);

  if (error) {
    // Never block the user flow on training errors; just log.
    // eslint-disable-next-line no-console
    console.error("[AI] Failed to insert training event", {
      source,
      shopId,
      error,
    });
  }
}

/* ---------- QUOTE TRAINING – APPLY AI QUOTE ---------- */

export type RecordQuoteTrainingInput = {
  quoteId: string;
  shopId: string;
  vehicleYmm?: string | null;
  workOrderId?: string | null;
  workOrderLineId?: string | null;
  payload: Record<string, unknown>;
  createdAt?: string;
};

export async function recordQuoteTraining(
  input: RecordQuoteTrainingInput,
): Promise<void> {
  const {
    quoteId,
    shopId,
    vehicleYmm,
    workOrderId,
    workOrderLineId,
    payload,
    createdAt,
  } = input;

  await insertTrainingEvent({
    source: "apply_ai_quote",
    shopId,
    vehicleYmm: vehicleYmm ?? null,
    createdAt,
    payload: {
      kind: "apply_ai_quote",
      quoteId,
      workOrderId: workOrderId ?? null,
      workOrderLineId: workOrderLineId ?? null,
      ...(payload ?? {}),
    },
  });
}

/* ---------- WORK ORDER TRAINING – INVOICE / JOB REVIEW ---------- */

export type RecordWorkOrderTrainingInput = {
  workOrderId: string;
  workOrderLineId?: string | null;
  shopId: string;
  vehicleYmm?: string | null;
  payload: Record<string, unknown>;
  createdAt?: string;
};

export async function recordWorkOrderTraining(
  input: RecordWorkOrderTrainingInput,
): Promise<void> {
  const {
    workOrderId,
    workOrderLineId,
    shopId,
    vehicleYmm,
    payload,
    createdAt,
  } = input;

  await insertTrainingEvent({
    source: "invoice_review",
    shopId,
    vehicleYmm: vehicleYmm ?? null,
    createdAt,
    payload: {
      kind: "invoice_review",
      workOrderId,
      workOrderLineId: workOrderLineId ?? null,
      ...(payload ?? {}),
    },
  });
}

/* ---------- INSPECTION → QUOTE TRAINING ---------- */

export type RecordInspectionToQuoteTrainingInput = {
  shopId: string;
  vehicleYmm?: string | null;
  payload: Record<string, unknown>;
  createdAt?: string;
};

export async function recordInspectionToQuoteTraining(
  input: RecordInspectionToQuoteTrainingInput,
): Promise<void> {
  const { shopId, vehicleYmm, payload, createdAt } = input;

  await insertTrainingEvent({
    source: "inspection_to_quote",
    shopId,
    vehicleYmm: vehicleYmm ?? null,
    createdAt,
    payload: {
      kind: "inspection_to_quote",
      ...(payload ?? {}),
    },
  });
}

/* =============================== */
/* FILE: features/work-orders/mobile/MobileWorkOrderLines.tsx */
/* =============================== */

//Features/work-orders/mobile/MobileWorkOrderLines.tsx
"use client";

import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type WorkOrderLineRow = DB["public"]["Tables"]["work_order_lines"]["Row"];

type Props = {
  lines: WorkOrderLineRow[];
  workOrderId: string | null;
  onDelete: (lineId: string) => Promise<void> | void;
};

export function MobileWorkOrderLines({
  lines,
  workOrderId,
  onDelete,
}: Props) {
  if (!workOrderId) {
    return null;
  }

  if (!lines.length) {
    return (
      <div className="rounded-xl border border-dashed border-neutral-700 bg-neutral-950/60 px-3 py-3 text-xs text-neutral-400">
        No jobs added yet. Use{" "}
        <span className="font-semibold text-neutral-200">
          Add job line
        </span>{" "}
        below to start the quote.
      </div>
    );
  }

  return (
    <div className="space-y-2 rounded-xl border border-neutral-800 bg-neutral-950 p-3">
      <div className="mb-1 flex items-center justify-between">
        <h2 className="text-xs font-semibold uppercase tracking-wide text-neutral-400">
          Jobs on this work order
        </h2>
        <span className="text-[10px] text-neutral-500">
          {lines.length} line{lines.length === 1 ? "" : "s"}
        </span>
      </div>

      <ul className="space-y-2">
        {lines.map((line) => {
          const label =
            line.description ||
            line.complaint ||
            "Job line";

          return (
            <li
              key={line.id}
              className="flex items-start justify-between gap-2 rounded-lg border border-neutral-800 bg-neutral-900 px-3 py-2 text-xs"
            >
              <div className="min-w-0">
                <div className="truncate text-[0.8rem] font-medium text-neutral-50">
                  {label}
                </div>
                {line.complaint && (
                  <div className="mt-0.5 line-clamp-2 text-[0.7rem] text-neutral-400">
                    {line.complaint}
                  </div>
                )}
                {line.status && (
                  <div className="mt-1 text-[0.65rem] uppercase tracking-wide text-neutral-500">
                    {line.status.replaceAll("_", " ")}
                  </div>
                )}
              </div>
              <button
                type="button"
                onClick={() => onDelete(line.id)}
                className="shrink-0 rounded-full border border-red-500/60 px-2 py-0.5 text-[0.7rem] text-red-200 hover:bg-red-900/30"
              >
                Delete
              </button>
            </li>
          );
        })}
      </ul>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/mobile/MobileWorkOrderClient.tsx */
/* =============================== */

"use client";

import React, {
  useCallback,
  useEffect,
  useMemo,
  useState,
  type JSX,
} from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { format } from "date-fns";
import { toast } from "sonner";
import dynamic from "next/dynamic";

import { supabaseBrowser as supabase } from "@/features/shared/lib/supabase/client";
import type { Database } from "@shared/types/types/supabase";

import PreviousPageButton from "@shared/components/ui/PreviousPageButton";
import { UsePartButton } from "@work-orders/components/UsePartButton";
import VoiceContextSetter from "@/features/shared/voice/VoiceContextSetter";
import VoiceButton from "@/features/shared/voice/VoiceButton";
import { useTabState } from "@/features/shared/hooks/useTabState";
import PartsDrawer from "@/features/parts/components/PartsDrawer";

// assign-mechanic modal
import AssignTechModal from "@/features/work-orders/components/workorders/extras/AssignTechModal";

// inspection modal
const InspectionModal = dynamic(
  () => import("@/features/inspections/components/InspectionModal"),
  { ssr: false }
);

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];
type Customer = DB["public"]["Tables"]["customers"]["Row"];
type Profile = DB["public"]["Tables"]["profiles"]["Row"];
type AllocationRow =
  DB["public"]["Tables"]["work_order_part_allocations"]["Row"] & {
    parts?: { name: string | null } | null;
  };
type LineTechRow =
  DB["public"]["Tables"]["work_order_line_technicians"]["Row"];

const looksLikeUuid = (s: string) => s.includes("-") && s.length >= 36;

function splitCustomId(raw: string): { prefix: string; n: number | null } {
  const m = raw.toUpperCase().match(/^([A-Z]+)\s*0*?(\d+)?$/);
  if (!m) return { prefix: raw.toUpperCase(), n: null };
  const n = m[2] ? parseInt(m[2], 10) : null;
  return { prefix: m[1], n: Number.isFinite(n!) ? n : null };
}

/* ---------------------------- Badges & Row Tints ---------------------------- */

type KnownStatus =
  | "awaiting_approval"
  | "awaiting"
  | "queued"
  | "in_progress"
  | "on_hold"
  | "planned"
  | "new"
  | "completed"
  | "ready_to_invoice"
  | "invoiced";

const BASE_BADGE =
  "inline-flex items-center whitespace-nowrap rounded border px-2 py-0.5 text-xs font-medium";

const BADGE: Record<KnownStatus, string> = {
  awaiting_approval: "bg-blue-900/20 border-blue-500/40 text-blue-300",
  awaiting: "bg-sky-900/20  border-sky-500/40  text-sky-300",
  queued: "bg-indigo-900/20 border-indigo-500/40 text-indigo-300",
  in_progress: "bg-orange-900/20 border-orange-500/40 text-orange-300",
  on_hold: "bg-amber-900/20  border-amber-500/40  text-amber-300",
  planned: "bg-purple-900/20 border-purple-500/40 text-purple-300",
  new: "bg-neutral-800   border-neutral-600   text-neutral-200",
  completed: "bg-green-900/20  border-green-500/40 text-green-300",
  ready_to_invoice: "bg-emerald-900/20 border-emerald-500/40 text-emerald-300",
  invoiced: "bg-teal-900/20    border-teal-500/40    text-teal-300",
};

const chip = (s: string | null | undefined): string => {
  const key = (s ?? "awaiting")
    .toLowerCase()
    .replaceAll(" ", "_") as KnownStatus;
  return `${BASE_BADGE} ${BADGE[key] ?? BADGE.awaiting}`;
};

const statusBorder: Record<string, string> = {
  awaiting: "border-l-4 border-slate-400",
  queued: "border-l-4 border-indigo-400",
  in_progress: "border-l-4 border-orange-500",
  on_hold: "border-l-4 border-amber-500",
  completed: "border-l-4 border-green-500",
  awaiting_approval: "border-l-4 border-blue-500",
  planned: "border-l-4 border-purple-500",
  new: "border-l-4 border-gray-400",
};

const statusRowTint: Record<string, string> = {
  awaiting: "bg-neutral-950",
  queued: "bg-neutral-950",
  in_progress: "bg-neutral-950",
  on_hold: "bg-amber-900/30",
  completed: "bg-green-900/30",
  awaiting_approval: "bg-neutral-950",
  planned: "bg-neutral-950",
  new: "bg-neutral-950",
};

// roles allowed to assign
const ASSIGN_ROLES = new Set(["owner", "admin", "manager", "advisor"]);

/* ------------------------------------------------------------------------- */

export default function MobileWorkOrderClient({
  routeId,
}: {
  routeId: string;
}): JSX.Element {
  const router = useRouter();

  const [wo, setWo] = useTabState<WorkOrder | null>("m:wo:id:wo", null);
  const [lines, setLines] = useTabState<WorkOrderLine[]>(
    "m:wo:id:lines",
    []
  );
  const [vehicle, setVehicle] = useTabState<Vehicle | null>(
    "m:wo:id:veh",
    null
  );
  const [customer, setCustomer] = useTabState<Customer | null>(
    "m:wo:id:cust",
    null
  );

  const [allocsByLine, setAllocsByLine] = useState<
    Record<string, AllocationRow[]>
  >({});
  const [loading, setLoading] = useState<boolean>(false);
  const [viewError, setViewError] = useState<string | null>(null);

  const [currentUserId, setCurrentUserId] = useTabState<string | null>(
    "m:wo:id:uid",
    null
  );
  const [, setUserId] = useTabState<string | null>(
    "m:wo:id:effectiveUid",
    null
  );
  const [currentUserRole, setCurrentUserRole] = useState<string | null>(null);

  const [showDetails, setShowDetails] = useTabState<boolean>(
    "m:wo:showDetails",
    true
  );
  const [warnedMissing, setWarnedMissing] = useState(false);

  // parts
  const [partsLineId, setPartsLineId] = useState<string | null>(null);
  const [bulkQueue, setBulkQueue] = useState<string[]>([]);
  const [bulkActive, setBulkActive] = useState<boolean>(false);

  // inspection
  const [inspectionOpen, setInspectionOpen] = useState(false);
  const [inspectionSrc, setInspectionSrc] = useState<string | null>(null);

  // assign mechanic
  const [assignOpen, setAssignOpen] = useState(false);
  const [assignLineId, setAssignLineId] = useState<string | null>(null);
  const [assignables, setAssignables] = useState<
    Array<Pick<Profile, "id" | "full_name" | "role">>
  >([]);

  // per-line technicians
  const [lineTechsByLine, setLineTechsByLine] = useState<
    Record<string, string[]>
  >({});

  /* ---------------------- AUTH + assignables ---------------------- */
  useEffect(() => {
    let mounted = true;

    const waitForSession = async () => {
      let {
        data: { session },
      } = await supabase.auth.getSession();

      if (!session) {
        for (let i = 0; i < 8; i++) {
          await new Promise((r) => setTimeout(r, 150 * (i + 1)));
          const res = await supabase.auth.getSession();
          session = res.data.session;
          if (session) break;
        }
      }

      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!mounted) return;

      const uid = user?.id ?? null;
      setCurrentUserId(uid);
      setUserId(uid);

      if (uid) {
        const { data: prof } = await supabase
          .from("profiles")
          .select("role")
          .eq("id", uid)
          .maybeSingle();
        setCurrentUserRole(prof?.role ?? null);
      }

      try {
        const res = await fetch("/api/assignables");
        const json = await res.json();
        if (res.ok && Array.isArray(json.data)) {
          setAssignables(json.data);
        }
      } catch {
        // ignore
      }

      if (!uid) setLoading(false);
    };

    void waitForSession();

    const { data: sub } = supabase.auth.onAuthStateChange((_evt, s) => {
      if (s?.user) void waitForSession();
      else {
        setCurrentUserId(null);
        setUserId(null);
        setLoading(false);
      }
    });

    return () => {
      mounted = false;
      sub?.subscription?.unsubscribe?.();
    };
  }, [routeId, setCurrentUserId, setUserId]);

  /* ---------------------- FETCH ---------------------- */
  const fetchAll = useCallback(
    async (retry = 0) => {
      if (!routeId) return;
      setLoading(true);
      setViewError(null);

      try {
        let woRow: WorkOrder | null = null;

        // by UUID
        if (looksLikeUuid(routeId)) {
          const { data, error } = await supabase
            .from("work_orders")
            .select("*")
            .eq("id", routeId)
            .maybeSingle();
          if (!error) woRow = (data as WorkOrder | null) ?? null;
        }

        // by custom_id
        if (!woRow) {
          const eqRes = await supabase
            .from("work_orders")
            .select("*")
            .eq("custom_id", routeId)
            .maybeSingle();
          woRow = (eqRes.data as WorkOrder | null) ?? null;

          if (!woRow) {
            const ilikeRes = await supabase
              .from("work_orders")
              .select("*")
              .ilike("custom_id", routeId.toUpperCase())
              .maybeSingle();
            woRow = (ilikeRes.data as WorkOrder | null) ?? null;
          }

          if (!woRow) {
            const { prefix, n } = splitCustomId(routeId);
            if (n !== null) {
              const { data: cands } = await supabase
                .from("work_orders")
                .select("*")
                .ilike("custom_id", `${prefix}%`)
                .limit(50);
              const wanted = `${prefix}${n}`;
              const match = (cands ?? []).find(
                (r) =>
                  (r.custom_id ?? "")
                    .toUpperCase()
                    .replace(/^([A-Z]+)0+/, "$1") === wanted
              );
              if (match) woRow = match as WorkOrder;
            }
          }
        }

        if (!woRow) {
          if (retry < 2) {
            await new Promise((r) => setTimeout(r, 200 * Math.pow(2, retry)));
            return fetchAll(retry + 1);
          }
          setViewError("Work order not visible / not found.");
          setWo(null);
          setLines([]);
          setVehicle(null);
          setCustomer(null);
          setAllocsByLine({});
          setLineTechsByLine({});
          setLoading(false);
          return;
        }

        setWo(woRow);

        if (!warnedMissing && (!woRow.vehicle_id || !woRow.customer_id)) {
          toast.error(
            "This work order is missing vehicle and/or customer. Open the Create form to set them."
          );
          setWarnedMissing(true);
        }

        const [linesRes, vehRes, custRes] = await Promise.all([
          supabase
            .from("work_order_lines")
            .select("*")
            .eq("work_order_id", woRow.id)
            .order("created_at", { ascending: true }),
          woRow.vehicle_id
            ? supabase
                .from("vehicles")
                .select("*")
                .eq("id", woRow.vehicle_id)
                .maybeSingle()
            : Promise.resolve({ data: null, error: null } as const),
          woRow.customer_id
            ? supabase
                .from("customers")
                .select("*")
                .eq("id", woRow.customer_id)
                .maybeSingle()
            : Promise.resolve({ data: null, error: null } as const),
        ]);

        if (linesRes.error) throw linesRes.error;
        const lineRows = (linesRes.data ?? []) as WorkOrderLine[];
        setLines(lineRows);

        if (vehRes?.error) throw vehRes.error;
        setVehicle((vehRes?.data as Vehicle | null) ?? null);

        if (custRes?.error) throw custRes.error;
        setCustomer((custRes?.data as Customer | null) ?? null);

        // allocations + line techs
        if (lineRows.length) {
          const [allocsQuery, lineTechsQuery] = await Promise.all([
            supabase
              .from("work_order_part_allocations")
              .select("*, parts(name)")
              .in(
                "work_order_line_id",
                lineRows.map((l) => l.id)
              ),
            supabase
              .from("work_order_line_technicians")
              .select("work_order_line_id, technician_id")
              .in(
                "work_order_line_id",
                lineRows.map((l) => l.id)
              ),
          ]);

          const byLine: Record<string, AllocationRow[]> = {};
          (allocsQuery.data ?? []).forEach((a) => {
            const key = (a as AllocationRow).work_order_line_id;
            if (!byLine[key]) byLine[key] = [];
            byLine[key].push(a as AllocationRow);
          });
          setAllocsByLine(byLine);

          const techMap: Record<string, string[]> = {};
          (lineTechsQuery.data as LineTechRow[] | null)?.forEach((lt) => {
            const lnId = lt.work_order_line_id;
            const techId = lt.technician_id;
            if (!techMap[lnId]) techMap[lnId] = [];
            if (!techMap[lnId].includes(techId)) {
              techMap[lnId].push(techId);
            }
          });
          setLineTechsByLine(techMap);
        } else {
          setAllocsByLine({});
          setLineTechsByLine({});
        }
      } catch (e: unknown) {
        const msg =
          e instanceof Error ? e.message : "Failed to load work order.";
        setViewError(msg);
        console.error("[Mobile WO id page] load error:", e);
      } finally {
        setLoading(false);
      }
    },
    [routeId, warnedMissing, setWo, setLines, setVehicle, setCustomer]
  );

  useEffect(() => {
    if (!routeId || !currentUserId) return;
    void fetchAll();
  }, [fetchAll, routeId, currentUserId]);

  /* ---------------------- REALTIME ---------------------- */
  useEffect(() => {
    if (!wo?.id) return;

    const ch = supabase
      .channel(`m:wo:${wo.id}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_orders",
          filter: `id=eq.${wo.id}`,
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_lines",
          filter: `work_order_id=eq.${wo.id}`,
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_part_allocations",
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_line_technicians",
        },
        () => fetchAll()
      )
      .subscribe();

    const local = () => fetchAll();
    window.addEventListener("wo:parts-used", local);

    return () => {
      try {
        supabase.removeChannel(ch);
      } catch {}
      window.removeEventListener("wo:parts-used", local);
    };
  }, [wo?.id, fetchAll]);

  // 🔁 refresh this page when a parts request is submitted from elsewhere
  useEffect(() => {
    const handler = () => {
      void fetchAll();
    };
    window.addEventListener("parts-request:submitted", handler);
    return () => window.removeEventListener("parts-request:submitted", handler);
  }, [fetchAll]);

  /* ----------------------- Derived data ----------------------- */
  const approvalPending = useMemo(
    () => lines.filter((l) => (l.approval_state ?? null) === "pending"),
    [lines]
  );

  const activeJobLines = useMemo(
    () => lines.filter((l) => (l.approval_state ?? null) !== "pending"),
    [lines]
  );

  const sortedLines = useMemo(() => {
    const pr: Record<string, number> = {
      diagnosis: 1,
      inspection: 2,
      maintenance: 3,
      repair: 4,
    };
    return [...activeJobLines].sort((a, b) => {
      const pa = pr[String(a.job_type ?? "repair")] ?? 999;
      const pb = pr[String(b.job_type ?? "repair")] ?? 999;
      if (pa !== pb) return pa - pb;
      const ta = a.created_at ? new Date(a.created_at).getTime() : 0;
      const tb = b.created_at ? new Date(b.created_at).getTime() : 0;
      return ta - tb;
    });
  }, [activeJobLines]);

  const createdAt = wo?.created_at ? new Date(wo.created_at) : null;
  const createdAtText =
    createdAt && !isNaN(createdAt.getTime())
      ? format(createdAt, "PPpp")
      : "—";

  const canAssign = currentUserRole ? ASSIGN_ROLES.has(currentUserRole) : false;

  const assignablesById = useMemo(() => {
    const m: Record<
      string,
      { full_name: string | null; role: string | null }
    > = {};
    assignables.forEach((a) => {
      m[a.id] = { full_name: a.full_name, role: a.role };
    });
    return m;
  }, [assignables]);

  /* ----------------------- line actions ----------------------- */

  const approveLine = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          approval_state: "approved",
          status: "queued",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      toast.success("Line approved");
      void fetchAll();
    },
    [fetchAll]
  );

  const declineLine = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          approval_state: "declined",
          status: "awaiting",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      toast.success("Line declined");
      void fetchAll();
    },
    [fetchAll]
  );

  const sendToParts = useCallback(async (lineId: string) => {
    if (!lineId) return;
    const { error } = await supabase
      .from("work_order_lines")
      .update({
        status: "on_hold",
        hold_reason: "Awaiting parts quote",
      } as DB["public"]["Tables"]["work_order_lines"]["Update"])
      .eq("id", lineId);
    if (error) return toast.error(error.message);
    setPartsLineId(lineId);
    toast.success("Sent to parts for quoting");
  }, []);

  const sendAllPendingToParts = useCallback(async () => {
    if (!approvalPending.length) return;
    const ids = approvalPending.map((l) => l.id);
    const { error } = await supabase
      .from("work_order_lines")
      .update({
        status: "on_hold",
        hold_reason: "Awaiting parts quote",
      } as DB["public"]["Tables"]["work_order_lines"]["Update"])