===== FILE: app/api/portal/bookings/[id]/route.ts =====
// app/api/portal/bookings/[id]/route.ts
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { NextResponse } from "next/server";
import type { Database } from "@shared/types/types/supabase";

export const runtime = "nodejs";

type PatchBody = {
  status?: "pending" | "confirmed" | "completed" | "cancelled";
  starts_at?: string;
  ends_at?: string;
  notes?: string | null;
};

function jsonError(msg: string, status = 400) {
  return NextResponse.json({ error: msg }, { status });
}

function getIdFromUrl(url: string): string {
  const { pathname } = new URL(url);
  return pathname.split("/").pop() ?? "";
}

const STAFF_ROLES = new Set([
  "owner",
  "admin",
  "manager",
  "advisor",
  "mechanic",
  "parts",
]);

async function isStaffForShop(
  supabase: ReturnType<typeof createRouteHandlerClient<Database>>,
  userId: string,
  shopId: string,
): Promise<boolean> {
  const { data: profile } = await supabase
    .from("profiles")
    .select("id, role, shop_id")
    .eq("id", userId)
    .maybeSingle();

  if (!profile) return false;
  return STAFF_ROLES.has(profile.role ?? "") && profile.shop_id === shopId;
}

async function isCustomerOwner(
  supabase: ReturnType<typeof createRouteHandlerClient<Database>>,
  userId: string,
  customerId: string | null,
): Promise<boolean> {
  if (!customerId) return false;
  const { data } = await supabase
    .from("customers")
    .select("id")
    .eq("id", customerId)
    .eq("user_id", userId)
    .maybeSingle();
  return !!data;
}

export async function PATCH(req: Request): Promise<Response> {
  const bookingId = getIdFromUrl(req.url);
  if (!bookingId) return jsonError("Missing booking id");

  const supabase = createRouteHandlerClient<Database>({ cookies });

  const {
    data: { user },
    error: authErr,
  } = await supabase.auth.getUser();

  if (authErr || !user) return jsonError("Not authenticated", 401);

  let body: PatchBody;
  try {
    body = (await req.json()) as PatchBody;
  } catch {
    return jsonError("Invalid JSON body");
  }

  const { data: booking, error: bErr } = await supabase
    .from("bookings")
    .select("id, shop_id, customer_id, status, starts_at, ends_at, notes")
    .eq("id", bookingId)
    .maybeSingle();

  if (bErr || !booking) return jsonError("Booking not found", 404);

  const staff = await isStaffForShop(supabase, user.id, booking.shop_id);
  const owner = await isCustomerOwner(supabase, user.id, booking.customer_id);

  if (!staff && !owner) return jsonError("Not allowed", 403);

  // Customers can only cancel, not reschedule or mark complete.
  if (owner) {
    if (body.starts_at || body.ends_at) {
      return jsonError("Customers may not reschedule bookings", 403);
    }
    if (body.status && body.status !== "cancelled") {
      return jsonError("Customers may only cancel a booking", 403);
    }
  }

  // Validate reschedule times (staff only)
  let nextStart: Date | null = null;
  let nextEnd: Date | null = null;
  if (body.starts_at || body.ends_at) {
    if (!staff) return jsonError("Only staff can reschedule", 403);

    if (!body.starts_at || !body.ends_at) {
      return jsonError("starts_at and ends_at are required to reschedule");
    }

    nextStart = new Date(body.starts_at);
    nextEnd = new Date(body.ends_at);

    if (Number.isNaN(nextStart.getTime()) || Number.isNaN(nextEnd.getTime())) {
      return jsonError("Invalid starts_at/ends_at");
    }
    if (nextEnd <= nextStart) return jsonError("ends_at must be after starts_at");
  }

  const patch: Partial<Database["public"]["Tables"]["bookings"]["Update"]> = {};

  if (typeof body.notes !== "undefined") patch.notes = body.notes ?? null;
  if (body.status) patch.status = body.status;
  if (nextStart && nextEnd) {
    patch.starts_at = nextStart.toISOString();
    patch.ends_at = nextEnd.toISOString();
  }

  if (Object.keys(patch).length === 0) {
    return jsonError("Nothing to update");
  }

  const { data: updated, error: upErr } = await supabase
    .from("bookings")
    .update(patch)
    .eq("id", bookingId)
    .select("*")
    .maybeSingle();

  if (upErr || !updated) return jsonError("Failed to update booking", 500);

  return NextResponse.json({ booking: updated }, { status: 200 });
}

export async function DELETE(req: Request): Promise<Response> {
  const bookingId = getIdFromUrl(req.url);
  if (!bookingId) return jsonError("Missing booking id");

  const supabase = createRouteHandlerClient<Database>({ cookies });

  const {
    data: { user },
    error: authErr,
  } = await supabase.auth.getUser();

  if (authErr || !user) return jsonError("Not authenticated", 401);

  const { data: booking, error: bErr } = await supabase
    .from("bookings")
    .select("id, shop_id, customer_id")
    .eq("id", bookingId)
    .maybeSingle();

  if (bErr || !booking) return jsonError("Booking not found", 404);

  const staff = await isStaffForShop(supabase, user.id, booking.shop_id);
  const owner = await isCustomerOwner(supabase, user.id, booking.customer_id);

  if (!staff && !owner) return jsonError("Not allowed", 403);

  const { error: delErr } = await supabase.from("bookings").delete().eq("id", bookingId);
  if (delErr) return jsonError("Failed to delete booking", 500);

  return NextResponse.json({ ok: true }, { status: 200 });
}
