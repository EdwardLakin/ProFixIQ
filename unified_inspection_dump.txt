=============== Inspection Header ===============
"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";

type Props = {
  session: InspectionSession;
};

export default function InspectionHeader({ session }: Props) {
  return (
    <div className="flex flex-col gap-1 rounded-xl border border-white/10 bg-black/40 p-3 text-xs text-neutral-200">
      <div className="text-sm font-semibold text-orange-400">
        {session.templateName || "Inspection"}
      </div>
      <div>
        Vehicle:{" "}
        {session.vehicle?.year} {session.vehicle?.make}{" "}
        {session.vehicle?.model}
      </div>
      <div>Customer: {session.customer?.first_name} {session.customer?.last_name}</div>
      <div>Status: {session.status}</div>
    </div>
  );
}

=============== Inspection Action Bar ===============
"use client";



type Props = {
  onSave?: () => void;
  onFinish?: () => void;
  onStartVoice?: () => void;
  onStopVoice?: () => void;
  isListening?: boolean;
};

export default function InspectionActionBar({
  onSave,
  onFinish,
  onStartVoice,
  onStopVoice,
  isListening,
}: Props) {
  return (
    <div className="flex flex-wrap items-center justify-between gap-2 rounded-xl border border-white/10 bg-black/40 p-3 text-xs">
      <div className="font-semibold text-neutral-200">Inspection actions</div>
      <div className="flex gap-2">
        <button
          type="button"
          onClick={onSave}
          className="rounded bg-neutral-800 px-3 py-1 text-xs text-white"
        >
          Save
        </button>
        <button
          type="button"
          onClick={onFinish}
          className="rounded bg-orange-600 px-3 py-1 text-xs text-white"
        >
          Finish
        </button>
        {isListening ? (
          <button
            type="button"
            onClick={onStopVoice}
            className="rounded bg-red-600 px-3 py-1 text-xs text-white"
          >
            Stop voice
          </button>
        ) : (
          <button
            type="button"
            onClick={onStartVoice}
            className="rounded bg-green-600 px-3 py-1 text-xs text-white"
          >
            Start voice
          </button>
        )}
      </div>
    </div>
  );
}

=============== Inspection Summary ===============
"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";

type Props = {
  session: InspectionSession;
};

export default function InspectionSummary({ session }: Props) {
  const sections = session.sections ?? [];
  const totalItems = sections.reduce(
    (sum, s) => sum + (s.items?.length ?? 0),
    0,
  );

  return (
    <div className="rounded-xl border border-white/10 bg-black/40 p-3 text-xs text-neutral-200">
      <div className="mb-1 text-sm font-semibold text-orange-400">
        Quick summary
      </div>
      <div>Sections: {sections.length}</div>
      <div>Items: {totalItems}</div>
      <div>Status: {session.status}</div>
    </div>
  );
}

=============== Section Renderer ===============
"use client";


import type {
  InspectionSection,
  InspectionItem,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/unified/ui/CornerGrid";
import AxleGrid from "@inspections/unified/ui/AxleGrid";
import SectionDisplay from "@inspections/unified/ui/SectionDisplay";

type Props = {
  sections: InspectionSection[];
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
};

// Steer / Drive / Trailer Left|Right ...
const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
// LF / RF / LR / RR ...
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
// Left Front / Right Rear ...
const HYD_FULL_RE =
  /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

function detectLayout(items: InspectionItem[]): "air" | "hyd" | "plain" {
  let airMatches = 0;
  let hydMatches = 0;

  for (const it of items) {
    const label = it.item ?? it.name ?? "";
    if (!label) continue;

    if (AIR_RE.test(label)) airMatches += 1;
    if (HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label)) hydMatches += 1;
  }

  if (airMatches > 0) return "air";
  if (hydMatches > 0) return "hyd";
  return "plain";
}

export default function SectionRenderer({ sections, onUpdateItem }: Props) {
  return (
    <div className="flex flex-col gap-4">
      {sections.map((section, sectionIndex) => {
        const items = section.items ?? [];
        const layout = detectLayout(items);

        // HYDRAULIC CORNER GRID (LF/RF/LR/RR + metrics)
        if (layout === "hyd") {
          return (
            <CornerGrid
              key={`${sectionIndex}-${section.title || "hyd"}`}
              sectionIndex={sectionIndex}
              items={items}
              unitMode="imperial"
              showKpaHint={true}
              onUpdateItem={onUpdateItem}
            />
          );
        }

        // AIR / AXLE GRID (Steer / Drive / Trailer Left/Right + metrics)
        if (layout === "air") {
          return (
            <AxleGrid
              key={`${sectionIndex}-${section.title || "air"}`}
              sectionIndex={sectionIndex}
              items={items}
              unitMode="imperial"
              showKpaHint={true}
              onUpdateItem={onUpdateItem}
            />
          );
        }

        // GENERIC “CARD” SECTION – unified theme, no legacy imports
        return (
          <SectionDisplay
            key={`${sectionIndex}-${section.title || "plain"}`}
            title={section.title ?? `Section ${sectionIndex + 1}`}
            section={section}
            sectionIndex={sectionIndex}
            showNotes
            showPhotos
            onUpdateStatus={(
              secIdx: number,
              itemIdx: number,
              status: InspectionItemStatus,
            ) => onUpdateItem(secIdx, itemIdx, { status })}
            onUpdateNote={(
              secIdx: number,
              itemIdx: number,
              note: string,
            ) => onUpdateItem(secIdx, itemIdx, { notes: note })}
            onUpload={(
              photoUrl: string,
              secIdx: number,
              itemIdx: number,
            ) => {
              const item = sections[secIdx]?.items?.[itemIdx];
              const existing = (item?.photoUrls ?? []) as string[];
              onUpdateItem(secIdx, itemIdx, {
                photoUrls: [...existing, photoUrl],
              });
            }}
          />
        );
      })}
    </div>
  );
}

=============== Section Display ===============
//features/inspections/unified/ui/SectionDisplay.tsx
"use client";

import { useMemo, useState } from "react";
import type {
  InspectionSection,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";
import { Button } from "@shared/components/ui/Button";

type SectionDisplayProps = {
  title: string;
  section: InspectionSection;
  sectionIndex: number;
  showNotes: boolean;
  showPhotos: boolean;
  onUpdateStatus: (
    sectionIndex: number,
    itemIndex: number,
    status: InspectionItemStatus,
  ) => void;
  onUpdateNote: (
    sectionIndex: number,
    itemIndex: number,
    note: string,
  ) => void;
  onUpload: (
    photoUrl: string,
    sectionIndex: number,
    itemIndex: number,
  ) => void;
};

export default function SectionDisplay({
  title,
  section,
  sectionIndex,
  showNotes,
  showPhotos,
  onUpdateStatus,
  onUpdateNote,
  onUpload,
}: SectionDisplayProps) {
  const [open, setOpen] = useState<boolean>(true);

  const stats = useMemo(() => {
    const total = section.items.length;
    const counts: Record<
      "ok" | "fail" | "na" | "recommend" | "unset",
      number
    > = { ok: 0, fail: 0, na: 0, recommend: 0, unset: 0 };

    for (const it of section.items) {
      const status = (it.status ?? "unset") as keyof typeof counts;
      if (status in counts) counts[status] += 1;
      else counts.unset += 1;
    }

    return { total, ...counts };
  }, [section.items]);

  const markAll = (status: InspectionItemStatus) => {
    section.items.forEach((_item, itemIndex) =>
      onUpdateStatus(sectionIndex, itemIndex, status),
    );
  };

  return (
    <div className="mb-6 rounded-2xl border border-white/8 bg-black/30 px-4 py-3 shadow-card backdrop-blur-md md:px-5 md:py-4">
      {/* Header */}
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-white/5 pb-3">
        <button
          type="button"
          onClick={() => setOpen((v) => !v)}
          className="text-left text-lg font-semibold tracking-wide text-orange-400"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
          aria-expanded={open}
        >
          {title}
        </button>

        <div className="flex flex-wrap items-center gap-2">
          <span
            className="hidden text-[11px] uppercase tracking-wide text-neutral-400 md:inline"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {stats.ok} OK · {stats.fail} FAIL · {stats.na} NA ·{" "}
            {stats.recommend} REC · {stats.unset} —
          </span>

          <div className="flex flex-wrap items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("ok")}
            >
              All OK
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("fail")}
            >
              All FAIL
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("na")}
            >
              All NA
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("recommend")}
            >
              All REC
            </Button>

            <Button
              variant="ghost"
              size="sm"
              className="ml-1 h-7 px-2 text-[11px]"
              type="button"
              onClick={() => setOpen((v) => !v)}
              aria-expanded={open}
              title={open ? "Collapse section" : "Expand section"}
            >
              {open ? "Collapse" : "Expand"}
            </Button>
          </div>
        </div>
      </div>

      {/* Body */}
      {open && (
        <div className="space-y-3 pt-3">
          {section.items.map((item, itemIndex) => {
            const keyBase =
              item.item ?? item.name ?? `item-${sectionIndex}-${itemIndex}`;

            const status = (item.status ?? "").toString().toLowerCase();
            const note = (item.notes ?? "").toString();
            const photoUrls = (item.photoUrls ?? []) as string[];

            return (
              <div
                key={`${keyBase}-${itemIndex}`}
                className="rounded-xl border border-white/5 bg-black/40 p-3 md:p-3.5"
              >
                {/* Top row: label + status buttons */}
                <div className="flex flex-wrap items-center justify-between gap-2">
                  <div className="min-w-0 flex-1 text-sm font-medium text-white">
                    {item.item ?? item.name ?? "Item"}
                  </div>

                  <div className="flex flex-wrap items-center gap-1">
                    {(["ok", "fail", "na", "recommend"] as const).map(
                      (s) => (
                        <Button
                          key={s}
                          type="button"
                          size="sm"
                          variant={
                            (status as InspectionItemStatus) === s
                              ? "orange"
                              : "outline"
                          }
                          className="h-7 px-2 text-[11px]"
                          onClick={() =>
                            onUpdateStatus(
                              sectionIndex,
                              itemIndex,
                              s as InspectionItemStatus,
                            )
                          }
                        >
                          {s.toUpperCase()}
                        </Button>
                      ),
                    )}
                  </div>
                </div>

                {/* Measurement + notes/photos */}
                <div className="mt-2 space-y-2 text-xs text-neutral-200">
                  <div className="flex flex-wrap items-center gap-2">
                    <span className="text-neutral-400">Value:</span>
                    <span>
                      {item.value ?? "—"}
                      {item.unit ? ` ${item.unit}` : ""}
                    </span>
                  </div>

                  {showNotes && (
                    <div className="space-y-1">
                      <div className="text-neutral-400">Notes</div>
                      <textarea
                        className="min-h-[60px] w-full rounded-md border border-white/10 bg-black/40 px-2 py-1 text-xs text-white outline-none focus:border-orange-400 focus:ring-1 focus:ring-orange-400"
                        value={note}
                        onChange={(e) =>
                          onUpdateNote(
                            sectionIndex,
                            itemIndex,
                            e.currentTarget.value,
                          )
                        }
                      />
                    </div>
                  )}

                  {showPhotos && (
                    <div className="space-y-1">
                      <div className="flex items-center justify-between text-neutral-400">
                        <span>Photos ({photoUrls.length})</span>
                        {/* hook up to actual uploader later */}
                        <Button
                          type="button"
                          size="xs"
                          variant="outline"
                          className="h-6 px-2 text-[10px]"
                          onClick={() => {
                            const dummyUrl = window.prompt(
                              "Photo URL (stub for now)",
                            );
                            if (!dummyUrl) return;
                            onUpload(dummyUrl, sectionIndex, itemIndex);
                          }}
                        >
                          + Add
                        </Button>
                      </div>

                      {photoUrls.length > 0 && (
                        <div className="flex flex-wrap gap-2">
                          {photoUrls.map((url) => (
                            <div
                              key={url}
                              className="h-12 w-12 overflow-hidden rounded border border-white/10 bg-neutral-900"
                            >
                              {/* eslint-disable-next-line @next/next/no-img-element */}
                              <img
                                src={url}
                                alt="Inspection"
                                className="h-full w-full object-cover"
                              />
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}
=============== Axle Grid ===============
"use client";


import type { InspectionItem } from "@inspections/lib/inspection/types";

type GridUnitMode = "metric" | "imperial";
type Side = "left" | "right";
type Variant = "main" | "inner" | "outer";

interface AxleGridProps {
  title?: string;
  sectionIndex: number;
  items: InspectionItem[];
  unitMode: GridUnitMode;
  showKpaHint: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
  onAddAxle?: () => void;
}

interface AxleCell {
  itemIndex: number;
  item: InspectionItem;
}

interface AxleSideInputs {
  main?: AxleCell;
  inner?: AxleCell;
  outer?: AxleCell;
}

interface AxleMetricRow {
  metricKey: string;
  metricLabel: string;
  left: AxleSideInputs;
  right: AxleSideInputs;
}

interface AxleBlock {
  axleName: string;
  rows: AxleMetricRow[];
}

interface ParsedAirLabel {
  axle: string;
  side: Side;
  variant: Variant;
  metric: string;
  metricBase: string;
}

function normaliseMetric(metric: string): string {
  return metric
    .replace(/\(\s*(inner|outer)\s*\)/gi, "")
    .replace(/\b(inner|outer)\b/gi, "")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/**
 * Supported label shapes:
 *  - "Steer Left Tire Pressure"
 *  - "Drive 1 Right Inner Tire Tread"
 *  - "Drive 2 LRI Pushrod Travel"
 *  - "Trailer 1 RRO Drum / Rotor Thickness"
 */
function parseAirLabel(labelRaw: string): ParsedAirLabel | null {
  const label = labelRaw.trim();
  if (!label) return null;

  // Abbreviation: "<axle> <code> <metric>"
  const abbrMatch = label.match(
    /^(?<axle>.+?)\s+(?<code>LRI|LRO|RRI|RRO|LF|RF|LR|RR)\s+(?<metric>.+)$/i,
  );
  if (abbrMatch && abbrMatch.groups) {
    const axle = abbrMatch.groups.axle.trim();
    const code = abbrMatch.groups.code.toUpperCase();
    const metric = abbrMatch.groups.metric.trim();
    if (!axle || !metric) return null;

    const side: Side = code.startsWith("L") ? "left" : "right";
    let variant: Variant = "main";
    if (code.endsWith("I")) variant = "inner";
    if (code.endsWith("O")) variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      axle,
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  // Text form: "<axle> Left [Inner|Outer] Metric..."
  const textMatch = label.match(
    /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?:(?<io>Inner|Outer)\s+)?(?<metric>.+)$/i,
  );
  if (textMatch && textMatch.groups) {
    const axle = textMatch.groups.axle.trim();
    const side: Side =
      textMatch.groups.side.toLowerCase() === "left" ? "left" : "right";
    const ioRaw = (textMatch.groups.io ?? "").toLowerCase();
    const metric = textMatch.groups.metric.trim();
    if (!axle || !metric) return null;

    let variant: Variant = "main";
    if (ioRaw === "inner") variant = "inner";
    if (ioRaw === "outer") variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      axle,
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  return null;
}

function buildAxles(items: InspectionItem[]): {
  axles: AxleBlock[];
  loose: Array<{ itemIndex: number; item: InspectionItem }>;
} {
  const perAxle = new Map<string, Map<string, AxleMetricRow>>();
  const loose: Array<{ itemIndex: number; item: InspectionItem }> = [];

  items.forEach((item, idx) => {
    const label = item.item ?? item.name ?? "";
    const parsed = parseAirLabel(label);
    if (!parsed) {
      loose.push({ itemIndex: idx, item });
      return;
    }

    const axleMap =
      perAxle.get(parsed.axle) ?? new Map<string, AxleMetricRow>();

    const existingRow =
      axleMap.get(parsed.metricBase) ??
      ({
        metricKey: parsed.metricBase,
        metricLabel: parsed.metricBase,
        left: {},
        right: {},
      } as AxleMetricRow);

    const cell: AxleCell = { itemIndex: idx, item };

    if (parsed.side === "left") {
      existingRow.left[parsed.variant] = cell;
    } else {
      existingRow.right[parsed.variant] = cell;
    }

    axleMap.set(parsed.metricBase, existingRow);
    perAxle.set(parsed.axle, axleMap);
  });

  const axles: AxleBlock[] = Array.from(perAxle.entries()).map(
    ([axleName, rowsMap]) => ({
      axleName,
      rows: Array.from(rowsMap.values()),
    }),
  );

  return { axles, loose };
}

function getUnitLabel(metricLabel: string, unitMode: GridUnitMode): string {
  const lower = metricLabel.toLowerCase();

  // Air pressure always psi, regardless of unit toggle.
  if (lower.includes("pressure")) return "psi";

  // Pushrod travel / drum / rotor / shoe thickness etc.
  if (
    lower.includes("tread") ||
    lower.includes("pad") ||
    lower.includes("shoe") ||
    lower.includes("drum") ||
    lower.includes("rotor") ||
    lower.includes("thickness") ||
    lower.includes("pushrod") ||
    lower.includes("push-rod") ||
    lower.includes("push rod")
  ) {
    return unitMode === "metric" ? "mm" : "in";
  }

  return unitMode === "metric" ? "mm" : "in";
}

interface ValueInputProps {
  value: string | number | null | undefined;
  unit: string;
  showKpaHint?: boolean;
  isPressure?: boolean;
  onChange: (next: string) => void;
}

const ValueInput: React.FC<ValueInputProps> = ({
  value,
  unit,
  showKpaHint,
  isPressure,
  onChange,
}) => {
  const display = value ?? "";

  return (
    <div className="flex items-center gap-2 rounded-xl border border-[color:var(--metal-border-soft)] bg-black/70 px-3 py-1.5 text-xs shadow-[0_10px_25px_rgba(0,0,0,0.9)] backdrop-blur-md">
      <input
        type="number"
        inputMode="decimal"
        className="w-full bg-transparent text-sm text-white placeholder:text-neutral-500 focus:outline-none"
        placeholder="Value"
        value={display}
        onChange={(e) => onChange(e.target.value)}
      />
      <div className="flex flex-col items-end text-[10px] leading-tight text-neutral-400">
        <span>{unit}</span>
        {isPressure && showKpaHint && (
          <span className="text-[9px] text-neutral-500">kPa hint</span>
        )}
      </div>
    </div>
  );
};

interface SideStackProps {
  sideLabel: string; // "Left" / "Right"
  side: AxleSideInputs;
  sectionIndex: number;
  unit: string;
  isPressure: boolean;
  showKpaHint: boolean;
  alignRight?: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

const SideStack: React.FC<SideStackProps> = ({
  sideLabel,
  side,
  sectionIndex,
  unit,
  isPressure,
  showKpaHint,
  alignRight = false,
  onUpdateItem,
}) => {
  const pieces: Array<{ key: string; caption: string; cell: AxleCell }> = [];

  if (side.main) {
    pieces.push({ key: "main", caption: sideLabel, cell: side.main });
  }
  if (side.outer) {
    pieces.push({
      key: "outer",
      caption: `${sideLabel} Outer`,
      cell: side.outer,
    });
  }
  if (side.inner) {
    pieces.push({
      key: "inner",
      caption: `${sideLabel} Inner`,
      cell: side.inner,
    });
  }

  if (!pieces.length) return null;

  return (
    <div className="space-y-1 sm:max-w-[40%]">
      {pieces.map(({ key, caption, cell }) => (
        <div key={key} className="space-y-1">
          <div
            className={`text-[11px] font-medium uppercase tracking-[0.18em] text-neutral-400 ${
              alignRight ? "text-right" : ""
            }`}
          >
            {caption}
          </div>
          <ValueInput
            value={cell.item.value}
            unit={unit}
            isPressure={isPressure}
            showKpaHint={isPressure && showKpaHint}
            onChange={(next) =>
              onUpdateItem(sectionIndex, cell.itemIndex, { value: next })
            }
          />
        </div>
      ))}
    </div>
  );
};

const AxleGrid: React.FC<AxleGridProps> = ({
  title,
  sectionIndex,
  items,
  unitMode,
  showKpaHint,
  onUpdateItem,
  onAddAxle,
}) => {
  const { axles, loose } = buildAxles(items);

  if (axles.length === 0 && loose.length === 0) return null;

  return (
    <section className="space-y-4">
      <div className="flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title ?? "Axle Measurements (Air Brake)"}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Steer, drive, and trailer axles – tire pressure, tread depth,
            push-rod travel, drum/rotor, pads/shoes. Values only.
          </p>
        </div>
        {onAddAxle && (
          <button
            type="button"
            onClick={onAddAxle}
            className="rounded-full bg-[color:var(--accent-copper)] px-3 py-1.5 text-[11px] font-semibold text-black shadow-[0_0_20px_rgba(193,102,59,0.75)] hover:bg-[color:var(--accent-copper-soft)]"
          >
            + Add axle
          </button>
        )}
      </div>

      <div className="space-y-4">
        {axles.map((axle) => (
          <div
            key={axle.axleName}
            className="metal-card rounded-2xl p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)]"
          >
            <div className="mb-3 flex items-center justify-between gap-2">
              <div className="text-xs font-semibold uppercase tracking-[0.18em] text-neutral-400">
                {axle.axleName}
              </div>
            </div>

            {/* Desktop header */}
            <div className="hidden text-[11px] text-neutral-400 sm:grid sm:grid-cols-[minmax(0,1fr)_minmax(0,2fr)_minmax(0,1fr)] sm:gap-2 sm:border-t sm:border-white/10 sm:pt-2">
              <div className="px-2 py-1">Left</div>
              <div className="px-2 py-1 text-center">Item</div>
              <div className="px-2 py-1 text-right">Right</div>
            </div>

            <div className="space-y-3 pt-1">
              {axle.rows.map((row) => {
                const unit = getUnitLabel(row.metricLabel, unitMode);
                const isPressure =
                  row.metricLabel.toLowerCase().includes("pressure");

                return (
                  <div
                    key={row.metricKey}
                    className="rounded-xl border border-white/10 bg-black/65 p-3 backdrop-blur-md"
                  >
                    <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
                      <SideStack
                        sideLabel="Left"
                        side={row.left}
                        sectionIndex={sectionIndex}
                        unit={unit}
                        isPressure={isPressure}
                        showKpaHint={showKpaHint}
                        onUpdateItem={onUpdateItem}
                      />

                      <div className="flex-1 text-center text-sm font-medium text-neutral-100">
                        {row.metricLabel}
                      </div>

                      <SideStack
                        sideLabel="Right"
                        side={row.right}
                        sectionIndex={sectionIndex}
                        unit={unit}
                        isPressure={isPressure}
                        showKpaHint={showKpaHint}
                        alignRight
                        onUpdateItem={onUpdateItem}
                      />
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ))}
      </div>

      {loose.length > 0 && (
        <div className="rounded-xl border border-amber-500/30 bg-amber-950/30 p-3 text-[11px] text-amber-100">
          <div className="mb-1 font-semibold tracking-wide">
            Other axle measurements
          </div>
          <div className="space-y-2">
            {loose.map(({ item, itemIndex }) => {
              const label = item.item ?? item.name ?? "Item";
              const unit = getUnitLabel(label, unitMode);
              const isPressure = label.toLowerCase().includes("pressure");

              return (
                <div key={itemIndex} className="space-y-1">
                  <div className="text-[11px] text-amber-100/80">
                    {label}
                  </div>
                  <ValueInput
                    value={item.value}
                    unit={unit}
                    isPressure={isPressure}
                    showKpaHint={showKpaHint}
                    onChange={(next) =>
                      onUpdateItem(sectionIndex, itemIndex, { value: next })
                    }
                  />
                </div>
              );
            })}
          </div>
        </div>
      )}
    </section>
  );
};

export default AxleGrid;
=============== Battery Grid ===============
"use client";



export interface BatteryMeasurement {
  label: string;
  factoryCca: number | null;
  testedCca: number | null;
  notes?: string;
}

interface BatteryGridProps {
  title?: string;
  batteries: BatteryMeasurement[];
  onChange: (index: number, patch: Partial<BatteryMeasurement>) => void;
  onAddBattery: () => void;
  onRemoveBattery?: (index: number) => void;
}

const BatteryGrid: React.FC<BatteryGridProps> = ({
  title = "Battery Measurements",
  batteries,
  onChange,
  onAddBattery,
  onRemoveBattery,
}) => {
  return (
    <section className="metal-card rounded-2xl p-4 sm:p-5">
      <div className="mb-3 flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Capture factory and tested CCA for each battery. Values only – any
            FAIL / RECOMMEND status is handled in the main inspection sections.
          </p>
        </div>
        <button
          type="button"
          onClick={onAddBattery}
          className="rounded-full bg-[color:var(--accent-copper)] px-3 py-1.5 text-[11px] font-semibold text-black shadow-[0_0_20px_rgba(193,102,59,0.75)] hover:bg-[color:var(--accent-copper-soft)]"
        >
          + Add battery
        </button>
      </div>

      {batteries.length === 0 ? (
        <p className="text-xs text-neutral-400">
          No batteries added yet. Use “Add battery” to start.
        </p>
      ) : (
        <div className="space-y-3">
          {batteries.map((batt, idx) => (
            <div
              key={idx}
              className="rounded-xl border border-white/10 bg-black/65 p-3 shadow-[0_12px_30px_rgba(0,0,0,0.9)] backdrop-blur-md"
            >
              <div className="mb-2 flex items-center justify-between gap-2">
                <div className="flex flex-col">
                  <span className="text-[11px] font-semibold uppercase tracking-[0.18em] text-neutral-400">
                    Battery {idx + 1}
                  </span>
                  <input
                    type="text"
                    className="mt-1 w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="Location / label (Start, Aux, LH, RH...)"
                    value={batt.label}
                    onChange={(e) =>
                      onChange(idx, { label: e.target.value })
                    }
                  />
                </div>

                {onRemoveBattery && batteries.length > 1 && (
                  <button
                    type="button"
                    onClick={() => onRemoveBattery(idx)}
                    className="rounded-full border border-red-500/70 px-2 py-1 text-[10px] font-medium text-red-100 hover:bg-red-500/10"
                  >
                    Remove
                  </button>
                )}
              </div>

              <div className="grid gap-3 text-xs sm:grid-cols-3">
                <div className="space-y-1">
                  <div className="text-[11px] text-neutral-400">
                    Factory CCA
                  </div>
                  <input
                    type="number"
                    inputMode="numeric"
                    className="w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="e.g. 750"
                    value={batt.factoryCca ?? ""}
                    onChange={(e) =>
                      onChange(idx, {
                        factoryCca:
                          e.target.value === ""
                            ? null
                            : Number(e.target.value),
                      })
                    }
                  />
                </div>

                <div className="space-y-1">
                  <div className="text-[11px] text-neutral-400">
                    Tested CCA
                  </div>
                  <input
                    type="number"
                    inputMode="numeric"
                    className="w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="e.g. 680"
                    value={batt.testedCca ?? ""}
                    onChange={(e) =>
                      onChange(idx, {
                        testedCca:
                          e.target.value === ""
                            ? null
                            : Number(e.target.value),
                      })
                    }
                  />
                </div>

                <div className="space-y-1 sm:col-span-1">
                  <div className="text-[11px] text-neutral-400">Notes</div>
                  <textarea
                    rows={2}
                    className="w-full resize-none rounded border border-white/15 bg-black/40 px-2 py-1 text-xs text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="Additional info (age, location, condition...)"
                    value={batt.notes ?? ""}
                    onChange={(e) =>
                      onChange(idx, { notes: e.target.value })
                    }
                  />
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </section>
  );
};

export default BatteryGrid;
=============== Corner Grid ===============
"use client";


import type { InspectionItem } from "@inspections/lib/inspection/types";

type GridUnitMode = "metric" | "imperial";
type Side = "left" | "right";
type Variant = "main" | "inner" | "outer";

interface CornerGridProps {
  title?: string;
  sectionIndex: number;
  items: InspectionItem[];
  unitMode: GridUnitMode;
  showKpaHint: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

interface CornerCell {
  itemIndex: number;
  item: InspectionItem;
}

interface CornerSideInputs {
  main?: CornerCell; // LF / RF / LR / RR
  inner?: CornerCell; // LRI / RRI
  outer?: CornerCell; // LRO / RRO
}

interface CornerRow {
  metricKey: string;
  metricLabel: string;
  left: CornerSideInputs;
  right: CornerSideInputs;
}

interface ParsedHydLocation {
  side: Side;
  variant: Variant;
  metric: string;
  metricBase: string;
}

/**
 * Remove "Inner" / "Outer" markup from a metric to group rows,
 * e.g. "Tire Tread (Outer)" + "Tire Tread (Inner)" → "Tire Tread".
 */
function normaliseMetric(metric: string): string {
  return metric
    .replace(/\(\s*(inner|outer)\s*\)/gi, "")
    .replace(/\b(inner|outer)\b/gi, "")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/**
 * Support:
 *  - "LF Tire Pressure"
 *  - "RRI Brake Pad Thickness"
 *  - "Left Front Tire Tread"
 *  - "Right Rear Inner Tire Tread (Outer)"
 */
function parseHydLabel(labelRaw: string): ParsedHydLocation | null {
  const label = labelRaw.trim();
  if (!label) return null;

  // Abbreviated location codes
  const abbrMatch = label.match(
    /^(LF|RF|LR|RR|LRI|LRO|RRI|RRO)\s+(.+)$/i,
  );
  if (abbrMatch) {
    const code = abbrMatch[1].toUpperCase();
    const metric = abbrMatch[2].trim();
    if (!metric) return null;

    const side: Side = code.startsWith("L") ? "left" : "right";
    let variant: Variant = "main";

    if (code.endsWith("I")) variant = "inner";
    if (code.endsWith("O")) variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  // Full text – e.g. "Left Rear Inner Tire Tread"
  const fullMatch = label.match(
    /^(Left|Right)\s+(Front|Rear)(?:\s+(Inner|Outer))?\s+(.+)$/i,
  );
  if (fullMatch) {
    const side: Side = fullMatch[1].toLowerCase() === "left" ? "left" : "right";
    const innerOuter = (fullMatch[3] ?? "").toLowerCase();
    const metric = fullMatch[4].trim();
    if (!metric) return null;

    let variant: Variant = "main";
    if (innerOuter === "inner") variant = "inner";
    if (innerOuter === "outer") variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  return null;
}

function buildRows(items: InspectionItem[]): {
  rows: CornerRow[];
  loose: Array<{ itemIndex: number; item: InspectionItem }>;
} {
  const rowsMap = new Map<string, CornerRow>();
  const loose: Array<{ itemIndex: number; item: InspectionItem }> = [];

  items.forEach((item, idx) => {
    const label = item.item ?? item.name ?? "";
    const parsed = parseHydLabel(label);
    if (!parsed) {
      loose.push({ itemIndex: idx, item });
      return;
    }

    const existing =
      rowsMap.get(parsed.metricBase) ??
      ({
        metricKey: parsed.metricBase,
        metricLabel: parsed.metricBase,
        left: {},
        right: {},
      } as CornerRow);

    const cell: CornerCell = { itemIndex: idx, item };

    if (parsed.side === "left") {
      existing.left[parsed.variant] = cell;
    } else {
      existing.right[parsed.variant] = cell;
    }

    rowsMap.set(parsed.metricBase, existing);
  });

  return { rows: Array.from(rowsMap.values()), loose };
}

function getUnitLabel(metricLabel: string, unitMode: GridUnitMode): string {
  const lower = metricLabel.toLowerCase();

  // Pressure is always psi – unit toggle does not affect this.
  if (lower.includes("pressure")) return "psi";

  // Everything else here is a length/thickness-style measurement.
  if (
    lower.includes("tread") ||
    lower.includes("pad") ||
    lower.includes("rotor") ||
    lower.includes("thickness")
  ) {
    return unitMode === "metric" ? "mm" : "in";
  }

  return unitMode === "metric" ? "mm" : "in";
}

interface ValueInputProps {
  value: string | number | null | undefined;
  unit: string;
  showKpaHint?: boolean;
  isPressure?: boolean;
  placeholder?: string;
  onChange: (next: string) => void;
}

const ValueInput: React.FC<ValueInputProps> = ({
  value,
  unit,
  showKpaHint,
  isPressure,
  placeholder = "Value",
  onChange,
}) => {
  const display = value ?? "";

  return (
    <div className="flex items-center gap-2 rounded-xl border border-[color:var(--metal-border-soft)] bg-black/70 px-3 py-1.5 text-xs shadow-[0_10px_25px_rgba(0,0,0,0.9)] backdrop-blur-md">
      <input
        type="number"
        inputMode="decimal"
        className="w-full bg-transparent text-sm text-white placeholder:text-neutral-500 focus:outline-none"
        placeholder={placeholder}
        value={display}
        onChange={(e) => onChange(e.target.value)}
      />
      <div className="flex flex-col items-end text-[10px] leading-tight text-neutral-400">
        <span>{unit}</span>
        {isPressure && showKpaHint && (
          <span className="text-[9px] text-neutral-500">kPa hint</span>
        )}
      </div>
    </div>
  );
};

interface SideStackProps {
  label: string;
  side: CornerSideInputs;
  sectionIndex: number;
  unit: string;
  isPressure: boolean;
  showKpaHint: boolean;
  alignRight?: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

const SideStack: React.FC<SideStackProps> = ({
  label,
  side,
  sectionIndex,
  unit,
  isPressure,
  showKpaHint,
  alignRight = false,
  onUpdateItem,
}) => {
  const pieces: Array<{ key: string; caption: string; cell: CornerCell }> = [];

  if (side.main) {
    pieces.push({ key: "main", caption: label, cell: side.main });
  }
  if (side.outer) {
    pieces.push({ key: "outer", caption: `${label} Outer`, cell: side.outer });
  }
  if (side.inner) {
    pieces.push({ key: "inner", caption: `${label} Inner`, cell: side.inner });
  }

  if (!pieces.length) return null;

  return (
    <div className="space-y-1 sm:max-w-[40%]">
      {pieces.map(({ key, caption, cell }) => (
        <div key={key} className="space-y-1">
          <div
            className={`text-[11px] font-medium uppercase tracking-[0.18em] text-neutral-400 ${
              alignRight ? "text-right" : ""
            }`}
          >
            {caption}
          </div>
          <ValueInput
            value={cell.item.value}
            unit={unit}
            isPressure={isPressure}
            showKpaHint={isPressure && showKpaHint}
            onChange={(next) =>
              onUpdateItem(sectionIndex, cell.itemIndex, { value: next })
            }
          />
        </div>
      ))}
    </div>
  );
};

const CornerGrid: React.FC<CornerGridProps> = ({
  title,
  sectionIndex,
  items,
  unitMode,
  showKpaHint,
  onUpdateItem,
}) => {
  const { rows, loose } = buildRows(items);

  if (rows.length === 0 && loose.length === 0) return null;

  return (
    <section className="metal-card rounded-2xl p-4 sm:p-5">
      <div className="mb-3 flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title ?? "Measurements (Hydraulic)"}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Corner-based measurements: tire pressure, tread depth, pad / rotor
            thickness. Values only – statuses live in other sections.
          </p>
        </div>
      </div>

      {/* Desktop header */}
      <div className="hidden text-[11px] text-neutral-400 sm:grid sm:grid-cols-[minmax(0,1fr)_minmax(0,2fr)_minmax(0,1fr)] sm:gap-2 sm:border-t sm:border-white/10 sm:pt-3">
        <div className="px-2 py-1">Left</div>
        <div className="px-2 py-1 text-center">Item</div>
        <div className="px-2 py-1 text-right">Right</div>
      </div>

      <div className="space-y-3 pt-1">
        {rows.map((row) => {
          const unit = getUnitLabel(row.metricLabel, unitMode);
          const isPressure = row.metricLabel.toLowerCase().includes("pressure");

          return (
            <div
              key={row.metricKey}
              className="rounded-xl border border-white/10 bg-black/60 p-3 shadow-[0_12px_30px_rgba(0,0,0,0.9)] backdrop-blur-md"
            >
              <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
                <SideStack
                  label="Left"
                  side={row.left}
                  sectionIndex={sectionIndex}
                  unit={unit}
                  isPressure={isPressure}
                  showKpaHint={showKpaHint}
                  onUpdateItem={onUpdateItem}
                />

                <div className="flex-1 text-center text-sm font-medium text-neutral-100">
                  {row.metricLabel}
                </div>

                <SideStack
                  label="Right"
                  side={row.right}
                  sectionIndex={sectionIndex}
                  unit={unit}
                  isPressure={isPressure}
                  showKpaHint={showKpaHint}
                  alignRight
                  onUpdateItem={onUpdateItem}
                />
              </div>
            </div>
          );
        })}
      </div>

      {loose.length > 0 && (
        <div className="mt-4 rounded-xl border border-amber-500/30 bg-amber-950/30 p-3 text-[11px] text-amber-100">
          <div className="mb-1 font-semibold tracking-wide">
            Other measurements
          </div>
          <div className="space-y-2">
            {loose.map(({ item, itemIndex }) => {
              const label = item.item ?? item.name ?? "Item";
              const unit = getUnitLabel(label, unitMode);
              const isPressure = label.toLowerCase().includes("pressure");

              return (
                <div key={itemIndex} className="space-y-1">
                  <div className="text-[11px] text-amber-100/80">
                    {label}
                  </div>
                  <ValueInput
                    value={item.value}
                    unit={unit}
                    isPressure={isPressure}
                    showKpaHint={showKpaHint}
                    onChange={(next) =>
                      onUpdateItem(sectionIndex, itemIndex, { value: next })
                    }
                  />
                </div>
              );
            })}
          </div>
        </div>
      )}
    </section>
  );
};

export default CornerGrid;
=============== Unified Screen (current) ===============
// features/inspections/unified/ui/InspectionUnifiedScreen.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { v4 as uuidv4 } from "uuid";
import { toast } from "sonner";

import type {
  InspectionSession,
  InspectionSection,
  InspectionItemStatus,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import SectionRenderer from "./SectionRenderer";
import VoiceInspectionController from "../voice/VoiceInspectionController";

// Simple helpers for progress + filtering
function countItems(sections: InspectionSection[]): {
  total: number;
  completed: number;
} {
  let total = 0;
  let completed = 0;
  for (const s of sections) {
    for (const it of s.items ?? []) {
      total += 1;
      const status = String(it.status ?? "").toLowerCase();
      if (status === "ok" || status === "fail" || status === "na" || status === "recommend") {
        completed += 1;
      }
    }
  }
  return { total, completed };
}

type Props = {
  session: InspectionSession;
  onUpdateSession: (patch: Partial<InspectionSession>) => void;
};

export default function InspectionUnifiedScreen({
  session,
  onUpdateSession,
}: Props) {
  const [unitMode, setUnitMode] = useState<"metric" | "imperial">("metric");
  const [buildingQuote, setBuildingQuote] = useState(false);

  // Track in-flight AI requests by "secIdx:itemIdx"
  const inflightRef = useRef<Set<string>>(new Set());

  const { total, completed } = useMemo(
    () => countItems(session.sections ?? []),
    [session.sections],
  );

  const workOrderId = session.workOrderId ?? undefined;

  // --- low-level helpers ----------------------------------------------------

  const updateSections = (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionSection["items"][number]>,
  ) => {
    const currentSections = session.sections ?? [];
    if (!currentSections[sectionIndex]) return;

    const nextSections = [...currentSections];
    const items = [...(nextSections[sectionIndex].items ?? [])];
    if (!items[itemIndex]) return;

    items[itemIndex] = { ...items[itemIndex], ...patch };
    nextSections[sectionIndex] = {
      ...nextSections[sectionIndex],
      items,
    };

    onUpdateSession({ sections: nextSections });
  };

  const updateQuoteLine = (id: string, patch: Partial<QuoteLineItem>) => {
    const existing = (session.quote ?? []) as QuoteLineItem[];
    const next = existing.map((line) =>
      line.id === id ? { ...line, ...patch } : line,
    );
    onUpdateSession({ quote: next });
  };

  const pushQuoteLine = (line: QuoteLineItem) => {
    const existing = (session.quote ?? []) as QuoteLineItem[];
    onUpdateSession({ quote: [...existing, line] });
  };

  // --- AI quote + work-order + parts request -------------------------------

  const buildQuoteForItem = async (
    sectionIndex: number,
    itemIndex: number,
  ): Promise<void> => {
    const key = `${sectionIndex}:${itemIndex}`;
    if (inflightRef.current.has(key)) return;

    const section = session.sections?.[sectionIndex];
    const it = section?.items?.[itemIndex];
    if (!section || !it) return;

    const status = String(it.status ?? "").toLowerCase() as InspectionItemStatus;
    const note = (it.notes ?? "").trim();
    if (!(status === "fail" || status === "recommend")) return;
    if (!note) {
      toast.error("Add a note before submitting this item for estimate.");
      return;
    }

    inflightRef.current.add(key);

    const description =
      it.item ?? it.name ?? section.title ?? "Inspection item";

    const id = uuidv4();
    const placeholder: QuoteLineItem = {
      id,
      description,
      item: description,
      name: description,
      inspectionItem: description,
      status,
      notes: it.notes ?? "",
      price: 0,
      laborHours: 0.5,
      laborRate: 0,
      editable: true,
      source: "inspection",
      value: it.value ?? null,
      photoUrls: it.photoUrls ?? [],
      aiState: "loading",
    };

    pushQuoteLine(placeholder);

    try {
      const tId = toast.loading("Getting AI estimate…");

      const suggestion = await requestQuoteSuggestion({
        item: description,
        notes: it.notes ?? "",
        section: section.title,
        status,
        value: it.value != null ? String(it.value) : undefined,
        unit: it.unit ?? undefined,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available.", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborHours = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborHours);

      updateQuoteLine(id, {
        price,
        laborHours,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      let jobId: string | undefined;

      // Create a work-order line if we know the work order id
      if (workOrderId) {
        const res = await addWorkOrderLineFromSuggestion({
          workOrderId,
          description,
          section: section.title,
          status,
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });

        jobId = res.id;
      }

      // Also send a parts request if we have both work order + job id
      if (workOrderId && jobId && suggestion.parts?.length) {
        try {
          const items = suggestion.parts.map((p) => ({
            description: p.name || "Part",
            qty: p.qty && p.qty > 0 ? p.qty : 1,
          }));

          const res = await fetch("/api/parts/requests/create", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              workOrderId,
              jobId,
              notes: suggestion.summary || undefined,
              items,
            }),
          });

          const raw = await res.text();
          let json: { requestId?: string; error?: string } | null = null;
          try {
            json = raw ? (JSON.parse(raw) as any) : null;
          } catch {
            /* ignore parse error; fall through */
          }

          if (!res.ok || !json?.requestId) {
            const msg = json?.error || raw || `status ${res.status}`;
            console.warn("Parts request failed:", msg);
          }
        } catch (err) {
          console.warn("Parts request error:", err);
        }
      }

      toast.success("Estimate generated.", { id: tId });
    } catch (err) {
      console.error("AI quote error:", err);
      updateQuoteLine(id, { aiState: "error" });
      toast.error("Couldn't generate estimate.");
    } finally {
      inflightRef.current.delete(key);
    }
  };

  const buildQuotesForAll = async () => {
    if (!session.sections?.length) return;
    if (buildingQuote) return;

    setBuildingQuote(true);

    try {
      for (let sIdx = 0; sIdx < session.sections.length; sIdx += 1) {
        const sec = session.sections[sIdx];
        for (let iIdx = 0; iIdx < (sec.items?.length ?? 0); iIdx += 1) {
          const it = sec.items[iIdx];
          const status = String(it.status ?? "").toLowerCase();
          if (
            (status === "fail" || status === "recommend") &&
            (it.notes ?? "").trim().length > 0
          ) {
            // eslint-disable-next-line no-await-in-loop
            await buildQuoteForItem(sIdx, iIdx);
          }
        }
      }
    } finally {
      setBuildingQuote(false);
    }
  };

  // --------------------------------------------------------------------------

  const hasSections = (session.sections?.length ?? 0) > 0;

  return (
    <div className="flex flex-col gap-4">
      {/* Header */}
      <div className="flex flex-col gap-1 border-b border-white/10 pb-3">
        <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
          Unified Inspection
        </div>
        <div className="flex flex-wrap items-baseline justify-between gap-2">
          <h1 className="text-xl font-blackops text-white">
            {session.templateName || session.templateitem || "Inspection"}
          </h1>
          {hasSections && (
            <div className="text-xs text-neutral-400">
              {completed}/{total} items marked
            </div>
          )}
        </div>
        <div className="flex flex-wrap items-center gap-2 text-[11px] text-neutral-500">
          <span>
            Work order:{" "}
            <span className="font-mono text-neutral-300">
              {session.workOrderId || "—"}
            </span>
          </span>
          <span className="mx-1 text-neutral-600">•</span>
          <button
            type="button"
            className="rounded-full border border-white/15 bg-black/60 px-2 py-0.5 text-[10px] uppercase tracking-[0.16em] text-neutral-200 hover:border-orange-400 hover:text-orange-300"
            onClick={() =>
              setUnitMode((m) => (m === "metric" ? "imperial" : "metric"))
            }
          >
            Units:{" "}
            {unitMode === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
          </button>
        </div>
      </div>

      {/* Voice controller (new unified stack) */}
      <VoiceInspectionController
        session={session}
        onUpdateSession={onUpdateSession}
      />

      {/* Main sections */}
      <SectionRenderer
        sections={session.sections ?? []}
        // minimal contract: SectionRenderer owns layout (corner grids, batteries, etc)
        onUpdateItem={updateSections}
      />

      {/* Footer actions */}
      <div className="mt-4 flex flex-col gap-3 border-t border-white/10 pt-3 text-xs text-neutral-400 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-2">
          <button
            type="button"
            disabled={buildingQuote}
            onClick={buildQuotesForAll}
            className="inline-flex items-center gap-1 rounded-full border border-orange-500/70 bg-orange-500/10 px-3 py-1.5 text-[11px] font-semibold uppercase tracking-[0.18em] text-orange-200 hover:bg-orange-500/20 disabled:opacity-50"
          >
            {buildingQuote ? "Building estimates…" : "Build estimates for FAIL / REC"}
          </button>
          {!workOrderId && (
            <span className="text-[11px] text-red-300">
              Work order id missing – new jobs & parts requests will not be created.
            </span>
          )}
        </div>

        <div className="text-[11px] text-neutral-500 md:text-right">
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable &nbsp;•&nbsp;
          REC = Recommend
        </div>
      </div>
    </div>
  );
}
=============== Voice Inspection Controller ===============
"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import type { InspectionSession } from "@inspections/lib/inspection/types";

import { interpretTranscript } from "./interpretTranscript";
import { applyVoiceCommands } from "./commandMapper";

type Props = {
  session: InspectionSession;
  onUpdateSession: (patch: Partial<InspectionSession>) => void;
};

/**
 * Simple browser SpeechRecognition fallback for now.
 * You already use OpenAI Realtime elsewhere – once you paste me that file,
 * I will replace this stub with the full Hey-Techy Realtime pipeline.
 */
export default function VoiceInspectionController({
  session,
  onUpdateSession,
}: Props) {
  // UI state only — must be "used"
  const [isListening, setIsListening] = useState<boolean>(false);

  const recognitionRef = useRef<SpeechRecognition | null>(null);

  /** Create SpeechRecognition instance */
  const initRecognition = useCallback(() => {
    if (typeof window === "undefined") return null;

    const SpeechRecognition =
      (window as any).SpeechRecognition ||
      (window as any).webkitSpeechRecognition;

    if (!SpeechRecognition) {
      console.warn("Browser speech recognition unsupported");
      return null;
    }

    const recog = new SpeechRecognition();
    recog.lang = "en-US";
    recog.interimResults = true;
    recog.continuous = false;

    return recog;
  }, []);

  /** Start listening */
  const startListening = useCallback(() => {
    const recog = recognitionRef.current ?? initRecognition();
    if (!recog) return;

    recognitionRef.current = recog;
    setIsListening(true);

    recog.onresult = async (event: SpeechRecognitionEvent) => {
      let finalText = "";

      for (let i = 0; i < event.results.length; i++) {
        const res = event.results[i];
        if (res.isFinal) finalText += res[0].transcript;
      }

      // Only send final text into command mapper
      if (finalText.trim().length > 0) {
        const cmds = await interpretTranscript(finalText.trim());
        applyVoiceCommands(cmds, session, onUpdateSession);
      }
    };

    recog.onerror = () => {
      setIsListening(false);
    };

    recog.onend = () => {
      setIsListening(false);
    };

    recog.start();
  }, [initRecognition, onUpdateSession, session]);

  /** Stop listening */
  const stopListening = useCallback(() => {
    const recog = recognitionRef.current;
    if (recog) recog.stop();
    setIsListening(false);
  }, []);

  /** “Hey Techy” wake-word keyword */
  useEffect(() => {
    if (typeof window === "undefined") return;

    let wakeActive = true;
    const wakePhrase = "hey techy"; // lower-case match

    const handleWake = (e: SpeechRecognitionEvent) => {
      let text = "";
      for (let i = 0; i < e.results.length; i++) {
        const r = e.results[i];
        if (r.isFinal) text += r[0].transcript.toLowerCase();
      }
      if (text.includes(wakePhrase)) {
        startListening();
      }
    };

    const SpeechRecognition =
      (window as any).SpeechRecognition ||
      (window as any).webkitSpeechRecognition;

    if (!SpeechRecognition) return;

    const wake = new SpeechRecognition();
    wake.lang = "en-US";
    wake.interimResults = false;
    wake.continuous = true;

    wake.onresult = handleWake;
    wake.onerror = () => {};
    wake.onend = () => {
      if (wakeActive) wake.start();
    };

    wake.start();

    return () => {
      wakeActive = false;
      wake.stop();
    };
  }, [startListening]);

  return (
    <div className="mt-2 flex items-center gap-2 text-xs text-neutral-300">
      <button
        type="button"
        onClick={isListening ? stopListening : startListening}
        className="rounded bg-neutral-800 px-3 py-1 text-xs text-white"
      >
        {isListening ? "Stop listening" : "Start voice"}
      </button>

      <span className={isListening ? "text-green-400" : "text-neutral-500"}>
        {isListening ? "Listening…" : "Idle"}
      </span>
    </div>
  );
}
=============== Unified Inspection Hook (if exists) ===============
"use client";

import { useState } from "react";
import type { InspectionSession } from "@inspections/lib/inspection/types";

export default function useUnifiedInspection(initial: InspectionSession) {
  const [session, setSession] = useState<InspectionSession>(initial);

  const updateSession = (patch: Partial<InspectionSession>) =>
    setSession((prev) => ({ ...prev, ...patch }));

  return {
    session,
    updateSession,
  };
}

=============== Types ===============
/** ---------- Item / Section ---------- */
export type InspectionItemStatus = "ok" | "fail" | "na" | "recommend";
export type BrakeType = "air" | "hydraulic";

/** Duty class for inspections (light/medium/heavy) */
export type DutyClass = "light" | "medium" | "heavy";

export interface InspectionItem {
  /** Primary label. Some code uses `item`, some uses `name` — support both. */
  item?: string;
  name?: string;

  status?: InspectionItemStatus;
  notes?: string;
  /** Some AI/normalizers use singular `note`. */
  note?: string;

  value?: string | number | null;
  unit?: string | null;

  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionCategory {
  title: string;
  items: InspectionItem[];
}

/** Many places import `InspectionSection`; keep it as an alias. */
export type InspectionSection = InspectionCategory;

/** Template definition used by unified inspection builder / loader */
export interface InspectionTemplate {
  id: string;
  templateName: string;

  description?: string | null;
  tags?: string[] | null;
  vehicleType?: string | null;

  /** Whether this template is shared/public in the shop/library */
  isPublic?: boolean | null;

  /** Optional default labor hours for the template */
  laborHours?: number | null;

  /** Rendered sections (mirrors inspection_templates.sections JSON) */
  sections: InspectionSection[];

  /** Optional audit fields (mapped from DB created_at/updated_at) */
  createdAt?: string | null;
  updatedAt?: string | null;
}

/** ---------- Parsed voice/AI commands (support both shapes) ---------- */
/** Older, name-based command shape used by dispatchCommand/interpreter */
export type ParsedCommandNameBased =
  | { type: "status"; section: string; item: string; status: InspectionItemStatus }
  | { type: "add"; section: string; item: string; note: string }
  | { type: "recommend"; section: string; item: string; note: string }
  | {
      type: "measurement";
      section: string;
      item: string;
      value: number | string;
      unit?: string;
    };

/** Newer, index-based command shape used by convertParsedCommands.ts */
export type ParsedCommandIndexed = {
  command:
    | "update_status"
    | "update_value"
    | "add_note"
    | "recommend"
    | "complete_item"
    | "skip_item"
    | "pause_inspection"
    | "finish_inspection";
  sectionIndex?: number;
  itemIndex?: number;
  status?: InspectionItemStatus;
  value?: string | number;
  unit?: string;
  notes?: string;
  recommend?: string;
};

/** Unified ParsedCommand covering both shapes */
export type ParsedCommand = ParsedCommandNameBased | ParsedCommandIndexed;

/**
 * Commands consumed by dispatchCommand (older name-based shape),
 * plus a simple "pause" variant used in a few places.
 */
export type InspectionCommand =
  | ParsedCommandNameBased
  | { type: "pause"; section?: string; item?: string };

/** ---------- Runtime command objects (AI → actions) ---------- */
export type Command =
  | {
      type: "update_status";
      sectionIndex: number;
      itemIndex: number;
      status: InspectionItemStatus;
    }
  | {
      type: "update_value";
      sectionIndex: number;
      itemIndex: number;
      value: string | number;
      unit?: string;
    }
  | {
      type: "add_note";
      sectionIndex: number;
      itemIndex: number;
      notes: string;
    }
  | {
      type: "recommend";
      sectionIndex: number;
      itemIndex: number;
      recommendation: string;
    }
  | {
      type: "complete";
      sectionIndex: number;
      itemIndex: number;
    }
  | {
      type: "skip";
      sectionIndex: number;
      itemIndex: number;
    }
  | { type: "pause" }
  | { type: "finish" };

/** ---------- Quote shapes ---------- */
/** Rich source descriptor for where a line came from. */
export type QuoteSource = "inspection" | "manual" | string;

/**
 * Lightweight line produced by AI generators / costing flows.
 * Extended to include fields your costing + menu matching code writes.
 */
export interface QuoteLine {
  /** Core */
  description: string;

  /** IDs / provenance */
  id?: string;
  source?: QuoteSource;

  /** Names used across flows */
  item?: string;             // selected service/menu name
  name?: string;             // occasional alias
  inspectionItem?: string;   // originating inspection item text

  /** Status / notes */
  status?: InspectionItemStatus;
  notes?: string;

  /** Time & rates */
  hours?: number;
  rate?: number;
  total?: number;
  laborHours?: number | null;
  laborTime?: number;        // alias used on some screens
  laborRate?: number;

  /** Parts */
  parts?: Array<{ name?: string; number?: string; price?: number; type?: string }>;
  partNumber?: string | null;
  partName?: string;
  unitPrice?: number | null;

  /** Roll-up / pricing */
  qty?: number;
  price?: number;            // some code writes final line price here
  totalCost?: number;
}

/** Detailed line used by PDF/store. */
export interface QuoteLineItem {
  id: string;

  /** Some places map description into both `item` and `name`. */
  item?: string;
  name?: string;
  description: string;

  status: InspectionItemStatus;
  notes?: string;

  /** Unified commercial fields */
  price: number; // line price/total
  laborHours?: number;
  /** Additional variants used in some flows */
  laborTime?: number; // alias used on some pages
  laborRate?: number;

  /** Item-level measurement value (rare) */
  value?: string | number | null;

  /** Parts can be object or split fields */
  part?: { name: string; price: number };
  partName?: string;
  partPrice?: number | null;

  /** Old-style fields occasionally present */
  qty?: number;
  unitPrice?: number | null;

  /** Misc UI helpers */
  photoUrls?: string[];
  editable?: boolean;
  source?: QuoteSource;

  /** Collections used by some UIs */
  parts?: Array<{ name?: string; number?: string; price?: number }>;
  totalCost?: number;

  /** Optional back-reference to the inspection item */
  inspectionItem?: string;

  /** Optional AI suggestion metadata */
  ai?: {
    summary: string;
    confidence?: string;
    parts?: { name: string; qty?: number; cost?: number; notes?: string }[];
  };

  /** UI-only: track AI enrichment progress for this line */
  aiState?: "idle" | "loading" | "done" | "error";
}

/** ---------- Inspection Summary ---------- */
export interface SummaryItem {
  section: string;
  item: string;
  status: InspectionItemStatus;
  note?: string;
  value?: string | number | null;
  unit?: string | null;
  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionSummary {
  templateName?: string | null;
  date: string;
  items: SummaryItem[];
  summaryText: string;
}

/** ---------- Session (customer/vehicle) ---------- */
export interface SessionCustomer {
  first_name: string | null;
  last_name: string | null;
  phone: string | null;
  email: string | null;
  address: string | null;
  city: string | null;
  province: string | null;
  postal_code: string | null;
}

export interface SessionVehicle {
  year: string | null;
  make: string | null;
  model: string | null;
  vin: string | null;
  license_plate: string | null;
  mileage: string | null;
  color: string | null;
  /** Added for your form */
  unit_number?: string | null;
  engine_hours?: string | null;
}

/** ---------- Session status ---------- */
export type InspectionStatus = "not_started" | "in_progress" | "paused" | "completed";

/** ---------- Full session ---------- */
export interface InspectionSession {
  id?: string;

  /** Links to other records */
  customerId?: string | null;
  vehicleId?: string | null;
  workOrderId?: string | null;

  /** Template meta */
  templateId?: string | null;
  templateName?: string | null;
  /** Legacy alias still used by some pages */
  templateitem?: string | null;

  /** Selected brake system for rendering/units */
  brakeType?: BrakeType;

  /** Optional duty class for this inspection (light/medium/heavy) */
  dutyClass?: DutyClass | null;

  location?: string | null;

  /** Progress */
  currentSectionIndex: number;
  currentItemIndex: number;

  /** Voice */
  transcript?: string;
  isListening: boolean;

  /** Lifecycle */
  status: InspectionStatus;
  started: boolean;
  completed: boolean;
  isPaused: boolean;

  /** Audit */
  lastUpdated?: string;

  /** Entities */
  customer?: SessionCustomer | null;
  vehicle?: SessionVehicle | null;

  /** Content */
  sections: InspectionSection[];

  /** Quotes can be DB-sourced or UI-generated — accept both */
  quote?: Array<QuoteLine | QuoteLineItem>;

  /**
   * Optional runtime-only metadata.
   * Unified flows can stash arbitrary info here (e.g. source, duty class, debug flags).
   */
  meta?: {
    dutyClass?: DutyClass | null;
    source?: string;
    [key: string]: unknown;
  };
}