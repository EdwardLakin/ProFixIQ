===== FILE: ./debug/inspection_bundle.txt =====
// shared/components/ui/CornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  unitHint?: (label: string) => string;
};

type CornerKey = "LF" | "RF" | "LR" | "RR";
type Side = "Left" | "Right";
type Region = "Front" | "Rear";

const cornerToRegion: Record<CornerKey, { side: Side; region: Region }> = {
  LF: { side: "Left", region: "Front" },
  RF: { side: "Right", region: "Front" },
  LR: { side: "Left", region: "Rear" },
  RR: { side: "Right", region: "Rear" },
};

const abbrevRE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const fullRE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

const metricOrder = [
  "Tire Pressure",
  "Tire Tread",
  "Brake Pad",
  "Rotor",
  "Rotor Condition",
  "Rotor Thickness",
  "Wheel Torque",
];
const orderIndex = (m: string) => {
  const i = metricOrder.findIndex((x) =>
    m.toLowerCase().includes(x.toLowerCase()),
  );
  return i === -1 ? Number.MAX_SAFE_INTEGER : i;
};

export default function CornerGrid({ sectionIndex, items, unitHint }: Props) {
  const { updateItem } = useInspectionForm();

  const parseCorner = (
    label: string,
  ): { corner: CornerKey | null; metric: string } => {
    let corner: CornerKey | null = null;
    let metric = "";

    const m1 = label.match(abbrevRE);
    if (m1?.groups) {
      corner = (m1.groups.corner.toUpperCase() as CornerKey) || null;
      metric = m1.groups.metric.trim();
      return { corner, metric };
    }

    const m2 = label.match(fullRE);
    if (m2?.groups) {
      const c = m2.groups.corner.toLowerCase();
      if (c === "left front") corner = "LF";
      if (c === "right front") corner = "RF";
      if (c === "left rear") corner = "LR";
      if (c === "right rear") corner = "RR";
      metric = m2.groups.metric.trim();
      return { corner, metric };
    }

    return { corner: null, metric: "" };
  };

  type MetricCell = {
    idx: number;
    metric: string;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };

  type RowTriplet = { metric: string; left?: MetricCell; right?: MetricCell };

  const groups = useMemo(() => {
    const byRegion = new Map<Region, Map<string, RowTriplet>>();
    const ensureRegion = (r: Region) =>
      byRegion.get(r) ?? byRegion.set(r, new Map()).get(r)!;

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const { corner, metric } = parseCorner(label);
      if (!corner) return;

      const { side, region } = cornerToRegion[corner];
      const reg = ensureRegion(region);

      const key = metric.toLowerCase();
      if (!reg.has(key)) reg.set(key, { metric });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: MetricCell = {
        idx,
        metric,
        unit,
        fullLabel: label,
        isPressure: /pressure/i.test(metric),
        initial: String(it.value ?? ""),
      };

      const row = reg.get(key)!;
      if (side === "Left") row.left = cell;
      else row.right = cell;
    });

    const sorted: Array<{ region: Region; rows: RowTriplet[] }> = [];
    (["Front", "Rear"] as Region[]).forEach((region) => {
      const reg = byRegion.get(region);
      if (!reg) return;
      const rows = Array.from(reg.values()).sort(
        (a, b) => orderIndex(a.metric) - orderIndex(b.metric),
      );
      sorted.push({ region, rows });
    });

    return sorted;
  }, [items, unitHint]);

  const [open, setOpen] = useState(true);
  const [showKpaHint, setShowKpaHint] = useState(true);

  const [, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });

  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    const has = value.trim().length > 0;
    setFilledMap((p) => (p[idx] === has ? p : { ...p, [idx]: has }));
  };

  const kpaFromPsi = (psiStr: string) => {
    const n = Number(psiStr);
    return isFinite(n) ? Math.round(n * 6.894757) : null;
  };

  const InputCell = ({
    idx,
    defaultValue,
    isPressure,
    unit,
  }: {
    idx: number;
    defaultValue: string;
    isPressure: boolean;
    unit: string;
  }) => {
    const kpaRef = useRef<HTMLSpanElement | null>(null);

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressure || !kpaRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpaHint) {
        kpaRef.current.textContent = "psi";
      } else if (k != null) {
        kpaRef.current.textContent = `psi (${k} kPa)`;
      } else {
        kpaRef.current.textContent = "psi (— kPa)";
      }
    };

    // seed text
    const seed = () => {
      if (!isPressure) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpaHint) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          name={`hyd-${idx}`}
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          autoCorrect="off"
          autoCapitalize="off"
          spellCheck={false}
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) => {
            if (e.key === "Enter") (e.currentTarget as HTMLInputElement).blur();
          }}
        />
        <span
          ref={kpaRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-[11px] text-neutral-400"
        >
          {seed()}
        </span>
      </div>
    );
  };

  const RegionCard = ({
    region,
    rows,
  }: {
    region: Region;
    rows: RowTriplet[];
  }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {region}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${region}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputCell
                    idx={row.left.idx}
                    defaultValue={row.left.initial}
                    isPressure={row.left.isPressure}
                    unit={row.left.unit}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputCell
                    idx={row.right.idx}
                    defaultValue={row.right.initial}
                    isPressure={row.right.isPressure}
                    unit={row.right.unit}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-end gap-3 px-1">
        <label className="flex items-center gap-2 select-none text-xs text-neutral-400">
          <input
            type="checkbox"
            className="h-3 w-3 accent-orange-500"
            checked={showKpaHint}
            onChange={(e) => setShowKpaHint(e.target.checked)}
            tabIndex={-1}
          />
          kPa hint
        </label>

        <button
          onClick={() => setOpen((v) => !v)}
          className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
          aria-expanded={open}
          title={open ? "Collapse" : "Expand"}
          tabIndex={-1}
        >
          {open ? "Collapse" : "Expand"}
        </button>
      </div>

      <div className="grid gap-4">
        {groups.map((g) => (
          <RegionCard key={g.region} region={g.region} rows={g.rows} />
        ))}
      </div>
    </div>
  );
}// shared/components/ui/AirCornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  unitHint?: (label: string) => string;
  onAddAxle?: (axleLabel: string) => void;
};

export default function AirCornerGrid({
  sectionIndex,
  items,
  unitHint,
  onAddAxle,
}: Props) {
  const { updateItem } = useInspectionForm();

  type Side = "Left" | "Right";
  const labelRe = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;

  type MetricCell = {
    metric: string;
    idx: number;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type AxleGroup = { axle: string; left: MetricCell[]; right: MetricCell[] };

  const airPriority = (metric: string): [number, number] => {
    const m = metric.toLowerCase();
    if (/tire\s*pressure/i.test(m)) {
      const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
      return [0, second];
    }
    if (/(tire\s*)?tread\s*depth|tire\s*tread/i.test(m)) {
      const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
      return [1, second];
    }
    if (/(lining|shoe|pad)/i.test(m)) return [2, 0];
    if (/(drum|rotor)/i.test(m)) return [3, 0];
    if (/push\s*rod/i.test(m)) return [4, 0];
    if (/wheel\s*torque/i.test(m)) return [5, /inner/i.test(m) ? 1 : 0];
    return [99, 0];
  };
  const orderCompare = (a: string, b: string) => {
    const [pa, sa] = airPriority(a);
    const [pb, sb] = airPriority(b);
    return pa !== pb ? pa - pb : sa - sb;
  };

  const isDualAxle = (axleLabel: string) => {
    const a = axleLabel.toLowerCase();
    if (a.startsWith("drive") || a.startsWith("trailer") || a.includes("rear"))
      return true;
    if (a.startsWith("tag") || a.startsWith("steer")) return false;
    return false;
  };

  const isDualizableMetric = (metric: string) =>
    /tire\s*pressure/i.test(metric) ||
    /(tire\s*)?tread\s*depth|tire\s*tread/i.test(metric);
  const hasInnerOuter = (metric: string) => /(inner|outer)/i.test(metric);

  function expandDuals(axle: string, cells: MetricCell[]): MetricCell[] {
    if (!isDualAxle(axle)) return cells;

    const out: MetricCell[] = [];
    for (const c of cells) {
      if (isDualizableMetric(c.metric) && !hasInnerOuter(c.metric)) {
        const base = c.metric.replace(/\s*\((inner|outer)\)\s*/i, "").trim();
        out.push({ ...c, metric: `${base} (Outer)` });
        out.push({ ...c, metric: `${base} (Inner)` });
      } else {
        out.push(c);
      }
    }
    return out;
  }

  const groups: AxleGroup[] = useMemo(() => {
    const byAxle = new Map<string, { Left: MetricCell[]; Right: MetricCell[] }>();

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const m = label.match(labelRe);
      if (!m?.groups) return;

      const axle = m.groups.axle.trim();
      const side = (m.groups.side as Side) || "Left";
      const metric = m.groups.metric.trim();

      if (!byAxle.has(axle)) byAxle.set(axle, { Left: [], Right: [] });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: MetricCell = {
        metric,
        idx,
        unit,
        fullLabel: label,
        isPressure: /pressure/i.test(metric),
        initial: String(it.value ?? ""),
      };

      byAxle.get(axle)![side].push(cell);
    });

    return Array.from(byAxle.entries()).map(([axle, sides]) => {
      const left = expandDuals(axle, sides.Left).sort((a, b) =>
        orderCompare(a.metric, b.metric),
      );
      const right = expandDuals(axle, sides.Right).sort((a, b) =>
        orderCompare(a.metric, b.metric),
      );
      return { axle, left, right };
    });
  }, [items, unitHint]);

  const [open, setOpen] = useState(true);
  const [showKpa, setShowKpa] = useState(true);

  const [filledMap, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });
  const count = (cells: MetricCell[]) =>
    cells.reduce((a, r) => a + (filledMap[r.idx] ? 1 : 0), 0);

  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    const has = value.trim().length > 0;
    setFilledMap((p) => (p[idx] === has ? p : { ...p, [idx]: has }));
  };

  const kpaFromPsi = (psiStr: string) => {
    const n = Number(psiStr);
    return isFinite(n) ? Math.round(n * 6.894757) : null;
  };

  type RowTriplet = { metric: string; left?: MetricCell; right?: MetricCell };

  const buildTriplets = (g: AxleGroup): RowTriplet[] => {
    const map = new Map<string, RowTriplet>();
    const add = (c: MetricCell, which: "left" | "right") => {
      const k = c.metric.toLowerCase();
      const existing = map.get(k) || { metric: c.metric };
      map.set(k, { ...existing, metric: c.metric, [which]: c });
    };
    g.left.forEach((c) => add(c, "left"));
    g.right.forEach((c) => add(c, "right"));
    return Array.from(map.values()).sort((a, b) =>
      orderCompare(a.metric, b.metric),
    );
  };

  const InputWithInlineUnit = ({
    idx,
    isPressure,
    unit,
    defaultValue,
    showKpaHint,
  }: {
    idx: number;
    isPressure: boolean;
    unit: string;
    defaultValue: string;
    showKpaHint: boolean;
  }) => {
    const spanRef = useRef<HTMLSpanElement | null>(null);

    const kSeed = () => {
      if (!isPressure) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpaHint) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressure || !spanRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpaHint) {
        spanRef.current.textContent = "psi";
      } else if (k != null) {
        spanRef.current.textContent = `psi (${k} kPa)`;
      } else {
        spanRef.current.textContent = "psi (— kPa)";
      }
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          name={`air-${idx}`}
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) =>
            e.key === "Enter" &&
            (e.currentTarget as HTMLInputElement).blur()
          }
        />
        <span
          ref={spanRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 whitespace-nowrap text-[11px] text-neutral-400"
        >
          {kSeed()}
        </span>
      </div>
    );
  };

  const AxleCard = ({ g }: { g: AxleGroup }) => {
    const rows = buildTriplets(g);
    return (
      <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
        <div
          className="mb-3 text-lg font-semibold text-accent"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
        >
          {g.axle}
        </div>

        <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
          <div>Left</div>
          <div className="text-center">Item</div>
          <div className="text-right">Right</div>
        </div>

        {open && (
          <div className="space-y-3">
            {rows.map((row, i) => {
              const leftUnit =
                row.left?.unit ??
                (unitHint ? unitHint(row.left?.fullLabel ?? "") : "") ??
                "";
              const rightUnit =
                row.right?.unit ??
                (unitHint ? unitHint(row.right?.fullLabel ?? "") : "") ??
                "";
              return (
                <div
                  key={`${row.metric}-${i}`}
                  className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
                >
                  <div>
                    {row.left ? (
                      <InputWithInlineUnit
                        idx={row.left.idx}
                        isPressure={row.left.isPressure}
                        unit={leftUnit}
                        defaultValue={row.left.initial}
                        showKpaHint={showKpa}
                      />
                    ) : (
                      <div className="h-[34px]" />
                    )}
                  </div>

                  <div
                    className="min-w-0 truncate text-center text-sm font-semibold text-white"
                    style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                    title={row.metric}
                  >
                    {row.metric}
                  </div>

                  <div className="justify-self-end">
                    {row.right ? (
                      <InputWithInlineUnit
                        idx={row.right.idx}
                        isPressure={row.right.isPressure}
                        unit={rightUnit}
                        defaultValue={row.right.initial}
                        showKpaHint={showKpa}
                      />
                    ) : (
                      <div className="h-[34px]" />
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-between gap-3 px-1">
        <div
          className="hidden text-xs text-neutral-400 md:block"
          style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
        >
          {groups.map((g, i) => {
            const filled = count(g.left) + count(g.right);
            const total = g.left.length + g.right.length;
            return (
              <span key={g.axle}>
                {g.axle} {filled}/{total}
                {i < groups.length - 1 ? "  |  " : ""}
              </span>
            );
          })}
        </div>

        <div className="flex items-center gap-3">
          <label className="flex select-none items-center gap-2 text-xs text-neutral-300">
            <input
              type="checkbox"
              className="h-3 w-3 accent-orange-500"
              checked={showKpa}
              onChange={(e) => setShowKpa(e.target.checked)}
              tabIndex={-1}
            />
            kPa hint
          </label>

          <button
            onClick={() => setOpen((v) => !v)}
            className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
            tabIndex={-1}
          >
            {open ? "Collapse" : "Expand"}
          </button>
        </div>
      </div>

      {onAddAxle && <AddAxlePicker groups={groups} onAddAxle={onAddAxle} />}

      {groups.map((g) => (
        <AxleCard key={g.axle} g={g} />
      ))}
    </div>
  );
}

/** Inline axle picker (same, but glassy) */
function AddAxlePicker({
  groups,
  onAddAxle,
}: {
  groups: { axle: string }[];
  onAddAxle: (axleLabel: string) => void;
}) {
  const existing = useMemo(() => groups.map((g) => g.axle), [groups]);
  const [pending, setPending] = useState<string>("");

  const candidates = useMemo(() => {
    const wants: string[] = [];
    for (let i = 1; i <= 2; i++) wants.push(`Steer ${i}`);
    for (let i = 1; i <= 4; i++) wants.push(`Drive ${i}`);
    wants.push("Tag", "Trailer 1", "Trailer 2", "Trailer 3");
    return wants.filter((l) => !existing.includes(l));
  }, [existing]);

  return (
    <div className="flex items-center gap-2 px-1">
      <select
        className="rounded-lg border border-neutral-700 bg-neutral-900/80 px-2 py-1 text-sm text-white"
        value={pending}
        onChange={(e) => setPending(e.target.value)}
      >
        <option value="">Add axle…</option>
        {candidates.map((l) => (
          <option key={l} value={l}>
            {l}
          </option>
        ))}
      </select>
      <button
        className="rounded-lg bg-accent px-3 py-1 text-sm font-semibold text-black hover:bg-orange-500 disabled:opacity-40"
        onClick={() => pending && onAddAxle(pending)}
        disabled={!pending}
      >
        + Add
      </button>
    </div>
  );
}// shared/components/ui/AxlesCornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  /** Optional unit resolver when an item has no unit */
  unitHint?: (label: string) => string;
  /** Only shown (and used) for AIR mode */
  onAddAxle?: (axleLabel: string) => void;
};

/* ---------------------------- shared helpers ---------------------------- */

const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const HYD_FULL_RE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

type Side = "Left" | "Right";
type Region = "Front" | "Rear";
type CornerKey = "LF" | "RF" | "LR" | "RR";

const cornerToRegion: Record<CornerKey, { side: Side; region: Region }> = {
  LF: { side: "Left", region: "Front" },
  RF: { side: "Right", region: "Front" },
  LR: { side: "Left", region: "Rear" },
  RR: { side: "Right", region: "Rear" },
};

const normalizeCorner = (raw: string): CornerKey | null => {
  const s = raw.toLowerCase();
  if (s.startsWith("lf") || s === "left front") return "LF";
  if (s.startsWith("rf") || s === "right front") return "RF";
  if (s.startsWith("lr") || s === "left rear") return "LR";
  if (s.startsWith("rr") || s === "right rear") return "RR";
  return null;
};

const isPressureMetric = (label: string) => /pressure/i.test(label);
const kpaFromPsi = (psiStr: string) => {
  const n = Number(psiStr);
  return isFinite(n) ? Math.round(n * 6.894757) : null;
};

/* --------------------- strict ordering for AIR (matches steer) --------------------- */
const airPriority = (metric: string): [number, number] => {
  const m = metric.toLowerCase();

  if (/tire\s*pressure/i.test(m)) {
    const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
    return [0, second];
  }
  if (/(tire\s*)?tread\s*depth|tire\s*tread/i.test(m)) {
    const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
    return [1, second];
  }
  if (/(lining|shoe|pad)/i.test(m)) return [2, 0];
  if (/(drum|rotor)/i.test(m)) return [3, 0];
  if (/push\s*rod/i.test(m)) return [4, 0];
  if (/wheel\s*torque/i.test(m)) return [5, /inner/i.test(m) ? 1 : 0];
  return [99, 0];
};
const airCompare = (a: string, b: string) => {
  const [pa, sa] = airPriority(a);
  const [pb, sb] = airPriority(b);
  return pa !== pb ? pa - pb : sa - sb;
};

/* ---------------------- ordering for HYD (CornerGrid parity) ---------------------- */
const hydMetricOrder = [
  "Tire Pressure",
  "Tire Tread",
  "Brake Pad",
  "Rotor",
  "Rotor Condition",
  "Rotor Thickness",
  "Wheel Torque",
];
const hydCompare = (a: string, b: string) => {
  const ai = hydMetricOrder.findIndex((x) =>
    a.toLowerCase().includes(x.toLowerCase()),
  );
  const bi = hydMetricOrder.findIndex((x) =>
    b.toLowerCase().includes(x.toLowerCase()),
  );
  const A = ai === -1 ? Number.MAX_SAFE_INTEGER : ai;
  const B = bi === -1 ? Number.MAX_SAFE_INTEGER : bi;
  return A - B;
};

export default function AxlesCornerGrid({
  sectionIndex,
  items,
  unitHint,
  onAddAxle,
}: Props) {
  const { updateItem } = useInspectionForm();

  // Detect mode from the item labels
  const mode: "air" | "hyd" = useMemo(() => {
    for (const it of items) {
      const label = it.item ?? "";
      if (AIR_RE.test(label)) return "air";
      if (HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label)) return "hyd";
    }
    return "hyd"; // safe default
  }, [items]);

  /* ------------------------------------------------------------------ */
  /* HYDRAULIC (LF/RF/LR/RR) — matches CornerGrid layout                */
  /* ------------------------------------------------------------------ */

  type HydCell = {
    idx: number;
    metric: string;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type HydRow = { metric: string; left?: HydCell; right?: HydCell };

  const hydGroups = useMemo(() => {
    if (mode !== "hyd") return [] as Array<{ region: Region; rows: HydRow[] }>;

    const byRegion = new Map<Region, Map<string, HydRow>>();
    const ensureRegion = (r: Region) =>
      byRegion.get(r) ?? byRegion.set(r, new Map()).get(r)!;

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      let ck: CornerKey | null = null;
      let metric = "";

      const m1 = label.match(HYD_ABBR_RE);
      if (m1?.groups) {
        ck = normalizeCorner(m1.groups.corner);
        metric = m1.groups.metric.trim();
      } else {
        const m2 = label.match(HYD_FULL_RE);
        if (m2?.groups) {
          ck = normalizeCorner(m2.groups.corner);
          metric = m2.groups.metric.trim();
        }
      }
      if (!ck) return;

      const { side, region } = cornerToRegion[ck];
      const reg = ensureRegion(region);

      const key = metric.toLowerCase();
      if (!reg.has(key)) reg.set(key, { metric });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: HydCell = {
        idx,
        metric,
        unit,
        fullLabel: label,
        isPressure: isPressureMetric(metric),
        initial: String(it.value ?? ""),
      };

      const row = reg.get(key)!;
      if (side === "Left") row.left = cell;
      else row.right = cell;
    });

    const out: Array<{ region: Region; rows: HydRow[] }> = [];
    (["Front", "Rear"] as Region[]).forEach((region) => {
      const reg = byRegion.get(region);
      if (!reg) return;
      const rows = Array.from(reg.values()).sort((a, b) =>
        hydCompare(a.metric, b.metric),
      );
      out.push({ region, rows });
    });
    return out;
  }, [items, unitHint, mode]);

  /* ------------------------------------------------------------------ */
  /* AIR (Steer / Drive / Trailer … Left | Item | Right)                */
  /* ------------------------------------------------------------------ */

  type AirCell = {
    metric: string;
    idx: number;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type AirGroup = { axle: string; left: AirCell[]; right: AirCell[] };
  type AirRow = { metric: string; left?: AirCell; right?: AirCell };

  const isDualAxle = (axle: string) => {
    const a = axle.toLowerCase();
    if (a.startsWith("drive") || a.startsWith("trailer") || a.includes("rear"))
      return true;
    if (a.startsWith("tag") || a.startsWith("steer")) return false;
    return false;
  };

  const isDualizable = (metric: string) =>
    /tire\s*pressure/i.test(metric) ||
    /(tire\s*)?tread\s*depth|tire\s*tread/i.test(metric);
  const hasInnerOuter = (m: string) => /(inner|outer)/i.test(m);

  function expandDuals(axle: string, cells: AirCell[]): AirCell[] {
    if (!isDualAxle(axle)) return cells;
    const out: AirCell[] = [];
    for (const c of cells) {
      if (isDualizable(c.metric) && !hasInnerOuter(c.metric)) {
        const base = c.metric.replace(/\s*\((inner|outer)\)\s*/i, "").trim();
        out.push({ ...c, metric: `${base} (Outer)` });
        out.push({ ...c, metric: `${base} (Inner)` });
      } else {
        out.push(c);
      }
    }
    return out;
  }

  const airGroups = useMemo(() => {
    if (mode !== "air") return [] as AirGroup[];

    const byAxle = new Map<string, { Left: AirCell[]; Right: AirCell[] }>();

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const m = label.match(AIR_RE);
      if (!m?.groups) return;

      const axle = m.groups.axle.trim();
      const side = (m.groups.side as Side) || "Left";
      const metric = m.groups.metric.trim();

      if (!byAxle.has(axle)) byAxle.set(axle, { Left: [], Right: [] });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: AirCell = {
        metric,
        idx,
        unit,
        fullLabel: label,
        isPressure: isPressureMetric(metric),
        initial: String(it.value ?? ""),
      };

      byAxle.get(axle)![side].push(cell);
    });

    return Array.from(byAxle.entries()).map(([axle, sides]) => {
      const left = expandDuals(axle, sides.Left).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      const right = expandDuals(axle, sides.Right).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      return { axle, left, right };
    });
  }, [items, unitHint, mode]);

  // build rows for AIR like AirCornerGrid (merge left/right by metric)
  const airRowsPerAxle: Array<{ axle: string; rows: AirRow[] }> = useMemo(() => {
    if (mode !== "air") return [];
    const rows: Array<{ axle: string; rows: AirRow[] }> = [];

    for (const g of airGroups) {
      const map = new Map<string, AirRow>();
      const add = (c: AirCell, which: "left" | "right") => {
        const k = c.metric.toLowerCase();
        const existing = map.get(k) || { metric: c.metric };
        map.set(k, { ...existing, metric: c.metric, [which]: c } as AirRow);
      };
      g.left.forEach((c) => add(c, "left"));
      g.right.forEach((c) => add(c, "right"));
      const merged = Array.from(map.values()).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      rows.push({ axle: g.axle, rows: merged });
    }
    return rows;
  }, [airGroups, mode]);

  /* ---------------------------- UI state ---------------------------- */

  const [open, setOpen] = useState(true);
  const [showKpa, setShowKpa] = useState(true);
  const [filledMap, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });
  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    setFilledMap((p) =>
      p[idx] === !!value.trim() ? p : { ...p, [idx]: !!value.trim() },
    );
  };

  /* ------------------- shared input used by both modes ------------------ */

  const InputWithInlineUnit = ({
    idx,
    isPressureRow,
    unit,
    defaultValue,
  }: {
    idx: number;
    isPressureRow: boolean;
    unit: string;
    defaultValue: string;
  }) => {
    const spanRef = useRef<HTMLSpanElement | null>(null);

    const seedText = () => {
      if (!isPressureRow) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpa) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressureRow || !spanRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpa) {
        spanRef.current.textContent = "psi";
      } else if (k != null) {
        spanRef.current.textContent = `psi (${k} kPa)`;
      } else {
        spanRef.current.textContent = "psi (— kPa)";
      }
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) =>
            e.key === "Enter" &&
            (e.currentTarget as HTMLInputElement).blur()
          }
        />
        <span
          ref={spanRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 whitespace-nowrap text-[11px] text-neutral-400"
        >
          {seedText()}
        </span>
      </div>
    );
  };

  /* ---------------------------- HYD UI ---------------------------- */

  const HydRegionCard = ({ region, rows }: { region: Region; rows: HydRow[] }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {region}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${region}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputWithInlineUnit
                    idx={row.left.idx}
                    isPressureRow={row.left.isPressure}
                    unit={row.left.unit}
                    defaultValue={row.left.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputWithInlineUnit
                    idx={row.right.idx}
                    isPressureRow={row.right.isPressure}
                    unit={row.right.unit}
                    defaultValue={row.right.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  /* ----------------------------- AIR UI ----------------------------- */

  const AirAxleCard = ({ axle, rows }: { axle: string; rows: AirRow[] }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {axle}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${axle}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputWithInlineUnit
                    idx={row.left.idx}
                    isPressureRow={row.left.isPressure}
                    unit={row.left.unit}
                    defaultValue={row.left.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputWithInlineUnit
                    idx={row.right.idx}
                    isPressureRow={row.right.isPressure}
                    unit={row.right.unit}
                    defaultValue={row.right.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  const countFilled = (cells: Array<{ idx: number }>) =>
    cells.reduce((sum, c) => sum + (filledMap[c.idx] ? 1 : 0), 0);

  /* ------------------------------- render ------------------------------ */

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-between gap-3 px-1">
        {/* progress strip for AIR mode */}
        {mode === "air" ? (
          <div
            className="hidden text-xs text-neutral-400 md:block"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {airGroups.map((g, i) => {
              const filled = countFilled(g.left) + countFilled(g.right);
              const total = g.left.length + g.right.length;
              return (
                <span key={g.axle}>
                  {g.axle} {filled}/{total}
                  {i < airGroups.length - 1 ? "  |  " : ""}
                </span>
              );
            })}
          </div>
        ) : (
          <div />
        )}

        <div className="flex items-center gap-3">
          <label className="flex select-none items-center gap-2 text-xs text-neutral-300">
            <input
              type="checkbox"
              className="h-3 w-3 accent-orange-500"
              checked={showKpa}
              onChange={(e) => setShowKpa(e.target.checked)}
              tabIndex={-1}
            />
            kPa hint
          </label>

          <button
            onClick={() => setOpen((v) => !v)}
            className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
            title={open ? "Collapse" : "Expand"}
            tabIndex={-1}
          >
            {open ? "Collapse" : "Expand"}
          </button>
        </div>
      </div>

      {/* inline axle picker only for AIR and when provided */}
      {mode === "air" && onAddAxle && (
        <AddAxlePicker
          existingAxles={airGroups.map((g) => g.axle)}
          onAddAxle={onAddAxle}
        />
      )}

      {mode === "hyd" ? (
        <div className="grid gap-4">
          {hydGroups.map((g) => (
            <HydRegionCard key={g.region} region={g.region} rows={g.rows} />
          ))}
        </div>
      ) : (
        <>
          {airRowsPerAxle.map(({ axle, rows }) => (
            <AirAxleCard key={axle} axle={axle} rows={rows} />
          ))}
        </>
      )}
    </div>
  );
}

/* -------------------------- Add Axle (AIR only) -------------------------- */

function AddAxlePicker({
  existingAxles,
  onAddAxle,
}: {
  existingAxles: string[];
  onAddAxle: (axleLabel: string) => void;
}) {
  const [pending, setPending] = useState<string>("");

  const candidates = useMemo(() => {
    const wants: string[] = [];
    for (let i = 1; i <= 2; i++) wants.push(`Steer ${i}`);
    for (let i = 1; i <= 4; i++) wants.push(`Drive ${i}`);
    wants.push("Tag", "Trailer 1", "Trailer 2", "Trailer 3");
    return wants.filter((l) => !existingAxles.includes(l));
  }, [existingAxles]);

  return (
    <div className="flex items-center gap-2 px-1">
      <select
        className="rounded-lg border border-neutral-700 bg-neutral-900/80 px-2 py-1 text-sm text-white"
        value={pending}
        onChange={(e) => setPending(e.target.value)}
      >
        <option value="">Add axle…</option>
        {candidates.map((l) => (
          <option key={l} value={l}>
            {l}
          </option>
        ))}
      </select>
      <button
        className="rounded-lg bg-accent px-3 py-1 text-sm font-semibold text-black hover:bg-orange-500 disabled:opacity-40"
        onClick={() => pending && onAddAxle(pending)}
        disabled={!pending}
      >
        + Add
      </button>
    </div>
  );
}// shared/components/Section.tsx
"use client";


import { cn } from "@shared/lib/utils";

interface SectionProps {
  children: React.ReactNode;
  className?: string;
  id?: string;
  ariaLabel?: string;
}

export default function Section({
  children,
  className,
  id,
  ariaLabel,
}: SectionProps) {
  return (
    <section
      id={id}
      aria-label={ariaLabel || id || undefined}
      className={cn(
        "w-full py-10 md:py-14 lg:py-20 px-4 sm:px-6",
        "fade-in",
        "bg-transparent",
        className,
      )}
    >
      {children}
    </section>
  );
}"use client";

import { useState, useMemo } from "react";
import {
  InspectionSection,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";
import InspectionItemCard from "./InspectionItemCard";
import { Button } from "@shared/components/ui/Button";

interface SectionDisplayProps {
  title: string;
  section: InspectionSection;
  sectionIndex: number;
  showNotes: boolean;
  showPhotos: boolean;
  onUpdateStatus: (
    sectionIndex: number,
    itemIndex: number,
    status: InspectionItemStatus,
  ) => void;
  onUpdateNote: (
    sectionIndex: number,
    itemIndex: number,
    note: string,
  ) => void;
  onUpload: (
    photoUrl: string,
    sectionIndex: number,
    itemIndex: number,
  ) => void;

  /** require a note and show a Submit button for AI */
  requireNoteForAI?: boolean;
  /** handler to run AI + persist, invoked per item */
  onSubmitAI?: (sectionIndex: number, itemIndex: number) => void;
  /** let parent indicate a submit is in-flight for this item */
  isSubmittingAI?: (sectionIndex: number, itemIndex: number) => boolean;
}

export default function SectionDisplay(props: SectionDisplayProps) {
  const {
    title,
    section,
    sectionIndex,
    showNotes = false,
    showPhotos = true,
    onUpdateStatus,
    onUpdateNote,
    onUpload,
    requireNoteForAI,
    onSubmitAI,
    isSubmittingAI,
  } = props;

  const [open, setOpen] = useState(true);

  const stats = useMemo(() => {
    const total = section.items.length || 0;
    const counts = { ok: 0, fail: 0, na: 0, recommend: 0, unset: 0 };
    for (const it of section.items) {
      const s = (it.status ?? "unset") as keyof typeof counts;
      if (counts[s] !== undefined) counts[s] += 1;
      else counts.unset += 1;
    }
    return { total, ...counts };
  }, [section.items]);

  const markAll = (status: InspectionItemStatus) => {
    section.items.forEach((_item, idx) =>
      onUpdateStatus(sectionIndex, idx, status),
    );
  };

  return (
    <div className="mb-6 rounded-2xl border border-white/8 bg-black/30 px-4 py-3 shadow-card backdrop-blur-md md:px-5 md:py-4">
      {/* Header */}
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-white/5 pb-3">
        {/* Title still toggles open/closed */}
        <button
          onClick={() => setOpen((v) => !v)}
          className="text-left text-lg font-semibold tracking-wide text-orange-400"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
          aria-expanded={open}
        >
          {title}
        </button>

        <div className="flex flex-wrap items-center gap-2">
          <span
            className="hidden text-[11px] uppercase tracking-wide text-neutral-400 md:inline"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {stats.ok} OK · {stats.fail} FAIL · {stats.na} NA ·{" "}
            {stats.recommend} REC · {stats.unset} —
          </span>

          <div className="flex flex-wrap items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("ok")}
              title="Mark all OK"
              type="button"
            >
              All OK
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("fail")}
              title="Mark all FAIL"
              type="button"
            >
              All FAIL
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("na")}
              title="Mark all NA"
              type="button"
            >
              All NA
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("recommend")}
              title="Mark all Recommend"
              type="button"
            >
              All REC
            </Button>

            {/* explicit collapse/expand control */}
            <Button
              variant="ghost"
              size="sm"
              className="ml-1 h-7 px-2 text-[11px]"
              onClick={() => setOpen((v) => !v)}
              aria-expanded={open}
              title={open ? "Collapse section" : "Expand section"}
              type="button"
            >
              {open ? "Collapse" : "Expand"}
            </Button>
          </div>
        </div>
      </div>

      {/* Body */}
      {open && (
        <div className="space-y-3 pt-3">
          {section.items.map((item, itemIndex) => {
            const key =
              (item.item ?? item.name ?? `item-${sectionIndex}-${itemIndex}`) +
              `-${itemIndex}`;

            const status = String(item.status ?? "").toLowerCase();
            const isFailOrRec = status === "fail" || status === "recommend";
            const note = (item.notes ?? "").trim();
            const canShowSubmit =
              !!requireNoteForAI &&
              isFailOrRec &&
              note.length > 0 &&
              typeof onSubmitAI === "function";

            const submitting =
              isSubmittingAI?.(sectionIndex, itemIndex) ?? false;

            return (
              <div
                key={key}
                className="rounded-xl border border-white/5 bg-black/40 p-3 md:p-3.5"
              >
                <InspectionItemCard
                  item={item}
                  sectionIndex={sectionIndex}
                  itemIndex={itemIndex}
                  showNotes={showNotes}
                  showPhotos={showPhotos}
                  onUpdateStatus={onUpdateStatus}
                  onUpdateNote={onUpdateNote}
                  onUpload={onUpload}
                />

                {canShowSubmit && (
                  <div className="mt-3 flex items-center justify-end">
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      className="px-3"
                      disabled={submitting}
                      onClick={() => onSubmitAI!(sectionIndex, itemIndex)}
                    >
                      {submitting ? "Submitting…" : "Submit for estimate"}
                    </Button>
                  </div>
                )}
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}// components/inspection/SectionWrapper.tsx
import { useState } from "react";

interface SectionWrapperProps {
  title: string;
  children: React.ReactNode;
  defaultOpen?: boolean;
}

const SectionWrapper: React.FC<SectionWrapperProps> = ({
  title,
  children,
  defaultOpen = true,
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className="mb-4 rounded-lg bg-black/40 p-4 shadow-md">
      <button
        className="w-full text-left font-black text-lg text-orange-400 mb-2 flex justify-between items-center"
        onClick={() => setIsOpen(!isOpen)}
      >
        <span>{title}</span>
        <span>{isOpen ? "−" : "+"}</span>
      </button>
      {isOpen && <div className="space-y-2">{children}</div>}
    </div>
  );
};

export default SectionWrapper;
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import AxlesCornerGrid from "@inspections/lib/inspection/ui/AxlesCornerGrid";

import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* -------------------------- helpers -------------------------- */

function toHeaderCustomer(c?: SessionCustomer | null) {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}
function toHeaderVehicle(v?: SessionVehicle | null) {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/** Try to give a sensible unit hint for common labels */
function unitHintGeneric(label: string, mode: "metric" | "imperial"): string {
  const l = (label || "").toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad") || l.includes("lining") || l.includes("shoe"))
    return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor") || l.includes("drum")) return mode === "metric" ? "mm" : "in";
  if (l.includes("push rod")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  if (l.includes("leak rate")) return mode === "metric" ? "kPa/min" : "psi/min";
  if (l.includes("gov cut") || l.includes("warning")) return mode === "metric" ? "kPa" : "psi";
  return "";
}

/** Safe reader for sessionStorage JSON */
function readStaged<T>(key: string): T | null {
  try {
    if (typeof window === "undefined") return null;
    const raw = sessionStorage.getItem(key);
    return raw ? (JSON.parse(raw) as T) : null;
  } catch {
    return null;
  }
}

/** Normalize + merge sections (copy name→item; merge same titles; dedupe items) */
function normalizeSections(input: unknown): InspectionSection[] {
  try {
    const arr = Array.isArray(input) ? input : [];
    const byTitle = new Map<string, InspectionSection>();

    for (const s of arr as any[]) {
      const title = String(s?.title ?? "").trim();
      if (!title) continue;

      const itemsRaw = Array.isArray(s?.items) ? s.items : [];
      const items = itemsRaw
        .map((it: any) => {
          const label = String(it?.item ?? it?.name ?? "").trim();
          if (!label) return null;
          return {
            ...it,
            item: label,
            unit: it?.unit ?? null,
          };
        })
        .filter(Boolean);

      if (!byTitle.has(title)) byTitle.set(title, { title, items: [] });
      const bucket = byTitle.get(title)!;
      const seen = new Set((bucket.items ?? []).map((x) => (x.item ?? "").toLowerCase()));
      for (const it of items as any[]) {
        const key = (it.item ?? "").toLowerCase();
        if (!seen.has(key)) {
          bucket.items = [...(bucket.items ?? []), it];
          seen.add(key);
        }
      }
    }

    return Array.from(byTitle.values()).filter((s) => (s.items?.length ?? 0) > 0);
  } catch {
    return [];
  }
}

/* -------- smarter corner-grid detector -------- */

const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const HYD_FULL_RE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

function shouldRenderCornerGrid(
  title: string | undefined,
  items: { item?: string | null }[] = []
): boolean {
  const t = (title || "").toLowerCase();

  if (
    t.includes("corner grid") ||
    t.includes("tires & brakes — truck") ||
    t.includes("tires & brakes — air") ||
    t.includes("axle grid")
  ) {
    return true;
  }

  if (!items || items.length < 4) return false;

  const hasStrongPattern = items.some((it) => {
    const label = it.item ?? "";
    return AIR_RE.test(label) || HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label);
  });

  const measurementKeywords = [
    "tread",
    "pressure",
    "lining",
    "shoe",
    "drum",
    "rotor",
    "push rod",
    "pad",
    "torque",
  ];
  const measurementLikeCount = items.reduce((count, it) => {
    const label = (it.item || "").toLowerCase();
    const isMeasurement = measurementKeywords.some((kw) => label.includes(kw));
    return count + (isMeasurement ? 1 : 0);
  }, 0);

  const enoughMeasurements = measurementLikeCount >= Math.floor(items.length / 2);

  const titleSuggestsMeasurement =
    t.includes("tire") ||
    t.includes("tires") ||
    t.includes("brake") ||
    t.includes("measurement") ||
    t.includes("axle");

  return hasStrongPattern || (titleSuggestsMeasurement && enoughMeasurements);
}

/* -------------------------------------------------------------------- */
/* Component                                                            */
/* -------------------------------------------------------------------- */

export default function GenericInspectionScreen(): JSX.Element {
  const sp = useSearchParams();
  const rootRef = useRef<HTMLDivElement | null>(null);

  // 🔸 only the mobile companion should use voice
  const isMobileView =
    (sp.get("view") || "").toLowerCase() === "mobile";

  // Embed for iframe/modal
  const isEmbed = useMemo(
    () =>
      ["1", "true", "yes"].includes(
        (sp.get("embed") || sp.get("compact") || "").toLowerCase()
      ),
    [sp]
  );

  const workOrderId = sp.get("workOrderId") || null;
  const workOrderLineId = sp.get("workOrderLineId") || "";
  const templateName =
    (typeof window !== "undefined" ? sessionStorage.getItem("inspection:title") : null) ||
    (sp.get("template") || "Inspection");

  const customer: SessionCustomer = {
    first_name: sp.get("first_name") || "",
    last_name: sp.get("last_name") || "",
    phone: sp.get("phone") || "",
    email: sp.get("email") || "",
    address: sp.get("address") || "",
    city: sp.get("city") || "",
    province: sp.get("province") || "",
    postal_code: sp.get("postal_code") || "",
  };
  const vehicle: SessionVehicle = {
    year: sp.get("year") || "",
    make: sp.get("make") || "",
    model: sp.get("model") || "",
    vin: sp.get("vin") || "",
    license_plate: sp.get("license_plate") || "",
    mileage: sp.get("mileage") || "",
    color: sp.get("color") || "",
    unit_number: sp.get("unit_number") || "",
    engine_hours: sp.get("engine_hours") || "",
  };

  const bootSections = useMemo<InspectionSection[]>(() => {
    const staged = readStaged<InspectionSection[]>("inspection:sections");
    if (Array.isArray(staged) && staged.length) return normalizeSections(staged);

    try {
      const legacy =
        typeof window !== "undefined"
          ? sessionStorage.getItem("customInspection:sections")
          : null;
      if (legacy) {
        const parsed = JSON.parse(legacy) as InspectionSection[];
        const norm = normalizeSections(parsed);
        return norm;
      }
    } catch {}

    return [
      {
        title: "General",
        items: [{ item: "Visual walkaround" }, { item: "Record warning lights" }],
      },
    ];
  }, [sp]);

  const inspectionId = useMemo(
    () => sp.get("inspectionId") || uuidv4(),
    [sp]
  );

  // 🔸 try to hydrate from localStorage
  const persistedSession = useMemo(() => {
    if (typeof window === "undefined") return null;
    const raw = localStorage.getItem(`inspection-${inspectionId}`);
    if (!raw) return null;
    try {
      return JSON.parse(raw) as InspectionSession;
    } catch {
      return null;
    }
  }, [inspectionId]);

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState(false);
  const [isPaused, setIsPaused] = useState(false);

  // 🔴 wake-word state
  const [wakeActive, setWakeActive] = useState(false);
  const wakeTimeoutRef = useRef<number | null>(null);

  // openai realtime refs
  const wsRef = useRef<WebSocket | null>(null);
  const mediaRef = useRef<MediaStream | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(persistedSession ?? initialSession);

  // start
  useEffect(() => {
    if (persistedSession) {
      startSession(persistedSession);
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [persistedSession]);
  useEffect(() => {
    if (session && (session.sections?.length ?? 0) === 0) {
      updateInspection({ sections: bootSections });
    }
  }, [session, bootSections, updateInspection]);

  // persist
  useEffect(() => {
    if (!session) return;
    const key = `inspection-${inspectionId}`;
    localStorage.setItem(key, JSON.stringify(session));
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // 🔸 turn final text into inspection commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess = session;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // 🔔 wake-word helper
  function maybeHandleWakeWord(raw: string): string | null {
    const lower = raw.toLowerCase().trim();
    const WAKE_WORDS = ["hey techy", "hey techie", "hey teki", "hey tekky"];

    if (!wakeActive) {
      const hit = WAKE_WORDS.find((w) => lower.startsWith(w));
      if (hit) {
        setWakeActive(true);
        if (wakeTimeoutRef.current) window.clearTimeout(wakeTimeoutRef.current);
        wakeTimeoutRef.current = window.setTimeout(() => {
          setWakeActive(false);
        }, 8000);
        return lower.slice(hit.length).trim();
      }
      return null;
    }

    if (wakeTimeoutRef.current) window.clearTimeout(wakeTimeoutRef.current);
    wakeTimeoutRef.current = window.setTimeout(() => {
      setWakeActive(false);
    }, 8000);

    return raw;
  }

  // 🔊 openai realtime start (used only when mobile buttons are visible)
  const startListening = async (): Promise<void> => {
    if (isListening) return;
    try {
      const res = await fetch("/api/openai/realtime-token");
      const { apiKey } = (await res.json()) as { apiKey: string };
      if (!apiKey) throw new Error("Missing OpenAI key");

      const ws = new WebSocket("wss://api.openai.com/v1/realtime?intent=transcription");
      wsRef.current = ws;

      ws.onopen = async () => {
        ws.send(
          JSON.stringify({
            type: "authorization",
            authorization: `Bearer ${apiKey}`,
          })
        );

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRef.current = stream;

        const mr = new MediaRecorder(stream, { mimeType: "audio/webm" });
        mediaRecorderRef.current = mr;
        mr.ondataavailable = (evt) => {
          if (evt.data.size > 0 && ws.readyState === WebSocket.OPEN) {
            ws.send(evt.data);
          }
        };
        mr.start(250);

        setIsListening(true);
      };

      ws.onmessage = async (evt) => {
        if (typeof evt.data !== "string") return;
        try {
          const msg = JSON.parse(evt.data);
          const text: string =
            msg.text || msg.transcript || msg.output || msg.content || "";
          if (!text) return;

          const maybeText = maybeHandleWakeWord(text);
          if (!maybeText) return;

          const lower = maybeText.toLowerCase();
          if (lower === "stop listening" || lower === "go to sleep") {
            setWakeActive(false);
            return;
          }

          await handleTranscript(maybeText);
        } catch {
          // ignore parse errors
        }
      };

      ws.onerror = (err) => {
        console.error("realtime ws error", err);
        toast.error("Voice connection error");
        stopListening();
      };

      ws.onclose = () => {
        stopListening();
      };
    } catch (e: any) {
      console.error(e);
      toast.error(e?.message || "Unable to start voice");
      stopListening();
    }
  };

  const stopListening = (): void => {
    mediaRecorderRef.current?.stop();
    mediaRecorderRef.current = null;

    mediaRef.current?.getTracks().forEach((t) => t.stop());
    mediaRef.current = null;

    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.close();
    }
    wsRef.current = null;
    setIsListening(false);
    setWakeActive(false);
    if (wakeTimeoutRef.current) {
      window.clearTimeout(wakeTimeoutRef.current);
      wakeTimeoutRef.current = null;
    }
  };

  useEffect(() => {
    return () => {
      stopListening();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // AI submit flow
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? (it as any).name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // 🧹 embed-safe scrubber (for iframe / modal host)
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child as HTMLElement);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  // 🔐 Focus trap so Tab stays inside the inspection when embedded in modal
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      // If focus is already outside the root, jump to first
      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        // Shift+Tab: if we're on first, loop to last
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        // Tab forward: if we're on last, loop to first
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return (
      <div className="p-4 text-sm text-neutral-300">
        Loading inspection…
      </div>
    );
  }

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header card */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Inspection"}
          </div>
        </div>

        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      {/* Controls row */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {/* Voice only in mobile companion */}
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              stopListening();
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              void startListening();
            }}
            recognitionInstance={null}
            onTranscript={handleTranscript}
            setRecognitionRef={(): void => {
              /* noop – using OpenAI now */
            }}
          />
        )}

        {/* Unit toggle stays on both desktop + mobile */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => {
          const itemsWithHints = section.items.map((it) => ({
            ...it,
            unit: it.unit || unitHintGeneric(it.item ?? "", unit),
          }));

          const useGrid = shouldRenderCornerGrid(section.title, itemsWithHints);

          return (
            <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
              <h2 className={sectionTitle}>{section.title}</h2>
              {useGrid && (
                <span className={hint}>
                  {unit === "metric"
                    ? "Enter mm / kPa / N·m"
                    : "Enter in / psi / ft·lb"}
                </span>
              )}

              <div className="mt-4">
                {useGrid ? (
                  <AxlesCornerGrid
                    sectionIndex={sectionIndex}
                    items={itemsWithHints}
                  />
                ) : (
                  <SectionDisplay
                    title=""
                    section={{ ...section, items: itemsWithHints }}
                    sectionIndex={sectionIndex}
                    showNotes
                    showPhotos
                    onUpdateStatus={(
                      secIdx: number,
                      itemIdx: number,
                      status: InspectionItemStatus
                    ) => {
                      updateItem(secIdx, itemIdx, { status });
                    }}
                    onUpdateNote={(secIdx, itemIdx, note) => {
                      updateItem(secIdx, itemIdx, { notes: note });
                    }}
                    onUpload={(photoUrl, secIdx, itemIdx) => {
                      const prev =
                        session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                      updateItem(secIdx, itemIdx, {
                        photoUrls: [...prev, photoUrl],
                      });
                    }}
                    requireNoteForAI
                    onSubmitAI={(secIdx, itemIdx) => {
                      void submitAIForItem(secIdx, itemIdx);
                    }}
                    isSubmittingAI={isSubmittingAI}
                  />
                )}
              </div>
            </div>
          );
        })}
      </InspectionFormCtx.Provider>

      {/* Footer actions */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton session={session} workOrderLineId={workOrderLineId} />
          <FinishInspectionButton session={session} workOrderLineId={workOrderLineId} />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Inspection"}
      description="Run guided inspections, capture notes, and push items into work orders."
    >
      {body}
    </PageShell>
  );
}/** ---------- Item / Section ---------- */
export type InspectionItemStatus = "ok" | "fail" | "na" | "recommend";
export type BrakeType = "air" | "hydraulic";

export interface InspectionItem {
  /** Primary label. Some code uses `item`, some uses `name` — support both. */
  item?: string;
  name?: string;

  status?: InspectionItemStatus;
  notes?: string;
  /** Some AI/normalizers use singular `note`. */
  note?: string;

  value?: string | number | null;
  unit?: string | null;

  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionCategory {
  title: string;
  items: InspectionItem[];
}

/** Many places import `InspectionSection`; keep it as an alias. */
export type InspectionSection = InspectionCategory;

/** ---------- Parsed voice/AI commands (support both shapes) ---------- */
/** Older, name-based command shape used by dispatchCommand/interpreter */
export type ParsedCommandNameBased =
  | { type: "status"; section: string; item: string; status: InspectionItemStatus }
  | { type: "add"; section: string; item: string; note: string }
  | { type: "recommend"; section: string; item: string; note: string }
  | {
      type: "measurement";
      section: string;
      item: string;
      value: number | string;
      unit?: string;
    };

/** Newer, index-based command shape used by convertParsedCommands.ts */
export type ParsedCommandIndexed = {
  command:
    | "update_status"
    | "update_value"
    | "add_note"
    | "recommend"
    | "complete_item"
    | "skip_item"
    | "pause_inspection"
    | "finish_inspection";
  sectionIndex?: number;
  itemIndex?: number;
  status?: InspectionItemStatus;
  value?: string | number;
  unit?: string;
  notes?: string;
  recommend?: string;
};

/** Unified ParsedCommand covering both shapes */
export type ParsedCommand = ParsedCommandNameBased | ParsedCommandIndexed;

/**
 * Commands consumed by dispatchCommand (older name-based shape),
 * plus a simple "pause" variant used in a few places.
 */
export type InspectionCommand =
  | ParsedCommandNameBased
  | { type: "pause"; section?: string; item?: string };

/** ---------- Runtime command objects (AI → actions) ---------- */
export type Command =
  | {
      type: "update_status";
      sectionIndex: number;
      itemIndex: number;
      status: InspectionItemStatus;
    }
  | {
      type: "update_value";
      sectionIndex: number;
      itemIndex: number;
      value: string | number;
      unit?: string;
    }
  | {
      type: "add_note";
      sectionIndex: number;
      itemIndex: number;
      notes: string;
    }
  | {
      type: "recommend";
      sectionIndex: number;
      itemIndex: number;
      recommendation: string;
    }
  | {
      type: "complete";
      sectionIndex: number;
      itemIndex: number;
    }
  | {
      type: "skip";
      sectionIndex: number;
      itemIndex: number;
    }
  | { type: "pause" }
  | { type: "finish" };

/** ---------- Quote shapes ---------- */
/** Rich source descriptor for where a line came from. */
export type QuoteSource = "inspection" | "manual" | string;

/**
 * Lightweight line produced by AI generators / costing flows.
 * Extended to include fields your costing + menu matching code writes.
 */
export interface QuoteLine {
  /** Core */
  description: string;

  /** IDs / provenance */
  id?: string;
  source?: QuoteSource;

  /** Names used across flows */
  item?: string;             // selected service/menu name
  name?: string;             // occasional alias
  inspectionItem?: string;   // originating inspection item text

  /** Status / notes */
  status?: InspectionItemStatus;
  notes?: string;

  /** Time & rates */
  hours?: number;
  rate?: number;
  total?: number;
  laborHours?: number | null;
  laborTime?: number;        // alias used on some screens
  laborRate?: number;

  /** Parts */
  parts?: Array<{ name?: string; number?: string; price?: number; type?: string }>;
  partNumber?: string | null;
  partName?: string;
  unitPrice?: number | null;

  /** Roll-up / pricing */
  qty?: number;
  price?: number;            // some code writes final line price here
  totalCost?: number;
}

/** Detailed line used by PDF/store. */
export interface QuoteLineItem {
  id: string;

  /** Some places map description into both `item` and `name`. */
  item?: string;
  name?: string;
  description: string;

  status: InspectionItemStatus;
  notes?: string;

  /** Unified commercial fields */
  price: number; // line price/total
  laborHours?: number;
  /** Additional variants used in some flows */
  laborTime?: number; // alias used on some pages
  laborRate?: number;

  /** Item-level measurement value (rare) */
  value?: string | number | null;

  /** Parts can be object or split fields */
  part?: { name: string; price: number };
  partName?: string;
  partPrice?: number | null;

  /** Old-style fields occasionally present */
  qty?: number;
  unitPrice?: number | null;

  /** Misc UI helpers */
  photoUrls?: string[];
  editable?: boolean;
  source?: QuoteSource;

  /** Collections used by some UIs */
  parts?: Array<{ name?: string; number?: string; price?: number }>;
  totalCost?: number;

  /** Optional back-reference to the inspection item */
  inspectionItem?: string;

  /** Optional AI suggestion metadata */
  ai?: {
    summary: string;
    confidence?: string;
    parts?: { name: string; qty?: number; cost?: number; notes?: string }[];
  };

  /** UI-only: track AI enrichment progress for this line */
  aiState?: "idle" | "loading" | "done" | "error";
}

/** ---------- Inspection Summary ---------- */
export interface SummaryItem {
  section: string;
  item: string;
  status: InspectionItemStatus;
  note?: string;
  value?: string | number | null;
  unit?: string | null;
  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionSummary {
  templateName?: string | null;
  date: string;
  items: SummaryItem[];
  summaryText: string;
}

/** ---------- Session (customer/vehicle) ---------- */
export interface SessionCustomer {
  first_name: string | null;
  last_name: string | null;
  phone: string | null;
  email: string | null;
  address: string | null;
  city: string | null;
  province: string | null;
  postal_code: string | null;
}

export interface SessionVehicle {
  year: string | null;
  make: string | null;
  model: string | null;
  vin: string | null;
  license_plate: string | null;
  mileage: string | null;
  color: string | null;
  /** Added for your form */
  unit_number?: string | null;
  engine_hours?: string | null;
}

/** ---------- Session status ---------- */
export type InspectionStatus = "not_started" | "in_progress" | "paused" | "completed";

/** ---------- Full session ---------- */
export interface InspectionSession {
  id?: string;

  /** Links to other records */
  customerId?: string | null;
  vehicleId?: string | null;
  workOrderId?: string | null;

  /** Template meta */
  templateId?: string | null;
  templateName?: string | null;
  /** Legacy alias still used by some pages */
  templateitem?: string | null;

  /** Selected brake system for rendering/units */
  brakeType?: BrakeType;

  location?: string | null;

  /** Progress */
  currentSectionIndex: number;
  currentItemIndex: number;

  /** Voice */
  transcript?: string;
  isListening: boolean;

  /** Lifecycle */
  status: InspectionStatus;
  started: boolean;
  completed: boolean;
  isPaused: boolean;

  /** Audit */
  lastUpdated?: string;

  /** Entities */
  customer?: SessionCustomer | null;
  vehicle?: SessionVehicle | null;

  /** Content */
  sections: InspectionCategory[];

  /** Quotes can be DB-sourced or UI-generated — accept both */
  quote?: Array<QuoteLine | QuoteLineItem>;
}"use client";

import { useState } from "react";
import {
  InspectionItem,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,      // ⬅️ use only QuoteLineItem here
  BrakeType,
} from "@inspections/lib/inspection/types";

type AxleLayoutConfig = { axleCount: number; brakeType: BrakeType };

function generateAxleSections({ axleCount, brakeType }: AxleLayoutConfig): InspectionSection[] {
  const sections: InspectionSection[] = [];

  for (let i = 1; i <= axleCount; i++) {
    const title = `Axle ${i}`;
    const items: InspectionItem[] = [
      { item: "Left Tread Depth",  name: "Left Tread Depth",  value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Right Tread Depth", name: "Right Tread Depth", value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Left Tire Pressure",  name: "Left Tire Pressure",  value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Right Tire Pressure", name: "Right Tire Pressure", value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Left Lining Thickness",  name: "Left Lining Thickness",  value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Right Lining Thickness", name: "Right Lining Thickness", value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Wheel Torque", name: "Wheel Torque", value: null, unit: "ft lbs", notes: "", photoUrls: [] },
    ];

    if (brakeType === "air") {
      items.push(
        { item: "Left Push Rod Travel",  name: "Left Push Rod Travel",  value: null, unit: "in", notes: "", photoUrls: [] },
        { item: "Right Push Rod Travel", name: "Right Push Rod Travel", value: null, unit: "in", notes: "", photoUrls: [] },
      );
    }

    sections.push({ title, items });
  }

  return sections;
}

export default function useInspectionSession(initialSession?: Partial<InspectionSession>) {
  const [session, setSession] = useState<InspectionSession>(() => ({
    id: "",
    vehicleId: "",
    customerId: "",
    workOrderId: "",
    templateId: "",
    templateName: "",
    location: "",
    currentSectionIndex: 0,
    currentItemIndex: 0,
    transcript: "",
    status: "not_started",
    started: false,
    completed: false,
    isListening: false,
    isPaused: false,
    quote: [],                                 // ⬅️ QuoteLineItem[]
    lastUpdated: new Date().toISOString(),
    customer: {
      first_name: "",
      last_name: "",
      phone: "",
      email: "",
      address: "",
      city: "",
      province: "",
      postal_code: "",
    },
    vehicle: {
      year: "",
      make: "",
      model: "",
      vin: "",
      license_plate: "",
      mileage: "",
      color: "",
    },
    sections: [],
    ...initialSession,
  }));

  const stamp = () => ({ lastUpdated: new Date().toISOString() });

  const updateInspection = (updates: Partial<InspectionSession>) =>
    setSession(prev => ({ ...prev, ...updates, ...stamp() }));

  const updateSection = (sectionIndex: number, updates: Partial<InspectionSection>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      sections[sectionIndex] = { ...sections[sectionIndex], ...updates };
      return { ...prev, sections, ...stamp() };
    });

  const updateItem = (sectionIndex: number, itemIndex: number, updates: Partial<InspectionItem>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      const items = [...sections[sectionIndex].items];
      items[itemIndex] = { ...items[itemIndex], ...updates };
      sections[sectionIndex] = { ...sections[sectionIndex], items };
      return { ...prev, sections, ...stamp() };
    });

  // ✅ strictly QuoteLineItem (the normalized/store+PDF shape)
  const addQuoteLine = (line: QuoteLineItem) =>
    setSession(prev => ({ ...prev, quote: [...(prev.quote ?? []), line], ...stamp() }));

  const updateQuoteLines = (lines: QuoteLineItem[]) =>
    setSession(prev => ({ ...prev, quote: lines, ...stamp() }));

  // ✅ targeted updater for enriching a single line (AI merge, edits, etc.)
  const updateQuoteLine = (id: string, patch: Partial<QuoteLineItem>) =>
    setSession(prev => ({
      ...prev,
      quote: (prev.quote ?? []).map((l) => (l.id === id ? { ...l, ...patch } : l)),
      ...stamp(),
    }));

  const startSession = (sessionData: Partial<InspectionSession> & { axleConfig?: AxleLayoutConfig }) => {
    const { axleConfig, ...rest } = sessionData;
    const newSections =
      axleConfig?.axleCount && axleConfig?.brakeType
        ? generateAxleSections(axleConfig)
        : sessionData.sections || session.sections;

    setSession(prev => ({
      ...prev,
      ...rest,
      sections: newSections,
      currentSectionIndex: 0,
      currentItemIndex: 0,
      transcript: "",
      started: true,
      completed: false,
      status: "in_progress",
      isPaused: false,
      ...stamp(),
    }));
  };

  const pauseSession  = () => updateInspection({ isPaused: true,  status: "paused" });
  const resumeSession = () => updateInspection({ isPaused: false, status: "in_progress" });
  const finishSession = () => updateInspection({ completed: true, status: "completed", isPaused: false });
  const setIsListening = (value: boolean) => updateInspection({ isListening: value });

  return {
    session,
    updateInspection,
    updateSection,
    updateItem,
    addQuoteLine,
    updateQuoteLines,
    updateQuoteLine,   // ⬅️ expose the targeted updater
    startSession,
    pauseSession,
    resumeSession,
    finishSession,
    setIsListening,
    isPaused: session.isPaused,
  };
}"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { Dialog } from "@headlessui/react";
import InspectionHost from "@/features/inspections/components/inspectionHost";

type Props = {
  open: boolean;
  src: string | null;
  title?: string;
  onClose?: () => void;
};

function paramsToObject(sp: URLSearchParams) {
  const out: Record<string, string> = {};
  sp.forEach((v, k) => (out[k] = v));
  return out;
}

export default function InspectionModal({
  open,
  src,
  title = "Inspection",
  onClose,
}: Props) {
  const [compact, setCompact] = useState(true);
  const scrollRef = useRef<HTMLDivElement | null>(null);

  const derived = useMemo(() => {
    if (!src)
      return { template: null as string | null, params: {}, missingWOLine: false };
    try {
      const base =
        typeof window !== "undefined" ? window.location.origin : "http://localhost";
      const url = new URL(src, base);
      const parts = url.pathname.split("/").filter(Boolean);
      const idx = parts.findIndex((p) => p === "inspection" || p === "inspections");
      const template = idx >= 0 ? parts[idx + 1] : parts[parts.length - 1];
      const params = paramsToObject(url.searchParams);
      const missingWOLine = !url.searchParams.get("workOrderLineId");
      return { template, params, missingWOLine };
    } catch {
      return { template: src.replace(/^\//, ""), params: {}, missingWOLine: false };
    }
  }, [src]);

  const close = () => {
    onClose?.();
    if (typeof window !== "undefined") {
      window.dispatchEvent(new CustomEvent("inspection:close"));
    }
  };

  // 💡 wheel/touch guard: keep scroll inside THIS box
  useEffect(() => {
    if (!open) return;
    const el = scrollRef.current;
    if (!el) return;

    const onWheel = (e: WheelEvent) => {
      const target = el;
      const { scrollTop, scrollHeight, clientHeight } = target;
      const atTop = scrollTop <= 0;
      const atBottom = scrollTop + clientHeight >= scrollHeight - 1;

      if (e.deltaY > 0 && atBottom) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      if (e.deltaY < 0 && atTop) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    };

    let lastY = 0;
    const onTouchStart = (e: TouchEvent) => {
      lastY = e.touches[0]?.clientY ?? 0;
    };
    const onTouchMove = (e: TouchEvent) => {
      const target = el;
      const { scrollTop, scrollHeight, clientHeight } = target;
      const atTop = scrollTop <= 0;
      const atBottom = scrollTop + clientHeight >= scrollHeight - 1;
      const currentY = e.touches[0]?.clientY ?? 0;
      const goingDown = lastY > currentY;
      const goingUp = lastY < currentY;
      lastY = currentY;

      if ((goingDown && atBottom) || (goingUp && atTop)) {
        e.preventDefault();
        e.stopPropagation();
      }
    };

    el.addEventListener("wheel", onWheel, { passive: false });
    el.addEventListener("touchstart", onTouchStart, { passive: true });
    el.addEventListener("touchmove", onTouchMove, { passive: false });

    return () => {
      el.removeEventListener("wheel", onWheel);
      el.removeEventListener("touchstart", onTouchStart);
      el.removeEventListener("touchmove", onTouchMove);
    };
  }, [open]);

  const panelWidth = compact ? "max-w-4xl" : "max-w-6xl";
  const bodyHeight = compact ? "max-h-[80vh]" : "max-h-[92vh]";

  return (
    <Dialog
      open={open}
      onClose={close}
      className="fixed inset-0 z-[300] flex items-center justify-center px-2 py-6 sm:px-4"
    >
      {/* Backdrop */}
      <div
        className="fixed inset-0 z-[300] bg-black/70 backdrop-blur-sm"
        aria-hidden="true"
      />

      {/* Panel */}
      <Dialog.Panel
        className={`relative z-[310] mx-auto w-full ${panelWidth}`}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="mb-2 flex items-start justify-between gap-3 rounded-t-lg border border-b-0 border-orange-500 bg-neutral-950/90 px-4 py-3">
          <div className="space-y-1">
            <Dialog.Title className="text-base font-blackops tracking-wide text-orange-400 sm:text-lg">
              {title}
            </Dialog.Title>
            {derived.template && (
              <p className="text-[11px] text-neutral-400">
                Template:{" "}
                <span className="font-mono text-neutral-200">
                  {derived.template}
                </span>
              </p>
            )}
          </div>
          <div className="flex items-center gap-2">
            <button
              type="button"
              onClick={() => setCompact((v) => !v)}
              className="rounded border border-neutral-700 bg-neutral-900 px-3 py-1.5 text-[11px] text-neutral-100 hover:border-orange-500 hover:bg-neutral-800"
            >
              {compact ? "Expand" : "Shrink"}
            </button>
            <button
              type="button"
              onClick={close}
              className="rounded border border-neutral-700 bg-neutral-900 px-2 py-1 text-xs text-neutral-200 hover:bg-neutral-800"
            >
              ✕
            </button>
          </div>
        </div>

        {/* Scrollable body */}
        <div
          ref={scrollRef}
          className={`${bodyHeight} overflow-y-auto overscroll-contain rounded-b-lg border border-orange-500 bg-neutral-950 p-4 text-white shadow-xl`}
          style={{
            WebkitOverflowScrolling: "touch",
            scrollbarGutter: "stable both-edges",
          }}
        >
          {derived.missingWOLine && (
            <div className="mb-3 rounded border border-yellow-700 bg-yellow-900/30 px-3 py-2 text-xs text-yellow-200">
              <strong>Heads up:</strong>{" "}
              <code className="font-mono text-yellow-100">workOrderLineId</code>{" "}
              is missing; Save/Finish may be blocked.
            </div>
          )}

          {!derived.template ? (
            <div className="rounded border border-neutral-800 bg-neutral-900 px-4 py-6 text-center text-sm text-neutral-400">
              No inspection selected.
            </div>
          ) : (
            <div className="mx-auto w-full max-w-5xl">
              <InspectionHost
                template={derived.template}
                embed
                params={derived.params}
              />
            </div>
          )}

          {/* Footer actions */}
          <div className="mt-4 flex flex-col gap-2 border-t border-neutral-800 pt-3 sm:flex-row sm:items-center sm:justify-between">
            <button
              type="button"
              onClick={() => setCompact((v) => !v)}
              className="inline-flex items-center justify-center rounded border border-neutral-700 bg-neutral-900 px-3 py-1.5 text-xs text-neutral-100 hover:border-orange-500 hover:bg-neutral-800 sm:text-[11px]"
            >
              {compact ? "Expand View" : "Shrink View"}
            </button>
            <div className="flex justify-end gap-2">
              <button
                type="button"
                onClick={close}
                className="rounded border border-neutral-700 bg-neutral-900 px-4 py-1.5 text-xs sm:text-sm text-neutral-200 hover:bg-neutral-800"
              >
                Cancel
              </button>
              <button
                type="button"
                onClick={close}
                className="rounded border border-orange-500 bg-orange-500/10 px-4 py-1.5 text-xs sm:text-sm font-medium text-orange-100 hover:bg-orange-500/20"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </Dialog.Panel>
    </Dialog>
  );
}

===== FILE: ./quotes-full.txt =====

      .in("id", ids);
    if (error) {
      toast.error(error.message);
      return;
    }
    setBulkQueue(ids);
    setBulkActive(true);
    setPartsLineId(ids[0] ?? null);
    toast.success("Queued all pending lines for parts quoting");
  }, [approvalPending]);

  // open inspection
  const openInspectionForLine = useCallback(
    async (ln: WorkOrderLine) => {
      if (!ln?.id) return;

      const desc = String(ln.description ?? "").toLowerCase();
      const isAir = /\bair\b|cvip|push\s*rod|air\s*brake/.test(desc);
      const isCustom = /\bcustom\b|\bbuilder\b|\bprompt\b|\bad[-\s]?hoc\b/.test(
        desc
      );

      let templateSlug = isAir ? "maintenance50-air" : "maintenance50";
      if (isCustom) {
        templateSlug = "custom:pending";
      }

      try {
        const res = await fetch("/api/inspections/session/create", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            workOrderId: wo?.id ?? null,
            workOrderLineId: ln.id,
            vehicleId: vehicle?.id ?? null,
            customerId: customer?.id ?? null,
            template: templateSlug,
          }),
        });

        const j = (await res.json().catch(() => null)) as
          | { sessionId?: string; error?: string }
          | null;

        if (!res.ok || !j?.sessionId) {
          throw new Error(j?.error || "Failed to create inspection session");
        }

        if (isCustom) {
          templateSlug = `custom:${j.sessionId}`;
        }

        const sp = new URLSearchParams();
        if (wo?.id) sp.set("workOrderId", wo.id);
        sp.set("workOrderLineId", ln.id);
        sp.set("inspectionId", j.sessionId);
        sp.set("template", templateSlug);
        sp.set("embed", "1");
        if (isCustom && ln.description)
          sp.set("seed", String(ln.description));

        const url = `/inspection/${templateSlug}?${sp.toString()}`;

        setInspectionSrc(url);
        setInspectionOpen(true);
        toast.success("Inspection opened");
      } catch (e) {
        const err = e as { message?: string };
        toast.error(err?.message ?? "Unable to open inspection");
      }
    },
    [wo?.id, vehicle?.id, customer?.id]
  );

  // parts drawer close / bulk
  useEffect(() => {
    if (!partsLineId) return;

    const evtName = `parts-drawer:closed:${partsLineId}`;

    const handler = () => {
      if (bulkActive && bulkQueue.length > 0) {
        const [, ...rest] = bulkQueue;
        setBulkQueue(rest);
        setPartsLineId(rest[0] ?? null);
        if (rest.length === 0) {
          setBulkActive(false);
          void fetchAll();
        }
      } else {
        setPartsLineId(null);
        void fetchAll();
      }
    };

    window.addEventListener(evtName, handler as EventListener);
    return () => window.removeEventListener(evtName, handler as EventListener);
  }, [partsLineId, bulkActive, bulkQueue, fetchAll]);

  /* -------------------------- UI -------------------------- */
  if (!routeId)
    return <div className="p-6 text-red-500">Missing work order id.</div>;

  const Skeleton = ({ className = "" }: { className?: string }) => (
    <div className={`animate-pulse rounded-lg bg-neutral-800/60 ${className}`} />
  );

  return (
    <div className="mx-auto flex min-h-screen max-w-4xl flex-col px-3 py-4 bg-background text-foreground">
      <VoiceContextSetter
        currentView="work_order_page_mobile"
        workOrderId={wo?.id}
        vehicleId={vehicle?.id}
        customerId={customer?.id}
        lineId={null}
      />

      {/* header bar */}
      <div className="mb-4 flex items-center justify-between gap-2">
        <PreviousPageButton to="/mobile/work-orders" />
        {wo?.custom_id && (
          <span className="rounded-full border border-neutral-800 bg-neutral-900/70 px-3 py-1 text-[11px] text-neutral-300">
            Internal ID: {wo.id.slice(0, 8)}
          </span>
        )}
      </div>

      {!currentUserId && (
        <div className="mb-4 rounded-lg border border-amber-500/30 bg-amber-900/10 p-3 text-xs text-amber-100">
          You appear signed out on this tab. If actions fail, open{" "}
            <Link href="/sign-in" className="underline hover:text-white">
              Sign In
            </Link>{" "}
            and return here.
        </div>
      )}

      {viewError && (
        <div className="mb-4 whitespace-pre-wrap rounded-lg border border-red-500/40 bg-red-950/60 p-3 text-xs text-red-200">
          {viewError}
        </div>
      )}

      {loading ? (
        <div className="mt-4 grid gap-4">
          <Skeleton className="h-20" />
          <Skeleton className="h-32" />
          <Skeleton className="h-40" />
        </div>
      ) : !wo ? (
        <div className="mt-4 text-sm text-red-400">Work order not found.</div>
      ) : (
        <div className="space-y-5">
          {/* Header */}
          <div className="rounded-xl border border-border bg-card/95 p-4 shadow-sm">
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
              <div className="space-y-1">
                <div className="flex flex-wrap items-center gap-2">
                  <h1 className="text-lg font-semibold text-white sm:text-xl">
                    Work Order{" "}
                    <span className="text-orange-400">
                      {wo.custom_id || `#${wo.id.slice(0, 8)}`}
                    </span>
                  </h1>
                  <span className={chip(wo.status)}>
                    {(wo.status ?? "awaiting").replaceAll("_", " ")}
                  </span>
                </div>
                <p className="text-[11px] text-neutral-400">
                  Created {createdAtText}
                </p>
              </div>
            </div>

            <div className="mt-3 grid gap-3 text-[11px] text-neutral-300 sm:grid-cols-2">
              <div>
                <div className="text-neutral-500">Created</div>
                <div>{createdAtText}</div>
              </div>
              <div>
                <div className="text-neutral-500">WO ID</div>
                <div className="truncate font-mono text-[11px] text-neutral-200">
                  {wo.id}
                </div>
              </div>
              <div>
                <div className="text-neutral-500">Custom ID</div>
                <div className="truncate">
                  {wo.custom_id ?? (
                    <span className="text-neutral-500">Not set</span>
                  )}
                </div>
              </div>
              <div>
                <div className="text-neutral-500">Status</div>
                <div className="mt-0.5">
                  <span className={chip(wo.status)}>
                    {(wo.status ?? "awaiting").replaceAll("_", " ")}
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* Vehicle & Customer */}
          <div className="rounded-xl border border-border bg-card/95 p-4">
            <div className="flex items-center justify-between gap-2">
              <h2 className="text-sm font-semibold text-white sm:text-base">
                Vehicle &amp; Customer
              </h2>
              <button
                type="button"
                className="text-[11px] font-medium text-orange-400 hover:text-orange-300 hover:underline"
                onClick={() => setShowDetails((v) => !v)}
                aria-expanded={showDetails}
              >
                {showDetails ? "Hide details" : "Show details"}
              </button>
            </div>

            {showDetails && (
              <div className="mt-3 grid gap-4 sm:grid-cols-2">
                <div className="rounded-lg bg-neutral-950/60 p-3">
                  <h3 className="mb-1 text-[11px] font-semibold uppercase tracking-wide text-neutral-400">
                    Vehicle
                  </h3>
                  {vehicle ? (
                    <>
                      <p className="text-sm font-medium text-white">
                        {(vehicle.year ?? "").toString()} {vehicle.make ?? ""}{" "}
                        {vehicle.model ?? ""}
                      </p>
                      <p className="mt-1 text-[11px] text-neutral-400">
                        VIN:{" "}
                        <span className="font-mono">
                          {vehicle.vin ?? "—"}
                        </span>
                        <br />
                        Plate:{" "}
                        {vehicle.license_plate ?? (
                          <span className="text-neutral-500">—</span>
                        )}
                      </p>
                    </>
                  ) : (
                    <p className="text-sm text-neutral-500">
                      No vehicle linked yet.
                    </p>
                  )}
                </div>

                <div className="rounded-lg bg-neutral-950/60 p-3">
                  <h3 className="mb-1 text-[11px] font-semibold uppercase tracking-wide text-neutral-400">
                    Customer
                  </h3>
                  {customer ? (
                    <>
                      <p className="text-sm font-medium text-white">
                        {[
                          customer.first_name ?? "",
                          customer.last_name ?? "",
                        ]
                          .filter(Boolean)
                          .join(" ") || "—"}
                      </p>
                      <p className="mt-1 text-[11px] text-neutral-400">
                        {customer.phone ?? "—"}{" "}
                        {customer.email ? (
                          <>
                            <span className="mx-1 text-neutral-600">•</span>
                            {customer.email}
                          </>
                        ) : null}
                      </p>
                      {customer.id && (
                        <Link
                          href={`/customers/${customer.id}`}
                          className="mt-2 inline-flex text-[11px] font-medium text-orange-400 hover:text-orange-300 hover:underline"
                          title="Open customer profile"
                        >
                          View customer profile →
                        </Link>
                      )}
                    </>
                  ) : (
                    <p className="text-sm text-neutral-500">
                      No customer linked yet.
                    </p>
                  )}
                </div>
              </div>
            )}
          </div>

          {/* Awaiting Customer Approval */}
          <div className="rounded-xl border border-blue-900/60 bg-gradient-to-b from-slate-950 to-slate-950/90 p-4">
            <div className="mb-3 flex items-center justify-between gap-2">
              <h2 className="text-sm font-semibold text-blue-200 sm:text-base">
                Awaiting customer approval
              </h2>
              {approvalPending.length > 1 && (
                <button
                  type="button"
                  className="rounded-md bg-blue-600 px-3 py-1.5 text-xs font-semibold text-white shadow-sm hover:bg-blue-500"
                  onClick={sendAllPendingToParts}
                  title="Queue all lines for parts quoting"
                >
                  Quote all pending lines
                </button>
              )}
            </div>

            {approvalPending.length === 0 ? (
              <p className="text-xs text-neutral-400">
                No lines waiting for approval.
              </p>
            ) : (
              <div className="space-y-2">
                {approvalPending.map((ln, idx) => {
                  const isAwaitingParts =
                    (ln.status === "on_hold" &&
                      (ln.hold_reason ?? "")
                        .toLowerCase()
                        .includes("part")) ||
                    (ln.hold_reason ?? "")
                      .toLowerCase()
                      .includes("quote");

                  return (
                    <div
                      key={ln.id}
                      className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3"
                    >
                      <div className="flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
                        <div className="min-w-0">
                          <div className="truncate text-sm font-medium text-white">
                            {idx + 1}.{" "}
                            {ln.description ||
                              ln.complaint ||
                              "Untitled job"}
                          </div>
                          <div className="mt-0.5 text-[11px] text-neutral-400">
                            {String(ln.job_type ?? "job").replaceAll(
                              "_",
                              " "
                            )}{" "}
                            •{" "}
                            {typeof ln.labor_time === "number"
                              ? `${ln.labor_time}h`
                              : "—"}{" "}
                            • Status:{" "}
                            {(ln.status ?? "awaiting").replaceAll("_", " ")}{" "}
                            • Approval:{" "}
                            {(ln.approval_state ?? "pending").replaceAll(
                              "_",
                              " "
                            )}
                          </div>
                          {ln.notes && (
                            <div className="mt-1 text-[11px] text-neutral-400">
                              Notes: {ln.notes}
                            </div>
                          )}
                        </div>

                        <div className="flex flex-wrap items-center gap-2">
                          <button
                            type="button"
                            className="rounded-md border border-green-700 px-2 py-1 text-[11px] font-medium text-green-200 hover:bg-green-900/25"
                            onClick={() => approveLine(ln.id)}
                          >
                            Approve
                          </button>
                          <button
                            type="button"
                            className="rounded-md border border-red-700 px-2 py-1 text-[11px] font-medium text-red-200 hover:bg-red-900/30"
                            onClick={() => declineLine(ln.id)}
                          >
                            Decline
                          </button>

                          {isAwaitingParts ? (
                            <button
                              type="button"
                              disabled
                              className="cursor-not-allowed rounded-md border border-neutral-700 px-2 py-1 text-[11px] text-neutral-400"
                            >
                              Sent to parts
                            </button>
                          ) : (
                            <button
                              type="button"
                              className="rounded-md border border-blue-700 px-2 py-1 text-[11px] font-medium text-blue-200 hover:bg-blue-900/25"
                              onClick={() => sendToParts(ln.id)}
                              title="Send to parts for quoting"
                            >
                              Send to parts
                            </button>
                          )}
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          {/* Jobs list */}
          <div className="rounded-xl border border-border bg-card/95 p-4">
            <div className="mb-3 flex items-center justify-between gap-2">
              <div>
                <h2 className="text-sm font-semibold text-white sm:text-base">
                  Jobs in this work order
                </h2>
                <p className="text-[11px] text-neutral-500">
                  Tap a job to open its full-screen mobile view.
                </p>
              </div>
            </div>

            {sortedLines.length === 0 ? (
              <p className="text-sm text-neutral-400">No lines yet.</p>
            ) : (
              <div className="space-y-2">
                {sortedLines.map((ln, idx) => {
                  const statusKey = (ln.status ?? "awaiting")
                    .toLowerCase()
                    .replaceAll(" ", "_");
                  const borderCls =
                    statusBorder[statusKey] ||
                    "border-l-4 border-gray-400";
                  const tintCls =
                    statusRowTint[statusKey] || "bg-neutral-950";
                  const punchedIn =
                    !!ln.punched_in_at && !ln.punched_out_at;

                  const partsForLine = allocsByLine[ln.id] ?? [];

                  const lineTechIds = lineTechsByLine[ln.id] ?? [];
                  const primaryId =
                    typeof ln.assigned_to === "string"
                      ? (ln.assigned_to as string)
                      : null;

                  const orderedTechIds: string[] = [];
                  if (primaryId) orderedTechIds.push(primaryId);
                  lineTechIds.forEach((tid) => {
                    if (!orderedTechIds.includes(tid)) {
                      orderedTechIds.push(tid);
                    }
                  });

                  return (
                    <button
                      key={ln.id}
                      type="button"
                      className={`group block w-full rounded-lg border border-neutral-800 ${tintCls} p-3 text-left transition hover:border-orange-500/70 hover:bg-neutral-900/80 ${borderCls} ${
                        punchedIn ? "ring-2 ring-orange-500/80" : ""
                      }`}
                      title="Open focused job"
                      onClick={() => {
                        router.push(`/mobile/jobs/${ln.id}`);
                      }}
                    >
                      <div className="flex flex-col gap-2">
                        <div className="flex flex-wrap items-start justify-between gap-2">
                          <div className="min-w-0">
                            <div className="flex flex-wrap items-center gap-2">
                              <div className="truncate text-sm font-medium text-white">
                                {idx + 1}.{" "}
                                {ln.description ||
                                  ln.complaint ||
                                  "Untitled job"}
                              </div>
                              {ln.job_type === "inspection" && (
                                <button
                                  type="button"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    void openInspectionForLine(ln);
                                  }}
                                  className={`rounded-md border px-2 py-0.5 text-[11px] font-medium ${
                                    ln.status === "completed"
                                      ? "border-green-400 text-green-200"
                                      : "border-orange-400 text-orange-200 hover:bg-orange-500/10"
                                  }`}
                                >
                                  {ln.status === "completed"
                                    ? "View inspection"
                                    : "Open inspection"}
                                </button>
                              )}
                              {canAssign && (
                                <button
                                  type="button"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setAssignLineId(ln.id);
                                    setAssignOpen(true);
                                  }}
                                  className="rounded-md border border-sky-500/70 px-2 py-0.5 text-[11px] font-medium text-sky-200 hover:bg-sky-900/25"
                                  title="Assign mechanic to this line"
                                >
                                  Assign mechanic
                                </button>
                              )}
                            </div>
                            <div className="mt-0.5 text-[11px] text-neutral-400">
                              {String(ln.job_type ?? "job").replaceAll(
                                "_",
                                " "
                              )}{" "}
                              •{" "}
                              {typeof ln.labor_time === "number"
                                ? `${ln.labor_time}h`
                                : "—"}{" "}
                              • Status:{" "}
                              {(ln.status ?? "awaiting").replaceAll(
                                "_",
                                " "
                              )}
                            </div>

                            {orderedTechIds.length > 0 && (
                              <div className="mt-1 flex flex-wrap gap-1">
                                {orderedTechIds.map((tid) => {
                                  const info = assignablesById[tid];
                                  const label =
                                    info?.full_name ?? "Mechanic";
                                  return (
                                    <span
                                      key={tid}
                                      className="inline-flex items-center gap-1 rounded-full bg-sky-900/40 px-2 py-0.5 text-[10px] text-sky-100"
                                    >
                                      <span className="h-1.5 w-1.5 rounded-full bg-sky-300" />
                                      {label}
                                    </span>
                                  );
                                })}
                              </div>
                            )}

                            {(ln.complaint ||
                              ln.cause ||
                              ln.correction) && (
                              <div className="mt-1 flex flex-wrap items-center gap-2 text-[11px] text-neutral-400">
                                {ln.complaint ? (
                                  <span>Cmpl: {ln.complaint}</span>
                                ) : null}
                                {ln.cause ? (
                                  <span>| Cause: {ln.cause}</span>
                                ) : null}
                                {ln.correction ? (
                                  <span>| Corr: {ln.correction}</span>
                                ) : null}
                              </div>
                            )}

                            {/* Parts used */}
                            <div className="mt-2 rounded-lg border border-neutral-800 bg-neutral-950/80 p-2">
                              <div className="mb-1 flex items-center justify-between gap-2">
                                <div className="text-[11px] font-semibold uppercase tracking-wide text-neutral-300">
                                  Parts used
                                </div>
                                <div className="shrink-0">
                                  <UsePartButton
                                    workOrderLineId={ln.id}
                                    onApplied={() =>
                                      window.dispatchEvent(
                                        new CustomEvent("wo:parts-used")
                                      )
                                    }
                                    label="Add part"
                                  />
                                </div>
                              </div>
                              {partsForLine.length ? (
                                <ul className="mt-1 divide-y divide-neutral-800 rounded border border-neutral-800 text-sm">
                                  {partsForLine.map((a) => (
                                    <li
                                      key={a.id}
                                      className="flex items-center justify-between bg-neutral-900/70 p-2"
                                    >
                                      <div className="min-w-0">
                                        <div className="truncate text-sm text-white">
                                          {a.parts?.name ?? "Part"}
                                        </div>
                                        <div className="text-[11px] text-neutral-500">
                                          loc{" "}
                                          {String(a.location_id).slice(
                                            0,
                                            6
                                          )}
                                          …
                                        </div>
                                      </div>
                                      <div className="pl-3 text-sm font-semibold text-neutral-100">
                                        × {a.qty}
                                      </div>
                                    </li>
                                  ))}
                                </ul>
                              ) : (
                                <div className="mt-1 text-[11px] text-neutral-500">
                                  No parts used yet.
                                </div>
                              )}
                            </div>
                          </div>

                          <span className={chip(ln.status)}>
                            {(ln.status ?? "awaiting").replaceAll(
                              "_",
                              " "
                            )}
                          </span>
                        </div>
                      </div>
                    </button>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      )}

      {/* Parts Drawer */}
      {partsLineId && wo?.id && (
        <PartsDrawer
          open={!!partsLineId}
          workOrderId={wo.id}
          workOrderLineId={partsLineId}
          vehicleSummary={
            vehicle
              ? {
                  year: (
                    vehicle.year as string | number | null
                  )?.toString() ?? null,
                  make: vehicle.make ?? null,
                  model: vehicle.model ?? null,
                }
              : null
          }
          jobDescription={
            lines.find((l) => l.id === partsLineId)?.description ??
            lines.find((l) => l.id === partsLineId)?.complaint ??
            null
          }
          jobNotes={
            lines.find((l) => l.id === partsLineId)?.notes ?? null
          }
          closeEventName={`parts-drawer:closed:${partsLineId}`}
        />
      )}

      {/* Inspection modal */}
      {inspectionOpen && inspectionSrc && (
        <InspectionModal
          open={inspectionOpen}
          src={inspectionSrc}
          title="Inspection"
          onClose={() => setInspectionOpen(false)}
        />
      )}

      {/* Assign mechanic modal */}
      {assignOpen && assignLineId && (
        <AssignTechModal
          isOpen={assignOpen}
          onClose={() => setAssignOpen(false)}
          workOrderLineId={assignLineId}
          mechanics={assignables}
          onAssigned={async () => {
            await fetchAll();
          }}
        />
      )}

      <div className="mt-4 flex justify-center">
        <VoiceButton />
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/lib/capabilities.ts */
/* =============================== */

export function capabilities(role: string | null) {
  const r = (role || "").toLowerCase();
  const staff = ["owner", "admin", "manager", "advisor", "tech"];
  return {
    canView: true,
    canEditWoMeta: ["owner", "admin", "manager", "advisor"].includes(r),
    canTechOps: ["tech", "manager"].includes(r),
    canAddJobs: staff.includes(r),
    canGenerateQuote: staff.includes(r),
  } as const;
}


/* =============================== */
/* FILE: features/work-orders/lib/work-orders/generateQuotePdf.ts */
/* =============================== */

import { PDFDocument, rgb, StandardFonts } from "pdf-lib";
import type {
  QuoteLine,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

/**
 * Normalizes either QuoteLine or QuoteLineItem into a common shape
 * so the PDF renderer doesn't care which one you pass.
 */
function toUnified(line: QuoteLine | QuoteLineItem) {
  // Heuristic: QuoteLine has "parts" or "laborTime"
  const isQuoteLine =
    (line as QuoteLine).parts !== undefined ||
    (line as QuoteLine).laborTime !== undefined;

  if (isQuoteLine) {
    const q = line as QuoteLine;
    const first = q.parts?.[0];
    const laborHours = q.laborTime ?? 0;
    const laborRate = q.laborRate ?? 0;
    const laborPrice = laborRate * laborHours;

    return {
      name: q.item ?? q.inspectionItem ?? "",
      description: q.description ?? "",
      status: (q.status ?? "ok") as "ok" | "fail" | "na" | "recommend",
      notes: q.notes ?? "",
      partName: first?.name ?? "",
      partPrice:
        typeof first?.price === "number"
          ? first!.price
          : Number(first?.price ?? 0),
      laborHours,
      laborPrice,
    };
  }

  // Otherwise treat as QuoteLineItem
  const qi = line as QuoteLineItem;
  const numericPartPrice =
    typeof qi.part?.price === "number"
      ? qi.part?.price
      : typeof qi.partPrice === "number"
        ? qi.partPrice
        : Number(qi.partPrice ?? 0);

  return {
    name: qi.name ?? (qi.item ?? ""),
    description: qi.description ?? "",
    status: qi.status,
    notes: qi.notes ?? "",
    partName: qi.part?.name ?? qi.partName ?? "",
    partPrice: numericPartPrice ?? 0,
    laborHours: qi.laborHours ?? 0,
    laborPrice: qi.price ?? 0,
  };
}

export async function generateQuotePDFBytes(
  quoteLines: ReadonlyArray<QuoteLine | QuoteLineItem>,
  summaryText: string,
): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create();
  let page = pdfDoc.addPage();
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const fontSize = 12;

  const drawText = (text: string, x = 50, dy = fontSize + 6) => {
    const { height } = page.getSize();
    // track y on the page
    if ((drawText as any)._y === undefined) (drawText as any)._y = height - 40;
    let y = (drawText as any)._y as number;

    page.drawText(text, { x, y, size: fontSize, font, color: rgb(0, 0, 0) });
    y -= dy;

    // Start new page if we’re near the bottom
    if (y < 60) {
      page = pdfDoc.addPage();
      y = page.getSize().height - 40;
    }
    (drawText as any)._y = y;
  };

  // Summary
  drawText("Inspection Summary:");
  for (const line of (summaryText || "").split("\n")) {
    drawText(line);
  }

  // Spacer + header
  drawText("", 50, 20);
  drawText("Quote Items:");

  // Items
  for (const raw of quoteLines) {
    const u = toUnified(raw);

    drawText(`• ${u.name || "(unnamed item)"}`);
    if (u.description) drawText(`   ${u.description}`);

    const priceStr =
      typeof u.partPrice === "number" ? u.partPrice.toFixed(2) : "0.00";
    drawText(`   Part: ${u.partName || "—"} - $${priceStr}`);

    drawText(
      `   Labor: ${u.laborHours ?? 0} hrs - $${(u.laborPrice ?? 0).toFixed(2)}`,
    );

    drawText(`   Status: ${u.status}`);
    if (u.notes) drawText(`   Notes: ${u.notes}`);

    // Extra gap between items
    drawText("", 50, 10);
  }

  return pdfDoc.save(); // Uint8Array
}

/** Back-compat alias so existing imports `{ generateQuotePDF }` still compile */
export const generateQuotePDF = generateQuotePDFBytes;

/* =============================== */
/* FILE: features/work-orders/api/update-status/route.ts */
/* =============================== */

import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import type { Database } from "@shared/types/types/supabase";

const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
);

type Command = "punch-in" | "complete";

type QuoteLineItem = {
  name: string;
  description?: string;
  labor_time?: number;
  part_name?: string;
  part_price?: number;
  parts_cost?: number;
  total_price?: number;
};

interface RequestBody {
  workOrderId: string;
  command: Command;
  quote?: QuoteLineItem[];
  summary?: string;
}

export async function POST(req: NextRequest) {
  try {
    const body: RequestBody = await req.json();
    const { workOrderId, command, quote, summary } = body;

    if (!workOrderId || !command) {
      return NextResponse.json(
        { error: "Missing workOrderId or command" },
        { status: 400 },
      );
    }

    let updateFields: Partial<
      Database["public"]["Tables"]["work_orders"]["Update"]
    > = {};

    if (command === "punch-in") {
      updateFields = {
        status: "in_progress",
      };
    } else if (command === "complete") {
      updateFields = {
        status: "completed",
      };

      if (quote && summary) {
        updateFields.quote = {
          summary,
          items: quote,
        } as any; // keep if `quote` column is jsonb; remove `as any` if typed
      }
    } else {
      return NextResponse.json({ error: "Unknown command" }, { status: 400 });
    }

    const { error } = await supabase
      .from("work_orders")
      .update(updateFields)
      .eq("id", workOrderId);

    if (error) throw error;

    return NextResponse.json({ success: true, updated: updateFields });
  } catch (err: unknown) {
    const message = err instanceof Error ? err.message : String(err);
    console.error("Work order update failed:", message);
    return NextResponse.json({ error: "Update failed" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: features/work-orders/app/work-orders/page.tsx */
/* =============================== */

// app/work-orders/page.tsx
"use client";

import Link from "next/link";

export const revalidate = 0;

type TileProps = {
  href: string;
  title: string;
  subtitle?: string;
  cta?: string;
};

function Tile(props: TileProps) {
  return (
    <Link
      href={props.href}
      className="block rounded-lg border border-white/10 bg-neutral-900 p-4 transition
                 hover:-translate-y-0.5 hover:border-orange-500 hover:shadow-lg hover:shadow-orange-500/10"
      aria-label={props.title}
    >
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-white">{props.title}</h2>
        {props.cta ? (
          <span className="rounded bg-orange-500 px-3 py-1 text-sm font-semibold text-black">
            {props.cta}
          </span>
        ) : null}
      </div>
      {props.subtitle ? (
        <p className="mt-1 text-sm text-white/70">{props.subtitle}</p>
      ) : null}
    </Link>
  );
}

export default function WorkOrdersHome() {
  return (
    <div className="mx-auto max-w-3xl px-4 py-8 text-white">
      <h1 className="mb-6 text-3xl font-bold text-orange-400">Work Orders</h1>

      <div className="grid grid-cols-1 gap-4">
        <Tile
          href="/work-orders/create"
          title="Create Work Order"
          subtitle="Start a new job for a vehicle"
          cta="+"
        />
        <Tile
          href="/work-orders/queue"
          title="Job Queue"
          subtitle="See active, paused, and in-progress jobs"
        />
        <Tile
          href="/work-orders/editor"
          title="Work Order Editor"
          subtitle="Compose job lines from menu items or free-type"
        />
        <Tile
          href="/work-orders/quote-review"
          title="Quote Review"
          subtitle="Review and send estimates"
        />
        <Tile
          href="/work-orders/view"
          title="View Work Orders"
          subtitle="Browse and manage all work orders"
        />
        <Tile
          href="/customers"
          title="Customer Profiles"
          subtitle="Browse customers, history, and vehicles"
        />
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/app/work-orders/quote-review/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import SignaturePad, {
  openSignaturePad,
} from "@/features/shared/signaturePad/controller";
import { formatCurrency } from "@/features/shared/lib/formatCurrency";

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type Line = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Shop = DB["public"]["Tables"]["shops"]["Row"];

const SIGNATURE_BUCKET = "signatures";

/* ----------------------------- helpers ----------------------------- */

function dataUrlToBlob(dataUrl: string): Blob {
  const [header, b64] = dataUrl.split(",");
  const mime = /data:(.*?);base64/.exec(header)?.[1] ?? "image/png";
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return new Blob([bytes], { type: mime });
}

const fmt = (n: number) => {
  try {
    return formatCurrency(n);
  } catch {
    return `$${n.toFixed(2)}`;
  }
};

/* ----------------------- approvals list (cards) ----------------------- */

function ApprovalsList() {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [rows, setRows] = useState<WorkOrderWithMeta[]>([]);
  const [loading, setLoading] = useState(true);

  type WorkOrderWithMeta = WorkOrder & {
    shops?: Pick<Shop, "name"> | null;
    labor_hours?: number | null;
  };

  const load = async () => {
    setLoading(true);

    // Only show awaiting_approval here
    const { data: wo } = await supabase
      .from("work_orders")
      .select(`*, shops!inner(name)`)
      .eq("status", "awaiting_approval")
      .order("created_at", { ascending: false });

    let withMeta: WorkOrderWithMeta[] = (wo ?? []) as any;

    if (withMeta.length) {
      const woIds = withMeta.map((w) => w.id);
      const { data: lines } = await supabase
        .from("work_order_lines")
        .select("work_order_id, labor_time")
        .in("work_order_id", woIds);

      const hoursByWO = new Map<string, number>();
      (lines ?? []).forEach((l) => {
        const cur = hoursByWO.get(l.work_order_id) ?? 0;
        hoursByWO.set(
          l.work_order_id,
          cur +
            (typeof l.labor_time === "number" ? l.labor_time : 0)
        );
      });

      withMeta = withMeta.map((w) => ({
        ...w,
        labor_hours: hoursByWO.get(w.id) ?? 0,
      }));
    }

    setRows(withMeta);
    setLoading(false);
  };

  useEffect(() => {
    void load();

    // Realtime: if any WO flips status, refresh the list
    const ch = supabase
      .channel("qr:work_orders")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "work_orders" },
        () => void load()
      )
      .subscribe();

    return () => {
      try {
        supabase.removeChannel(ch);
      } catch {
        /* ignore */
      }
    };
  }, [supabase]);

  if (loading)
    return <div className="mt-6 text-muted-foreground">Loading…</div>;
  if (rows.length === 0)
    return (
      <div className="mt-6 text-muted-foreground">
        No work orders waiting for approval.
      </div>
    );

  return (
    <div className="mt-4 rounded-lg border border-border bg-card">
      <div className="border-b border-border px-4 py-2 font-semibold">
        Awaiting Approval
      </div>

      <div className="divide-y divide-border">
        {rows.map((w) => (
          <div
            key={w.id}
            className="flex items-center justify-between gap-3 px-4 py-3"
          >
            <div className="min-w-0">
              <div className="truncate font-medium">
                {w.custom_id ? `#${w.custom_id}` : `#${w.id.slice(0, 8)}`}
              </div>
              <div className="text-xs text-muted-foreground">
                {w.shops?.name ? `${w.shops.name} • ` : ""}
                {(w.status ?? "").replaceAll("_", " ")}
                {typeof w.labor_hours === "number"
                  ? ` • ${w.labor_hours.toFixed(1)}h`
                  : ""}
              </div>
            </div>
            <div className="flex shrink-0 gap-2">
              <a
                href={`/work-orders/${w.id}/approve`}
                className="rounded border border-orange-500 px-3 py-1 text-sm text-orange-500 hover:bg-orange-500/10"
                title="Open customer-facing approval workflow"
              >
                Review &amp; Sign
              </a>
              <a
                href={`/work-orders/${w.id}`}
                className="rounded border border-border px-3 py-1 text-sm hover:bg-muted"
                title="Open this work order"
              >
                Open WO
              </a>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

/* ---------------------- single WO review + sign ---------------------- */

function SingleQuoteReview({ woId }: { woId: string }) {
  const router = useRouter();
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);

  const [wo, setWo] = useState<WorkOrder | null>(null);
  const [shop, setShop] = useState<Shop | null>(null);
  const [lines, setLines] = useState<Line[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!woId) return;
    (async () => {
      setLoading(true);

      const { data: woRow } = await supabase
        .from("work_orders")
        .select("*")
        .eq("id", woId)
        .maybeSingle();
      setWo(woRow ?? null);

      if (woRow?.shop_id) {
        const { data: shopRow } = await supabase
          .from("shops")
          .select("*")
          .eq("id", woRow.shop_id)
          .maybeSingle();
        setShop(shopRow ?? null);
      }

      const { data: lineRows } = await supabase
        .from("work_order_lines")
        .select("*")
        .eq("work_order_id", woId)
        .order("created_at", { ascending: true });
      setLines(lineRows ?? []);

      setLoading(false);
    })();
  }, [woId, supabase]);

  const laborRate = 120;
  const totalLaborHours = lines.reduce(
    (sum, l) => sum + (typeof l.labor_time === "number" ? l.labor_time : 0),
    0
  );
  const laborTotal = totalLaborHours * laborRate;
  const partsTotal = 0;
  const grandTotal = laborTotal + partsTotal;

  async function handleSignatureSave(base64: string) {
    if (!woId) return;
    try {
      const blob = dataUrlToBlob(base64);
      const filename = `wo/${wo?.shop_id ?? "unknown"}/${woId}/${Date.now()}.png`;

      const { error: upErr } = await supabase.storage
        .from(SIGNATURE_BUCKET)
        .upload(filename, blob, { contentType: "image/png", upsert: false });
      if (upErr) throw upErr;

      const { error: updErr } = await supabase
        .from("work_orders")
        .update({
          // @ts-ignore pending schema fields in types
          customer_approval_signature_path: filename,
          // @ts-ignore pending schema fields in types
          customer_approval_at: new Date().toISOString() as any,
          status: "queued" as any, // moves it out of Quote Review
        })
        .eq("id", woId);
      if (updErr) throw updErr;

      alert("Work order approved and signed!");
      router.push("/work-orders/create?from=review&new=1");
    } catch (err: unknown) {
      const msg =
        err instanceof Error ? err.message : "Failed to save signature";
      alert(msg);
    }
  }

  async function markAwaitingApproval() {
    if (!woId) return;
    try {
      const { error } = await supabase
        .from("work_orders")
        .update({
          status: "awaiting_approval" as any,
          // @ts-ignore pending schema fields in types
          customer_approval_signature_path: null,
          // @ts-ignore pending schema fields in types
          customer_approval_at: null,
        })
        .eq("id", woId);
      if (error) throw error;
      alert("Saved. This work order is now awaiting customer approval.");
    } catch (e: unknown) {
      const msg = e instanceof Error ? e.message : "Failed to update status.";
      alert(msg);
    }
  }

  function copyApprovalLink() {
    if (!woId) return;
    const origin =
      typeof window !== "undefined"
        ? window.location.origin
        : (process.env.NEXT_PUBLIC_SITE_URL || "").replace(/\/$/, "");
    const url = `${origin || ""}/work-orders/${woId}/approve`;
    navigator.clipboard
      .writeText(url)
      .then(() => alert("Approval link copied to clipboard."))
      .catch(() => alert(url));
  }

  if (loading) return <div className="mt-6 text-muted-foreground">Loading…</div>;
  if (!wo) return <div className="mt-6 text-destructive">Work order not found.</div>;

  return (
    <>
      <div className="mt-2 text-sm text-muted-foreground">
        <div>Work Order ID: {wo.id}</div>
        <div>Status: {(wo.status ?? "").replaceAll("_", " ") || "—"}</div>
        {shop?.name && <div>Shop: {shop.name}</div>}
      </div>

      <div className="mt-6 rounded-lg border border-border bg-card">
        <div className="border-b border-border px-4 py-2 font-semibold">
          Line Items
        </div>
        <div className="divide-y divide-border">
          {lines.length === 0 ? (
            <div className="px-4 py-3 text-muted-foreground">
              No items yet.
            </div>
          ) : (
            lines.map((l) => (
              <div key={l.id} className="px-4 py-3">
                <div className="flex items-center justify-between">
                  <div className="min-w-0">
                    <div className="truncate font-medium">
                      {l.description || l.complaint || "Untitled job"}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      {String(l.job_type ?? "job").replaceAll("_", " ")} •{" "}
                      {typeof l.labor_time === "number"
                        ? `${l.labor_time}h`
                        : "—"}{" "}
                      • {(l.status ?? "awaiting").replaceAll("_", " ")}
                    </div>
                  </div>
                  <div className="text-right text-sm">
                    {typeof l.labor_time === "number"
                      ? fmt(l.labor_time * 120)
                      : "—"}
                  </div>
                </div>
              </div>
            ))
          )}
        </div>

        <div className="px-4 py-3 text-sm">
          <div className="flex items-center justify-between">
            <span>
              Labor ({totalLaborHours.toFixed(1)}h @ {fmt(120)}/hr)
            </span>
            <span className="font-medium">{fmt(laborTotal)}</span>
          </div>
          <div className="mt-1 flex items-center justify-between">
            <span>Parts</span>
            <span className="font-medium">{fmt(0)}</span>
          </div>
          <div className="mt-2 flex items-center justify-between border-t border-border pt-2">
            <span className="font-semibold">Total</span>
            <span className="font-bold text-orange-500">{fmt(grandTotal)}</span>
          </div>
        </div>
      </div>

      <div className="mt-6 flex flex-wrap gap-2">
        <button
          onClick={async () => {
            const base64 = await openSignaturePad({ shopName: shop?.name || "" });
            if (!base64) return;
            await handleSignatureSave(base64);
          }}
          className="rounded bg-green-600 px-4 py-2 font-semibold text-white hover:bg-green-700"
        >
          Approve &amp; Sign
        </button>

        <button
          onClick={markAwaitingApproval}
          className="rounded border border-border px-4 py-2 hover:bg-muted"
          title="Save this work order as awaiting customer approval"
        >
          Save for Customer Approval
        </button>

        <button
          onClick={copyApprovalLink}
          className="rounded border border-border px-4 py-2 hover:bg-muted"
          title="Copy link to the customer-facing approval page"
        >
          Copy Approval Link
        </button>

        <a
          href={`/work-orders/${woId}`}
          className="rounded border border-border px-4 py-2 hover:bg-muted"
        >
          Back to Work Order
        </a>
      </div>
    </>
  );
}

/* ------------------------------ page ------------------------------ */

export default function QuoteReviewPage() {
  const woId = useSearchParams().get("woId");
  const router = useRouter();

  return (
    <div className="min-h-screen bg-background px-4 py-6 text-foreground">
      <div className="mx-auto max-w-5xl">
        <div className="mb-4">
          <button
            onClick={() => router.back()}
            className="text-sm text-orange-500 hover:underline"
          >
            ← Back
          </button>
        </div>

        <h1 className="text-2xl font-semibold">Quote Review</h1>

        {!woId ? (
          <>
            <p className="mt-1 text-muted-foreground">
              Work orders waiting for customer approval
            </p>
            <ApprovalsList />
            <SignaturePad />
          </>
        ) : (
          <>
            <SingleQuoteReview woId={woId!} />
            <SignaturePad />
          </>
        )}
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/components/SuggestedQuickAdd.tsx */
/* =============================== */

"use client";

import { useEffect, useState } from "react";

type Suggestion = {
  name: string;
  laborHours: number | null; // ← allow null in our TS shape
  jobType: "diagnosis" | "repair" | "maintenance" | "tech-suggested";
  notes: string;
  aiComplaint?: string;
  aiCause?: string;
  aiCorrection?: string;
};

function asSuggestions(input: any): Suggestion[] {
  if (!Array.isArray(input)) return [];
  return input.map((raw) => {
    const name = typeof raw?.name === "string" && raw.name.trim() ? raw.name.trim() : "Suggested item";
    const hours = Number(raw?.laborHours);
    const jobType =
      raw?.jobType === "diagnosis" ||
      raw?.jobType === "repair" ||
      raw?.jobType === "maintenance" ||
      raw?.jobType === "tech-suggested"
        ? raw.jobType
        : "maintenance"; // sane default
    const notes = typeof raw?.notes === "string" ? raw.notes : "";
    return {
      name,
      laborHours: Number.isFinite(hours) ? hours : null,
      jobType,
      notes,
      aiComplaint: typeof raw?.aiComplaint === "string" ? raw.aiComplaint : undefined,
      aiCause: typeof raw?.aiCause === "string" ? raw.aiCause : undefined,
      aiCorrection: typeof raw?.aiCorrection === "string" ? raw.aiCorrection : undefined,
    } as Suggestion;
  });
}

export default function SuggestedQuickAdd({
  jobId,
  workOrderId,
  vehicleId,
  onAdded, // <-- NEW
}: {
  jobId: string;
  workOrderId: string;
  vehicleId?: string | null;
  onAdded?: () => void | Promise<void>; // <-- NEW
}) {
  const [loading, setLoading] = useState(false);
  const [adding, setAdding] = useState<string | null>(null);
  const [items, setItems] = useState<Suggestion[]>([]);
  const [error, setError] = useState<string | null>(null);

  async function fetchSuggestions() {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch("/api/work-orders/suggest-lines", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ jobId }),
      });
      const j = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error(j?.error || "Failed to load suggestions");
      setItems(asSuggestions(j?.suggestions));
    } catch (e) {
      setError(e instanceof Error ? e.message : "Failed to load suggestions");
      setItems([]);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    if (jobId) void fetchSuggestions();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [jobId]);

  async function addQuote(s: Suggestion) {
    setAdding(s.name);
    try {
      const res = await fetch("/api/work-orders/quotes/add", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          workOrderId,
          vehicleId: vehicleId ?? null,
          items: [
            {
              description: s.name,
              jobType: s.jobType,
              estLaborHours: s.laborHours ?? 0, // ← safe default
              notes: s.notes,
              aiComplaint: s.aiComplaint,
              aiCause: s.aiCause,
              aiCorrection: s.aiCorrection,
            },
          ],
        }),
      });
      if (!res.ok) {
        const j = await res.json().catch(() => ({}));
        throw new Error(j?.error || "Failed to add quote line");
      }

      // ✅ Notify parent if provided
      await onAdded?.();
    } catch (e) {
      alert(e instanceof Error ? e.message : "Failed to add quote line");
    } finally {
      setAdding(null);
    }
  }

  return (
    <div className="rounded border border-neutral-800 bg-neutral-950 p-3">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold text-orange-400">AI Suggestions</h3>
        <button
          onClick={fetchSuggestions}
          disabled={loading}
          className="text-xs px-2 py-1 rounded border border-neutral-700 hover:bg-neutral-800 disabled:opacity-60"
        >
          {loading ? "Thinking…" : "Regenerate"}
        </button>
      </div>

      {error && <p className="mt-2 text-xs text-red-400">{error}</p>}

      <div className="mt-3 grid gap-2 sm:grid-cols-2">
        {items.map((s) => (
          <button
            key={s.name}
            onClick={() => addQuote(s)}
            disabled={adding === s.name}
            className="text-left border border-neutral-800 bg-neutral-900 hover:bg-neutral-800 rounded p-3 disabled:opacity-60"
          >
            <div className="font-medium">{s.name}</div>
            <div className="text-xs text-neutral-400">
              {s.jobType} • {typeof s.laborHours === "number" ? s.laborHours.toFixed(1) : "—"}h
            </div>
            {s.notes && <div className="text-xs text-neutral-500 mt-1">{s.notes}</div>}
          </button>
        ))}

        {!loading && items.length === 0 && (
          <div className="text-xs text-neutral-400">No suggestions yet.</div>
        )}
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/components/MenuQuickAdd.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";
import type { Database, TablesInsert } from "@shared/types/types/supabase";

type DB = Database;
type WorkOrderLineInsert = TablesInsert<"work_order_lines">;

type JobType = "maintenance" | "repair" | "diagnosis" | "inspection";

type PackageItem = {
  description: string;
  jobType?: JobType;
  laborHours?: number | null;
  notes?: string | null;
};

type PackageDef = {
  id: string;
  name: string;
  summary: string;
  jobType: "inspection" | "maintenance";
  estLaborHours: number | null;
  items: PackageItem[];
};

type MenuItemRow = DB["public"]["Tables"]["menu_items"]["Row"];

// DB table has labor_hours, so add it if your generated type is missing it
type TemplateRow = DB["public"]["Tables"]["inspection_templates"]["Row"] & {
  labor_hours?: number | null;
};

type VehicleLite = {
  id?: string | null;
  year?: string | number | null;
  make?: string | null;
  model?: string | null;
  vin?: string | null;
  license_plate?: string | null;
};

type CustomerLite = {
  id?: string | null;
  first_name?: string | null;
  last_name?: string | null;
  phone?: string | null;
  email?: string | null;
};

type PartToAllocate = {
  sku?: string | null;
  name?: string | null;
  qty: number;
};

type AddMenuParams =
  | {
      kind?: "normal";
      name: string;
      jobType: JobType;
      laborHours?: number | null;
      notes?: string | null;
      source?: "single" | "package" | "menu_item" | "ai" | "inspection";
      returnLineId?: boolean;
      partsToAllocate?: PartToAllocate[];
    }
  | {
      kind: "template";
      template: TemplateRow;
      name?: string;
      laborHours?: number | null;
    };

export function MenuQuickAdd({ workOrderId }: { workOrderId: string }) {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const router = useRouter();

  // curated packages
  const packages: PackageDef[] = [
    {
      id: "oil-gas",
      name: "Oil Change – Gasoline",
      jobType: "maintenance",
      estLaborHours: 0.8,
      summary: "Oil & filter, fluids, tire pressures, quick leak check.",
      items: [],
    },
    {
      id: "insp-gas",
      name: "Multi-Point Inspection – Gas",
      jobType: "inspection",
      estLaborHours: 1.0,
      summary: "Brakes, tires, suspension, battery, lights, codes scan.",
      items: [],
    },
    {
      id: "maintenance-50",
      name: "Maintenance 50",
      jobType: "inspection",
      estLaborHours: 1.0,
      summary: "50-point inspection checklist.",
      items: [],
    },
    {
      id: "maintenance-50-air",
      name: "Maintenance 50 – Air",
      jobType: "inspection",
      estLaborHours: 1.0,
      summary: "50-point inspection checklist (air systems focus).",
      items: [],
    },
  ];

  const [addingId, setAddingId] = useState<string | null>(null);
  const [vehicle, setVehicle] = useState<VehicleLite | null>(null);
  const [, setCustomer] = useState<CustomerLite | null>(null);
  const [woLineCount, setWoLineCount] = useState<number | null>(null);

  // saved menu items
  const [menuItems, setMenuItems] = useState<MenuItemRow[]>([]);
  const [menuLoading, setMenuLoading] = useState(false);

  // inspection templates
  const [templates, setTemplates] = useState<TemplateRow[]>([]);
  const [templatesLoading, setTemplatesLoading] = useState(false);

  // shop context
  const [shopId, setShopId] = useState<string | null>(null);
  const shopReady = !!shopId;
  const vehicleId = vehicle?.id ?? null;

  // AI modal
  const [aiOpen, setAiOpen] = useState(false);
  const [aiPrompt, setAiPrompt] = useState("");
  const [aiBusy, setAiBusy] = useState(false);

  const lastSetShopId = useRef<string | null>(null);
  async function ensureShopContext(id: string | null) {
    if (!id) return;
    if (lastSetShopId.current === id) return;
    const { error } = await supabase.rpc("set_current_shop_id", { p_shop_id: id });
    if (!error) {
      lastSetShopId.current = id;
    } else {
      throw error;
    }
  }

  // bootstrap WO + related
  useEffect(() => {
    (async () => {
      const { data: wo } = await supabase
        .from("work_orders")
        .select("id, vehicle_id, customer_id, shop_id")
        .eq("id", workOrderId)
        .maybeSingle();

      setShopId(wo?.shop_id ?? null);

      if (wo?.vehicle_id) {
        const { data: v } = await supabase
          .from("vehicles")
          .select("id, year, make, model, vin, license_plate")
          .eq("id", wo.vehicle_id)
          .maybeSingle();
        if (v) setVehicle(v as VehicleLite);
      } else {
        setVehicle(null);
      }

      if (wo?.customer_id) {
        const { data: c } = await supabase
          .from("customers")
          .select("id, first_name, last_name, phone, email")
          .eq("id", wo.customer_id)
          .maybeSingle();
        if (c) setCustomer(c as CustomerLite);
      } else {
        setCustomer(null);
      }

      const { count } = await supabase
        .from("work_order_lines")
        .select("*", { count: "exact", head: true })
        .eq("work_order_id", workOrderId);
      setWoLineCount(typeof count === "number" ? count : null);
    })();
  }, [supabase, workOrderId]);

  // load saved menu items
  const loadMenuItems = useCallback(async () => {
    setMenuLoading(true);
    try {
      const { data, error } = await supabase
        .from("menu_items")
        .select("*")
        .order("created_at", { ascending: false })
        .limit(20);
      if (error) throw error;
      setMenuItems(data ?? []);
    } catch {
      // ignore
    } finally {
      setMenuLoading(false);
    }
  }, [supabase]);

  // load inspection templates (mine + public)
  const loadTemplates = useCallback(async () => {
    setTemplatesLoading(true);
    try {
      const { data: me } = await supabase.auth.getUser();
      const uid = me?.user?.id ?? null;

      const minePromise = uid
        ? supabase
            .from("inspection_templates")
            .select("*")
            .eq("user_id", uid)
            .order("created_at", { ascending: false })
        : Promise.resolve({ data: [] as TemplateRow[], error: null });

      const sharedPromise = supabase
        .from("inspection_templates")
        .select("*")
        .eq("is_public", true)
        .order("created_at", { ascending: false });

      const [{ data: mineRaw }, { data: sharedRaw }] = await Promise.all([
        minePromise,
        sharedPromise,
      ]);

      setTemplates([
        ...(Array.isArray(mineRaw) ? mineRaw : []),
        ...(Array.isArray(sharedRaw) ? sharedRaw : []),
      ]);
    } catch {
      // ignore
    } finally {
      setTemplatesLoading(false);
    }
  }, [supabase]);

  // initial loads
  useEffect(() => {
    void loadMenuItems();
    void loadTemplates();
  }, [loadMenuItems, loadTemplates]);

  // ============================================================
  // add line (menu or template)
  // ============================================================
  async function addMenuItem(params: AddMenuParams): Promise<string | null> {
    if (!shopReady) return null;

    setAddingId(params.kind === "template" ? params.template.id : params.name);
    try {
      await ensureShopContext(shopId);

      // template-backed line
      if (params.kind === "template") {
        const line: WorkOrderLineInsert & { inspection_template_id?: string | null } = {
          work_order_id: workOrderId,
          vehicle_id: vehicleId,
          description:
            params.name ?? params.template.template_name ?? "Inspection",
          job_type: "inspection",
          labor_time:
            params.laborHours ??
            (typeof params.template.labor_hours === "number"
              ? params.template.labor_hours
              : null),
          status: "awaiting",
          priority: 3,
          notes: params.template.description ?? null,
          shop_id: shopId!,
          inspection_template_id: params.template.id,
        };

        const { data, error } = await supabase
          .from("work_order_lines")
          .insert(line)
          .select("id")
          .single();

        if (error) throw error;

        window.dispatchEvent(new CustomEvent("wo:line-added"));
        toast.success("Inspection added");
        return data?.id ?? null;
      }

      // normal branch
      const line: WorkOrderLineInsert = {
        work_order_id: workOrderId,
        vehicle_id: vehicleId,
        description: params.name,
        job_type: params.jobType,
        labor_time: params.laborHours ?? null,
        status: "awaiting",
        priority: 3,
        notes: params.notes ?? null,
        shop_id: shopId!,
      };

      const { data, error } = await supabase
        .from("work_order_lines")
        .insert(line)
        .select("id")
        .single();

      if (error) throw error;

      if (params.partsToAllocate && params.partsToAllocate.length && data?.id) {
        await autoAllocateExplicitParts(params.partsToAllocate, data.id);
      }

      window.dispatchEvent(new CustomEvent("wo:line-added"));
      toast.success(
        params.source === "ai"
          ? "AI suggestion added"
          : params.source === "menu_item"
          ? "Menu item added"
          : "Job added",
      );

      return params.returnLineId ? (data?.id ?? null) : null;
    } catch (e: unknown) {
      const msg = e instanceof Error ? e.message : "Failed to add job.";
      lastSetShopId.current = null;
      toast.error(msg);
      return null;
    } finally {
      setAddingId(null);
    }
  }

  // ---------- allocation helpers ----------
  type MenuItemPartRow = {
    id: string;
    name: string | null;
    sku: string | null;
    quantity: number | null;
    unit_cost: number | null;
  };

  async function findPartIdForShop({
    sku,
    name,
    shop,
  }: {
    sku?: string | null;
    name?: string | null;
    shop: string;
  }): Promise<string | null> {
    if (sku) {
      const bySku = await supabase
        .from("parts")
        .select("id")
        .eq("shop_id", shop)
        .eq("sku", sku)
        .limit(1)
        .maybeSingle();
      if (!bySku.error && bySku.data?.id) return bySku.data.id;
    }
    if (name) {
      const byName = await supabase
        .from("parts")
        .select("id")
        .eq("shop_id", shop)
        .ilike("name", name)
        .limit(1)
        .maybeSingle();
      if (byName.data?.id) return byName.data.id;
    }
    return null;
  }

  async function pickDefaultLocationId(
    partId: string,
    shop: string,
  ): Promise<string | null> {
    const withStock = await supabase
      .from("part_stock")
      .select("location_id, qty")
      .eq("part_id", partId)
      .order("qty", { ascending: false })
      .limit(1);

    if (!withStock.error && withStock.data?.length) {
      return withStock.data[0].location_id as unknown as string;
    }

    const anyLoc = await supabase
      .from("stock_locations")
      .select("id")
      .eq("shop_id", shop)
      .order("created_at", { ascending: true })
      .limit(1)
      .maybeSingle();

    return anyLoc.data?.id ?? null;
  }

  async function autoAllocateMenuParts(
    menuItemId: string,
    workOrderLineId: string,
  ) {
    if (!shopId) return;

    const { data: rows, error } = await supabase
      .from("menu_item_parts")
      .select("id, name, sku, quantity, unit_cost")
      .eq("menu_item_id", menuItemId);

    if (error) {
      toast.message("Added job, but couldn't read menu parts.");
      return;
    }

    const mParts = (rows ?? []) as MenuItemPartRow[];
    const allocations: {
      work_order_line_id: string;
      part_id: string;
      location_id: string;
      qty: number;
    }[] = [];

    for (const p of mParts) {
      const qty =
        typeof p.quantity === "number" && p.quantity > 0 ? p.quantity : 0;
      if (!qty) continue;

      const partId = await findPartIdForShop({
        sku: p.sku ?? undefined,
        name: p.name ?? undefined,
        shop: shopId,
      });
      if (!partId) {
        toast.message(
          `Skipped "${p.name ?? p.sku ?? "part"}" (not in Parts).`,
        );
        continue;
      }
      const locId = await pickDefaultLocationId(partId, shopId);
      if (!locId) {
        toast.message(
          `Skipped "${p.name ?? p.sku ?? "part"}" (no stock location).`,
        );
        continue;
      }
      allocations.push({
        work_order_line_id: workOrderLineId,
        part_id: partId,
        location_id: locId,
        qty,
      });
    }

    if (!allocations.length) return;

    const { error: allocErr } = await supabase
      .from("work_order_part_allocations")
      .insert(allocations);
    if (allocErr) {
      toast.warning("Job added, but parts couldn't be allocated.");
    } else {
      window.dispatchEvent(new CustomEvent("wo:parts-used"));
      toast.success(
        `Allocated ${allocations.length} part${
          allocations.length > 1 ? "s" : ""
        }`,
      );
    }
  }

  async function autoAllocateExplicitParts(
    list: PartToAllocate[],
    workOrderLineId: string,
  ) {
    if (!shopId || !list.length) return;

    const allocations: {
      work_order_line_id: string;
      part_id: string;
      location_id: string;
      qty: number;
    }[] = [];

    for (const raw of list) {
      const qty = typeof raw.qty === "number" && raw.qty > 0 ? raw.qty : 0;
      if (!qty) continue;

      const partId = await findPartIdForShop({
        sku: raw.sku ?? undefined,
        name: raw.name ?? undefined,
        shop: shopId,
      });
      if (!partId) continue;

      const locId = await pickDefaultLocationId(partId, shopId);
      if (!locId) continue;

      allocations.push({
        work_order_line_id: workOrderLineId,
        part_id: partId,
        location_id: locId,
        qty,
      });
    }

    if (!allocations.length) return;
    const { error } = await supabase
      .from("work_order_part_allocations")
      .insert(allocations);
    if (!error) window.dispatchEvent(new CustomEvent("wo:parts-used"));
  }

  // tiny wrappers
  async function addPackage(pkg: PackageDef) {
    await addMenuItem({
      kind: "normal",
      name: pkg.name,
      jobType: pkg.jobType === "inspection" ? "inspection" : "maintenance",
      laborHours: pkg.estLaborHours ?? null,
      notes: pkg.summary,
      source: "package",
    });
  }

  async function addSavedMenuItem(mi: MenuItemRow) {
    const lineId = await addMenuItem({
      kind: "normal",
      name: mi.name ?? "Service",
      jobType: "maintenance",
      laborHours:
        typeof mi.labor_time === "number"
          ? mi.labor_time
          : // fallback in case you add labor_hours to menu_items later
            null,
      notes: mi.description ?? null,
      source: "menu_item",
      returnLineId: true,
    });
    if (lineId && mi.id) {
      await autoAllocateMenuParts(mi.id, lineId);
    }
  }

  async function addTemplateAsLine(t: TemplateRow) {
    await addMenuItem({
      kind: "template",
      template: t,
    });
  }

  // AI
  async function runAiSuggest() {
    if (!aiPrompt.trim()) return;
    setAiBusy(true);
    try {
      const res = await fetch("/api/ai/menu/suggest", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: aiPrompt,
          vehicle: vehicle
            ? {
                year: vehicle.year,
                make: vehicle.make,
                model: vehicle.model,
              }
            : null,
        }),
      });
      const j = (await res.json()) as {
        items?: {
          name: string;
          jobType: JobType;
          laborHours?: number | null;
          notes?: string | null;
          parts?: PartToAllocate[];
        }[];
        error?: string;
      };
      if (!res.ok || j.error) throw new Error(j.error || "AI suggestion failed");

      const items = (j.items ?? []).slice(0, 5);
      if (!items.length) {
        toast.message("No suggestions returned.");
        return;
      }

      for (const it of items) {
        await addMenuItem({
          kind: "normal",
          name: it.name,
          jobType: it.jobType,
          laborHours: it.laborHours ?? null,
          notes: it.notes ?? null,
          partsToAllocate: Array.isArray(it.parts) ? it.parts : undefined,
          source: "ai",
        });
      }
      setAiOpen(false);
      setAiPrompt("");
    } catch (e: unknown) {
      const msg =
        e instanceof Error ? e.message : "Could not get suggestions.";
      toast.error(msg);
    } finally {
      setAiBusy(false);
    }
  }

  // ---------------------------------------------------------------------------
  // UI
  // ---------------------------------------------------------------------------
  const vehicleLabel =
    vehicle && (vehicle.year || vehicle.make || vehicle.model)
      ? `${vehicle.year ?? ""} ${vehicle.make ?? ""} ${vehicle.model ?? ""}`.trim()
      : vehicle?.license_plate
      ? `Plate ${vehicle.license_plate}`
      : null;

  return (
    <div className="space-y-5 text-white">
      {/* Header / context */}
      <div className="rounded-lg border border-neutral-800 bg-neutral-950/80 px-3 py-3 sm:px-4 sm:py-3">
        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div className="space-y-1">
            <div className="flex items-center gap-2">
              <h3 className="text-sm font-semibold text-orange-400">
                Quick Add Jobs
              </h3>
              <span className="rounded-full border border-neutral-700 bg-neutral-900 px-2 py-0.5 text-[10px] font-mono text-neutral-300">
                WO {workOrderId.slice(0, 8)}…
              </span>
            </div>
            {vehicleLabel && (
              <p className="text-[11px] text-neutral-400">
                Vehicle:&nbsp;
                <span className="font-medium text-neutral-200">
                  {vehicleLabel}
                </span>
              </p>
            )}
            {!vehicleLabel && (
              <p className="text-[11px] text-neutral-500">
                Add lines now — you can update vehicle details later.
              </p>
            )}
          </div>

          <div className="flex flex-wrap items-center justify-end gap-2">
            <button
              type="button"
              onClick={() =>
                router.push(`/work-orders/quote-review?woId=${workOrderId}`)
              }
              className="rounded-md border border-neutral-700 bg-neutral-900 px-3 py-1.5 text-xs sm:text-sm text-neutral-100 hover:border-orange-500 hover:bg-neutral-800"
            >
              Review quote
              {typeof woLineCount === "number" && woLineCount > 0
                ? ` (${woLineCount})`
                : ""}
            </button>
            <button
              type="button"
              onClick={() => setAiOpen(true)}
              className="rounded-md border border-blue-600 bg-neutral-950 px-3 py-1.5 text-xs sm:text-sm text-blue-300 hover:bg-blue-900/30"
              title="Describe work and let AI suggest service lines"
            >
              AI Suggest
            </button>
          </div>
        </div>
      </div>

      {/* Packages */}
      <div className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3 sm:p-4">
        <div className="mb-2 flex items-center justify-between gap-2">
          <h4 className="text-xs font-semibold uppercase tracking-wide text-neutral-300">
            Packages
          </h4>
          <p className="text-[10px] text-neutral-500">
            Common services with pre-set labor & notes.
          </p>
        </div>
        <div className="grid gap-2 sm:grid-cols-2">
          {packages.map((p) => (
            <button
              type="button"
              key={p.id}
              onClick={() => addPackage(p)}
              disabled={addingId === p.id || !shopReady}
              className="flex flex-col rounded-md border border-neutral-800 bg-neutral-950 p-3 text-left text-sm hover:border-orange-500/70 hover:bg-neutral-900 disabled:opacity-60"
              title={p.summary}
            >
              <div className="flex items-center justify-between gap-2">
                <span className="font-medium text-neutral-50">{p.name}</span>
                <span className="rounded-full border border-neutral-700 bg-neutral-900 px-2 py-0.5 text-[10px] uppercase tracking-wide text-neutral-300">
                  {p.jobType}
                </span>
              </div>
              <div className="mt-1 text-xs text-neutral-400">
                {p.estLaborHours != null
                  ? `~${p.estLaborHours.toFixed(1)}h`
                  : "Labor TBD"}
              </div>
              <div className="mt-1 line-clamp-2 text-[11px] text-neutral-500">
                {p.summary}
              </div>
            </button>
          ))}
        </div>
      </div>

      {/* Inspection templates */}
      <div className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3 sm:p-4">
        <div className="mb-2 flex items-center justify-between gap-2">
          <h4 className="text-xs font-semibold uppercase tracking-wide text-neutral-300">
            Inspection Templates
          </h4>
          <p className="text-[10px] text-neutral-500">
            Saved/standard inspections you can attach as jobs.
          </p>
        </div>
        <div className="grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
          {templatesLoading && (
            <div className="col-span-full w-full py-2 text-center text-sm text-neutral-400">
              Loading templates…
            </div>
          )}
          {!templatesLoading &&
            (templates.length ? (
              templates.slice(0, 9).map((t) => (
                <button
                  key={t.id}
                  type="button"
                  onClick={() => addTemplateAsLine(t)}
                  disabled={addingId === t.id || !shopReady}
                  className="flex flex-col rounded-md border border-neutral-800 bg-neutral-950 p-3 text-left text-sm hover:border-orange-500/70 hover:bg-neutral-900 disabled:opacity-60"
                  title={t.description ?? undefined}
                >
                  <span className="font-medium text-neutral-50">
                    {t.template_name ?? "Inspection"}
                  </span>
                  <div className="mt-1 text-xs text-neutral-400">
                    inspection •{" "}
                    {typeof t.labor_hours === "number"
                      ? `${t.labor_hours.toFixed(1)}h`
                      : "Labor TBD"}
                  </div>
                  {t.description && (
                    <div className="mt-1 line-clamp-2 text-[11px] text-neutral-500">
                      {t.description}
                    </div>
                  )}
                </button>
              ))
            ) : (
              <div className="col-span-full w-full py-2 text-center text-sm text-neutral-400">
                No templates yet.
              </div>
            ))}
        </div>
      </div>

      {/* From My Menu */}
      <div className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3 sm:p-4">
        <div className="mb-2 flex items-center justify-between gap-2">
          <h4 className="text-xs font-semibold uppercase tracking-wide text-neutral-300">
            From My Menu
          </h4>
          <p className="text-[10px] text-neutral-500">
            Saved services — great for repeat jobs.
          </p>
        </div>
        <div className="grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
          {menuLoading && (
            <div className="col-span-full w-full py-2 text-center text-sm text-neutral-400">
              Loading menu items…
            </div>
          )}
          {!menuLoading &&
            (menuItems.length ? (
              menuItems.slice(0, 9).map((mi) => (
                <button
                  type="button"
                  key={mi.id}
                  onClick={() => addSavedMenuItem(mi)}
                  disabled={addingId === (mi.name ?? "") || !shopReady}
                  className="flex flex-col rounded-md border border-neutral-800 bg-neutral-950 p-3 text-left text-sm hover:border-orange-500/70 hover:bg-neutral-900 disabled:opacity-60"
                  title={mi.description ?? undefined}
                >
                  <span className="font-medium text-neutral-50">
                    {mi.name}
                  </span>
                  <div className="mt-1 text-xs text-neutral-400">
                    {typeof mi.labor_time === "number"
                      ? `${mi.labor_time.toFixed(1)}h`
                      : "Labor TBD"}{" "}
                    •{" "}
                    {typeof mi.total_price === "number"
                      ? `$${mi.total_price.toFixed(0)}`
                      : "No price"}
                  </div>
                  {mi.description && (
                    <div className="mt-1 line-clamp-2 text-[11px] text-neutral-500">
                      {mi.description}
                    </div>
                  )}
                </button>
              ))
            ) : (
              <div className="col-span-full w-full py-2 text-center text-sm text-neutral-400">
                No saved menu items yet.
              </div>
            ))}
        </div>
      </div>

      {/* AI modal */}
      {aiOpen && (
        <div className="fixed inset-0 z-[300] grid place-items-center">
          <div
            className="absolute inset-0 bg-black/70 backdrop-blur-sm"
            onClick={() => setAiOpen(false)}
          />
          <div
            className="relative z-[310] w-full max-w-xl rounded-lg border border-orange-400 bg-neutral-950 p-4 sm:p-5 text-white shadow-xl"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="mb-3 flex items-center justify-between gap-2">
              <div>
                <div className="text-sm font-semibold text-orange-400">
                  AI: Suggest Services
                </div>
                <p className="text-[11px] text-neutral-400">
                  Describe the concern; we’ll suggest jobs and add them to this
                  work order.
                </p>
              </div>
              <button
                type="button"
                className="rounded-md border border-neutral-700 px-2 py-1 text-xs text-neutral-200 hover:bg-neutral-800"
                onClick={() => setAiOpen(false)}
              >
                ✕
              </button>
            </div>

            {vehicleLabel && (
              <div className="mb-2 rounded-md border border-neutral-800 bg-neutral-900/70 px-3 py-1.5 text-[11px] text-neutral-300">
                Using context for:{" "}
                <span className="font-medium text-neutral-100">
                  {vehicleLabel}
                </span>
              </div>
            )}

            <textarea
              rows={4}
              className="w-full rounded-md border border-neutral-700 bg-neutral-900 p-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-400 focus:outline-none"
              placeholder="Example: Customer reports vibration at highway speeds, no dash lights on. Recently replaced front tires."
              value={aiPrompt}
              onChange={(e) => setAiPrompt(e.target.value)}
            />
            <div className="mt-3 flex justify-end gap-2">
              <button
                type="button"
                className="rounded-md border border-neutral-700 px-3 py-1.5 text-xs sm:text-sm text-neutral-200 hover:bg-neutral-800"
                onClick={() => setAiOpen(false)}
              >
                Cancel
              </button>
              <button
                type="button"
                disabled={aiBusy}
                className="rounded-md border border-blue-600 bg-neutral-950 px-3 py-1.5 text-xs sm:text-sm text-blue-300 hover:bg-blue-900/30 disabled:opacity-60"
                onClick={runAiSuggest}
              >
                {aiBusy ? "Thinking…" : "Suggest & Add"}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/components/TechPanel.tsx */
/* =============================== */

"use client";

import * as React from "react";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
export type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
export type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
export type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];
export type Customer = DB["public"]["Tables"]["customers"]["Row"];

export default function TechPanel({
  workOrder,
  vehicle,
  customer,
  lines,
}: {
  workOrder: WorkOrder;
  vehicle: Vehicle | null;
  customer: Customer | null;
  lines: WorkOrderLine[];
}) {
  const vehicleText = vehicle
    ? `${vehicle.year ?? ""} ${vehicle.make ?? ""} ${vehicle.model ?? ""}${
        vehicle.license_plate ? ` (${vehicle.license_plate})` : ""
      }`.trim()
    : "—";

  const customerText = customer
    ? [customer.first_name ?? "", customer.last_name ?? ""].filter(Boolean).join(" ").trim() || "—"
    : "—";

  return (
    <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
      <div className="mb-2 font-semibold text-orange-400">Tech Panel</div>
      <p className="text-sm text-neutral-300">
        Work on <strong>{workOrder.custom_id || workOrder.id.slice(0, 8)}</strong>.{" "}
        Vehicle: {vehicleText} · Customer: {customerText}.
      </p>
      <p className="mt-2 text-sm text-neutral-400">Jobs: {lines.length}</p>

      <div className="mt-3">
        <button
          onClick={() => window.location.reload()}
          className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:border-orange-500"
        >
          Refresh
        </button>
      </div>

      <div className="mt-4 text-xs text-neutral-500">
        Placeholder: wire your existing tech UI (punch, cause/correction, add job/quote, AI suggestions, photos) here.
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: src/profixiq/knowledge/base.ts */
/* =============================== */

/**
 * Lightweight, hard-coded knowledge base for the ProFixIQ agent.
 *
 * This is intentionally simple and file-based so we can:
 *  - keep core concepts/versioning in git
 *  - hydrate vector search or prompt scaffolding for the agent
 *
 * Later we can replace/augment this with DB-backed content.
 */

export type KnowledgeTag =
  | "ai"
  | "architecture"
  | "work_orders"
  | "inspections"
  | "payments"
  | "integrations"
  | "support"
  | "pricing";

export interface KnowledgeItem {
  id: string;
  title: string;
  body: string;
  tags: KnowledgeTag[];
  /**
   * Optional link back into the app (e.g. settings page, report, etc.)
   * so the agent can point users to the right screen.
   */
  appPath?: string;
}

/**
 * Seed knowledge items. Keep these high-level and durable; ephemeral,
 * shop-specific stuff belongs in the DB, not here.
 */
export const ProFixIQKnowledgeBase: KnowledgeItem[] = [
  {
    id: "ai-overview",
    title: "ProFixIQ AI overview",
    body: [
      "ProFixIQ uses AI to assist with inspections, quotes, and work orders.",
      "Key AI features include:",
      "- AI quote suggestions based on menu items and past work.",
      "- Inspection-to-quote automation, turning failed items into jobs.",
      "- Work-order and invoice review to highlight inconsistencies.",
      "- Future TechBot / InspectionBot style chat helpers for technicians.",
      "",
      "AI should never silently override user choices. Human edits, approvals,",
      "and overrides are always the source of truth and are used as training data.",
    ].join(" "),
    tags: ["ai", "architecture"],
    appPath: "/ai",
  },
  {
    id: "work-orders-core",
    title: "Work orders & job lines",
    body: [
      "A work order represents a single visit/RO. Individual jobs are tracked",
      "as work_order_lines, which may be created manually, from inspections,",
      "or from saved menu items. Approval state and technician assignment live",
      "on the line, not the work order.",
    ].join(" "),
    tags: ["work_orders", "architecture"],
    appPath: "/work-orders",
  },
  {
    id: "inspections-core",
    title: "Inspections & results",
    body: [
      "Inspections are built from configurable templates. Each template has",
      "sections and items with statuses like ok, fail, recommend, and na.",
      "Inspection results can be converted into quote/work-order lines by",
      "mapping failed items to saved menu items or ad-hoc jobs.",
    ].join(" "),
    tags: ["inspections", "ai"],
    appPath: "/inspections",
  },
  {
    id: "payments-core",
    title: "Stripe subscriptions & payments",
    body: [
      "ProFixIQ uses Stripe for subscription billing and card payments.",
      "Each shop has a Stripe customer record tied to its ProFixIQ account.",
      "Invoices and receipts are generated in Stripe but surfaced inside the app.",
    ].join(" "),
    tags: ["payments", "integrations"],
    appPath: "/settings/billing",
  },
];


/* =============================== */
/* FILE: app/parts/requests/[id]/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type Request = DB["public"]["Tables"]["part_requests"]["Row"];
type Item = DB["public"]["Tables"]["part_request_items"]["Row"] & {
  // schema is catching up
  work_order_line_id?: string | null;
  markup_pct?: number | null;
  qty?: number | null;
};
type Status = Request["status"];
type Part = DB["public"]["Tables"]["parts"]["Row"];

const DEFAULT_MARKUP = 30; // %

export default function PartsRequestDetail() {
  const { id } = useParams<{ id: string }>();
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const router = useRouter();

  const [req, setReq] = useState<Request | null>(null);
  const [items, setItems] = useState<Item[]>([]);
  const [loading, setLoading] = useState(true);
  const [parts, setParts] = useState<Part[]>([]);
  const [markupPct, setMarkupPct] = useState<Record<string, number>>({});
  const [savedRows, setSavedRows] = useState<Record<string, boolean>>({});
  // per-line manual part inputs
  const [manualParts, setManualParts] = useState<
    Record<string, { name: string; sku: string }>
  >({});

  async function load() {
    setLoading(true);

    // header
    const { data: r, error: rErr } = await supabase
      .from("part_requests")
      .select("*")
      .eq("id", id)
      .maybeSingle();
    if (rErr) toast.error(rErr.message);
    setReq(r ?? null);

    // items
    const { data: its, error: itErr } = await supabase
      .from("part_request_items")
      .select("*")
      .eq("request_id", id);
    if (itErr) toast.error(itErr.message);
    const itemsList = (its ?? []) as Item[];
    setItems(itemsList);

    // inventory
    if (r?.shop_id) {
      const { data: ps } = await supabase
        .from("parts")
        .select("*")
        .eq("shop_id", r.shop_id)
        .order("name")
        .limit(500);
      setParts(ps ?? []);
    } else {
      setParts([]);
    }

    // markup init
    const m: Record<string, number> = {};
    for (const it of itemsList) {
      m[it.id] =
        typeof it.markup_pct === "number" && !Number.isNaN(it.markup_pct)
          ? it.markup_pct
          : DEFAULT_MARKUP;
    }
    setMarkupPct(m);

    // clear saved flags on fresh load
    setSavedRows({});

    setLoading(false);
  }

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id]);

  function getLineIdFromItems(list: Item[]): string | null {
    for (const it of list) {
      if (it.work_order_line_id) return it.work_order_line_id;
    }
    return null;
  }

  async function setStatus(s: Status) {
    const { error } = await supabase.rpc("set_part_request_status", {
      p_request: id,
      p_status: s,
    });
    if (error) {
      toast.error(error.message);
      return;
    }

    if (s === "quoted") {
      const lineId = getLineIdFromItems(items);
      if (lineId) {
        // mark line quoted
        const { error: wolErr } = await supabase
          .from("work_order_lines")
          .update({
            status: "quoted",
          } as DB["public"]["Tables"]["work_order_lines"]["Update"])
          .eq("id", lineId);
        if (wolErr) {
          console.warn("could not set line to quoted:", wolErr.message);
        }

        // save to menu items
        try {
          const res = await fetch("/api/menu-items/save-from-line", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ workOrderLineId: lineId }),
          });
          const j = (await res.json().catch(() => null)) as {
            ok?: boolean;
            error?: string;
          } | null;
          if (!res.ok) {
            console.warn("menu save failed:", j?.error);
            toast.warning("Quoted, but couldn’t save to menu items.");
          } else {
            toast.success("Quoted and saved to menu items.");
          }
        } catch (e) {
          console.warn("menu save error:", e);
          toast.warning("Quoted, but couldn’t save to menu items.");
        }
      } else {
        toast.success("Parts request marked as quoted.");
      }
    } else {
      toast.success(`Parts request marked as ${s}.`);
    }

    await load();
  }

  async function saveLine(it: Item) {
    const qty =
      typeof it.qty === "number" && !Number.isNaN(it.qty) ? it.qty : null;
    if (!qty || qty <= 0) {
      toast.error("Enter a quantity greater than 0 before saving.");
      return;
    }

    const cost =
      typeof it.quoted_price === "number" && !Number.isNaN(it.quoted_price)
        ? it.quoted_price
        : 0;
    const m = markupPct[it.id] ?? DEFAULT_MARKUP;

    const { error } = await supabase
      .from("part_request_items")
      .update({
        vendor: it.vendor ?? null,
        quoted_price: cost,
        qty,
        markup_pct: m,
      })
      .eq("id", it.id);

    if (error) {
      toast.error(error.message);
      return;
    }

    setSavedRows((prev) => ({ ...prev, [it.id]: true }));
    toast.success("Line saved");
  }

  async function attachPartToItem(itemId: string, partId: string) {
    const p = parts.find((x) => x.id === partId);
    const desc = p?.name ?? "Part";

    const { error } = await supabase
      .from("part_request_items")
      .update({
        part_id: partId,
        description: desc,
      })
      .eq("id", itemId);

    if (error) {
      console.warn("attachPartToItem failed:", error.message);
      toast.error("Cannot attach part — check RLS.");
    } else {
      // change → unsave
      setSavedRows((prev) => ({ ...prev, [itemId]: false }));
      await load();
    }
  }

  // manual: create part in inventory, then attach
  async function createManualPartAndAttach(
    itemId: string,
    name: string,
    sku: string
  ) {
    const item = items.find((x) => x.id === itemId);
    if (!item) return;
    if (!req?.shop_id) {
      toast.error("Cannot create part — missing shop.");
      return;
    }
    if (!name.trim()) {
      toast.error("Enter a name for the part.");
      return;
    }

    // create part in inventory
    const { data: inserted, error } = await supabase
      .from("parts")
      .insert({
        shop_id: req.shop_id,
        name: name.trim(),
        sku: sku.trim() || null,
      })
      .select("*")
      .maybeSingle<Part>();

    if (error) {
      toast.error(error.message);
      return;
    }

    if (!inserted) {
      toast.error("Unable to create part.");
      return;
    }

    // attach to item
    const { error: attachErr } = await supabase
      .from("part_request_items")
      .update({
        part_id: inserted.id,
        description: inserted.name ?? name.trim(),
      })
      .eq("id", itemId);

    if (attachErr) {
      toast.error(attachErr.message);
      return;
    }

    toast.success("Part created and attached.");
    // clear manual fields for that line
    setManualParts((prev) => {
      const copy = { ...prev };
      delete copy[itemId];
      return copy;
    });

    // reload so the new part shows up in the select too
    await load();
  }

  const grandTotals = (() => {
    let sum = 0;
    for (const it of items) {
      const cost =
        typeof it.quoted_price === "number" && !Number.isNaN(it.quoted_price)
          ? it.quoted_price
          : 0;
      const m = markupPct[it.id] ?? DEFAULT_MARKUP;
      const unitSell = cost * (1 + m / 100);
      const qty =
        typeof it.qty === "number" && it.qty > 0 ? Number(it.qty) : 0;
      sum += unitSell * qty;
    }
    return sum;
  })();

  return (
    <div className="p-6 text-white space-y-4">
      <button
        className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
        onClick={() => router.back()}
      >
        ← Back
      </button>

      {loading || !req ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-neutral-400">
          Loading…
        </div>
      ) : (
        <>
          {/* header */}
          <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
            <div className="flex flex-wrap items-center justify-between gap-2">
              <div>
                <div className="text-xl font-semibold">
                  Request #{req.id.slice(0, 8)}
                </div>
                <div className="text-sm text-neutral-400">
                  WO: {req.work_order_id ?? "—"} ·{" "}
                  {req.created_at
                    ? new Date(req.created_at).toLocaleString()
                    : "—"}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-sm text-neutral-300 capitalize">
                  Status: {req.status}
                </span>
                {req.status !== "approved" && (
                  <button
                    className="rounded border border-blue-600 text-blue-300 px-3 py-1.5 text-sm hover:bg-blue-900/20"
                    onClick={() => void setStatus("approved")}
                  >
                    Mark Approved
                  </button>
                )}
                {req.status !== "quoted" && (
                  <button
                    className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10"
                    onClick={() => void setStatus("quoted")}
                  >
                    Mark Quoted
                  </button>
                )}
              </div>
            </div>
          </div>

          {/* table */}
          <div className="rounded border border-neutral-800 overflow-hidden">
            <table className="w-full text-sm">
              <thead className="bg-neutral-900 text-neutral-400">
                <tr>
                  <th className="p-2 text-left">Inventory</th>
                  <th className="p-2 text-left">Description</th>
                  <th className="p-2 text-right">Qty</th>
                  <th className="p-2 text-left">Vendor</th>
                  <th className="p-2 text-right">Cost (unit)</th>
                  <th className="p-2 text-right">Markup %</th>
                  <th className="p-2 text-right">Sell (unit)</th>
                  <th className="p-2 text-right">Line total</th>
                  <th className="p-2 w-28"></th>
                </tr>
              </thead>
              <tbody>
                {items.map((it) => {
                  const cost =
                    typeof it.quoted_price === "number" &&
                    !Number.isNaN(it.quoted_price)
                      ? it.quoted_price
                      : 0;
                  const m = markupPct[it.id] ?? DEFAULT_MARKUP;
                  const qty =
                    typeof it.qty === "number" && it.qty > 0 ? it.qty : null;
                  const unitSell = cost * (1 + m / 100);
                  const lineTotal = unitSell * (qty ?? 0);
                  const isSaved = savedRows[it.id] === true;

                  const manual = manualParts[it.id] || { name: "", sku: "" };

                  return (
                    <tr
                      key={it.id}
                      className={`border-t border-neutral-800 ${
                        isSaved ? "bg-neutral-900/50 text-neutral-400" : ""
                      }`}
                    >
                      <td className="p-2 align-top">
                        <div className="flex flex-col gap-1">
                          <select
                            className="w-40 rounded border border-neutral-700 bg-neutral-900 p-1 text-xs disabled:opacity-50"
                            value={it.part_id ?? ""}
                            onChange={(e) => {
                              setSavedRows((prev) => ({
                                ...prev,
                                [it.id]: false,
                              }));
                              void attachPartToItem(it.id, e.target.value);
                            }}
                            disabled={isSaved}
                          >
                            <option value="">— select —</option>
                            {parts.map((p) => (
                              <option key={p.id} value={p.id as string}>
                                {p.sku ? `${p.sku} — ${p.name}` : p.name}
                              </option>
                            ))}
                          </select>

                          {/* manual entry */}
                          <div className="flex gap-1">
                            <input
                              className="flex-1 rounded border border-neutral-700 bg-neutral-900 p-1 text-xs disabled:opacity-50"
                              placeholder="Manual part name"
                              value={manual.name}
                              onChange={(e) =>
                                setManualParts((prev) => ({
                                  ...prev,
                                  [it.id]: {
                                    name: e.target.value,
                                    sku: prev[it.id]?.sku ?? "",
                                  },
                                }))
                              }
                              disabled={isSaved}
                            />
                            <input
                              className="w-20 rounded border border-neutral-700 bg-neutral-900 p-1 text-xs disabled:opacity-50"
                              placeholder="SKU"
                              value={manual.sku}
                              onChange={(e) =>
                                setManualParts((prev) => ({
                                  ...prev,
                                  [it.id]: {
                                    name: prev[it.id]?.name ?? "",
                                    sku: e.target.value,
                                  },
                                }))
                              }
                              disabled={isSaved}
                            />
                          </div>
                          <button
                            className="rounded border border-neutral-700 bg-neutral-900 px-2 py-0.5 text-xs hover:bg-neutral-800 disabled:opacity-50"
                            onClick={() =>
                              void createManualPartAndAttach(
                                it.id,
                                manual.name,
                                manual.sku
                              )
                            }
                            disabled={isSaved}
                          >
                            Add & attach
                          </button>
                        </div>
                      </td>
                      <td className="p-2 align-top">{it.description}</td>
                      <td className="p-2 text-right align-top">
                        <input
                          type="number"
                          min={1}
                          step={1}
                          className="w-16 rounded border border-neutral-700 bg-neutral-900 p-1 text-right disabled:opacity-50"
                          value={qty ?? ""} // allow empty
                          onChange={(e) => {
                            const raw = e.target.value;
                            setItems((prev) => {
                              return prev.map((x) => {
                                if (x.id !== it.id) return x;
                                return {
                                  ...x,
                                  qty: raw === "" ? null : Number(raw),
                                } as Item;
                              });
                            });
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 align-top">
                        <input
                          className="w-32 rounded border border-neutral-700 bg-neutral-900 p-1 disabled:opacity-50"
                          value={it.vendor ?? ""}
                          onChange={(e) => {
                            const v = e.target.value;
                            setItems((prev) =>
                              prev.map((x) =>
                                x.id === it.id ? { ...x, vendor: v } : x
                              )
                            );
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 text-right align-top">
                        <input
                          type="number"
                          step={0.01}
                          className="w-24 rounded border border-neutral-700 bg-neutral-900 p-1 text-right disabled:opacity-50"
                          value={cost === 0 ? "" : cost}
                          onChange={(e) => {
                            const raw = e.target.value;
                            const v = raw === "" ? null : Number(raw);
                            setItems((prev) =>
                              prev.map((x) =>
                                x.id === it.id ? { ...x, quoted_price: v } : x
                              )
                            );
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 text-right align-top">
                        <input
                          type="number"
                          step={1}
                          className="w-20 rounded border border-neutral-700 bg-neutral-900 p-1 text-right disabled:opacity-50"
                          value={m}
                          onChange={(e) => {
                            setMarkupPct((prev) => ({
                              ...prev,
                              [it.id]: Math.max(
                                0,
                                Number(e.target.value || DEFAULT_MARKUP)
                              ),
                            }));
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 text-right tabular-nums align-top">
                        {unitSell.toFixed(2)}
                      </td>
                      <td className="p-2 text-right tabular-nums align-top">
                        {lineTotal.toFixed(2)}
                      </td>
                      <td className="p-2 text-right align-top">
                        <button
                          className={`rounded border px-2 py-1 text-xs ${
                            isSaved
                              ? "border-neutral-700 bg-neutral-800/60 text-neutral-300 cursor-default"
                              : "border-neutral-700 hover:bg-neutral-800"
                          }`}
                          onClick={() => !isSaved && void saveLine(it)}
                          disabled={isSaved}
                        >
                          {isSaved ? "Saved" : "Save"}
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
              <tfoot>
                <tr className="bg-neutral-900/50">
                  <td className="p-2 text-right" colSpan={7}>
                    <span className="text-sm text-neutral-300">
                      Total (with markup)
                    </span>
                  </td>
                  <td className="p-2 text-right tabular-nums font-semibold">
                    {grandTotals.toFixed(2)}
                  </td>
                  <td />
                </tr>
              </tfoot>
            </table>
          </div>
        </>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: app/parts/requests/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type Request = DB["public"]["Tables"]["part_requests"]["Row"];
type Item = DB["public"]["Tables"]["part_request_items"]["Row"];

const STATUSES: Request["status"][] = [
  "requested",
  "quoted",
  "approved",
  "fulfilled",
  "rejected",
  "cancelled",
];

export default function PartsRequestsPage() {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [byStatus, setByStatus] = useState<
    Record<Request["status"], (Request & { items: Item[] })[]>
  >({
    requested: [],
    quoted: [],
    approved: [],
    fulfilled: [],
    rejected: [],
    cancelled: [],
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    void (async () => {
      setLoading(true);

      // 1) fetch all requests
      const { data: reqs, error } = await supabase
        .from("part_requests")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) {
        console.error("load part_requests failed:", error.message);
        setLoading(false);
        return;
      }

      const requestList = reqs ?? [];
      const ids = requestList.map((r) => r.id);

      // 2) fetch all items for these requests
      const itemsMap: Record<string, Item[]> = {};
      if (ids.length) {
        const { data: items } = await supabase
          .from("part_request_items")
          .select("*")
          .in("request_id", ids);

        for (const it of items ?? []) {
          (itemsMap[it.request_id] ||= []).push(it);
        }
      }

      // 3) group by status
      const grouped: Record<Request["status"], (Request & { items: Item[] })[]> = {
        requested: [],
        quoted: [],
        approved: [],
        fulfilled: [],
        rejected: [],
        cancelled: [],
      };

      for (const r of requestList) {
  const status = (r.status ?? "requested") as Request["status"];
  const bucket = grouped[status];
  bucket.push({ ...r, items: itemsMap[r.id] ?? [] });
}

      setByStatus(grouped);
      setLoading(false);
    })();
  }, [supabase]);

  return (
    <div className="p-6 text-white space-y-4">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Parts Requests</h1>
        <Link
          href="/parts"
          className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
        >
          Parts Catalog
        </Link>
      </div>

      {loading ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-neutral-400">
          Loading…
        </div>
      ) : (
        <div className="grid gap-4 lg:grid-cols-3 xl:grid-cols-4">
          {STATUSES.map((status) => {
            const list = byStatus[status] ?? [];
            return (
              <div
                key={status}
                className="rounded border border-neutral-800 bg-neutral-900 flex flex-col"
              >
                <div className="border-b border-neutral-800 px-3 py-2 text-neutral-300 capitalize">
                  {status}
                </div>
                <div className="flex-1 space-y-3 p-3">
                  {list.length === 0 ? (
                    <div className="text-sm text-neutral-500">No requests</div>
                  ) : (
                    list.map((r) => (
                      <Link
                        key={r.id}
                        href={`/parts/requests/${r.id}`}
                        className="block rounded border border-neutral-800 p-3 hover:border-orange-500"
                      >
                        <div className="text-sm font-semibold">
                          WO: {r.work_order_id ?? "—"}
                        </div>
                        <div className="text-xs text-neutral-400">
                          {r.created_at
                            ? new Date(r.created_at).toLocaleString()
                            : "—"}
                        </div>
                        <ul className="mt-2 list-disc space-y-1 pl-5 text-sm">
                          {(r.items ?? []).slice(0, 4).map((it) => (
                            <li key={it.id}>
                              {it.description} × {Number(it.qty)}
                            </li>
                          ))}
                          {(r.items ?? []).length > 4 && (
                            <li>
                              + {(r.items ?? []).length - 4} more…
                            </li>
                          )}
                        </ul>
                      </Link>
                    ))
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: app/parts/quoting/page.tsx */
/* =============================== */

"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { toast } from "sonner";
import { format } from "date-fns";
import dynamic from "next/dynamic";

import { createBrowserSupabase } from "@/features/shared/lib/supabase/client";
import type { Database } from "@shared/types/types/supabase";
import VoiceContextSetter from "@/features/shared/voice/VoiceContextSetter";
import VoiceButton from "@/features/shared/voice/VoiceButton";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";

const PartsDrawer = dynamic(() => import("@/features/parts/components/PartsDrawer"), {
  ssr: false,
});

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];
type Customer = DB["public"]["Tables"]["customers"]["Row"];

type QueueRow = WorkOrderLine & {
  work_order: WorkOrder | null;
  vehicle: Vehicle | null;
  customer: Customer | null;
};

const BASE_BADGE =
  "inline-flex items-center whitespace-nowrap rounded border px-2 py-0.5 text-xs font-medium";
const BADGE: Record<string, string> = {
  awaiting: "bg-sky-900/20 border-sky-500/40 text-sky-300",
  awaiting_approval: "bg-blue-900/20 border-blue-500/40 text-blue-300",
  queued: "bg-indigo-900/20 border-indigo-500/40 text-indigo-300",
  in_progress: "bg-orange-900/20 border-orange-500/40 text-orange-300",
  on_hold: "bg-amber-900/20 border-amber-500/40 text-amber-300",
  completed: "bg-green-900/20 border-green-500/40 text-green-300",
};
const chip = (s: string | null | undefined): string => {
  const k = (s ?? "awaiting").toLowerCase().replaceAll(" ", "_");
  return `${BASE_BADGE} ${BADGE[k] ?? BADGE.awaiting}`;
};

export default function QuotingQueuePage(): JSX.Element {
  const supabase = useMemo(() => createBrowserSupabase(), []);

  const [rows, setRows] = useState<QueueRow[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [err, setErr] = useState<string | null>(null);

  const [selectedId, setSelectedId] = useState<string | null>(null);
  const selected = useMemo(() => rows.find((r) => r.id === selectedId) ?? null, [rows, selectedId]);

  const [bulkQueue, setBulkQueue] = useState<string[]>([]);
  const bulkActive = bulkQueue.length > 0;

  const fetchQueue = useCallback(async () => {
    setLoading(true);
    setErr(null);
    try {
      const { data: lines, error: lerr } = await supabase
        .from("work_order_lines")
        .select("*")
        .eq("approval_state", "pending")
        .order("created_at", { ascending: true });

      if (lerr) throw lerr;

      const wol = (lines ?? []) as WorkOrderLine[];
      if (wol.length === 0) {
        setRows([]);
        setLoading(false);
        return;
      }

      const woIds = [...new Set(wol.map((l) => l.work_order_id).filter(Boolean) as string[])];
      const { data: woRows } = await supabase.from("work_orders").select("*").in("id", woIds);

      const woById = new Map<string, WorkOrder>();
      (woRows ?? []).forEach((w) => woById.set(w.id, w as WorkOrder));

      const vehIds = [...new Set((woRows ?? []).map(w => (w as WorkOrder).vehicle_id).filter(Boolean) as string[])];
      const custIds = [...new Set((woRows ?? []).map(w => (w as WorkOrder).customer_id).filter(Boolean) as string[])];

      const [vehRes, custRes] = await Promise.all([
        vehIds.length ? supabase.from("vehicles").select("*").in("id", vehIds) : Promise.resolve({ data: [] } as const),
        custIds.length
          ? supabase.from("customers").select("*").in("id", custIds)
          : Promise.resolve({ data: [] } as const),
      ]);

      const vById = new Map<string, Vehicle>();
      (vehRes.data ?? []).forEach((v) => vById.set((v as Vehicle).id, v as Vehicle));

      const cById = new Map<string, Customer>();
      (custRes.data ?? []).forEach((c) => cById.set((c as Customer).id, c as Customer));

      const out: QueueRow[] = wol.map((l) => {
        const wo = l.work_order_id ? woById.get(l.work_order_id) ?? null : null;
        const vehicle = wo?.vehicle_id ? vById.get(wo.vehicle_id) ?? null : null;
        const customer = wo?.customer_id ? cById.get(wo.customer_id) ?? null : null;
        return { ...l, work_order: wo, vehicle, customer };
      });

      setRows(out);
    } catch (e) {
      const msg = (e as { message?: string })?.message ?? "Failed to load quoting queue.";
      setErr(msg);
    } finally {
      setLoading(false);
    }
  }, [supabase]);

  useEffect(() => { void fetchQueue(); }, [fetchQueue]);

  useEffect(() => {
    const ch = supabase
      .channel("quote-queue")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "work_order_lines", filter: "approval_state=eq.pending" },
        () => void fetchQueue()
      )
      .subscribe();
    return () => { try { supabase.removeChannel(ch); } catch {} };
  }, [supabase, fetchQueue]);

  const startBulk = useCallback(() => {
    if (!rows.length) return;
    const ids = rows.map((r) => r.id);
    setBulkQueue(ids);
    setSelectedId(ids[0] ?? null);
    toast.message(`Quoting ${ids.length} pending line(s)…`);
  }, [rows]);

  useEffect(() => {
    if (!selectedId) return;
    const evt = `parts-drawer:closed:${selectedId}`;
    const handler = () => {
      if (bulkActive) {
        const [, ...rest] = bulkQueue;
        setBulkQueue(rest);
        setSelectedId(rest[0] ?? null);
        if (rest.length === 0) void fetchQueue();
      } else {
        setSelectedId(null);
        void fetchQueue();
      }
    };
    window.addEventListener(evt, handler as EventListener);
    return () => window.removeEventListener(evt, handler as EventListener);
  }, [selectedId, bulkActive, bulkQueue, fetchQueue]);

  // ---- AI Apply: suggest + server inserts allocations + labor
  const aiApply = useCallback(async (row: QueueRow) => {
    if (!row.id) return;
    toast.loading("AI preparing parts & labor…", { id: `ai-${row.id}` });

    try {
      const suggestion = await requestQuoteSuggestion({
        item: row.description ?? "Job",
        notes: row.notes ?? "",
        section: "Quote Queue",
        status: "recommend",
        vehicle: row.vehicle ?? undefined,
      });

      if (!suggestion) {
        toast.error("AI returned no suggestion.", { id: `ai-${row.id}` });
        return;
      }

      const r = await fetch("/api/quotes/apply-ai", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ workOrderLineId: row.id, suggestion }),
      });

      const j = (await r.json()) as { ok?: boolean; labor_applied?: boolean; unmatched?: { name: string; qty: number }[]; error?: string };
      if (!r.ok || !j?.ok) {
        throw new Error(j?.error || "Apply AI failed");
      }

      if (j.unmatched && j.unmatched.length) {
        const list = j.unmatched.map(u => `${u.qty}× ${u.name}`).join(", ");
        toast.message(`Some parts need manual matching: ${list}`, { id: `ai-${row.id}` });
      } else {
        toast.success("AI parts & labor applied", { id: `ai-${row.id}` });
      }
      await fetchQueue();
    } catch (e) {
      toast.error((e as { message?: string })?.message ?? "AI apply failed", { id: `ai-${row.id}` });
    }
  }, [fetchQueue]);

  // ---- Mark as quoted (still pending approval) + grow Saved Menu
  const markQuoted = useCallback(async (row: QueueRow) => {
    if (!row.id) return;
    toast.loading("Marking as quoted…", { id: `quoted-${row.id}` });

    try {
      // Create/merge Saved Menu record for this Y/M/M + job title
      const r = await fetch("/api/menu-items/upsert-from-line", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ workOrderLineId: row.id }),
      });
      const j = (await r.json()) as { id?: string | null; ok?: boolean; error?: string };
      if (!r.ok || j?.error) {
        throw new Error(j?.error || "Could not upsert saved menu item");
      }

      // Keep status & approval_state unchanged (still pending).
      // You can optionally stamp a small flag in notes that says "quoted".
      const nextNotes = `${row.notes ?? ""}`.includes("[quoted]")
        ? row.notes
        : ([row.notes ?? "", "[quoted]"].filter(Boolean).join(" ").trim());

      const { error: ue } = await supabase
        .from("work_order_lines")
        .update({ notes: nextNotes } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", row.id);
      if (ue) throw ue;

      toast.success("Marked as quoted (awaiting approval). Saved Menu updated.", { id: `quoted-${row.id}` });
      await fetchQueue();
    } catch (e) {
      toast.error((e as { message?: string })?.message ?? "Failed to mark as quoted", { id: `quoted-${row.id}` });
    }
  }, [supabase, fetchQueue]);

  return (
    <div className="p-4 sm:p-6 text-white">
      <VoiceContextSetter currentView="parts_quoting" />

      <div className="mb-4 flex items-center justify-between">
        <h1 className="text-2xl font-semibold">Quoting Queue</h1>
        <div className="flex items-center gap-2">
          <Link href="/parts/inventory" className="text-sm text-orange-400 hover:underline">Open Inventory →</Link>
          <button
            type="button"
            className="rounded bg-blue-600 px-3 py-1.5 text-sm font-semibold text-white hover:bg-blue-500 disabled:opacity-50"
            onClick={startBulk}
            disabled={rows.length === 0}
          >
            Quote all pending ({rows.length})
          </button>
        </div>
      </div>

      {err && <div className="mb-4 rounded border border-red-500/40 bg-red-500/10 p-3 text-red-300">{err}</div>}

      <div className="grid grid-cols-1 gap-6 lg:grid-cols-[420px_1fr]">
        {/* LEFT: queue */}
        <div className="rounded border border-neutral-800 bg-neutral-900">
          <div className="border-b border-neutral-800 p-3 text-sm text-neutral-300">Pending approval lines</div>
          {loading ? (
            <div className="p-3 text-neutral-400">Loading…</div>
          ) : rows.length === 0 ? (
            <div className="p-3 text-neutral-400">Nothing awaiting quoting.</div>
          ) : (
            <ul className="divide-y divide-neutral-800">
              {rows.map((r) => (
                <li key={r.id} className="p-3">
                  <div className="flex items-start justify-between gap-3">
                    <div className="min-w-0">
                      <div className="truncate font-medium">{r.description || r.complaint || "Untitled job"}</div>
                      <div className="mt-0.5 text-xs text-neutral-400">
                        WO: {r.work_order?.custom_id || r.work_order?.id?.slice(0, 8) || "—"} •{" "}
                        {r.vehicle
                          ? `${r.vehicle.year ?? ""} ${r.vehicle.make ?? ""} ${r.vehicle.model ?? ""}`.trim()
                          : "No vehicle"}
                        {" • "}
                        {r.created_at ? format(new Date(r.created_at), "PPp") : "—"}
                      </div>
                      {r.notes && <div className="mt-1 truncate text-xs text-neutral-400">Notes: {r.notes}</div>}
                    </div>

                    <div className="flex shrink-0 items-center gap-2">
                      <span className={chip(r.status)}>{(r.status ?? "awaiting").replaceAll("_", " ")}</span>
                      <button
                        type="button"
                        className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                        onClick={() => void aiApply(r)}
                        title="AI: allocate parts + labor"
                      >
                        AI Apply
                      </button>
                      <button
                        type="button"
                        className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                        onClick={() => setSelectedId(r.id)}
                        title="Open Parts Drawer"
                      >
                        Quote
                      </button>
                      <button
                        type="button"
                        className="rounded bg-emerald-600 px-2 py-1 text-xs font-semibold text-black hover:bg-emerald-500"
                        onClick={() => void markQuoted(r)}
                        title="Mark as quoted (keeps awaiting approval) and grow Saved Menu"
                      >
                        Mark Quoted
                      </button>
                    </div>
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>

        {/* RIGHT: details */}
        <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
          <h2 className="mb-2 text-lg font-semibold">Details</h2>
          {selected ? (
            <div className="space-y-2 text-sm">
              <div className="text-neutral-400">Work Order</div>
              <div className="font-medium">
                {selected.work_order
                  ? selected.work_order.custom_id || selected.work_order.id?.slice(0, 8)
                  : "—"}
              </div>

              <div className="text-neutral-400">Vehicle</div>
              <div className="font-medium">
                {selected.vehicle
                  ? `${selected.vehicle.year ?? ""} ${selected.vehicle.make ?? ""} ${selected.vehicle.model ?? ""}`.trim() ||
                    "—"
                  : "—"}
              </div>

              <div className="text-neutral-400">Customer</div>
              <div className="font-medium">
                {selected.customer
                  ? [selected.customer.first_name ?? "", selected.customer.last_name ?? ""].filter(Boolean).join(" ") ||
                    "—"
                  : "—"}
              </div>

              <div className="text-neutral-400">Description</div>
              <div className="font-medium">{selected.description ?? "—"}</div>

              <div className="text-neutral-400">Notes</div>
              <div className="whitespace-pre-wrap font-medium">{selected.notes ?? "—"}</div>
            </div>
          ) : (
            <div className="text-neutral-400">Select a line on the left to see details.</div>
          )}
        </div>
      </div>

      {/* Parts drawer */}
      {selected && selected.work_order?.id && (
        <PartsDrawer
          open
          workOrderId={selected.work_order.id}
          workOrderLineId={selected.id}
          vehicleSummary={
            selected.vehicle
              ? {
                  year: (selected.vehicle.year as string | number | null)?.toString() ?? null,
                  make: selected.vehicle.make ?? null,
                  model: selected.vehicle.model ?? null,
                }
              : null
          }
          jobDescription={selected.description ?? null}
          jobNotes={selected.notes ?? null}
          closeEventName={`parts-drawer:closed:${selected.id}`}
        />
      )}

      <VoiceButton />
    </div>
  );
}

/* =============================== */
/* FILE: app/parts/inventory/page.tsx */
/* =============================== */

"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { v4 as uuidv4 } from "uuid";

/* ----------------------------- Types ----------------------------- */

type DB = Database;
type Part = DB["public"]["Tables"]["parts"]["Row"];
type PartInsert = DB["public"]["Tables"]["parts"]["Insert"];
type PartUpdate = DB["public"]["Tables"]["parts"]["Update"];
type StockLoc = DB["public"]["Tables"]["stock_locations"]["Row"];
type StockMove = DB["public"]["Tables"]["stock_moves"]["Row"];

// app-side view of the enum
type StockMoveReason = "receive" | "adjust" | "consume" | "transfer";

/* --------------------------- UI helpers -------------------------- */

function Modal(props: {
  open: boolean;
  title: string;
  onClose: () => void;
  children: React.ReactNode;
  footer?: React.ReactNode;
  widthClass?: string;
}) {
  const { open, title, onClose, children, footer, widthClass = "max-w-xl" } = props;
  if (!open) return null;
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 p-4">
      <div
        className={`w-full ${widthClass} rounded border border-orange-500 bg-neutral-950 p-4 text-white shadow-xl`}
        onClick={(e) => e.stopPropagation()}
        role="dialog"
        aria-modal="true"
      >
        <div className="mb-3 flex items-center justify-between">
          <h2 className="text-lg font-semibold">{title}</h2>
          <button
            onClick={onClose}
            className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
            aria-label="Close"
          >
            ✕
          </button>
        </div>
        <div>{children}</div>
        {footer ? <div className="mt-4">{footer}</div> : null}
      </div>
    </div>
  );
}

function TextField(props: {
  label: string;
  value: string;
  placeholder?: string;
  onChange: (v: string) => void;
}) {
  const { label, value, placeholder, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <input
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
      />
    </div>
  );
}

function NumberField(props: {
  label: string;
  value: number | "";
  min?: number;
  step?: number;
  onChange: (v: number | "") => void;
}) {
  const { label, value, min = 0, step = 0.01, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <input
        type="number"
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value === "" ? "" : value}
        min={min}
        step={step}
        onChange={(e) => {
          const raw = e.target.value;
          onChange(raw === "" ? "" : Number(raw));
        }}
      />
    </div>
  );
}

function SelectField(props: {
  label: string;
  value: string;
  options: { value: string; label: string }[];
  onChange: (v: string) => void;
}) {
  const { label, value, options, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <select
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value}
        onChange={(e) => onChange(e.target.value)}
      >
        {options.map((o) => (
          <option key={o.value} value={o.value}>
            {o.label}
          </option>
        ))}
      </select>
    </div>
  );
}

/* ---------------------- CSV parsing helper ---------------------- */

function parseCSV(text: string): string[][] {
  const rows: string[][] = [];
  let row: string[] = [];
  let cell = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (inQuotes) {
      if (ch === '"') {
        const next = text[i + 1];
        if (next === '"') {
          cell += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        cell += ch;
      }
    } else {
      if (ch === '"') inQuotes = true;
      else if (ch === ",") {
        row.push(cell.trim());
        cell = "";
      } else if (ch === "\n") {
        row.push(cell.trim());
        rows.push(row);
        row = [];
        cell = "";
      } else if (ch !== "\r") {
        cell += ch;
      }
    }
  }
  if (cell.length > 0 || row.length > 0) {
    row.push(cell.trim());
    rows.push(row);
  }
  return rows.filter((r) => r.length > 0 && r.some((c) => c.length > 0));
}

/* ------------------------- Error helper ------------------------- */
function errMsg(err: unknown): string {
  if (typeof err === "string") return err;
  if (err && typeof err === "object" && "message" in err) {
    return String((err as Record<string, unknown>).message);
  }
  try {
    return JSON.stringify(err);
  } catch {
    return String(err);
  }
}

/* ------------------------- RPC helper --------------------------- */
/** Try 6-arg function first; if schema cache hasn’t picked it up,
 * fall back to the 5-arg legacy shape. Strictly typed; ignores return value.
 */
async function applyStockMoveRPC(
  supabase: ReturnType<typeof createClientComponentClient<DB>>,
  args: {
    p_part: string;
    p_loc: string;
    p_qty: number;
    p_reason: StockMoveReason;
    p_ref_kind: string;
    p_ref_id?: string | null;
  },
): Promise<void> {
  type FnArgs = DB["public"]["Functions"]["apply_stock_move"]["Args"];

  // 6-arg (conditionally include p_ref_id so shapes match)
  const payload6 = {
    p_part: args.p_part,
    p_loc: args.p_loc,
    p_qty: args.p_qty,
    p_reason: args.p_reason as FnArgs extends { p_reason: infer R } ? R : never,
    p_ref_kind: args.p_ref_kind,
    ...(args.p_ref_id !== undefined ? { p_ref_id: args.p_ref_id } : {}),
  } as FnArgs;

  const call6 = await supabase.rpc("apply_stock_move", payload6);
  if (!call6.error) return;

  const msg = (call6.error?.message ?? "").toLowerCase();
  const cacheShapeIssue =
    msg.includes("could not find the function") ||
    msg.includes("schema cache") ||
    msg.includes("function apply_stock_move(");

  if (!cacheShapeIssue) throw new Error(call6.error?.message ?? "apply_stock_move failed");

  // 5-arg (legacy, no p_ref_id)
  const payload5 = {
    p_part: args.p_part,
    p_loc: args.p_loc,
    p_qty: args.p_qty,
    p_reason: args.p_reason as FnArgs extends { p_reason: infer R } ? R : never,
    p_ref_kind: args.p_ref_kind,
  } as FnArgs;

  const call5 = await supabase.rpc("apply_stock_move", payload5);
  if (call5.error) {
    throw new Error(call5.error.message ?? "apply_stock_move failed");
  }
}

/* ---------------------------- Page ---------------------------- */

export default function InventoryPage(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [shopId, setShopId] = useState<string>("");
  const [search, setSearch] = useState<string>("");
  const [parts, setParts] = useState<Part[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  // stock locations
  const [locs, setLocs] = useState<StockLoc[]>([]);

  // on-hand map: partId -> total qty
  const [onHand, setOnHand] = useState<Record<string, number>>({});
  // per-location detail modal
  const [ohOpen, setOhOpen] = useState<boolean>(false);
  const [ohForPart, setOhForPart] = useState<Part | null>(null);
  const [ohLines, setOhLines] = useState<{ location: string; qty: number }[]>([]);

  // add modal
  const [addOpen, setAddOpen] = useState<boolean>(false);
  const [name, setName] = useState<string>("");
  const [sku, setSku] = useState<string>("");
  const [category, setCategory] = useState<string>("");
  const [price, setPrice] = useState<number | "">("");

  // initial receive (optional) for Add
  const [initLoc, setInitLoc] = useState<string>("");
  const [initQty, setInitQty] = useState<number | "">("");

  // edit modal
  const [editOpen, setEditOpen] = useState<boolean>(false);
  const [editPart, setEditPart] = useState<Part | null>(null);
  const [editName, setEditName] = useState<string>("");
  const [editSku, setEditSku] = useState<string>("");
  const [editCategory, setEditCategory] = useState<string>("");
  const [editPrice, setEditPrice] = useState<number | "">("");

  // receive modal (standalone quick receive)
  const [recvOpen, setRecvOpen] = useState<boolean>(false);
  const [recvPart, setRecvPart] = useState<Part | null>(null);
  const [recvLoc, setRecvLoc] = useState<string>("");
  const [recvQty, setRecvQty] = useState<number | "">("");

  // CSV Import
  const [csvOpen, setCsvOpen] = useState<boolean>(false);
  const [csvText, setCsvText] = useState<string>("");
  const [csvRows, setCsvRows] = useState<
    { name: string; sku?: string; category?: string; price?: number; qty?: number }[]
  >([]);
  const [csvPreview, setCsvPreview] = useState<boolean>(false);
  const [csvDefaultLoc, setCsvDefaultLoc] = useState<string>("");

  // ---------- on-hand loader (pass sid directly; avoids first-render zeros)
  const loadOnHand = useCallback(
    async (sid: string, partIds: string[]) => {
      if (!partIds.length) {
        setOnHand({});
        return;
      }
      const { data, error } = await supabase
        .from("stock_moves")
        .select("part_id, qty_change")
        .in("part_id", partIds)
        .eq("shop_id", sid);

      if (error || !data) {
        setOnHand({});
        return;
      }

      const totals: Record<string, number> = {};
      (data as StockMove[]).forEach((m) => {
        const delta = Number(m.qty_change) || 0;
        totals[m.part_id] = (totals[m.part_id] ?? 0) + delta;
      });
      setOnHand(totals);
    },
    [supabase],
  );

  const load = async (sid: string) => {
    setLoading(true);
    const base = supabase
      .from("parts")
      .select("*")
      .eq("shop_id", sid)
      .order("name", { ascending: true });

    const { data, error } = await (search.trim()
      ? base.or(
          [
            `name.ilike.%${search}%`,
            `sku.ilike.%${search}%`,
            `category.ilike.%${search}%`,
          ].join(","),
        )
      : base);

    const partRows = (!error && (data as Part[])) || [];
    setParts(partRows);
    setLoading(false);

    void loadOnHand(sid, partRows.map((p) => p.id));
  };

  // --- on-hand detail (per-location)
  const openOnHandDetail = async (p: Part) => {
    setOhForPart(p);
    const { data, error } = await supabase
      .from("stock_moves")
      .select("location_id, qty_change")
      .eq("part_id", p.id)
      .eq("shop_id", shopId);

    if (error || !data) {
      setOhLines([]);
      setOhOpen(true);
      return;
    }

    const byLoc: Record<string, number> = {};
    (data as StockMove[]).forEach((r) => {
      const loc = r.location_id as string;
      const q = Number(r.qty_change) || 0;
      byLoc[loc] = (byLoc[loc] ?? 0) + q;
    });

    const lines = locs
      .map((l) => ({
        location: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
        qty: byLoc[l.id] ?? 0,
      }))
      .filter((x) => x.qty !== 0);

    setOhLines(lines);
    setOhOpen(true);
  };

  /* boot */
  useEffect(() => {
    (async () => {
      const { data: u } = await supabase.auth.getUser();
      const uid = u.user?.id ?? null;
      if (!uid) return;

      const { data: prof } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("user_id", uid)
        .maybeSingle();

      const sid = (prof?.shop_id as string) || "";
      setShopId(sid);
      if (!sid) return;

      const { data: l } = await supabase
        .from("stock_locations")
        .select("*")
        .eq("shop_id", sid)
        .order("code");

      const locRows = (l as StockLoc[]) ?? [];
      setLocs(locRows);

      const main = locRows.find((x) => (x.code ?? "").toUpperCase() === "MAIN");
      if (main) {
        setInitLoc(main.id);
        setRecvLoc(main.id);
        setCsvDefaultLoc(main.id);
      }

      await load(sid);
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [supabase]);

  /* refetch on search */
  useEffect(() => {
    if (shopId) void load(shopId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [search, shopId]);

  /* ----------------------- CRUD handlers ----------------------- */

  const createPart = async () => {
    if (!shopId || !name.trim()) return;

    const id = uuidv4();
    const insert: PartInsert = {
      id,
      shop_id: shopId,
      name: name.trim(),
      sku: sku.trim() ? sku.trim() : undefined,
      category: category.trim() ? category.trim() : undefined,
      price: typeof price === "number" ? price : undefined,
    };

    const { error } = await supabase.from("parts").insert(insert);
    if (error) {
      alert(error.message);
      return;
    }

    // optional initial receive
    if (initLoc && typeof initQty === "number" && initQty > 0) {
      try {
        await applyStockMoveRPC(supabase, {
          p_part: id,
          p_loc: initLoc,
          p_qty: initQty,
          p_reason: "receive",
          p_ref_kind: "manual_receive",
          p_ref_id: null,
        });
      } catch (err: unknown) {
        alert(`Part created, but stock receive failed: ${errMsg(err)}`);
      }
    }

    setAddOpen(false);
    setName("");
    setSku("");
    setCategory("");
    setPrice("");
    setInitQty("");
    await load(shopId);
  };

  const openEdit = (p: Part) => {
    setEditPart(p);
    setEditName(p.name ?? "");
    setEditSku(p.sku ?? "");
    setEditCategory(p.category ?? "");
    setEditPrice(typeof p.price === "number" ? p.price : "");
    setEditOpen(true);
  };

  const saveEdit = async () => {
    if (!editPart?.id) return;

    const patch: PartUpdate = {
      name: editName.trim() ? editName.trim() : undefined,
      sku: editSku.trim() ? editSku.trim() : undefined,
      category: editCategory.trim() ? editCategory.trim() : undefined,
      price: typeof editPrice === "number" ? editPrice : undefined,
    };

    const { error } = await supabase.from("parts").update(patch).eq("id", editPart.id);
    if (error) {
      alert(error.message);
      return;
    }

    setEditOpen(false);
    await load(shopId);
  };

  const openReceive = (p: Part) => {
    setRecvPart(p);
    setRecvQty("");
    setRecvOpen(true);
  };

  const applyReceive = async () => {
    if (!recvPart?.id || !recvLoc || typeof recvQty !== "number" || recvQty <= 0) return;
    try {
      await applyStockMoveRPC(supabase, {
        p_part: recvPart.id,
        p_loc: recvLoc,
        p_qty: recvQty,
        p_reason: "receive",
        p_ref_kind: "manual_receive",
        p_ref_id: null,
      });
      setRecvOpen(false);
      await load(shopId);
    } catch (err: unknown) {
      alert(errMsg(err));
    }
  };

  /* -------------------------- CSV Import -------------------------- */

  const parseAndPreviewCSV = (raw: string) => {
    const rows = parseCSV(raw);
    if (!rows.length) {
      setCsvRows([]);
      setCsvPreview(false);
      return;
    }
    const header = rows[0].map((h) => h.toLowerCase().trim());
    const idx = {
      name: header.indexOf("name"),
      sku: header.indexOf("sku"),
      category: header.indexOf("category"),
      price: header.indexOf("price"),
      qty: header.indexOf("qty"),
    };

    const out: { name: string; sku?: string; category?: string; price?: number; qty?: number }[] = [];

    for (let r = 1; r < rows.length; r++) {
      const row = rows[r];
      const name = idx.name >= 0 ? row[idx.name] : "";
      if (!name) continue;
      const sku = idx.sku >= 0 ? row[idx.sku] : undefined;
      const category = idx.category >= 0 ? row[idx.category] : undefined;
      const priceStr = idx.price >= 0 ? row[idx.price] : undefined;
      const qtyStr = idx.qty >= 0 ? row[idx.qty] : undefined;

      const price = priceStr && priceStr.length ? Number(priceStr) : undefined;
      const qty = qtyStr && qtyStr.length ? Number(qtyStr) : undefined;

      out.push({
        name,
        sku: sku && sku.length ? sku : undefined,
        category: category && category.length ? category : undefined,
        price: typeof price === "number" && !Number.isNaN(price) ? price : undefined,
        qty: typeof qty === "number" && !Number.isNaN(qty) ? qty : undefined,
      });
    }

    setCsvRows(out);
    setCsvPreview(true);
  };

  const handleCsvFile = async (file: File) => {
    const text = await file.text();
    setCsvText(text);
    parseAndPreviewCSV(text);
  };

  const runCsvImport = async () => {
    if (!shopId || !csvRows.length) return;

    for (const row of csvRows) {
      let partId: string | null = null;

      if (row.sku) {
        const { data: found } = await supabase
          .from("parts")
          .select("id")
          .eq("shop_id", shopId)
          .eq("sku", row.sku)
          .maybeSingle();
        if (found?.id) partId = found.id;
      }

      if (!partId) {
        const id = uuidv4();
        const insert: PartInsert = {
          id,
          shop_id: shopId,
          name: row.name,
          sku: row.sku || undefined,
          category: row.category || undefined,
          price: typeof row.price === "number" ? row.price : undefined,
        };
        const { error } = await supabase.from("parts").insert(insert);
        if (error) {
          console.warn("Insert failed:", row, error.message);
          continue;
        }
        partId = id;
      } else {
        const patch: PartUpdate = {
          name: row.name || undefined,
          sku: row.sku || undefined,
          category: row.category || undefined,
          price: typeof row.price === "number" ? row.price : undefined,
        };
        await supabase.from("parts").update(patch).eq("id", partId);
      }

      if (partId && csvDefaultLoc && typeof row.qty === "number" && row.qty > 0) {
        try {
          await applyStockMoveRPC(supabase, {
            p_part: partId,
            p_loc: csvDefaultLoc,
            p_qty: row.qty,
            p_reason: "receive",
            p_ref_kind: "csv_import",
            p_ref_id: null,
          });
        } catch (err: unknown) {
          console.warn("Stock receive failed for row:", row, errMsg(err));
        }
      }
    }

    setCsvOpen(false);
    setCsvPreview(false);
    setCsvText("");
    setCsvRows([]);
    await load(shopId);
  };

  /* ----------------------------- UI ----------------------------- */

  return (
    <div className="space-y-4 p-6 text-white">
      <div className="flex flex-wrap items-center justify-between gap-3">
        <h1 className="text-2xl font-bold">Inventory</h1>
        <div className="flex items-center gap-2">
          <input
            className="w-64 rounded border border-neutral-700 bg-neutral-900 p-2 text-sm"
            placeholder="Search name / SKU / category"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
          <button
            className="font-header rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
            onClick={() => setAddOpen(true)}
            disabled={!shopId}
          >
            Add Part
          </button>
          <button
            className="font-header rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
            onClick={() => setCsvOpen(true)}
            disabled={!shopId}
          >
            CSV Import
          </button>
        </div>
      </div>

      {loading ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          Loading…
        </div>
      ) : parts.length === 0 ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          No parts yet. Click “Add Part” to create your first item or use CSV Import.
        </div>
      ) : (
        <div className="overflow-hidden rounded border border-neutral-800 bg-neutral-900">
          <table className="w-full text-sm">
            <thead className="bg-neutral-900">
              <tr className="text-left text-neutral-400">
                <th className="p-2">Name</th>
                <th className="p-2">SKU</th>
                <th className="p-2">Category</th>
                <th className="p-2">Price</th>
                <th className="p-2">On hand</th>
                <th className="p-2 w-48 text-right">Actions</th>
              </tr>
            </thead>
            <tbody>
              {parts.map((p) => {
                const total = onHand[p.id] ?? 0;
                return (
                  <tr key={p.id} className="border-t border-neutral-800">
                    <td className="p-2">{p.name}</td>
                    <td className="p-2">{p.sku ?? "—"}</td>
                    <td className="p-2">{p.category ?? "—"}</td>
                    <td className="p-2">
                      {typeof p.price === "number" ? `$${p.price.toFixed(2)}` : "—"}
                    </td>
                    <td className="p-2">
                      <button
                        className="rounded border border-neutral-700 px-2 py-0.5 text-xs hover:bg-neutral-800"
                        onClick={() => openOnHandDetail(p)}
                        title="View per-location balance"
                      >
                        {total}
                      </button>
                    </td>
                    <td className="p-2">
                      <div className="flex justify-end gap-2">
                        <button
                          className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                          onClick={() => openEdit(p)}
                        >
                          Edit
                        </button>
                        <button
                          className="rounded border border-blue-600 px-2 py-1 text-xs text-blue-300 hover:bg-blue-900/20"
                          onClick={() => openReceive(p)}
                        >
                          Receive
                        </button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      )}

      {/* Add Part */}
      <Modal
        open={addOpen}
        title="Add Part"
        onClose={() => setAddOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setAddOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
              onClick={createPart}
              disabled={!name.trim()}
            >
              Save Part
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <div className="sm:col-span-2">
            <TextField label="Name*" value={name} onChange={setName} placeholder="Part name" />
          </div>
          <TextField label="SKU" value={sku} onChange={setSku} placeholder="Optional" />
          <TextField label="Category" value={category} onChange={setCategory} placeholder="Optional" />
          <NumberField
            label="Price"
            value={price}
            onChange={(v) => setPrice(v === "" ? "" : v)}
          />
        </div>

        <div className="mt-4 rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="mb-2 text-sm font-semibold">Initial Stock (optional)</div>
          <div className="grid gap-3 sm:grid-cols-2">
            <SelectField
              label="Location"
              value={initLoc}
              onChange={setInitLoc}
              options={[
                { value: "", label: "— none —" },
                ...locs.map((l) => ({
                  value: l.id,
                  label: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
                })),
              ]}
            />
            <NumberField
              label="Qty"
              value={initQty}
              min={0}
              step={1}
              onChange={(v) => setInitQty(v === "" ? "" : Math.max(0, v))}
            />
          </div>
        </div>
      </Modal>

      {/* Edit Part */}
      <Modal
        open={editOpen}
        title="Edit Part"
        onClose={() => setEditOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setEditOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
              onClick={saveEdit}
              disabled={!editName.trim()}
            >
              Save Changes
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <div className="sm:col-span-2">
            <TextField label="Name*" value={editName} onChange={setEditName} />
          </div>
          <TextField label="SKU" value={editSku} onChange={setEditSku} />
          <TextField label="Category" value={editCategory} onChange={setEditCategory} />
          <NumberField label="Price" value={editPrice} onChange={(v) => setEditPrice(v === "" ? "" : v)} />
        </div>
      </Modal>

      {/* Receive Stock */}
      <Modal
        open={recvOpen}
        title={recvPart ? `Receive — ${recvPart.name}` : "Receive Stock"}
        onClose={() => setRecvOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setRecvOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
              onClick={applyReceive}
              disabled={!recvPart?.id || !recvLoc || typeof recvQty !== "number" || recvQty <= 0}
            >
              Apply Receive
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <SelectField
            label="Location"
            value={recvLoc}
            onChange={setRecvLoc}
            options={locs.map((l) => ({
              value: l.id,
              label: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
            }))}
          />
          <NumberField
            label="Qty"
            value={recvQty}
            min={0}
            step={1}
            onChange={(v) => setRecvQty(v === "" ? "" : Math.max(0, v))}
          />
        </div>
      </Modal>

      {/* On-hand detail */}
      <Modal
        open={ohOpen}
        title={ohForPart ? `On hand — ${ohForPart.name}` : "On hand"}
        onClose={() => setOhOpen(false)}
        widthClass="max-w-lg"
      >
        {ohLines.length === 0 ? (
          <div className="text-sm text-neutral-400">No movement found for this part.</div>
        ) : (
          <div className="rounded border border-neutral-800">
            <table className="w-full text-sm">
              <thead className="text-left text-neutral-400">
                <tr>
                  <th className="p-2">Location</th>
                  <th className="p-2">Qty</th>
                </tr>
              </thead>
              <tbody>
                {ohLines.map((l, i) => (
                  <tr key={i} className="border-t border-neutral-800">
                    <td className="p-2">{l.location}</td>
                    <td className="p-2">{l.qty}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </Modal>

      {/* CSV Import */}
      <Modal
        open={csvOpen}
        title="CSV Import"
        onClose={() => setCsvOpen(false)}
        widthClass="max-w-3xl"
        footer={
          <div className="flex w-full flex-wrap items-center justify-between gap-3">
            <div className="flex items-center gap-2">
              <SelectField
                label="Default receive location (for rows with qty)"
                value={csvDefaultLoc}
                onChange={setCsvDefaultLoc}
                options={[
                  { value: "", label: "— none —" },
                  ...locs.map((l) => ({ value: l.id, label: `${l.code ?? "LOC"} — ${l.name ?? ""}` })),
                ]}
              />
            </div>
            <div className="flex items-center gap-2">
              <button
                className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
                onClick={() => {
                  setCsvPreview(false);
                  setCsvText("");
                  setCsvRows([]);
                  setCsvOpen(false);
                }}
              >
                Close
              </button>
              <button
                className="rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
                onClick={runCsvImport}
                disabled={!csvPreview || csvRows.length === 0}
              >
                Import
              </button>
            </div>
          </div>
        }
      >
        <div className="grid gap-3">
          <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-300">
            Expected headers (case-insensitive): <code>name, sku, category, price, qty</code>. Extra columns are ignored.
          </div>

          <div className="flex flex-wrap items-center gap-2">
            <input
              type="file"
              accept=".csv,text/csv"
              onChange={(e) => {
                const f = e.target.files?.[0];
                if (f) void handleCsvFile(f);
              }}
              className="text-sm"
            />
            <button
              className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
              onClick={() => {
                if (csvText.trim().length) parseAndPreviewCSV(csvText);
              }}
            >
              Parse text
            </button>
          </div>

          <textarea
            rows={8}
            className="w-full rounded border border-neutral-700 bg-neutral-900 p-2 text-sm"
            placeholder={`Paste CSV here… e.g.:
name,sku,category,price,qty
Oil Filter – Ford,OF-FORD-01,Filters,9.95,10
Spark Plug – Iridium,SP-IR-01,Ignition,9.95,24
`}
            value={csvText}
            onChange={(e) => setCsvText(e.target.value)}
          />

          {csvPreview && (
            <div className="rounded border border-neutral-800">
              <table className="w-full text-sm">
                <thead className="text-left text-neutral-400">
                  <tr>
                    <th className="p-2">Name</th>
                    <th className="p-2">SKU</th>
                    <th className="p-2">Category</th>
                    <th className="p-2">Price</th>
                    <th className="p-2">Qty</th>
                  </tr>
                </thead>
                <tbody>
                  {csvRows.map((r, i) => (
                    <tr key={i} className="border-t border-neutral-800">
                      <td className="p-2">{r.name}</td>
                      <td className="p-2">{r.sku ?? "—"}</td>
                      <td className="p-2">{r.category ?? "—"}</td>
                      <td className="p-2">{typeof r.price === "number" ? r.price.toFixed(2) : "—"}</td>
                      <td className="p-2">{typeof r.qty === "number" ? r.qty : "—"}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </Modal>
    </div>
  );
}

/* =============================== */
/* FILE: app/api/parts/requests/create/route.ts */
/* =============================== */

// app/api/parts/requests/create/route.ts
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type PRInsert = DB["public"]["Tables"]["part_requests"]["Insert"];
type PRIInsert = DB["public"]["Tables"]["part_request_items"]["Insert"];
type WORow = DB["public"]["Tables"]["work_orders"]["Row"];
type WOLUpdate = DB["public"]["Tables"]["work_order_lines"]["Update"];

const DEFAULT_MARKUP = 30; // %

type BodyItem = {
  description: string;
  qty: number;
};

type Body = {
  workOrderId: string;
  jobId?: string | null;
  items: BodyItem[];
  notes?: string | null;
};

// extend the generated insert type with the columns you just added in Supabase
type PartRequestItemInsertWithExtras = PRIInsert & {
  markup_pct: number;
  work_order_line_id: string | null;
};

export async function POST(req: Request) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  // 1) parse + validate
  const body = (await req.json().catch(() => null)) as Body | null;
  if (
    !body ||
    typeof body.workOrderId !== "string" ||
    !Array.isArray(body.items) ||
    body.items.length === 0
  ) {
    return NextResponse.json(
      { error: "Invalid body. Expect { workOrderId, items[] }." },
      { status: 400 },
    );
  }

  const { workOrderId, jobId, items, notes } = body;

  // 2) auth
  const {
    data: { user },
    error: userErr,
  } = await supabase.auth.getUser();
  if (userErr) {
    return NextResponse.json({ error: userErr.message }, { status: 401 });
  }
  if (!user) {
    return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
  }

  // 3) load WO for shop_id
  const { data: wo, error: woErr } = await supabase
    .from("work_orders")
    .select("id, shop_id")
    .eq("id", workOrderId)
    .maybeSingle<WORow>();

  if (woErr) {
    return NextResponse.json({ error: woErr.message }, { status: 400 });
  }
  if (!wo?.id || !wo.shop_id) {
    return NextResponse.json({ error: "Work order not found" }, { status: 404 });
  }

  // 4) insert header
  const header: PRInsert = {
    work_order_id: workOrderId,
    shop_id: wo.shop_id,
    requested_by: user.id,
    status: "requested",
    notes: notes ?? null,
  };

  const { data: pr, error: prErr } = await supabase
    .from("part_requests")
    .insert(header)
    .select("id")
    .single();

  if (prErr || !pr?.id) {
    return NextResponse.json(
      { error: prErr?.message ?? "Failed to create part request" },
      { status: 500 },
    );
  }

  // 5) insert item rows — now with markup_pct + work_order_line_id
  const itemRows: PartRequestItemInsertWithExtras[] = items.map((it) => ({
    request_id: pr.id,
    description: it.description.trim(),
    qty: Number(it.qty),
    approved: false,
    part_id: null,
    quoted_price: null,
    vendor: null,
    markup_pct: DEFAULT_MARKUP,
    work_order_line_id: jobId ?? null,
  }));

  const { error: itemsErr } = await supabase
    .from("part_request_items")
    .insert(itemRows);

  if (itemsErr) {
    // best-effort rollback if items fail
    await supabase.from("part_requests").delete().eq("id", pr.id);
    return NextResponse.json(
      { error: itemsErr.message ?? "Failed to insert request items" },
      { status: 500 },
    );
  }

  // 6) optionally put the line on hold / approval pending
  if (jobId) {
    const updatePayload: WOLUpdate = {
      status: "on_hold",
      approval_state: "pending",
    };
    await supabase
      .from("work_order_lines")
      .update(updatePayload)
      .eq("id", jobId);
  }

  return NextResponse.json({ requestId: pr.id });
}

/* =============================== */
/* FILE: app/api/ai/quote-suggest/route.ts */
/* =============================== */

import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database, Json } from "@shared/types/types/supabase";
import { ProFixAI, type QuoteEnginePart } from "@/features/integrations/ai";

type DB = Database;

type ConfidenceLevel = "low" | "medium" | "high";

// Keep the response structured and easy to consume
export type AISuggestion = {
  parts: { name: string; qty?: number; cost?: number; notes?: string }[];
  laborHours: number;
  laborRate?: number;
  summary: string;
  confidence?: ConfidenceLevel;
  price?: number;
  notes?: string;
  title?: string;
};

interface VehicleInput {
  year?: string | number | null;
  make?: string | null;
  model?: string | null;
  vin?: string | null;
}

interface RequestBody {
  item: string;
  notes?: string;
  section: string;
  status: string;
  value?: string;
  unit?: string;
  vehicle?: VehicleInput | null;
}

function isRequestBody(value: unknown): value is RequestBody {
  if (typeof value !== "object" || value === null) return false;
  const obj = value as Record<string, unknown>;
  return (
    typeof obj.item === "string" &&
    typeof obj.section === "string" &&
    typeof obj.status === "string"
  );
}

function mapConfidence(score: number): ConfidenceLevel {
  if (score >= 0.75) return "high";
  if (score >= 0.5) return "medium";
  return "low";
}

function buildVehicleYmm(vehicle?: VehicleInput | null): string | null {
  if (!vehicle) return null;

  const year =
    vehicle.year !== undefined && vehicle.year !== null
      ? String(vehicle.year)
      : "";
  const make = vehicle.make ?? "";
  const model = vehicle.model ?? "";

  const combined = [year, make, model].join(" ").trim();
  return combined.length > 0 ? combined : null;
}

function buildComplaint(input: RequestBody): string {
  const parts: string[] = [];

  if (input.section) {
    parts.push(`[${input.section}]`);
  }

  if (input.status) {
    parts.push(`Status: ${input.status}`);
  }

  parts.push(input.item);

  if (typeof input.notes === "string" && input.notes.trim().length > 0) {
    parts.push(`Notes: ${input.notes.trim()}`);
  }

  if (input.value) {
    const valuePart = input.unit ? `${input.value} ${input.unit}` : input.value;
    parts.push(`Value: ${valuePart}`);
  }

  return parts.join(" | ");
}

export async function POST(req: Request) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    const rawBody: unknown = await req.json();
    if (!isRequestBody(rawBody)) {
      return NextResponse.json(
        { error: "Invalid request body" },
        { status: 400 },
      );
    }

    const body: RequestBody = rawBody;
    const { item, notes, section, status, vehicle } = body;

    // Resolve shopId from the authenticated user (if available)
    let shopId: string | null = null;
    try {
      const {
        data: { session },
      } = await supabase.auth.getSession();

      const userId = session?.user?.id ?? null;
      if (userId) {
        const { data: profile } = await supabase
          .from("profiles")
          .select("shop_id")
          .eq("user_id", userId)
          .maybeSingle();

        if (profile?.shop_id) {
          shopId = profile.shop_id;
        }
      }
    } catch (resolveErr) {
      // Do not block suggestion if shop resolution fails
      console.warn(
        "[AI] Failed to resolve shopId for quote-suggest:",
        resolveErr,
      );
    }

    const complaint = buildComplaint(body);
    const vehicleYmm = buildVehicleYmm(vehicle);

    // Call central AI engine
    const aiResult = await ProFixAI.suggestQuote({
      shopId: shopId ?? "unknown_shop",
      vehicleYmm,
      complaint,
    });

    const baseSummary =
      typeof notes === "string" && notes.trim().length > 0
        ? notes.trim()
        : item;

    let suggestion: AISuggestion;

    if (aiResult) {
      suggestion = {
        parts: aiResult.parts.map((p: QuoteEnginePart) => ({
          name: p.description || "Suggested part",
          qty: p.qty,
          cost: p.price,
          notes: p.partId ? `Part ID: ${p.partId}` : undefined,
        })),
        laborHours: aiResult.laborHours,
        summary: baseSummary,
        confidence: mapConfidence(aiResult.confidence),
      };
    } else {
      // Fallback: minimal but valid suggestion
      suggestion = {
        parts: [],
        laborHours: 0.5,
        summary: baseSummary,
        confidence: "low",
      };
    }

    // Persist the inference into ai_events (best-effort; ignore failures)
    try {
      const vehiclePayload =
        vehicle !== undefined && vehicle !== null
          ? {
              year: vehicle.year ?? null,
              make: vehicle.make ?? null,
              model: vehicle.model ?? null,
              vin: vehicle.vin ?? null,
            }
          : null;

      const payload: Json = {
        input: {
          item,
          notes: notes ?? null,
          section,
          status,
          value: body.value ?? null,
          unit: body.unit ?? null,
          vehicle: vehiclePayload,
          complaint,
        },
        output: suggestion,
      } as unknown as Json;

      await supabase.from("ai_events").insert({
        event_type: "quote_suggest",
        payload,
        shop_id: shopId,
        entity_id: null,
        entity_table: "inspection_results",
      });
    } catch (logErr) {
      console.warn("[AI] Failed to log quote-suggest event:", logErr);
    }

    return NextResponse.json({ suggestion });
  } catch (err) {
    // eslint-disable-next-line no-console
    console.error("quote-suggest error:", err);
    return NextResponse.json(
      { error: "AI suggestion failed" },
      { status: 500 },
    );
  }
}


/* =============================== */
/* FILE: app/api/inspections/complete/route.ts */
/* =============================== */

// app/api/inspections/complete/route.ts
import "server-only";
import { NextResponse, type NextRequest } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database, TablesInsert } from "@shared/types/types/supabase";

import type { InspectionItem } from "@/features/inspections/lib/inspection/types";

import { generateQuoteFromInspection } from "@quotes/lib/quote/generateQuoteFromInspection";
import { normalizeQuoteLine } from "@quotes/lib/quote/normalizeQuoteLine";

export const runtime = "nodejs";

type DB = Database;
type QuoteLinesInsert = TablesInsert<"quote_lines">;

/* ----------------------------- Type guards ----------------------------- */
function isInspectionItem(value: unknown): value is InspectionItem {
  if (typeof value !== "object" || value === null) return false;
  return true; // minimal structural check
}
function isInspectionItemArray(value: unknown): value is InspectionItem[] {
  return Array.isArray(value) && value.every(isInspectionItem);
}

/* -------------------------------- Types -------------------------------- */
type CompleteRequest = {
  workOrderId: string;
  workOrderLineId: string;
  results: InspectionItem[];
  templateName?: string | null; // accepted, but we won't write it (no column)
};

/* --------------------------------- Route -------------------------------- */
export async function POST(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    // 1) Parse & validate
    const body = (await req.json()) as Partial<CompleteRequest>;
    const workOrderId = String(body.workOrderId ?? "");
    const workOrderLineId = String(body.workOrderLineId ?? "");
    const results = body.results;

    if (!workOrderId || !workOrderLineId) {
      return NextResponse.json(
        { error: "Missing workOrderId or workOrderLineId." },
        { status: 400 }
      );
    }
    if (!isInspectionItemArray(results)) {
      return NextResponse.json(
        { error: "results must be an array of InspectionItem." },
        { status: 400 }
      );
    }

    // current user (for quote_lines.user_id)
    const {
      data: { user },
    } = await supabase.auth.getUser();
    const userId = user?.id ?? null;

    // 2) Verify the WO line exists
    const { data: line, error: lineErr } = await supabase
      .from("work_order_lines")
      .select("*")
      .eq("id", workOrderLineId)
      .maybeSingle();

    if (lineErr) {
      return NextResponse.json(
        { error: `Failed to load work order line: ${lineErr.message}` },
        { status: 500 }
      );
    }
    if (!line) {
      return NextResponse.json(
        { error: "Work order line not found." },
        { status: 404 }
      );
    }

    // 3) Generate AI summary and quote lines from inspection results
    const { summary, quote } = await generateQuoteFromInspection(results);
    const normalized = await Promise.all(quote.map((q) => normalizeQuoteLine(q)));

    // 4) Insert quote_lines (match your schema exactly)
    const nowIso = new Date().toISOString();
    const quoteRows: QuoteLinesInsert[] = normalized.map((n): QuoteLinesInsert => ({
      work_order_id: workOrderId,

      // text columns used by your UI
      description: n.description,
      item: n.item ?? n.name ?? n.description,
      name: n.name ?? n.description,
      title: n.description, // required by your schema

      // pricing / labor
      quantity: 1,
      labor_time: typeof n.laborHours === "number" ? n.laborHours : null,
      price: typeof n.price === "number" ? n.price : null,
      total: typeof n.price === "number" ? n.price : null,

      // parts info if present / inferred
      part_name: n.part?.name ?? n.partName ?? null,
      part_price:
        typeof n.part?.price === "number"
          ? n.part.price
          : n.partPrice ?? null,

      // misc columns
      photo_urls: Array.isArray(n.photoUrls) ? n.photoUrls : null,
      status: "draft",
      user_id: userId,
      updated_at: nowIso,
    }));

    if (quoteRows.length > 0) {
      const { error: insErr } = await supabase
        .from("quote_lines")
        .insert(quoteRows);
      if (insErr) {
        return NextResponse.json(
          { error: `Failed to insert quote lines: ${insErr.message}` },
          { status: 500 }
        );
      }
    }

    // 5) Mark the inspection line complete & store AI summary in correction
    const { error: updErr } = await supabase
      .from("work_order_lines")
      .update({
        status: "completed",
        correction: summary ?? null,
        updated_at: nowIso,
      })
      .eq("id", workOrderLineId);

    if (updErr) {
      return NextResponse.json(
        { error: `Failed to update work order line: ${updErr.message}` },
        { status: 500 }
      );
    }

    // 6) Done
    return NextResponse.json({
      ok: true,
      workOrderId,
      workOrderLineId,
      summary,
      inserted: quoteRows.length,
    });
  } catch (err) {
    const message =
      err instanceof Error
        ? err.message
        : "Unexpected error handling inspection completion.";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/settings/update/route.ts */
/* =============================== */

// app/api/settings/update/route.ts
import { NextResponse } from "next/server";
import { cookies as nextCookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

const COOKIE_NAME = "pfq_owner_pin_shop";

// Whitelist fields that can be updated from Settings
const ALLOWED_FIELDS = new Set([
  "name",
  "address",
  "city",
  "province",
  "postal_code",
  "phone_number",
  "email",
  "logo_url",

  // numeric settings
  "labor_rate",
  "supplies_percent",
  "diagnostic_fee",
  "tax_rate",

  // boolean flags
  "use_ai",
  "require_cause_correction",
  "require_authorization",
  "email_on_complete",
  "auto_generate_pdf",
  "auto_send_quote_email",

  // text
  "invoice_terms",
  "invoice_footer",
]);

type Payload = {
  shopId?: string;
  update?: Record<string, unknown>;
};

export async function POST(req: Request) {
  try {
    // Pass the cookies FUNCTION to Supabase
    const supabase = createRouteHandlerClient<Database>({ cookies: nextCookies });

    // 1) Auth required
    const {
      data: { user },
      error: userErr,
    } = await supabase.auth.getUser();
    if (userErr || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2) Parse body
    const { shopId, update } = (await req.json().catch(() => ({}))) as Payload;
    if (!shopId || !update || typeof update !== "object") {
      return NextResponse.json(
        { error: "Missing shopId or update payload" },
        { status: 400 },
      );
    }

    // 3) Role + shop scope check (staff of this shop)
    const { data: profile } = await supabase
      .from("profiles")
      .select("role, shop_id")
      .eq("id", user.id)
      .single();

    if (!profile?.shop_id || profile.shop_id !== shopId) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // 4) Require valid owner-PIN cookie for this shop
    // 4) Require valid owner-PIN cookie for this shop
const cookieStore = await nextCookies();                // <-- add this
const pinCookie = cookieStore.get(COOKIE_NAME)?.value;  // <-- use store
if (!pinCookie || pinCookie !== shopId) {
  return NextResponse.json({ error: "Owner PIN required" }, { status: 401 });
}

    // 5) Filter payload to allowed fields only
    const safeUpdate: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(update)) {
      if (!ALLOWED_FIELDS.has(k)) continue;

      if (["labor_rate", "supplies_percent", "diagnostic_fee", "tax_rate"].includes(k)) {
        safeUpdate[k] =
          v === null || v === "" ? null : typeof v === "number" ? v : Number(v);
        continue;
      }

      if (
        [
          "use_ai",
          "require_cause_correction",
          "require_authorization",
          "email_on_complete",
          "auto_generate_pdf",
          "auto_send_quote_email",
        ].includes(k)
      ) {
        safeUpdate[k] = Boolean(v);
        continue;
      }

      safeUpdate[k] = v;
    }

    if (Object.keys(safeUpdate).length === 0) {
      return NextResponse.json({ error: "No valid fields to update" }, { status: 400 });
    }

    // 6) Update only within this shop
    const { error: updErr } = await supabase.from("shops").update(safeUpdate).eq("id", shopId);
    if (updErr) {
      return NextResponse.json({ error: updErr.message ?? "Update failed" }, { status: 500 });
    }

    return NextResponse.json({ ok: true });
  } catch (err) {
    console.error("settings.update error", err);
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/quotes/apply-ai/route.ts */
/* =============================== */

import { NextResponse } from "next/server";
import { createClient, type SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "@shared/types/types/supabase";
import { recordQuoteTraining } from "@/features/integrations/ai";

type DB = Database;

/* -------------------------- AI Suggestion Types -------------------------- */

type AISuggestion = {
  parts: { name: string; qty?: number; cost?: number; notes?: string }[];
  laborHours: number;
  laborRate: number;
  summary: string;
  confidence: "low" | "medium" | "high";
  price?: number;
  notes?: string;
  title?: string;
};

interface Body {
  workOrderLineId: string;
  suggestion: AISuggestion;
}

function isBody(x: unknown): x is Body {
  if (typeof x !== "object" || x === null) return false;
  const o = x as Record<string, unknown>;
  return (
    typeof o.workOrderLineId === "string" &&
    typeof o.suggestion === "object" &&
    o.suggestion !== null
  );
}

/* ----------------- Resolve a shop's primary inventory location ---------------- */

async function resolvePrimaryLocationId(
  sb: SupabaseClient<DB>,
  workOrderLineId: string,
): Promise<string | null> {
  const { data: line } = await sb
    .from("work_order_lines")
    .select("shop_id")
    .eq("id", workOrderLineId)
    .maybeSingle();

  if (!line?.shop_id) return null;

  const { data: locs } = await sb
    .from("inventory_locations")
    .select("id, is_primary")
    .eq("shop_id", line.shop_id)
    .order("is_primary", { ascending: false }) // primary first
    .limit(1);

  return locs?.[0]?.id ?? null;
}

/* ---------------------------------- Route ---------------------------------- */

export async function POST(req: Request) {
  try {
    const body: unknown = await req.json();
    if (!isBody(body)) {
      return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
    }

    const { workOrderLineId, suggestion } = body;

    // Env: server key only (non-null)
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseKey =
      (process.env.SUPABASE_SERVICE_ROLE_KEY ??
        process.env.SUPABASE_SERVICE_KEY)!;

    if (!supabaseUrl || !supabaseKey) {
      return NextResponse.json(
        {
          error: "Server misconfiguration — Supabase env missing",
          detail:
            "Check NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY (or SUPABASE_SERVICE_KEY).",
        },
        { status: 500 },
      );
    }

    const sb = createClient<DB>(supabaseUrl, supabaseKey);

    // Require an inventory location (prevents FK errors on allocations)
    const locationId = await resolvePrimaryLocationId(sb, workOrderLineId);
    if (!locationId) {
      return NextResponse.json(
        {
          error: "This shop has no inventory location configured.",
          detail: "Create a primary inventory location first.",
          code: "NO_LOCATION_CONFIGURED",
        },
        { status: 422 },
      );
    }

    const unmatched: { name: string; qty: number }[] = [];

    // Allocate each AI-suggested part to this line
    for (const { name, qty = 1 } of suggestion.parts ?? []) {
      const { data: found, error: pe } = await sb
        .from("parts")
        .select("id")
        // use % for ilike match; if you prefer exact, change to .eq("name", name)
        .ilike("name", `%${name}%`)
        .limit(1);

      if (pe) {
        unmatched.push({ name, qty });
        continue;
      }

      const match = found?.[0];
      if (!match) {
        unmatched.push({ name, qty });
        continue;
      }

      const alloc: DB["public"]["Tables"]["work_order_part_allocations"]["Insert"] =
        {
          work_order_line_id: workOrderLineId,
          part_id: match.id,
          qty,
          location_id: locationId, // required by FK; we resolved above
        };

      const { error: ae } = await sb
        .from("work_order_part_allocations")
        .insert(alloc);

      if (ae) {
        unmatched.push({ name, qty });
        continue;
      }
    }

    // Mark as "quoted" flow started (keep workflow status; set approval_state)
    const { error: updateErr } = await sb
      .from("work_order_lines")
      .update({ approval_state: "pending" })
      .eq("id", workOrderLineId);

    if (updateErr) {
      return NextResponse.json(
        { error: "Failed updating approval state", detail: updateErr.message },
        { status: 500 },
      );
    }

    // ------------------------ AI TRAINING: APPLIED QUOTE ------------------------
    try {
      const { data: line } = await sb
        .from("work_order_lines")
        .select("id, work_order_id, shop_id, description, complaint")
        .eq("id", workOrderLineId)
        .maybeSingle();

      if (line?.shop_id) {
        await recordQuoteTraining({
          quoteId: workOrderLineId, // treat the line as the "quote" record
          shopId: line.shop_id,
          workOrderId: line.work_order_id ?? null,
          workOrderLineId,
          vehicleYmm: null, // TODO: hydrate via vehicles table
          payload: {
            complaint: line.complaint,
            description: line.description,
            suggestion,
            unmatched,
          },
        });
      }
    } catch (trainErr) {
      // Never block user flow on training errors
      // eslint-disable-next-line no-console
      console.warn("AI training for apply-ai quote failed:", trainErr);
    }

    return NextResponse.json({ ok: true, unmatched });
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error("apply-ai Quote Error 👉", e);
    return NextResponse.json(
      { error: "Failed applying AI quote" },
      { status: 500 },
    );
  }
}

/* =============================== */
/* FILE: app/api/menu-items/upsert-from-line/route.ts */
/* =============================== */

import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;

/*
-- Suggested table
create table if not exists saved_menu_items (
  id uuid primary key default gen_random_uuid(),
  make text not null,
  model text not null,
  year_bucket text not null, -- e.g. "2015-2018" or "2019-2021"
  title text not null,       -- normalized job title
  labor_time numeric,        -- default hours
  parts jsonb not null default '[]',  -- [{part_id, qty}]
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create unique index if not exists saved_menu_items_uq
  on saved_menu_items(make, model, year_bucket, title);
*/

interface Body {
  workOrderLineId: string;
}

function isBody(x: unknown): x is Body {
  if (typeof x !== "object" || x === null) return false;
  const o = x as Record<string, unknown>;
  return typeof o.workOrderLineId === "string";
}

function yearBucket(y?: number | null): string {
  if (!y || Number.isNaN(y)) return "unknown";
  // e.g. 2015-2018, 2019-2021, etc. (3-year buckets)
  const start = y - ((y - 1) % 3);
  const end = start + 2;
  return `${start}-${end}`;
}

export async function POST(req: Request) {
  try {
    const bUnknown: unknown = await req.json();
    if (!isBody(bUnknown)) {
      return NextResponse.json({ error: "Invalid body" }, { status: 400 });
    }
    const { workOrderLineId } = bUnknown;

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const serviceKey =
      process.env.SUPABASE_SERVICE_ROLE_KEY ?? process.env.SUPABASE_SERVICE_KEY;
    if (!supabaseUrl || !serviceKey) {
      return NextResponse.json({ error: "Server not configured" }, { status: 500 });
    }
    const sb = createClient<DB>(supabaseUrl, serviceKey);

    // Line
    const { data: line, error: le } = await sb
      .from("work_order_lines").select("*")
      .eq("id", workOrderLineId)
      .maybeSingle<DB["public"]["Tables"]["work_order_lines"]["Row"]>();
    if (le || !line) {
      return NextResponse.json({ error: le?.message ?? "Line not found" }, { status: 404 });
    }

    // Parent WO => vehicle
    const { data: wo } = await sb
      .from("work_orders").select("*")
      .eq("id", line.work_order_id)
      .maybeSingle<DB["public"]["Tables"]["work_orders"]["Row"]>();
    const { data: vehicle } = wo?.vehicle_id
      ? await sb.from("vehicles").select("*").eq("id", wo.vehicle_id)
          .maybeSingle<DB["public"]["Tables"]["vehicles"]["Row"]>()
      : { data: null };

    const make = (vehicle?.make ?? "").trim();
    const model = (vehicle?.model ?? "").trim();
    const year = typeof vehicle?.year === "number"
      ? vehicle?.year
      : Number((vehicle?.year as unknown as string) ?? NaN);
    const yBucket = yearBucket(year);

    // Sanity: “fully quoted” = has labor_time OR has at least one allocation
    const { data: allocs } = await sb
      .from("work_order_part_allocations")
      .select("part_id, qty")
      .eq("work_order_line_id", workOrderLineId);

    const fullyQuoted = (line.labor_time !== null && line.labor_time !== undefined)
      || ((allocs ?? []).length > 0);

    if (!make || !model || !fullyQuoted) {
      return NextResponse.json({ error: "Line not fully quoted or vehicle missing" }, { status: 400 });
    }

    // Normalize a job title
    const rawTitle = (line.description ?? line.complaint ?? "Repair").trim();
    const title = rawTitle.replace(/\s+/g, " ").replace(/\.$/, "");

    // Upsert saved_menu_items
    const partsJson = (allocs ?? []).map(a => ({ part_id: a.part_id, qty: a.qty }));
    const insert = {
      make,
      model,
      year_bucket: yBucket,
      title,
      labor_time: line.labor_time ?? null,
      parts: partsJson as unknown as NonNullable<DB["public"]["Tables"]["saved_menu_items"]["Row"]["parts"]>,
      updated_at: new Date().toISOString(),
    };

    // NOTE: upsert based on the unique index (make, model, year_bucket, title)
    const { data, error } = await sb
      .from("saved_menu_items")
      .upsert(insert, { onConflict: "make,model,year_bucket,title" })
      .select("id")
      .single();

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ id: data?.id ?? null, ok: true });
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Unknown error";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/work-orders/add-line/route.ts */
/* =============================== */

import { NextResponse } from "next/server";
import { createClient, type PostgrestError } from "@supabase/supabase-js";

type PartLine = { name: string; qty?: number; cost?: number; notes?: string };

type AISuggestion = {
  parts: PartLine[];
  laborHours: number;
  laborRate?: number;
  summary: string;
  confidence?: "low" | "medium" | "high";
  price?: number;
  notes?: string;
  title?: string;
};

type LineStatus =
  | "awaiting"
  | "queued"
  | "in_progress"
  | "on_hold"
  | "paused"
  | "completed"
  | "assigned"
  | "unassigned"
  | "awaiting_approval"   // ✅ now supported in DB CHECK
  | "declined";           // ✅ now supported in DB CHECK

type ApprovalState = "pending" | "approved" | "declined" | null;

type JobType =
  | "diagnosis"
  | "inspection"
  | "maintenance"
  | "repair"
  | "tech-suggested"
  | null;

interface InsertWorkOrderLine {
  work_order_id: string;
  description: string;
  job_type: JobType;
  status: LineStatus;
  approval_state: ApprovalState;
  notes: string | null;
  labor_time: number | null;
}

interface AddLineRequestBody {
  workOrderId: string;
  description: string;
  section?: string;
  status?: "recommend" | "fail";
  suggestion: AISuggestion;
  jobType?: "inspection" | "repair" | "maintenance" | "diagnosis" | "tech-suggested";
}

function isValidBody(b: unknown): b is AddLineRequestBody {
  if (typeof b !== "object" || b === null) return false;
  const o = b as Record<string, unknown>;
  return (
    typeof o.workOrderId === "string" &&
    typeof o.description === "string" &&
    typeof o.suggestion === "object" &&
    o.suggestion !== null
  );
}

export async function POST(req: Request) {
  try {
    const bodyUnknown: unknown = await req.json();

    if (!isValidBody(bodyUnknown)) {
      return NextResponse.json(
        { error: "Invalid body: require workOrderId, description, suggestion" },
        { status: 400 }
      );
    }

    const {
      workOrderId,
      description,
      section,
      status,     // "recommend" | "fail" from inspection
      suggestion,
      jobType = "inspection",
    } = bodyUnknown;

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const serviceKey =
      process.env.SUPABASE_SERVICE_ROLE_KEY ?? process.env.SUPABASE_SERVICE_KEY;

    if (!supabaseUrl || !serviceKey) {
      return NextResponse.json(
        { error: "Server not configured for Supabase" },
        { status: 500 }
      );
    }

    const supabase = createClient(supabaseUrl, serviceKey);

    // Build compact notes (extra context for advisors)
    const notesParts: string[] = [];
    if (section) notesParts.push(`Section: ${section}`);
    if (status) notesParts.push(`From inspection: ${status.toUpperCase()}`);
    if (suggestion.summary?.trim()) notesParts.push(`AI: ${suggestion.summary.trim()}`);
    const notes: string | null = notesParts.length ? notesParts.join(" • ") : null;

    const laborTime: number | null =
      typeof suggestion.laborHours === "number" ? suggestion.laborHours : null;

    // ✅ Create as a quote line:
    // - status: awaiting_approval (non-punchable)
    // - approval_state: pending
    const insertPayload: InsertWorkOrderLine = {
      work_order_id: workOrderId,
      description,
      job_type: (jobType as JobType) ?? "inspection",
      status: "awaiting_approval",
      approval_state: "pending",
      notes,
      labor_time: laborTime,
    };

    const { data, error } = await supabase
      .from("work_order_lines")
      .insert(insertPayload)
      .select("id")
      .single();

    if (error) {
      const e = error as PostgrestError;
      return NextResponse.json(
        { error: e.message, details: e.details, hint: e.hint, code: e.code },
        { status: 500 }
      );
    }

    return NextResponse.json({ id: (data as { id: string }).id });
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Unknown error";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/work-orders/quotes/[id]/mark-quoted/route.ts */
/* =============================== */

// app/api/work-orders/quotes/[id]/mark-quoted/route.ts
import "server-only";
import { NextResponse, type NextRequest } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

export const runtime = "nodejs";

type DB = Database;

export async function PATCH(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    // Extract `[id]` from the pathname .../quotes/<id>/mark-quoted
    const segments = req.nextUrl.pathname.split("/").filter(Boolean);
    const id = segments[segments.length - 2]; // segment before "mark-quoted"

    if (!id) {
      return NextResponse.json({ error: "Missing quote line id" }, { status: 400 });
    }

    // Mark the quote line as quoted
    const { error: updErr } = await supabase
      .from("work_order_quote_lines")
      .update({ status: "quoted", updated_at: new Date().toISOString() })
      .eq("id", id);

    if (updErr) {
      return NextResponse.json({ error: updErr.message }, { status: 500 });
    }

    return NextResponse.json({ ok: true });
  } catch {
    return NextResponse.json({ error: "Failed to mark as quoted" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/work-orders/quotes/[id]/authorize/route.ts */
/* =============================== */

// app/api/work-orders/quotes/[id]/authorize/route.ts
import "server-only";
import { NextResponse, type NextRequest } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import type { Database, TablesInsert } from "@shared/types/types/supabase";

export const runtime = "nodejs";

type DB = Database;
type WorkOrderLineInsert = TablesInsert<"work_order_lines">;

export async function POST(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  try {
    // Extract `[id]` from the pathname .../quotes/<id>/authorize
    const segments = req.nextUrl.pathname.split("/").filter(Boolean);
    const id = segments[segments.length - 2]; // the segment before "authorize"

    if (!id) {
      return NextResponse.json({ error: "Missing quote line id" }, { status: 400 });
    }

    // 1) Load the quote line we’re authorizing
    const { data: q, error: qErr } = await supabase
      .from("work_order_quote_lines")
      .select("*")
      .eq("id", id)
      .single();

    if (qErr || !q) {
      return NextResponse.json({ error: "Quote line not found" }, { status: 404 });
    }

    // 2) Turn it into a punchable job line
    const newLine: WorkOrderLineInsert = {
      work_order_id: q.work_order_id,
      vehicle_id: q.vehicle_id,
      description: q.description,
      job_type: q.job_type ?? "repair",
      status: "queued",
      labor_time: q.est_labor_hours ?? null,
      complaint: q.ai_complaint ?? q.description,
      cause: q.ai_cause ?? null,
      correction: q.ai_correction ?? null,
    };

    const { data: inserted, error: insErr } = await supabase
      .from("work_order_lines")
      .insert(newLine)
      .select("id")
      .single();

    if (insErr) {
      return NextResponse.json({ error: insErr.message }, { status: 500 });
    }

    // 3) Mark quote line as converted
    const { error: updErr } = await supabase
      .from("work_order_quote_lines")
      .update({ status: "converted", updated_at: new Date().toISOString() })
      .eq("id", id);

    if (updErr) {
      return NextResponse.json({ error: updErr.message }, { status: 500 });
    }

    return NextResponse.json({ ok: true, jobLineId: inserted?.id ?? null });
  } catch {
    return NextResponse.json({ error: "Failed to authorize" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/api/work-orders/quotes/add/route.ts */
/* =============================== */

import "server-only";
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;

export async function POST(req: Request) {
  const supabase = createServerComponentClient<DB>({ cookies });
  try {
    const { workOrderId, vehicleId, items } = await req.json() as {
      workOrderId: string;
      vehicleId?: string | null;
      items: Array<{
        description: string;
        jobType?: "diagnosis"|"repair"|"maintenance"|"tech-suggested";
        estLaborHours?: number;
        notes?: string;
        aiComplaint?: string;
        aiCause?: string;
        aiCorrection?: string;
      }>;
    };

    if (!workOrderId || !Array.isArray(items) || items.length === 0) {
      return NextResponse.json({ error: "Missing workOrderId or items" }, { status: 400 });
    }

    const { data: { user } } = await supabase.auth.getUser();
    const suggested_by = user?.id ?? null;

    const rows = items.map(i => ({
      work_order_id: workOrderId,
      vehicle_id: vehicleId ?? null,
      suggested_by,
      description: i.description,
      job_type: i.jobType ?? "tech-suggested",
      est_labor_hours: i.estLaborHours ?? null,
      notes: i.notes ?? null,
      status: "pending_parts",
      ai_complaint: i.aiComplaint ?? null,
      ai_cause: i.aiCause ?? null,
      ai_correction: i.aiCorrection ?? null,
    }));

    const { error } = await supabase.from("work_order_quote_lines").insert(rows);
    if (error) return NextResponse.json({ error: error.message }, { status: 500 });

    return NextResponse.json({ ok: true });
  } catch {
    return NextResponse.json({ error: "Failed to add quote items" }, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/work-orders/[id]/Client.tsx */
/* =============================== */

"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { useParams } from "next/navigation";
import { format } from "date-fns";
import { toast } from "sonner";
import dynamic from "next/dynamic";

import { supabaseBrowser as supabase } from "@/features/shared/lib/supabase/client";
import type { Database } from "@shared/types/types/supabase";

import PreviousPageButton from "@shared/components/ui/PreviousPageButton";
import VehiclePhotoUploader from "@parts/components/VehiclePhotoUploader";
import VehiclePhotoGallery from "@parts/components/VehiclePhotoGallery";
import FocusedJobModal from "@/features/work-orders/components/workorders/FocusedJobModal";
import { UsePartButton } from "@work-orders/components/UsePartButton";
import VoiceContextSetter from "@/features/shared/voice/VoiceContextSetter";
import VoiceButton from "@/features/shared/voice/VoiceButton";
import { useTabState } from "@/features/shared/hooks/useTabState";
import PartsDrawer from "@/features/parts/components/PartsDrawer";

// assign-mechanic modal
import AssignTechModal from "@/features/work-orders/components/workorders/extras/AssignTechModal";

// inspection modal
const InspectionModal = dynamic(
  () => import("@/features/inspections/components/InspectionModal"),
  { ssr: false }
);

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];
type Customer = DB["public"]["Tables"]["customers"]["Row"];
type Profile = DB["public"]["Tables"]["profiles"]["Row"];
type AllocationRow =
  DB["public"]["Tables"]["work_order_part_allocations"]["Row"] & {
    parts?: { name: string | null } | null;
  };
type LineTechRow =
  DB["public"]["Tables"]["work_order_line_technicians"]["Row"];

const looksLikeUuid = (s: string) => s.includes("-") && s.length >= 36;

function splitCustomId(raw: string): { prefix: string; n: number | null } {
  const m = raw.toUpperCase().match(/^([A-Z]+)\s*0*?(\d+)?$/);
  if (!m) return { prefix: raw.toUpperCase(), n: null };
  const n = m[2] ? parseInt(m[2], 10) : null;
  return { prefix: m[1], n: Number.isFinite(n!) ? n : null };
}

/* ---------------------------- Badges & Row Tints ---------------------------- */

type KnownStatus =
  | "awaiting_approval"
  | "awaiting"
  | "queued"
  | "in_progress"
  | "on_hold"
  | "planned"
  | "new"
  | "completed"
  | "ready_to_invoice"
  | "invoiced";

const BASE_BADGE =
  "inline-flex items-center whitespace-nowrap rounded border px-2 py-0.5 text-xs font-medium";

const BADGE: Record<KnownStatus, string> = {
  awaiting_approval: "bg-blue-900/20 border-blue-500/40 text-blue-300",
  awaiting: "bg-sky-900/20  border-sky-500/40  text-sky-300",
  queued: "bg-indigo-900/20 border-indigo-500/40 text-indigo-300",
  in_progress: "bg-orange-900/20 border-orange-500/40 text-orange-300",
  on_hold: "bg-amber-900/20  border-amber-500/40  text-amber-300",
  planned: "bg-purple-900/20 border-purple-500/40 text-purple-300",
  new: "bg-neutral-800   border-neutral-600   text-neutral-200",
  completed: "bg-green-900/20  border-green-500/40 text-green-300",
  ready_to_invoice: "bg-emerald-900/20 border-emerald-500/40 text-emerald-300",
  invoiced: "bg-teal-900/20    border-teal-500/40    text-teal-300",
};

const chip = (s: string | null | undefined): string => {
  const key = (s ?? "awaiting").toLowerCase().replaceAll(" ", "_") as KnownStatus;
  return `${BASE_BADGE} ${BADGE[key] ?? BADGE.awaiting}`;
};

const statusBorder: Record<string, string> = {
  awaiting: "border-l-4 border-slate-400",
  queued: "border-l-4 border-indigo-400",
  in_progress: "border-l-4 border-orange-500",
  on_hold: "border-l-4 border-amber-500",
  completed: "border-l-4 border-green-500",
  awaiting_approval: "border-l-4 border-blue-500",
  planned: "border-l-4 border-purple-500",
  new: "border-l-4 border-gray-400",
};

const statusRowTint: Record<string, string> = {
  awaiting: "bg-neutral-950",
  queued: "bg-neutral-950",
  in_progress: "bg-neutral-950",
  on_hold: "bg-amber-900/30",
  completed: "bg-green-900/30",
  awaiting_approval: "bg-neutral-950",
  planned: "bg-neutral-950",
  new: "bg-neutral-950",
};

// roles allowed to assign
const ASSIGN_ROLES = new Set(["owner", "admin", "manager", "advisor"]);

/* ------------------------------------------------------------------------- */

export default function WorkOrderIdClient(): JSX.Element {
  const params = useParams();
  const routeId = (params?.id as string) || "";

  const [wo, setWo] = useTabState<WorkOrder | null>("wo:id:wo", null);
  const [lines, setLines] = useTabState<WorkOrderLine[]>("wo:id:lines", []);
  const [vehicle, setVehicle] = useTabState<Vehicle | null>("wo:id:veh", null);
  const [customer, setCustomer] = useTabState<Customer | null>("wo:id:cust", null);

  const [allocsByLine, setAllocsByLine] = useState<Record<string, AllocationRow[]>>({});
  const [loading, setLoading] = useState<boolean>(false);
  const [viewError, setViewError] = useState<string | null>(null);

  const [currentUserId, setCurrentUserId] = useTabState<string | null>("wo:id:uid", null);
  const [, setUserId] = useTabState<string | null>("wo:id:effectiveUid", null);
  const [currentUserRole, setCurrentUserRole] = useState<string | null>(null);

  const [showDetails, setShowDetails] = useTabState<boolean>("wo:showDetails", true);
  const [focusedJobId, setFocusedJobId] = useState<string | null>(null);
  const [focusedOpen, setFocusedOpen] = useState(false);
  const [warnedMissing, setWarnedMissing] = useState(false);

  // parts
  const [partsLineId, setPartsLineId] = useState<string | null>(null);
  const [bulkQueue, setBulkQueue] = useState<string[]>([]);
  const [bulkActive, setBulkActive] = useState<boolean>(false);

  // inspection
  const [inspectionOpen, setInspectionOpen] = useState(false);
  const [inspectionSrc, setInspectionSrc] = useState<string | null>(null);

  // assign mechanic
  const [assignOpen, setAssignOpen] = useState(false);
  const [assignLineId, setAssignLineId] = useState<string | null>(null);
  const [assignables, setAssignables] = useState<
    Array<Pick<Profile, "id" | "full_name" | "role">>
  >([]);

  // per-line technicians
  const [lineTechsByLine, setLineTechsByLine] = useState<Record<string, string[]>>({});

  /* ---------------------- AUTH + assignables ---------------------- */
  useEffect(() => {
    let mounted = true;

    const waitForSession = async () => {
      let {
        data: { session },
      } = await supabase.auth.getSession();

      if (!session) {
        for (let i = 0; i < 8; i++) {
          await new Promise((r) => setTimeout(r, 150 * (i + 1)));
          const res = await supabase.auth.getSession();
          session = res.data.session;
          if (session) break;
        }
      }

      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!mounted) return;

      const uid = user?.id ?? null;
      setCurrentUserId(uid);
      setUserId(uid);

      if (uid) {
        const { data: prof } = await supabase
          .from("profiles")
          .select("role")
          .eq("id", uid)
          .maybeSingle();
        setCurrentUserRole(prof?.role ?? null);
      }

      try {
        const res = await fetch("/api/assignables");
        const json = await res.json();
        if (res.ok && Array.isArray(json.data)) {
          setAssignables(json.data);
        }
      } catch {
        // ignore
      }

      if (!uid) setLoading(false);
    };

    void waitForSession();

    const { data: sub } = supabase.auth.onAuthStateChange((_evt, s) => {
      if (s?.user) void waitForSession();
      else {
        setCurrentUserId(null);
        setUserId(null);
        setLoading(false);
      }
    });

    return () => {
      mounted = false;
      sub?.subscription?.unsubscribe?.();
    };
  }, [supabase, routeId, setCurrentUserId, setUserId]);

  /* ---------------------- FETCH ---------------------- */
  const fetchAll = useCallback(
    async (retry = 0) => {
      if (!routeId) return;
      setLoading(true);
      setViewError(null);

      try {
        let woRow: WorkOrder | null = null;

        // by UUID
        if (looksLikeUuid(routeId)) {
          const { data, error } = await supabase
            .from("work_orders")
            .select("*")
            .eq("id", routeId)
            .maybeSingle();
          if (!error) woRow = (data as WorkOrder | null) ?? null;
        }

        // by custom_id
        if (!woRow) {
          const eqRes = await supabase
            .from("work_orders")
            .select("*")
            .eq("custom_id", routeId)
            .maybeSingle();
          woRow = (eqRes.data as WorkOrder | null) ?? null;

          if (!woRow) {
            const ilikeRes = await supabase
              .from("work_orders")
              .select("*")
              .ilike("custom_id", routeId.toUpperCase())
              .maybeSingle();
            woRow = (ilikeRes.data as WorkOrder | null) ?? null;
          }

          if (!woRow) {
            const { prefix, n } = splitCustomId(routeId);
            if (n !== null) {
              const { data: cands } = await supabase
                .from("work_orders")
                .select("*")
                .ilike("custom_id", `${prefix}%`)
                .limit(50);
              const wanted = `${prefix}${n}`;
              const match = (cands ?? []).find(
                (r) =>
                  (r.custom_id ?? "")
                    .toUpperCase()
                    .replace(/^([A-Z]+)0+/, "$1") === wanted
              );
              if (match) woRow = match as WorkOrder;
            }
          }
        }

        if (!woRow) {
          if (retry < 2) {
            await new Promise((r) => setTimeout(r, 200 * Math.pow(2, retry)));
            return fetchAll(retry + 1);
          }
          setViewError("Work order not visible / not found.");
          setWo(null);
          setLines([]);
          setVehicle(null);
          setCustomer(null);
          setAllocsByLine({});
          setLineTechsByLine({});
          setLoading(false);
          return;
        }

        setWo(woRow);

        if (!warnedMissing && (!woRow.vehicle_id || !woRow.customer_id)) {
          toast.error(
            "This work order is missing vehicle and/or customer. Open the Create form to set them."
          );
          setWarnedMissing(true);
        }

        const [linesRes, vehRes, custRes] = await Promise.all([
          supabase
            .from("work_order_lines")
            .select("*")
            .eq("work_order_id", woRow.id)
            .order("created_at", { ascending: true }),
          woRow.vehicle_id
            ? supabase
                .from("vehicles")
                .select("*")
                .eq("id", woRow.vehicle_id)
                .maybeSingle()
            : Promise.resolve({ data: null, error: null } as const),
          woRow.customer_id
            ? supabase
                .from("customers")
                .select("*")
                .eq("id", woRow.customer_id)
                .maybeSingle()
            : Promise.resolve({ data: null, error: null } as const),
        ]);

        if (linesRes.error) throw linesRes.error;
        const lineRows = (linesRes.data ?? []) as WorkOrderLine[];
        setLines(lineRows);

        if (vehRes?.error) throw vehRes.error;
        setVehicle((vehRes?.data as Vehicle | null) ?? null);

        if (custRes?.error) throw custRes.error;
        setCustomer((custRes?.data as Customer | null) ?? null);

        // allocations + line techs
        if (lineRows.length) {
          const [allocsQuery, lineTechsQuery] = await Promise.all([
            supabase
              .from("work_order_part_allocations")
              .select("*, parts(name)")
              .in(
                "work_order_line_id",
                lineRows.map((l) => l.id)
              ),
            supabase
              .from("work_order_line_technicians")
              .select("work_order_line_id, technician_id")
              .in(
                "work_order_line_id",
                lineRows.map((l) => l.id)
              ),
          ]);

          const byLine: Record<string, AllocationRow[]> = {};
          (allocsQuery.data ?? []).forEach((a) => {
            const key = (a as AllocationRow).work_order_line_id;
            if (!byLine[key]) byLine[key] = [];
            byLine[key].push(a as AllocationRow);
          });
          setAllocsByLine(byLine);

          const techMap: Record<string, string[]> = {};
          (lineTechsQuery.data as LineTechRow[] | null)?.forEach((lt) => {
            const lnId = lt.work_order_line_id;
            const techId = lt.technician_id;
            if (!techMap[lnId]) techMap[lnId] = [];
            if (!techMap[lnId].includes(techId)) {
              techMap[lnId].push(techId);
            }
          });
          setLineTechsByLine(techMap);
        } else {
          setAllocsByLine({});
          setLineTechsByLine({});
        }
      } catch (e: unknown) {
        const msg =
          e instanceof Error ? e.message : "Failed to load work order.";
        setViewError(msg);
        console.error("[WO id page] load error:", e);
      } finally {
        setLoading(false);
      }
    },
    [
      supabase,
      routeId,
      warnedMissing,
      setWo,
      setLines,
      setVehicle,
      setCustomer,
    ]
  );

  useEffect(() => {
    if (!routeId || !currentUserId) return;
    void fetchAll();
  }, [fetchAll, routeId, currentUserId]);

  /* ---------------------- REALTIME ---------------------- */
  useEffect(() => {
    if (!wo?.id) return;

    const ch = supabase
      .channel(`wo:${wo.id}`)
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "work_orders", filter: `id=eq.${wo.id}` },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_lines",
          filter: `work_order_id=eq.${wo.id}`,
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_part_allocations",
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_line_technicians",
        },
        () => fetchAll()
      )
      .subscribe();

    const local = () => fetchAll();
    window.addEventListener("wo:parts-used", local);

    return () => {
      try {
        supabase.removeChannel(ch);
      } catch {}
      window.removeEventListener("wo:parts-used", local);
    };
  }, [supabase, wo?.id, fetchAll]);

  // ---------- listen for inspection finish ----------
  useEffect(() => {
    interface InspectionCompletedEventDetail {
      workOrderLineId?: string;
      cause?: string;
      correction?: string;
    }

    const handler = (ev: CustomEvent<InspectionCompletedEventDetail>) => {
      const d = ev.detail || {};
      const lineId = d.workOrderLineId;
      if (!lineId) return;

      setFocusedJobId(lineId);
      setFocusedOpen(true);

      window.dispatchEvent(
        new CustomEvent("wo:prefill-cause-correction", {
          detail: {
            lineId,
            cause: d.cause ?? "",
            correction: d.correction ?? "",
          },
        })
      );
    };

    window.addEventListener("inspection:completed", handler as EventListener);
    return () => {
      window.removeEventListener("inspection:completed", handler as EventListener);
    };
  }, []);

  // 🔁 refresh this page when a parts request is submitted from the focused modal
  useEffect(() => {
    const handler = () => {
      void fetchAll();
    };
    window.addEventListener("parts-request:submitted", handler);
    return () => window.removeEventListener("parts-request:submitted", handler);
  }, [fetchAll]);

  /* ----------------------- Derived data ----------------------- */
  const approvalPending = useMemo(
    () => lines.filter((l) => (l.approval_state ?? null) === "pending"),
    [lines]
  );

  const activeJobLines = useMemo(
    () => lines.filter((l) => (l.approval_state ?? null) !== "pending"),
    [lines]
  );

  const sortedLines = useMemo(() => {
    const pr: Record<string, number> = {
      diagnosis: 1,
      inspection: 2,
      maintenance: 3,
      repair: 4,
    };
    return [...activeJobLines].sort((a, b) => {
      const pa = pr[String(a.job_type ?? "repair")] ?? 999;
      const pb = pr[String(b.job_type ?? "repair")] ?? 999;
      if (pa !== pb) return pa - pb;
      const ta = a.created_at ? new Date(a.created_at).getTime() : 0;
      const tb = b.created_at ? new Date(b.created_at).getTime() : 0;
      return ta - tb;
    });
  }, [activeJobLines]);

  const createdAt = wo?.created_at ? new Date(wo.created_at) : null;
  const createdAtText =
    createdAt && !isNaN(createdAt.getTime())
      ? format(createdAt, "PPpp")
      : "—";

  const canAssign = currentUserRole ? ASSIGN_ROLES.has(currentUserRole) : false;

  const assignablesById = useMemo(() => {
    const m: Record<string, { full_name: string | null; role: string | null }> = {};
    assignables.forEach((a) => {
      m[a.id] = { full_name: a.full_name, role: a.role };
    });
    return m;
  }, [assignables]);

  /* ----------------------- line actions ----------------------- */

  const approveLine = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          approval_state: "approved",
          status: "queued",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      toast.success("Line approved");
      void fetchAll();
    },
    [supabase, fetchAll]
  );

  const declineLine = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          approval_state: "declined",
          status: "awaiting",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      toast.success("Line declined");
      void fetchAll();
    },
    [supabase, fetchAll]
  );

  const sendToParts = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          status: "on_hold",
          hold_reason: "Awaiting parts quote",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      setPartsLineId(lineId);
      toast.success("Sent to parts for quoting");
    },
    [supabase]
  );

  const sendAllPendingToParts = useCallback(async () => {
    if (!approvalPending.length) return;
    const ids = approvalPending.map((l) => l.id);
    const { error } = await supabase
      .from("work_order_lines")
      .update({
        status: "on_hold",
        hold_reason: "Awaiting parts quote",
      } as DB["public"]["Tables"]["work_order_lines"]["Update"])
      .in("id", ids);
    if (error) {
      toast.error(error.message);
      return;
    }
    setBulkQueue(ids);
    setBulkActive(true);
    setPartsLineId(ids[0] ?? null);
    toast.success("Queued all pending lines for parts quoting");
  }, [approvalPending, supabase]);

  // open inspection
  const openInspectionForLine = useCallback(
    async (ln: WorkOrderLine) => {
      if (!ln?.id) return;

      const desc = String(ln.description ?? "").toLowerCase();
      const isAir = /\bair\b|cvip|push\s*rod|air\s*brake/.test(desc);
      const isCustom = /\bcustom\b|\bbuilder\b|\bprompt\b|\bad[-\s]?hoc\b/.test(
        desc
      );

      let templateSlug = isAir ? "maintenance50-air" : "maintenance50";
      if (isCustom) {
        templateSlug = "custom:pending";
      }

      try {
        const res = await fetch("/api/inspections/session/create", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            workOrderId: wo?.id ?? null,
            workOrderLineId: ln.id,
            vehicleId: vehicle?.id ?? null,
            customerId: customer?.id ?? null,
            template: templateSlug,
          }),
        });

        const j = (await res.json().catch(() => null)) as
          | { sessionId?: string; error?: string }
          | null;

        if (!res.ok || !j?.sessionId) {
          throw new Error(j?.error || "Failed to create inspection session");
        }

        if (isCustom) {
          templateSlug = `custom:${j.sessionId}`;
        }

        const sp = new URLSearchParams();
        if (wo?.id) sp.set("workOrderId", wo.id);
        sp.set("workOrderLineId", ln.id);
        sp.set("inspectionId", j.sessionId);
        sp.set("template", templateSlug);
        sp.set("embed", "1");
        if (isCustom && ln.description)
          sp.set("seed", String(ln.description));

        const url = `/inspection/${templateSlug}?${sp.toString()}`;

        setInspectionSrc(url);
        setInspectionOpen(true);
        toast.success("Inspection opened");
      } catch (e) {
        const err = e as { message?: string };
        toast.error(err?.message ?? "Unable to open inspection");
      }
    },
    [wo?.id, vehicle?.id, customer?.id]
  );

  // parts drawer close / bulk
  useEffect(() => {
    if (!partsLineId) return;

    const evtName = `parts-drawer:closed:${partsLineId}`;

    const handler = () => {
      if (bulkActive && bulkQueue.length > 0) {
        const [, ...rest] = bulkQueue;
        setBulkQueue(rest);
        setPartsLineId(rest[0] ?? null);
        if (rest.length === 0) {
          setBulkActive(false);
          void fetchAll();
        }
      } else {
        setPartsLineId(null);
        void fetchAll();
      }
    };

    window.addEventListener(evtName, handler as EventListener);
    return () => window.removeEventListener(evtName, handler as EventListener);
  }, [partsLineId, bulkActive, bulkQueue, fetchAll]);

  /* -------------------------- UI -------------------------- */
  if (!routeId)
    return <div className="p-6 text-red-500">Missing work order id.</div>;

  const Skeleton = ({ className = "" }: { className?: string }) => (
    <div className={`animate-pulse rounded-lg bg-neutral-800/60 ${className}`} />
  );

  return (
    <div className="mx-auto max-w-6xl px-3 py-6 bg-background text-foreground">
      <VoiceContextSetter
        currentView="work_order_page"
        workOrderId={wo?.id}
        vehicleId={vehicle?.id}
        customerId={customer?.id}
        lineId={null}
      />

      <div className="mb-4 flex items-center justify-between gap-2">
        <PreviousPageButton to="/work-orders" />
        {wo?.custom_id && (
          <span className="rounded-full border border-neutral-800 bg-neutral-900/70 px-3 py-1 text-xs text-neutral-300">
            Internal ID: {wo.id.slice(0, 8)}
          </span>
        )}
      </div>

      {!currentUserId && (
        <div className="mb-4 rounded-lg border border-amber-500/30 bg-amber-900/10 p-3 text-sm text-amber-100">
          You appear signed out on this tab. If actions fail, open{" "}
          <Link href="/sign-in" className="underline hover:text-white">
            Sign In
          </Link>{" "}
          and return here.
        </div>
      )}

      {viewError && (
        <div className="mb-4 whitespace-pre-wrap rounded-lg border border-red-500/40 bg-red-950/60 p-3 text-sm text-red-200">
          {viewError}
        </div>
      )}

      {loading ? (
        <div className="mt-6 grid gap-4">
          <Skeleton className="h-24" />
          <Skeleton className="h-40" />
          <Skeleton className="h-56" />
        </div>
      ) : !wo ? (
        <div className="mt-6 text-sm text-red-400">Work order not found.</div>
      ) : (
        <div className="grid grid-cols-1 gap-6 lg:grid-cols-[minmax(0,1.7fr),minmax(0,1fr)]">
          {/* LEFT */}
          <div className="space-y-6">
            {/* Header */}
            <div className="rounded-xl border border-border bg-card/95 p-4 shadow-sm">
              <div className="flex flex-wrap items-center justify-between gap-3">
                <div className="space-y-1">
                  <div className="flex flex-wrap items-center gap-2">
                    <h1 className="text-xl font-semibold text-white sm:text-2xl">
                      Work Order{" "}
                      <span className="text-orange-400">
                        {wo.custom_id || `#${wo.id.slice(0, 8)}`}
                      </span>
                    </h1>
                    <span className={chip(wo.status)}>
                      {(wo.status ?? "awaiting").replaceAll("_", " ")}
                    </span>
                  </div>
                  <p className="text-xs text-neutral-400">
                    Created {createdAtText}
                  </p>
                </div>
              </div>

              <div className="mt-3 grid gap-3 text-xs text-neutral-300 sm:grid-cols-4">
                <div>
                  <div className="text-neutral-500">Created</div>
                  <div>{createdAtText}</div>
                </div>
                <div>
                  <div className="text-neutral-500">WO ID</div>
                  <div className="truncate font-mono text-[11px] text-neutral-200">
                    {wo.id}
                  </div>
                </div>
                <div>
                  <div className="text-neutral-500">Custom ID</div>
                  <div className="truncate">
                    {wo.custom_id ?? (
                      <span className="text-neutral-500">Not set</span>
                    )}
                  </div>
                </div>
                <div>
                  <div className="text-neutral-500">Status</div>
                  <div className="mt-0.5">
                    <span className={chip(wo.status)}>
                      {(wo.status ?? "awaiting").replaceAll("_", " ")}
                    </span>
                  </div>
                </div>
              </div>
            </div>

            {/* Vehicle & Customer */}
            <div className="rounded-xl border border-border bg-card/95 p-4">
              <div className="flex items-center justify-between gap-2">
                <h2 className="text-sm font-semibold text-white sm:text-base">
                  Vehicle &amp; Customer
                </h2>
                <button
                  type="button"
                  className="text-xs font-medium text-orange-400 hover:text-orange-300 hover:underline"
                  onClick={() => setShowDetails((v) => !v)}
                  aria-expanded={showDetails}
                >
                  {showDetails ? "Hide details" : "Show details"}
                </button>
              </div>

              {showDetails && (
                <div className="mt-3 grid gap-4 sm:grid-cols-2">
                  <div className="rounded-lg bg-neutral-950/60 p-3">
                    <h3 className="mb-1 text-xs font-semibold uppercase tracking-wide text-neutral-400">
                      Vehicle
                    </h3>
                    {vehicle ? (
                      <>
                        <p className="text-sm font-medium text-white">
                          {(vehicle.year ?? "").toString()}{" "}
                          {vehicle.make ?? ""} {vehicle.model ?? ""}
                        </p>
                        <p className="mt-1 text-xs text-neutral-400">
                          VIN:{" "}
                          <span className="font-mono">
                            {vehicle.vin ?? "—"}
                          </span>
                          <br />
                          Plate:{" "}
                          {vehicle.license_plate ?? (
                            <span className="text-neutral-500">—</span>
                          )}
                        </p>
                      </>
                    ) : (
                      <p className="text-sm text-neutral-500">
                        No vehicle linked yet.
                      </p>
                    )}
                  </div>

                  <div className="rounded-lg bg-neutral-950/60 p-3">
                    <h3 className="mb-1 text-xs font-semibold uppercase tracking-wide text-neutral-400">
                      Customer
                    </h3>
                    {customer ? (
                      <>
                        <p className="text-sm font-medium text-white">
                          {[
                            customer.first_name ?? "",
                            customer.last_name ?? "",
                          ]
                            .filter(Boolean)
                            .join(" ") || "—"}
                        </p>
                        <p className="mt-1 text-xs text-neutral-400">
                          {customer.phone ?? "—"}{" "}
                          {customer.email ? (
                            <>
                              <span className="mx-1 text-neutral-600">•</span>
                              {customer.email}
                            </>
                          ) : null}
                        </p>
                        {customer.id && (
                          <Link
                            href={`/customers/${customer.id}`}
                            className="mt-2 inline-flex text-[11px] font-medium text-orange-400 hover:text-orange-300 hover:underline"
                            title="Open customer profile"
                          >
                            View customer profile →
                          </Link>
                        )}
                      </>
                    ) : (
                      <p className="text-sm text-neutral-500">
                        No customer linked yet.
                      </p>
                    )}
                  </div>
                </div>
              )}
            </div>

            {/* Awaiting Customer Approval */}
            <div className="rounded-xl border border-blue-900/60 bg-gradient-to-b from-slate-950 to-slate-950/90 p-4">
              <div className="mb-3 flex items-center justify-between gap-2">
                <h2 className="text-sm font-semibold text-blue-200 sm:text-base">
                  Awaiting customer approval
                </h2>
                {approvalPending.length > 1 && (
                  <button
                    type="button"
                    className="rounded-md bg-blue-600 px-3 py-1.5 text-xs font-semibold text-white shadow-sm hover:bg-blue-500"
                    onClick={sendAllPendingToParts}
                    title="Queue all lines for parts quoting"
                  >
                    Quote all pending lines
                  </button>
                )}
              </div>

              {approvalPending.length === 0 ? (
                <p className="text-xs text-neutral-400">
                  No lines waiting for approval.
                </p>
              ) : (
                <div className="space-y-2">
                  {approvalPending.map((ln, idx) => {
                    const isAwaitingParts =
                      (ln.status === "on_hold" &&
                        (ln.hold_reason ?? "")
                          .toLowerCase()
                          .includes("part")) ||
                      (ln.hold_reason ?? "")
                        .toLowerCase()
                        .includes("quote");

                    return (
                      <div
                        key={ln.id}
                        className="rounded-lg border border-neutral-800 bg-neutral-950/80 p-3"
                      >
                        <div className="flex items-start justify-between gap-3">
                          <div className="min-w-0">
                            <div className="truncate text-sm font-medium text-white">
                              {idx + 1}.{" "}
                              {ln.description || ln.complaint || "Untitled job"}
                            </div>
                            <div className="mt-0.5 text-[11px] text-neutral-400">
                              {String(ln.job_type ?? "job").replaceAll("_", " ")}{" "}
                              •{" "}
                              {typeof ln.labor_time === "number"
                                ? `${ln.labor_time}h`
                                : "—"}{" "}
                              • Status:{" "}
                              {(ln.status ?? "awaiting").replaceAll("_", " ")}{" "}
                              • Approval:{" "}
                              {(ln.approval_state ?? "pending").replaceAll(
                                "_",
                                " "
                              )}
                            </div>
                            {ln.notes && (
                              <div className="mt-1 text-[11px] text-neutral-400">
                                Notes: {ln.notes}
                              </div>
                            )}
                          </div>

                          <div className="flex shrink-0 flex-wrap items-center gap-2">
                            <button
                              type="button"
                              className="rounded-md border border-green-700 px-2 py-1 text-[11px] font-medium text-green-200 hover:bg-green-900/25"
                              onClick={() => approveLine(ln.id)}
                            >
                              Approve
                            </button>
                            <button
                              type="button"
                              className="rounded-md border border-red-700 px-2 py-1 text-[11px] font-medium text-red-200 hover:bg-red-900/30"
                              onClick={() => declineLine(ln.id)}
                            >
                              Decline
                            </button>

                            {isAwaitingParts ? (
                              <button
                                type="button"
                                disabled
                                className="cursor-not-allowed rounded-md border border-neutral-700 px-2 py-1 text-[11px] text-neutral-400"
                              >
                                Sent to parts
                              </button>
                            ) : (
                              <button
                                type="button"
                                className="rounded-md border border-blue-700 px-2 py-1 text-[11px] font-medium text-blue-200 hover:bg-blue-900/25"
                                onClick={() => sendToParts(ln.id)}
                                title="Send to parts for quoting"
                              >
                                Send to parts
                              </button>
                            )}
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>

            {/* Jobs list */}
            <div className="rounded-xl border border-border bg-card/95 p-4">
              <div className="mb-3 flex items-center justify-between gap-2">
                <div>
                  <h2 className="text-sm font-semibold text-white sm:text-base">
                    Jobs in this work order
                  </h2>
                  <p className="text-[11px] text-neutral-500">
                    Tap a job to open the focused panel with full controls.
                  </p>
                </div>
              </div>

              {sortedLines.length === 0 ? (
                <p className="text-sm text-neutral-400">No lines yet.</p>
              ) : (
                <div className="space-y-2">
                  {sortedLines.map((ln, idx) => {
                    const statusKey = (ln.status ?? "awaiting")
                      .toLowerCase()
                      .replaceAll(" ", "_");
                    const borderCls =
                      statusBorder[statusKey] ||
                      "border-l-4 border-gray-400";
                    const tintCls =
                      statusRowTint[statusKey] || "bg-neutral-950";
                    const punchedIn =
                      !!ln.punched_in_at && !ln.punched_out_at;

                    const partsForLine = allocsByLine[ln.id] ?? [];

                    const lineTechIds = lineTechsByLine[ln.id] ?? [];
                    const primaryId =
                      typeof ln.assigned_to === "string"
                        ? (ln.assigned_to as string)
                        : null;

                    const orderedTechIds: string[] = [];
                    if (primaryId) orderedTechIds.push(primaryId);
                    lineTechIds.forEach((tid) => {
                      if (!orderedTechIds.includes(tid)) {
                        orderedTechIds.push(tid);
                      }
                    });

                    return (
                      <div
                        key={ln.id}
                        className={`group rounded-lg border border-neutral-800 ${tintCls} p-3 transition hover:border-orange-500/70 hover:bg-neutral-900/80 ${borderCls} ${
                          punchedIn ? "ring-2 ring-orange-500/80" : ""
                        }`}
                        title="Open focused job"
                        onClick={() => {
                          setFocusedJobId(ln.id);
                          setFocusedOpen(true);
                        }}
                      >
                        <div className="flex items-start justify-between gap-3">
                          <div className="min-w-0">
                            <div className="flex flex-wrap items-center gap-2">
                              <div className="truncate text-sm font-medium text-white">
                                {idx + 1}.{" "}
                                {ln.description ||
                                  ln.complaint ||
                                  "Untitled job"}
                              </div>
                              {ln.job_type === "inspection" && (
                                <button
                                  type="button"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    void openInspectionForLine(ln);
                                  }}
                                  className={`rounded-md border px-2 py-0.5 text-[11px] font-medium ${
                                    ln.status === "completed"
                                      ? "border-green-400 text-green-200"
                                      : "border-orange-400 text-orange-200 hover:bg-orange-500/10"
                                  }`}
                                >
                                  {ln.status === "completed"
                                    ? "View inspection"
                                    : "Open inspection"}
                                </button>
                              )}
                              {canAssign && (
                                <button
                                  type="button"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setAssignLineId(ln.id);
                                    setAssignOpen(true);
                                  }}
                                  className="rounded-md border border-sky-500/70 px-2 py-0.5 text-[11px] font-medium text-sky-200 hover:bg-sky-900/25"
                                  title="Assign mechanic to this line"
                                >
                                  Assign mechanic
                                </button>
                              )}
                            </div>
                            <div className="mt-0.5 text-[11px] text-neutral-400">
                              {String(ln.job_type ?? "job").replaceAll("_", " ")}{" "}
                              •{" "}
                              {typeof ln.labor_time === "number"
                                ? `${ln.labor_time}h`
                                : "—"}{" "}
                              • Status:{" "}
                              {(ln.status ?? "awaiting").replaceAll("_", " ")}
                            </div>

                            {orderedTechIds.length > 0 && (
                              <div className="mt-1 flex flex-wrap gap-1">
                                {orderedTechIds.map((tid) => {
                                  const info = assignablesById[tid];
                                  const label = info?.full_name ?? "Mechanic";
                                  return (
                                    <span
                                      key={tid}
                                      className="inline-flex items-center gap-1 rounded-full bg-sky-900/40 px-2 py-0.5 text-[10px] text-sky-100"
                                    >
                                      <span className="h-1.5 w-1.5 rounded-full bg-sky-300" />
                                      {label}
                                    </span>
                                  );
                                })}
                              </div>
                            )}

                            {(ln.complaint || ln.cause || ln.correction) && (
                              <div className="mt-1 flex flex-wrap items-center gap-2 text-[11px] text-neutral-400">
                                {ln.complaint ? (
                                  <span>Cmpl: {ln.complaint}</span>
                                ) : null}
                                {ln.cause ? (
                                  <span>| Cause: {ln.cause}</span>
                                ) : null}
                                {ln.correction ? (
                                  <span>| Corr: {ln.correction}</span>
                                ) : null}
                              </div>
                            )}

                            {/* Parts used */}
                            <div className="mt-2 rounded-lg border border-neutral-800 bg-neutral-950/80 p-2">
                              <div className="mb-1 flex items-center justify-between gap-2">
                                <div className="text-[11px] font-semibold uppercase tracking-wide text-neutral-300">
                                  Parts used
                                </div>
                                <div className="shrink-0">
                                  <UsePartButton
                                    workOrderLineId={ln.id}
                                    onApplied={() =>
                                      window.dispatchEvent(
                                        new CustomEvent("wo:parts-used")
                                      )
                                    }
                                    label="Add part"
                                  />
                                </div>
                              </div>
                              {partsForLine.length ? (
                                <ul className="mt-1 divide-y divide-neutral-800 rounded border border-neutral-800 text-sm">
                                  {partsForLine.map((a) => (
                                    <li
                                      key={a.id}
                                      className="flex items-center justify-between bg-neutral-900/70 p-2"
                                    >
                                      <div className="min-w-0">
                                        <div className="truncate text-sm text-white">
                                          {a.parts?.name ?? "Part"}
                                        </div>
                                        <div className="text-[11px] text-neutral-500">
                                          loc {String(a.location_id).slice(0, 6)}
                                          …
                                        </div>
                                      </div>
                                      <div className="pl-3 text-sm font-semibold text-neutral-100">
                                        × {a.qty}
                                      </div>
                                    </li>
                                  ))}
                                </ul>
                              ) : (
                                <div className="mt-1 text-[11px] text-neutral-500">
                                  No parts used yet.
                                </div>
                              )}
                            </div>
                          </div>

                          <span className={chip(ln.status)}>
                            {(ln.status ?? "awaiting").replaceAll("_", " ")}
                          </span>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          </div>

          {/* RIGHT rail */}
          <aside className="space-y-4 lg:space-y-6">
            <div className="rounded-xl border border-border bg-card/95 p-4 text-sm text-neutral-300">
              <p>
                Select a job card on the left to open the focused job panel with
                full editing, punch and inspection controls.
              </p>
            </div>
          </aside>
        </div>
      )}

      {/* Vehicle photos */}
      {vehicle?.id && (
        <div className="mt-8 space-y-4">
          <h2 className="text-lg font-semibold text-white sm:text-xl">
            Vehicle photos
          </h2>
          <VehiclePhotoUploader vehicleId={vehicle.id} />
          <VehiclePhotoGallery
            vehicleId={vehicle.id}
            currentUserId={currentUserId || "anon"}
          />
        </div>
      )}

      {/* Focused job modal */}
      {focusedOpen && focusedJobId && (
        <FocusedJobModal
          isOpen={focusedOpen}
          onClose={() => setFocusedOpen(false)}
          workOrderLineId={focusedJobId}
          onChanged={fetchAll}
          mode="tech"
        />
      )}

      {/* Parts Drawer */}
      {partsLineId && wo?.id && (
        <PartsDrawer
          open={!!partsLineId}
          workOrderId={wo.id}
          workOrderLineId={partsLineId}
          vehicleSummary={
            vehicle
              ? {
                  year: (
                    vehicle.year as string | number | null
                  )?.toString() ?? null,
                  make: vehicle.make ?? null,
                  model: vehicle.model ?? null,
                }
              : null
          }
          jobDescription={
            lines.find((l) => l.id === partsLineId)?.description ??
            lines.find((l) => l.id === partsLineId)?.complaint ??
            null
          }
          jobNotes={
            lines.find((l) => l.id === partsLineId)?.notes ?? null
          }
          closeEventName={`parts-drawer:closed:${partsLineId}`}
        />
      )}

      {/* Inspection modal */}
      {inspectionOpen && inspectionSrc && (
        <InspectionModal
          open={inspectionOpen}
          src={inspectionSrc}
          title="Inspection"
          onClose={() => setInspectionOpen(false)}
        />
      )}

      {/* Assign mechanic modal */}
      {assignOpen && assignLineId && (
        <AssignTechModal
          isOpen={assignOpen}
          onClose={() => setAssignOpen(false)}
          workOrderLineId={assignLineId}
          mechanics={assignables}
          onAssigned={async () => {
            await fetchAll();
          }}
        />
      )}

      <VoiceButton />
    </div>
  );
}

/* =============================== */
/* FILE: app/work-orders/[id]/approve/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import SignaturePad, { openSignaturePad } from "@/features/shared/signaturePad/controller";
import LegalTerms from "@/features/shared/components/LegalTerms";
import { uploadSignatureImage } from "@/features/shared/lib/utils/uploadSignature";

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type Line = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Shop = DB["public"]["Tables"]["shops"]["Row"];

/* ------------------------------ helpers ---------------------------------- */
const getStr = (obj: unknown, key: string): string | null => {
  if (obj && typeof obj === "object") {
    const v = (obj as Record<string, unknown>)[key];
    if (typeof v === "string") return v.trim() || null;
  }
  return null;
};
const getNum = (obj: unknown, key: string): number | null => {
  if (obj && typeof obj === "object") {
    const v = (obj as Record<string, unknown>)[key];
    if (typeof v === "number" && Number.isFinite(v)) return v;
    if (typeof v === "string") {
      const n = Number(v);
      if (Number.isFinite(n)) return n;
    }
  }
  return null;
};
/* ------------------------------------------------------------------------- */

export default function ApproveWorkOrderPage() {
  const params = useParams<{ id: string }>();
  const id = Array.isArray(params?.id) ? params.id[0] : params?.id;
  const router = useRouter();
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);

  const [wo, setWo] = useState<WorkOrder | null>(null);
  const [shop, setShop] = useState<Shop | null>(null);
  const [lines, setLines] = useState<Line[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [err, setErr] = useState<string | null>(null);

  const [approved, setApproved] = useState<Set<string>>(new Set());
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [savedSigUrl, setSavedSigUrl] = useState<string | null>(null);
  const [agreed, setAgreed] = useState<boolean>(false);

  useEffect(() => {
    (async () => {
      if (!id) return;
      setLoading(true);
      setErr(null);
      try {
        const [{ data: woRow, error: woErr }, { data: lineRows, error: liErr }] = await Promise.all([
          supabase.from("work_orders").select("*").eq("id", id).maybeSingle(),
          supabase
            .from("work_order_lines")
            .select("*")
            .eq("work_order_id", id)
            .neq("status", "completed")
            .order("created_at", { ascending: true }),
        ]);

        if (woErr) throw woErr;
        if (liErr) throw liErr;

        setWo(woRow ?? null);
        setLines(lineRows ?? []);
        setApproved(new Set((lineRows ?? []).map((l) => l.id)));

        if (woRow?.shop_id) {
          const { data: shopRow, error: sErr } = await supabase
            .from("shops")
            .select("*")
            .eq("id", woRow.shop_id)
            .maybeSingle();
          if (sErr) throw sErr;
          setShop(shopRow ?? null);
        } else {
          setShop(null);
        }
      } catch (e) {
        const msg = e instanceof Error ? e.message : "Failed to load work order.";
        setErr(msg);
      } finally {
        setLoading(false);
      }
    })();
  }, [id, supabase]);

  const toggle = (lineId: string) =>
    setApproved((prev) => {
      const next = new Set(prev);
      if (next.has(lineId)) next.delete(lineId);
      else next.add(lineId);
      return next;
    });

  /* ---- Pricing helpers (mirrors Quote Review) --------------------------- */
  const hourlyRate: number =
    getNum(wo, "hourly_rate") ??
    getNum(shop, "hourly_rate") ??
    120;

  const currencyCode = (getStr(shop, "currency") ?? "USD").toUpperCase();
  const fmt = useMemo(
    () => new Intl.NumberFormat("en-US", { style: "currency", currency: currencyCode }),
    [currencyCode]
  );

  const approvedLines = lines.filter((l) => approved.has(l.id));
  const hours = approvedLines.reduce<number>(
    (sum, l) => sum + (typeof l.labor_time === "number" ? l.labor_time : 0),
    0
  );
  const laborTotal = hours * hourlyRate;

  // if your line rows don’t include parts_total, this stays 0
  const partsTotal = approvedLines.reduce<number>(
    (sum, l) => sum + (getNum(l, "parts_total") ?? 0),
    0
  );
  const grandTotal = laborTotal + partsTotal;

  const totals = { hours: hours.toFixed(1) };
  /* ---------------------------------------------------------------------- */

  async function handleSubmit(signatureDataUrl?: string) {
    if (!id) return;
    setSubmitting(true);
    try {
      let signatureUrl: string | null = savedSigUrl;
      if (signatureDataUrl) {
        const uploaded = await uploadSignatureImage(signatureDataUrl, id);
        signatureUrl = uploaded;
        setSavedSigUrl(uploaded);
      }

      const approvedLineIds: string[] = Array.from(approved);
      const declinedLineIds: string[] = lines.map((l) => l.id).filter((x) => !approved.has(x));

      const res = await fetch("/work-orders/approval-webhook", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          workOrderId: id,
          shopId: wo?.shop_id ?? null,
          customerId: wo?.customer_id ?? null,
          approvedLineIds,
          declinedLineIds,
          declineUnchecked: true,
          approverId: null,
          signatureUrl,
        }),
      });

      const j = (await res.json().catch(() => null)) as { error?: string } | null;
      if (!res.ok) {
        throw new Error(j?.error ?? "Failed to submit approval");
      }

      router.replace(`/work-orders/confirm?woId=${id}`);
    } catch (e) {
      setErr(e instanceof Error ? e.message : "Approval failed");
    } finally {
      setSubmitting(false);
    }
  }

  if (loading) {
    return (
      <div className="mx-auto max-w-2xl p-6 text-white">
        <div className="mb-4 h-8 w-48 animate-pulse rounded bg-neutral-800" />
        <div className="h-24 animate-pulse rounded bg-neutral-800" />
      </div>
    );
  }

  if (!wo) {
    return <div className="mx-auto max-w-2xl p-6 text-red-400">Work order not found.</div>;
  }

  return (
    <div className="mx-auto max-w-3xl p-4 text-white sm:p-6">
      <h1 className="text-2xl font-semibold">
        {shop?.name ? `${shop.name} — Customer Approval` : "Approve Work Order"}
      </h1>
      <p className="mt-1 text-neutral-300">
        {wo.custom_id ? `#${wo.custom_id}` : `#${wo.id.slice(0, 8)}`}
      </p>

      {err && <div className="mt-3 rounded border border-red-500/40 bg-red-500/10 p-3">{err}</div>}

      {/* Items */}
      <div className="mt-4 rounded border border-neutral-800 bg-neutral-900">
        <div className="border-b border-neutral-800 p-3 font-semibold">Items</div>
        <div className="divide-y divide-neutral-800">
          {lines.map((l) => (
            <label
              key={l.id}
              className="flex cursor-pointer items-start gap-3 p-3 hover:bg-neutral-900/60"
            >
              <input
                type="checkbox"
                className="mt-1 h-4 w-4"
                checked={approved.has(l.id)}
                onChange={() => toggle(l.id)}
              />
              <div className="min-w-0">
                <div className="truncate font-medium">
                  {l.description || l.complaint || "Untitled item"}
                </div>
                <div className="text-xs text-neutral-400">
                  {(l.job_type ?? "job").replaceAll("_", " ")} •{" "}
                  {typeof l.labor_time === "number" ? `${l.labor_time.toFixed(1)}h` : "—"}
                </div>
                {(l.cause || l.correction) && (
                  <div className="mt-1 text-xs text-neutral-500">
                    {l.cause ? `Cause: ${l.cause}  ` : ""}
                    {l.correction ? `| Corr: ${l.correction}` : ""}
                  </div>
                )}
              </div>
            </label>
          ))}
          {lines.length === 0 && (
            <div className="p-3 text-sm text-neutral-400">No items to approve.</div>
          )}
        </div>
        <div className="border-t border-neutral-800 p-3 text-sm text-neutral-300">
          Total labor (approved):{" "}
          <span className="font-semibold text-white">{totals.hours}h</span>
        </div>
      </div>

      {/* Totals (like Quote Review) */}
      <div className="mt-4 rounded border border-neutral-800 bg-neutral-900">
        <div className="border-b border-neutral-800 p-3 font-semibold">Totals</div>
        <div className="p-3 text-sm">
          <div className="flex items-center justify-between py-1">
            <div>Labor ({hours.toFixed(1)}h @ {fmt.format(hourlyRate)}/hr)</div>
            <div className="font-medium">{fmt.format(laborTotal)}</div>
          </div>
          <div className="flex items-center justify-between py-1">
            <div>Parts</div>
            <div className="font-medium">{fmt.format(partsTotal)}</div>
          </div>
          <div className="mt-2 border-t border-neutral-800 pt-2 flex items-center justify-between">
            <div className="font-semibold">Total</div>
            <div className="font-semibold">{fmt.format(grandTotal)}</div>
          </div>
        </div>
      </div>

      {/* Terms */}
      <LegalTerms onAgreeChange={setAgreed} defaultOpen />

      {/* Actions */}
      <div className="mt-4 flex flex-wrap gap-2">
        <button
          className="rounded bg-green-600 px-4 py-2 font-semibold text-white hover:bg-green-700 disabled:opacity-60"
          onClick={async () => {
            const base64: string | null = await openSignaturePad({ shopName: shop?.name || "" });
            if (base64) await handleSubmit(base64);
          }}
          disabled={submitting || !agreed}
          title={!agreed ? "Please agree to the Terms & Conditions" : "Sign & Submit"}
        >
          {submitting ? "Submitting…" : "Sign & Submit"}
        </button>

        <button
          className="rounded border border-neutral-700 px-4 py-2 hover:border-orange-500 disabled:opacity-60"
          onClick={() => void handleSubmit()}
          disabled={submitting || !agreed}
        >
          Submit without Signature
        </button>
      </div>

      {/* Mount the modal host once */}
      <SignaturePad />
    </div>
  );
}

/* =============================== */
/* FILE: app/work-orders/components/WorkOrderPreview.tsx */
/* =============================== */

"use client";

import { useEffect, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database, Tables } from "@shared/types/types/supabase";

type Props = { woId: string | null };

type WO = Pick<
  Tables<"work_orders">,
  | "id" | "status" | "type" | "created_at" | "updated_at" | "notes"
  | "customer_id" | "vehicle_id"
  | "invoice_total" | "labor_total" | "parts_total"
  | "quote_url" | "invoice_url"
>;

type Customer = Pick<Tables<"customers">, "name" | "email" | "phone" | "first_name" | "last_name">;
type Vehicle  = Pick<Tables<"vehicles">, "year" | "make" | "model" | "license_plate" | "vin" | "color" | "mileage" | "unit_number">;

type WOLine = Pick<
  Tables<"work_order_lines">,
  | "id" | "description" | "job_type" | "labor_time" | "notes"
  | "complaint" | "cause" | "correction" | "status"
  | "created_at" | "updated_at"
>;

export function WorkOrderPreview({ woId }: Props) {
  const supabase = createClientComponentClient<Database>();
  const [wo, setWO] = useState<WO | null>(null);
  const [customer, setCustomer] = useState<Customer | null>(null);
  const [vehicle, setVehicle] = useState<Vehicle | null>(null);
  const [lines, setLines] = useState<WOLine[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    let active = true;
    async function load() {
      if (!woId) {
        setWO(null);
        setCustomer(null);
        setVehicle(null);
        setLines([]);
        setLoading(false);
        return;
      }
      setLoading(true);
      setError(null);
      try {
        const { data: woData, error: woErr } = await supabase
          .from("work_orders")
          .select("id,status,type,created_at,updated_at,notes,customer_id,vehicle_id,invoice_total,labor_total,parts_total,quote_url,invoice_url")
          .eq("id", woId)
          .single<WO>();
        if (woErr || !woData) throw new Error(woErr?.message || "Work order not found");
        if (!active) return;
        setWO(woData);

        if (woData.customer_id) {
          const { data: c } = await supabase
            .from("customers")
            .select("name,email,phone,first_name,last_name")
            .eq("id", woData.customer_id)
            .single<Customer>();
          if (!active) return;
          setCustomer(c ?? null);
        } else {
          setCustomer(null);
        }

        if (woData.vehicle_id) {
          const { data: v } = await supabase
            .from("vehicles")
            .select("year,make,model,license_plate,vin,color,mileage,unit_number")
            .eq("id", woData.vehicle_id)
            .single<Vehicle>();
          if (!active) return;
          setVehicle(v ?? null);
        } else {
          setVehicle(null);
        }

        const { data: linesRaw } = await supabase
          .from("work_order_lines")
          .select("id,description,job_type,labor_time,notes,complaint,cause,correction,status,created_at,updated_at")
          .eq("work_order_id", woId)
          .order("created_at", { ascending: true })
          .returns<WOLine[]>();

        if (!active) return;
        setLines(linesRaw ?? []);
      } catch (e) {
        if (!active) return;
        setError(e instanceof Error ? e.message : String(e));
      } finally {
        if (active) setLoading(false);
      }
    }
    load();
    return () => { active = false; };
  }, [supabase, woId]);

  if (!woId) {
    return <div className="text-neutral-400 text-sm">No work order id provided yet.</div>;
  }

  if (loading) {
    return (
      <div className="rounded-lg border bg-neutral-950 p-5 text-neutral-300" style={{ borderColor: "#f97316" }}>
        Loading work order…
      </div>
    );
  }

  if (error || !wo) {
    return (
      <div className="text-red-400 text-sm">
        Failed to load work order{error ? `: ${error}` : ""}.
      </div>
    );
  }

  const customerName =
    customer?.name ??
    ([customer?.first_name, customer?.last_name].filter(Boolean).join(" ") || "—");

  const vehicleLabel = [vehicle?.year, vehicle?.make, vehicle?.model].filter(Boolean).join(" ");
  const plateOrVin = vehicle?.license_plate ?? vehicle?.vin ?? "—";

  return (
    <div className="rounded-lg border bg-neutral-950 p-5 shadow-xl" style={{ borderColor: "#f97316" }}>
      <div className="flex items-start justify-between gap-4">
        <h3 className="text-xl text-orange-400" style={{ fontFamily: "'Black Ops One', system-ui, sans-serif" }}>
          Work Order #{String(wo.id).slice(0, 8)}
        </h3>
        <span className="text-[11px] px-2 py-1 rounded bg-neutral-900 text-neutral-300 border border-neutral-800">
          {wo.status ?? "unknown"}
        </span>
      </div>

      <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4 text-sm" style={{ fontFamily: "'Roboto', system-ui, sans-serif" }}>
        <section className="space-y-1">
          <div className="text-neutral-400">Customer</div>
          <div className="text-neutral-100">{customerName}</div>
          <div className="text-neutral-300">{customer?.email || "—"}</div>
          <div className="text-neutral-300">{customer?.phone || "—"}</div>
        </section>

        <section className="space-y-1">
          <div className="text-neutral-400">Vehicle</div>
          <div className="text-neutral-100">{vehicleLabel || "—"}</div>
          <div className="text-neutral-300">Plate/VIN: {plateOrVin}</div>
          <div className="text-neutral-300">
            Color: {vehicle?.color || "—"} · Mileage: {vehicle?.mileage ?? "—"} · Unit: {vehicle?.unit_number || "—"}
          </div>
        </section>
      </div>

      <div className="mt-5 border-t border-neutral-800 pt-4">
        <div className="text-sm text-neutral-400 mb-2" style={{ fontFamily: "'Roboto', system-ui, sans-serif" }}>
          Lines
        </div>
        {lines.length === 0 ? (
          <div className="text-neutral-500 text-sm">No lines yet.</div>
        ) : (
          <ul className="space-y-3">
            {lines.map((l) => (
              <li key={l.id} className="rounded border border-neutral-800 bg-neutral-900 p-3">
                <div className="flex items-center justify-between">
                  <div className="text-neutral-100">{l.description || "(no description)"}</div>
                  <span className="text-[11px] px-2 py-0.5 rounded bg-neutral-950 text-neutral-300 border border-neutral-800">
                    {l.job_type || "—"}
                  </span>
                </div>
                <div className="mt-1 text-xs text-neutral-400">
                  Labor time: {l.labor_time ?? 0} · Status: {l.status || "—"}
                </div>
                {(l.complaint || l.cause || l.correction) && (
                  <div className="mt-2 grid grid-cols-1 md:grid-cols-3 gap-2 text-xs">
                    <div className="bg-neutral-950/60 rounded p-2 border border-neutral-800">
                      <div className="text-neutral-400 mb-1">Complaint</div>
                      <div className="text-neutral-200">{l.complaint || "—"}</div>
                    </div>
                    <div className="bg-neutral-950/60 rounded p-2 border border-neutral-800">
                      <div className="text-neutral-400 mb-1">Cause</div>
                      <div className="text-neutral-200">{l.cause || "—"}</div>
                    </div>
                    <div className="bg-neutral-950/60 rounded p-2 border border-neutral-800">
                      <div className="text-neutral-400 mb-1">Correction</div>
                      <div className="text-neutral-200">{l.correction || "—"}</div>
                    </div>
                  </div>
                )}
                {l.notes && <div className="mt-2 text-xs text-neutral-300">Notes: {l.notes}</div>}
              </li>
            ))}
          </ul>
        )}
      </div>

      <div className="mt-5 border-t border-neutral-800 pt-4 grid grid-cols-1 md:grid-cols-3 gap-3 text-sm">
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="text-neutral-400">Parts Total</div>
          <div className="text-neutral-100">${(wo.parts_total ?? 0).toFixed(2)}</div>
        </div>
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="text-neutral-400">Labor Total</div>
          <div className="text-neutral-100">${(wo.labor_total ?? 0).toFixed(2)}</div>
        </div>
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="text-neutral-400">Invoice Total</div>
          <div className="text-neutral-100">${(wo.invoice_total ?? 0).toFixed(2)}</div>
        </div>
      </div>

      {(wo.quote_url || wo.invoice_url) && (
        <div className="mt-4 flex gap-2">
          {wo.quote_url && (
            <a href={wo.quote_url} target="_blank" rel="noreferrer" className="text-xs underline text-orange-400 hover:text-orange-300">
              Open Quote
            </a>
          )}
          {wo.invoice_url && (
            <a href={wo.invoice_url} target="_blank" rel="noreferrer" className="text-xs underline text-orange-400 hover:text-orange-300">
              Open Invoice
            </a>
          )}
        </div>
      )}

      {wo.notes && (
        <div className="mt-4 text-sm text-neutral-200">
          <div className="text-neutral-400 mb-1">Notes</div>
          <p className="whitespace-pre-wrap">{wo.notes}</p>
        </div>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: app/work-orders/approval-webhook/route.ts */
/* =============================== */

// app/work-orders/approval-webhook/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type Json = Record<string, unknown>;

type Body = {
  workOrderId?: string;
  approvedLineIds?: string[];
  declinedLineIds?: string[];
  declineUnchecked?: boolean;
  approverId?: string | null;    // reserved for later use
  signatureUrl?: string | null;
};

const isString = (v: unknown): v is string => typeof v === "string";
const strArray = (v: unknown): string[] =>
  Array.isArray(v) ? v.filter(isString) : [];

export async function POST(req: NextRequest) {
  const supabase = createRouteHandlerClient<DB>({ cookies });

  // --- read & validate body ---
  let body: Body;
  try {
    body = (await req.json()) as Body;
  } catch {
    return NextResponse.json(
      { error: "Invalid JSON body" } satisfies Json,
      { status: 400 }
    );
  }

  const workOrderId = isString(body.workOrderId) ? body.workOrderId : "";
  const approvedLineIds = strArray(body.approvedLineIds);
  const declinedLineIds = strArray(body.declinedLineIds);
  const declineUnchecked = body.declineUnchecked ?? true;
  const signatureUrl = isString(body.signatureUrl) ? body.signatureUrl : null;

  if (!workOrderId) {
    return NextResponse.json(
      { error: "Missing workOrderId" } satisfies Json,
      { status: 400 }
    );
  }

  try {
    // 1) Mark approved items
    if (approvedLineIds.length > 0) {
      const { error } = await supabase
        .from("work_order_lines")
        .update({ approval_state: "approved" })
        .in("id", approvedLineIds)
        .eq("work_order_id", workOrderId);
      if (error) throw new Error(error.message);
    }

    // 2) Mark declined items (only if asked to decline unchecked)
    if (declineUnchecked && declinedLineIds.length > 0) {
      const { error } = await supabase
        .from("work_order_lines")
        .update({ approval_state: "declined" })
        .in("id", declinedLineIds)
        .eq("work_order_id", workOrderId);
      if (error) throw new Error(error.message);
    }

    // 3) Store signature + approval timestamp on the WO
    //    Also reflect the decision at the WO level so Quote Review hides it
    const { error: woErr } = await supabase
      .from("work_orders")
      .update({
        customer_approval_at: new Date().toISOString(),
        customer_approval_signature_path: signatureUrl,
        // ensure this WO drops out of quote-review and shows in normal flow
        approval_state: "approved",
        status: "queued",
      })
      .eq("id", workOrderId);
    if (woErr) throw new Error(woErr.message);

    return NextResponse.json(
      {
        success: true,
        workOrderId,
        approvedLineIds,
        declinedLineIds,
      } satisfies Json,
      { status: 200 }
    );
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Internal error";
    return NextResponse.json({ error: msg } satisfies Json, { status: 500 });
  }
}

/* =============================== */
/* FILE: app/work-orders/history/WorkOrdersHistoryClient.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState, useCallback } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import Link from "next/link";
import { format } from "date-fns";

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type Customer = DB["public"]["Tables"]["customers"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];

type Row = WorkOrder & {
  customers: Pick<
    Customer,
    "first_name" | "last_name" | "email" | "phone"
  > | null;
  vehicles: Pick<
    Vehicle,
    "year" | "make" | "model" | "license_plate" | "vin"
  > | null;
};

export default function WorkOrdersHistoryClient(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);

  const [shopId, setShopId] = useState<string | null>(null);
  const [rows, setRows] = useState<Row[]>([]);
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState<string | null>(null);

  const [q, setQ] = useState("");
  const [from, setFrom] = useState<string>("");
  const [to, setTo] = useState<string>("");

  // ---- Load current user's shop ----
  useEffect(() => {
    (async () => {
      setLoading(true);
      setErr(null);

      const {
        data: { user },
        error: userErr,
      } = await supabase.auth.getUser();

      if (userErr || !user) {
        setErr("You must be signed in to view work order history.");
        setLoading(false);
        return;
      }

      const { data: profile, error: profErr } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("id", user.id)
        .maybeSingle();

      if (profErr) {
        setErr(profErr.message);
        setLoading(false);
        return;
      }

      if (!profile?.shop_id) {
        setErr("No shop is linked to your profile yet.");
        setLoading(false);
        return;
      }

      setShopId(profile.shop_id);
      setLoading(false);
    })();
  }, [supabase]);

  // ---- Load completed work orders for this shop ----
  const load = useCallback(async () => {
    if (!shopId) return;

    setLoading(true);
    setErr(null);

    let query = supabase
      .from("work_orders")
      .select(
        `
        *,
        customers:customers(first_name,last_name,email,phone),
        vehicles:vehicles(year,make,model,license_plate,vin)
      `
      )
      .eq("shop_id", shopId)
      .eq("status", "completed")
      .order("updated_at", { ascending: false })
      .limit(300);

    if (from) {
      query = query.gte("updated_at", new Date(from + "T00:00:00Z").toISOString());
    }
    if (to) {
      const toEnd = new Date(to);
      toEnd.setHours(23, 59, 59, 999);
      query = query.lte("updated_at", toEnd.toISOString());
    }

    const { data, error } = await query;

    if (error) {
      setErr(error.message);
      setRows([]);
      setLoading(false);
      return;
    }

    const list = (data ?? []) as Row[];

    const qlc = q.trim().toLowerCase();
    const filtered = qlc
      ? list.filter((r) => {
          const name = [r.customers?.first_name ?? "", r.customers?.last_name ?? ""]
            .filter(Boolean)
            .join(" ")
            .toLowerCase();
          const plate = r.vehicles?.license_plate?.toLowerCase() ?? "";
          const vin = r.vehicles?.vin?.toLowerCase() ?? "";
          const ymm = [
            r.vehicles?.year ?? "",
            r.vehicles?.make ?? "",
            r.vehicles?.model ?? "",
          ]
            .join(" ")
            .toLowerCase();
          const cid = (r.custom_id ?? "").toLowerCase();
          return (
            r.id.toLowerCase().includes(qlc) ||
            cid.includes(qlc) ||
            name.includes(qlc) ||
            plate.includes(qlc) ||
            vin.includes(qlc) ||
            ymm.includes(qlc)
          );
        })
      : list;

    setRows(filtered);
    setLoading(false);
  }, [supabase, shopId, from, to, q]);

  // Initial load + reload when filters change via Apply button
  useEffect(() => {
    if (!shopId) return;
    void load();
  }, [load, shopId]);

  function exportCSV() {
    const header = [
      "WO ID",
      "Custom ID",
      "Updated",
      "Customer",
      "Email",
      "Phone",
      "Vehicle",
      "Plate",
      "VIN",
      "Invoice URL",
    ];
    const lines = rows.map((r) => {
      const customer = [r.customers?.first_name ?? "", r.customers?.last_name ?? ""]
        .filter(Boolean)
        .join(" ");
      const vehicle = r.vehicles
        ? `${r.vehicles.year ?? ""} ${r.vehicles.make ?? ""} ${
            r.vehicles.model ?? ""
          }`.trim()
        : "";
      const updated = r.updated_at
        ? format(new Date(r.updated_at), "yyyy-MM-dd HH:mm")
        : "";
      return [
        r.id,
        r.custom_id ?? "",
        updated,
        customer,
        r.customers?.email ?? "",
        r.customers?.phone ?? "",
        vehicle,
        r.vehicles?.license_plate ?? "",
        r.vehicles?.vin ?? "",
        r.invoice_url ?? r.quote_url ?? "",
      ]
        .map((x) => `"${String(x ?? "").replace(/"/g, '""')}"`)
        .join(",");
    });

    const blob = new Blob([header.join(",") + "\n" + lines.join("\n")], {
      type: "text/csv;charset=utf-8",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `work-order-history-${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  return (
    <div className="mx-auto max-w-6xl p-6 bg-background text-foreground">
      {/* Header */}
      <div className="mb-4 flex flex-wrap items-center gap-3">
        <div>
          <h1 className="text-2xl font-blackops text-orange-500">
            Work Order History
          </h1>
          <p className="text-xs text-muted-foreground">
            Completed work orders for your shop. Search, filter by date, export for
            reporting.
          </p>
        </div>

        <div className="ml-auto text-right text-xs text-muted-foreground">
          <div>
            <span className="font-semibold text-orange-400">
              {rows.length}
            </span>{" "}
            completed work orders
          </div>
          {from || to ? (
            <div className="mt-0.5">
              Range:{" "}
              <span className="font-mono">
                {from || "…"} → {to || "…"}
              </span>
            </div>
          ) : (
            <div className="mt-0.5">Showing last {rows.length} records loaded</div>
          )}
        </div>
      </div>

      {/* Filters bar */}
      <div className="mb-4 rounded-xl border border-border bg-card/80 p-3 shadow-sm">
        <div className="flex flex-wrap items-end gap-3">
          <div className="flex-1 min-w-[220px]">
            <label className="mb-1 block text-[11px] font-medium uppercase tracking-[0.12em] text-muted-foreground">
              Search
            </label>
            <input
              value={q}
              onChange={(e) => setQ(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && load()}
              placeholder="ID, custom ID, name, VIN, plate, YMM…"
              className="w-full rounded-md border border-border bg-background px-3 py-1.5 text-sm outline-none focus:border-orange-400 focus:ring-1 focus:ring-orange-500"
            />
          </div>

          <div>
            <label className="mb-1 block text-[11px] uppercase tracking-[0.12em] text-muted-foreground">
              From
            </label>
            <input
              type="date"
              value={from}
              onChange={(e) => setFrom(e.target.value)}
              className="rounded-md border border-border bg-background px-3 py-1.5 text-sm focus:border-orange-400 focus:ring-1 focus:ring-orange-500"
              aria-label="From date"
            />
          </div>
          <div>
            <label className="mb-1 block text-[11px] uppercase tracking-[0.12em] text-muted-foreground">
              To
            </label>
            <input
              type="date"
              value={to}
              onChange={(e) => setTo(e.target.value)}
              className="rounded-md border border-border bg-background px-3 py-1.5 text-sm focus:border-orange-400 focus:ring-1 focus:ring-orange-500"
              aria-label="To date"
            />
          </div>

          <div className="flex flex-wrap gap-2">
            <button
              onClick={load}
              className="rounded-md border border-border bg-muted/60 px-3 py-1.5 text-sm hover:bg-muted/90"
            >
              Apply
            </button>
            <button
              onClick={() => window.print()}
              className="rounded-md border border-border bg-neutral-900 px-3 py-1.5 text-sm hover:bg-neutral-800"
            >
              Print
            </button>
            <button
              onClick={exportCSV}
              className="rounded-md bg-purple-600 px-3 py-1.5 text-sm font-semibold text-white hover:bg-purple-500"
            >
              Export CSV
            </button>
          </div>
        </div>
      </div>

      {/* Error */}
      {err && (
        <div className="mb-3 rounded border border-red-500/40 bg-red-500/10 p-2 text-sm text-red-400">
          {err}
        </div>
      )}

      {/* Content */}
      {loading ? (
        <div className="rounded border border-dashed border-border bg-card/60 p-6 text-sm text-muted-foreground">
          Loading completed work orders…
        </div>
      ) : rows.length === 0 ? (
        <div className="rounded border border-dashed border-border bg-card/60 p-6 text-sm text-muted-foreground">
          No completed work orders found for this shop and date range.
        </div>
      ) : (
        <div className="divide-y divide-border rounded-xl border border-border bg-card">
          {rows.map((r) => {
            const updated = r.updated_at
              ? format(new Date(r.updated_at), "PPpp")
              : "—";
            const customer = r.customers
              ? [r.customers.first_name ?? "", r.customers.last_name ?? ""]
                  .filter(Boolean)
                  .join(" ")
              : "—";
            const vehicle = r.vehicles
              ? `${r.vehicles.year ?? ""} ${r.vehicles.make ?? ""} ${
                  r.vehicles.model ?? ""
                }`.trim()
              : "—";
            const plate = r.vehicles?.license_plate
              ? `(${r.vehicles.license_plate})`
              : "";
            const vin = r.vehicles?.vin ? `VIN: ${r.vehicles.vin}` : "";

            return (
              <div
                key={r.id}
                className="flex flex-col gap-2 p-3 sm:flex-row sm:items-center"
              >
                <div className="min-w-0 flex-1">
                  <div className="flex flex-wrap items-center gap-2">
                    <Link
                      href={`/work-orders/${r.id}`}
                      className="font-medium text-orange-400 underline decoration-transparent underline-offset-2 hover:decoration-orange-400"
                    >
                      {r.custom_id ? r.custom_id : `#${r.id.slice(0, 8)}`}
                    </Link>
                    {r.custom_id && (
                      <span className="text-[10px] rounded border border-border px-1 py-0.5 font-mono text-muted-foreground">
                        #{r.id.slice(0, 6)}
                      </span>
                    )}
                    <span className="inline-flex items-center rounded-full border border-emerald-400/40 bg-emerald-500/10 px-2 py-0.5 text-[11px] font-medium uppercase tracking-wide text-emerald-300">
                      Completed
                    </span>
                    <span className="text-xs text-muted-foreground">
                      {updated}
                    </span>
                  </div>
                  <div className="truncate text-sm text-muted-foreground">
                    {customer} • {vehicle} {plate} {vin && `• ${vin}`}
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  {r.invoice_url ? (
                    <a
                      href={r.invoice_url}
                      target="_blank"
                      rel="noreferrer"
                      className="rounded-md border border-border px-2 py-1 text-xs hover:bg-muted"
                    >
                      Open invoice
                    </a>
                  ) : r.quote_url ? (
                    <a
                      href={r.quote_url}
                      target="_blank"
                      rel="noreferrer"
                      className="rounded-md border border-border px-2 py-1 text-xs hover:bg-muted"
                    >
                      Open quote
                    </a>
                  ) : (
                    <span className="text-[11px] text-muted-foreground">
                      No invoice
                    </span>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}

/* =============================== */
/* FILE: app/work-orders/page.tsx */
/* =============================== */

// app/work-orders/page.tsx
export const dynamic = "force-dynamic";
export const revalidate = 0;

import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import type { Role } from "@shared/components/RoleHubTiles/tiles";
import { TILES } from "@shared/components/RoleHubTiles/tiles";
import Link from "next/link";
import PageShell from "@/features/shared/components/PageShell";

type DB = Database;

async function getUserRole(): Promise<Role | null> {
  const supabase = createServerComponentClient<DB>({ cookies });
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return null;

  const { data: profile } = await supabase
    .from("profiles")
    .select("role")
    .eq("id", user.id)
    .maybeSingle();

  return (profile?.role as Role | null) ?? null;
}

export default async function WorkOrdersHome() {
  const role = await getUserRole();

  // only show tiles that are work_orders scope and role-allowed
  const workOrderTiles = TILES.filter((tile) => {
    const forWorkOrders = tile.scopes.includes("work_orders") || tile.scopes.includes("all");
    const roleAllowed = role ? tile.roles.includes(role) : false;
    return forWorkOrders && roleAllowed;
  });

  return (
    <PageShell
      title="Work Orders"
      description="Create, view, and manage jobs, quotes, and invoices."
    >
      {workOrderTiles.length === 0 ? (
        <div className="rounded border border-neutral-800 bg-neutral-950/60 p-4 text-sm text-neutral-300">
          No work-order actions available for your role.
        </div>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {workOrderTiles.map((tile) => (
            <Link
              key={tile.href}
              href={tile.href}
              className="group rounded-lg border border-neutral-800 bg-neutral-950/60 px-4 py-4 transition hover:border-orange-400 hover:bg-neutral-900"
            >
              <div className="flex items-center justify-between gap-2">
                <h2 className="text-base font-semibold text-neutral-100">{tile.title}</h2>
                <span className="text-xs text-neutral-500 group-hover:text-orange-300">
                  {tile.cta ?? "→"}
                </span>
              </div>
              {tile.subtitle ? (
                <p className="mt-1 text-sm text-neutral-400">{tile.subtitle}</p>
              ) : null}
            </Link>
          ))}
        </div>
      )}
    </PageShell>
  );
}

/* =============================== */
/* FILE: app/work-orders/quote-review/page.tsx */
/* =============================== */

export const dynamic = "force-dynamic";
export const revalidate = 0;

export { default } from "@/features/work-orders/app/work-orders/quote-review/page";


/* =============================== */
/* FILE: app/compare-plans/page.tsx */
/* =============================== */

"use client";

import Link from "next/link";

import { FaCheck, FaTimes } from "react-icons/fa";

export default function ComparePlansPage() {
  const features = [
    "AI Diagnosis (limited or full)",
    "Inspection System",
    "Work Orders",
    "Voice-Controlled Inspections",
    "Photo-to-Quote",
    "PDF Export",
    "Custom Inspection Creation",
    "Shop Setup & Team Roles",
    "User Limit",
    "Priority Support",
  ];

  const plans = [
    {
      name: "Free",
      price: "$0",
      description: "Get started with limited AI features",
      values: [
        "5 uses/month",
        <FaTimes key="free-1" className="text-red-500 mx-auto" />,
        <FaTimes key="free-2" className="text-red-500 mx-auto" />,
        <FaTimes key="free-3" className="text-red-500 mx-auto" />,
        <FaTimes key="free-4" className="text-red-500 mx-auto" />,
        <FaTimes key="free-5" className="text-red-500 mx-auto" />,
        <FaTimes key="free-6" className="text-red-500 mx-auto" />,
        <FaTimes key="free-7" className="text-red-500 mx-auto" />,
        "1 user",
        <FaTimes key="free-8" className="text-red-500 mx-auto" />,
      ],
    },
    {
      name: "DIY",
      price: "$9",
      description: "Basic access for home users",
      values: [
        "Basic AI diagnosis",
        <FaCheck key="diy-1" className="text-green-400 mx-auto" />,
        <FaTimes key="diy-2" className="text-red-500 mx-auto" />,
        <FaTimes key="diy-3" className="text-red-500 mx-auto" />,
        <FaTimes key="diy-4" className="text-red-500 mx-auto" />,
        <FaCheck key="diy-5" className="text-green-400 mx-auto" />,
        <FaTimes key="diy-6" className="text-red-500 mx-auto" />,
        <FaTimes key="diy-7" className="text-red-500 mx-auto" />,
        "1 user",
        <FaTimes key="diy-8" className="text-red-500 mx-auto" />,
      ],
    },
    {
      name: "Pro",
      price: "$49",
      description: "Solo pros with full inspections and work orders",
      values: [
        "Unlimited AI",
        <FaCheck key="pro-1" className="text-green-400 mx-auto" />,
        <FaCheck key="pro-2" className="text-green-400 mx-auto" />,
        <FaCheck key="pro-3" className="text-green-400 mx-auto" />,
        <FaCheck key="pro-4" className="text-green-400 mx-auto" />,
        <FaCheck key="pro-5" className="text-green-400 mx-auto" />,
        "Limited",
        <FaTimes key="pro-6" className="text-red-500 mx-auto" />,
        "1 user",
        "Standard",
      ],
    },
    {
      name: "Pro+",
      price: "$99",
      description: "Shops & teams with full automation",
      values: [
        "Unlimited AI",
        <FaCheck key="proplus-1" className="text-green-400 mx-auto" />,
        <FaCheck key="proplus-2" className="text-green-400 mx-auto" />,
        <FaCheck key="proplus-3" className="text-green-400 mx-auto" />,
        <FaCheck key="proplus-4" className="text-green-400 mx-auto" />,
        <FaCheck key="proplus-5" className="text-green-400 mx-auto" />,
        "Unlimited",
        "✔ Admin, Manager, Mechanic",
        "5 users (expandable)",
        "Priority",
      ],
    },
  ];

  return (
    <div className="min-h-screen bg-black text-white px-4 py-12">
      <div className="max-w-7xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <h1 className="text-4xl font-blackops text-orange-500">
            Compare Plans
          </h1>
          <Link
            href="/"
            className="px-4 py-2 bg-orange-500 hover:bg-orange-600 rounded text-black font-blackops"
          >
            Home
          </Link>
        </div>

        <div className="overflow-x-auto">
          <table className="w-full border border-orange-500 text-sm text-left">
            <thead className="bg-neutral-800 text-orange-400">
              <tr>
                <th className="px-4 py-3 border border-orange-500">Features</th>
                {plans.map((plan) => (
                  <th
                    key={plan.name}
                    className="px-4 py-3 border border-orange-500 text-center"
                  >
                    <div className="text-lg font-blackops text-white">
                      {plan.name}
                    </div>
                    <div className="text-orange-400">{plan.price}/mo</div>
                    <div className="text-gray-400 text-xs mt-1">
                      {plan.description}
                    </div>
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {features.map((feature, i) => (
                <tr
                  key={feature}
                  className={i % 2 === 0 ? "bg-neutral-900" : "bg-neutral-950"}
                >
                  <td className="px-4 py-3 border border-orange-500 font-medium">
                    {feature}
                  </td>
                  {plans.map((plan) => (
                    <td
                      key={plan.name + "-" + i}
                      className="px-4 py-3 border border-orange-500 text-center"
                    >
                      {plan.values[i]}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        <div className="mt-12 text-center">
          <Link
            href="/subscribe"
            className="inline-block px-6 py-3 bg-orange-500 hover:bg-orange-600 text-white font-blackops rounded-lg text-lg"
          >
            Choose Your Plan
          </Link>
        </div>
      </div>
    </div>
  );
}


/* =============================== */
/* FILE: features/dashboard/app/dashboard/owner/settings/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";

import type { Database } from "@shared/types/types/supabase";
import { Input } from "@shared/components/ui/input";
import { Button } from "@shared/components/ui/Button";
import OwnerPinModal from "@shared/components/OwnerPinModal";
import OwnerPinBadge from "@shared/components/OwnerPinBadge";
import ShopPublicProfileSection from "@/features/shops/components/ShopPublicProfileSection";
import ReviewsList from "@shared/components/reviews/ReviewsList";

type HourRow = {
  weekday: number;
  open_time: string;
  close_time: string;
  closed?: boolean;
};
type TimeOffRow = {
  id: string;
  starts_at: string;
  ends_at: string;
  reason: string | null;
};

const WEEKDAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

export default function OwnerSettingsPage() {
  const supabase = useMemo(
    () => createClientComponentClient<Database>(),
    [],
  );

  const [loading, setLoading] = useState(true);
  const [shopId, setShopId] = useState<string | null>(null);

  // PIN modal + timer
  const [pinModalOpen, setPinModalOpen] = useState(false);
  const [pinExpiresAt, setPinExpiresAt] = useState<string | undefined>();
  const [now, setNow] = useState<number>(() => Date.now());

  // Shop fields
  const [shopName, setShopName] = useState("");
  const [address, setAddress] = useState("");
  const [city, setCity] = useState("");
  const [province, setProvince] = useState("");
  const [postalCode, setPostalCode] = useState("");
  const [phone, setPhone] = useState("");
  const [email, setEmail] = useState("");
  const [logoUrl, setLogoUrl] = useState("");

  // Money / defaults
  const [laborRate, setLaborRate] = useState("");
  const [suppliesPercent, setSuppliesPercent] = useState("");
  const [diagnosticFee, setDiagnosticFee] = useState("");
  const [taxRate, setTaxRate] = useState("");

  // Workflow flags
  const [useAi, setUseAi] = useState(false);
  const [requireCauseCorrection, setRequireCauseCorrection] = useState(false);
  const [requireAuthorization, setRequireAuthorization] = useState(false);

  // Communication
  const [invoiceTerms, setInvoiceTerms] = useState("");
  const [invoiceFooter, setInvoiceFooter] = useState("");
  const [emailOnComplete, setEmailOnComplete] = useState(false);

  // Automation
  const [autoGeneratePdf, setAutoGeneratePdf] = useState(false);
  const [autoSendQuoteEmail, setAutoSendQuoteEmail] = useState(false);

  // Hours + time off
  const [hours, setHours] = useState<HourRow[]>(
    Array.from({ length: 7 }, (_, i) => ({
      weekday: i,
      open_time: "08:00",
      close_time: "17:00",
      closed: i === 0 || i === 6, // default: closed on weekend
    })),
  );
  const [timeOff, setTimeOff] = useState<TimeOffRow[]>([]);
  const [newOffStart, setNewOffStart] = useState("");
  const [newOffEnd, setNewOffEnd] = useState("");
  const [newOffReason, setNewOffReason] = useState("");

  // heartbeat to re-evaluate unlock
  useEffect(() => {
    const id = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(id);
  }, []);

  const isUnlocked = useMemo(() => {
    if (!pinExpiresAt) return false;
    return new Date(pinExpiresAt).getTime() > now;
  }, [pinExpiresAt, now]);

  // initial load
  useEffect(() => {
    const fetchSettings = async () => {
      const {
        data: { user },
      } = await supabase.auth.getUser();

      if (!user) {
        setLoading(false);
        return;
      }

      const { data: profile, error: profErr } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("id", user.id)
        .maybeSingle();

      if (profErr) {
        toast.error(profErr.message);
        setLoading(false);
        return;
      }

      if (!profile?.shop_id) {
        setLoading(false);
        return;
      }

      const sid = profile.shop_id;
      setShopId(sid);

      // core shop row
      const { data: shop, error } = await supabase
        .from("shops")
        .select("*")
        .eq("id", sid)
        .maybeSingle();

      if (error) toast.error(error.message);

      if (shop) {
        setShopName(shop.name || "");
        setAddress(shop.address || "");
        setCity(shop.city || "");
        setProvince(shop.province || "");
        setPostalCode(shop.postal_code || "");
        setPhone(shop.phone_number || "");
        setEmail(shop.email || "");
        setLogoUrl(shop.logo_url || "");

        setLaborRate(shop.labor_rate?.toString() || "");
        setSuppliesPercent(shop.supplies_percent?.toString() || "");
        setDiagnosticFee(shop.diagnostic_fee?.toString() || "");
        setTaxRate(shop.tax_rate?.toString() || "");

        setUseAi(!!shop.use_ai);
        setRequireCauseCorrection(!!shop.require_cause_correction);
        setRequireAuthorization(!!shop.require_authorization);

        setInvoiceTerms(shop.invoice_terms || "");
        setInvoiceFooter(shop.invoice_footer || "");
        setEmailOnComplete(!!shop.email_on_complete);

        setAutoGeneratePdf(!!shop.auto_generate_pdf);
        setAutoSendQuoteEmail(!!shop.auto_send_quote_email);
      }

      // hours (from shop_hours)
      try {
        const res = await fetch(`/api/settings/hours?shopId=${sid}`, {
          cache: "no-store",
        });
        if (res.ok) {
          const j = await res.json();
          if (Array.isArray(j?.hours)) {
            const byDay = new Map<number, HourRow>();
            (j.hours as HourRow[]).forEach((h) =>
              byDay.set(h.weekday, { ...h, closed: false }),
            );
            const normalized = Array.from({ length: 7 }, (_, i) => {
              const existing = byDay.get(i);
              if (existing) return existing;
              // no row in DB ⇒ treat as closed by default
              return {
                weekday: i,
                open_time: "08:00",
                close_time: "17:00",
                closed: true,
              };
            });
            setHours(normalized);
          }
        }
      } catch {
        // ignore
      }

      // time off
      try {
        const res = await fetch(`/api/settings/time-off?shopId=${sid}`, {
          cache: "no-store",
        });
        if (res.ok) {
          const j = await res.json();
          if (Array.isArray(j?.items)) setTimeOff(j.items);
        }
      } catch {
        // ignore
      }

      setLoading(false);
    };

    void fetchSettings();
  }, [supabase]);

  const guardUnlock = () => {
    if (!isUnlocked) {
      toast.warning("Unlock with Owner PIN first.");
      setPinModalOpen(true);
      return false;
    }
    return true;
  };

  // save core shop
  const handleSave = async () => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    const payload = {
      shopId,
      update: {
        name: shopName,
        address,
        city,
        province,
        postal_code: postalCode,
        phone_number: phone,
        email,
        logo_url: logoUrl,
        labor_rate: laborRate ? parseFloat(laborRate) : null,
        supplies_percent: suppliesPercent ? parseFloat(suppliesPercent) : null,
        diagnostic_fee: diagnosticFee ? parseFloat(diagnosticFee) : null,
        tax_rate: taxRate ? parseFloat(taxRate) : null,
        use_ai: useAi,
        require_cause_correction: requireCauseCorrection,
        require_authorization: requireAuthorization,
        invoice_terms: invoiceTerms,
        invoice_footer: invoiceFooter,
        email_on_complete: emailOnComplete,
        auto_generate_pdf: autoGeneratePdf,
        auto_send_quote_email: autoSendQuoteEmail,
      },
    };

    const res = await fetch("/api/settings/update", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!res.ok) {
      const j = await res.json().catch(() => ({}));
      toast.error(j?.error || "Failed to save settings");
      return;
    }

    toast.success("Settings saved.");
  };

  const handleLogoUpload = async (
    e: React.ChangeEvent<HTMLInputElement>,
  ) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const filePath = `logos/${crypto.randomUUID()}-${file.name}`;
    const { error } = await supabase.storage
      .from("logos")
      .upload(filePath, file, { upsert: true });

    if (error) {
      toast.error(error.message);
      return;
    }

    const { data } = supabase.storage.from("logos").getPublicUrl(filePath);
    setLogoUrl(data.publicUrl);
    toast.success("Logo uploaded.");
  };

  const handleGenerateLogo = () => {
    toast.info("AI Logo generation coming soon…");
  };

  // save hours → /api/settings/hours → shop_hours
  const saveHours = async () => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    // only send OPEN days to the API; closed days are omitted
    const openDays = hours.filter((h) => !h.closed);

    const res = await fetch("/api/settings/hours", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ shopId, hours: openDays }),
    });

    if (!res.ok) {
      const j = await res.json().catch(() => ({}));
      toast.error(j?.error || "Failed to save hours");
      return;
    }
    toast.success("Hours updated.");
  };

  // add time off
  const addTimeOff = async () => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    if (!newOffStart || !newOffEnd) {
      toast.warning("Select start and end time.");
      return;
    }

    const res = await fetch("/api/settings/time-off", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        shopId,
        range: {
          starts_at: newOffStart,
          ends_at: newOffEnd,
          reason: newOffReason || null,
        },
      }),
    });

    const j = await res.json().catch(() => ({}));
    if (!res.ok) {
      toast.error(j?.error || "Failed to add time off");
      return;
    }

    setNewOffStart("");
    setNewOffEnd("");
    setNewOffReason("");

    try {
      const r = await fetch(`/api/settings/time-off?shopId=${shopId}`, {
        cache: "no-store",
      });
      if (r.ok) {
        const jj = await r.json();
        setTimeOff(jj.items || []);
      }
    } catch {
      // ignore
    }

    toast.success("Time off added.");
  };

  const deleteTimeOff = async (id: string) => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    const res = await fetch("/api/settings/time-off", {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ shopId, id }),
    });

    const j = await res.json().catch(() => ({}));
    if (!res.ok) {
      toast.error(j?.error || "Failed to remove time off");
      return;
    }

    setTimeOff((prev) => prev.filter((t) => t.id !== id));
    toast.success("Removed.");
  };

  if (loading) {
    return (
      <div className="p-6 text-muted-foreground">
        Loading shop settings…
      </div>
    );
  }

  return (
    <div className="mx-auto flex max-w-6xl flex-col gap-6 p-6 text-foreground">
      {/* top header */}
      <div className="flex flex-wrap items-center justify-between gap-3 rounded-xl border border-border bg-card px-4 py-3">
        <div>
          <h1 className="text-2xl font-blackops text-orange-400">
            Shop Settings
          </h1>
          <p className="text-xs text-neutral-400">
            Manage your shop profile, billing defaults, and scheduling.
          </p>
        </div>
        <div className="flex items-center gap-2">
          <OwnerPinBadge expiresAt={pinExpiresAt} />
          <Button size="sm" onClick={() => setPinModalOpen(true)}>
            {isUnlocked ? "Re-unlock" : "Unlock"}
          </Button>
          <Button size="sm" onClick={handleSave} disabled={!isUnlocked}>
            {isUnlocked ? "Save all" : "Unlock to save"}
          </Button>
        </div>
      </div>

      {/* main layout */}
      <div className="flex flex-col gap-6 lg:flex-row">
        {/* LEFT COLUMN */}
        <div className="flex-1 space-y-6">
          {/* Shop info */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Shop info
            </h2>
            <div className="space-y-2 text-sm">
              <Input
                value={shopName}
                onChange={(e) => setShopName(e.target.value)}
                placeholder="Shop name"
                disabled={!isUnlocked}
              />
              <Input
                value={address}
                onChange={(e) => setAddress(e.target.value)}
                placeholder="Street address"
                disabled={!isUnlocked}
              />
              <div className="grid gap-2 md:grid-cols-3">
                <Input
                  value={city}
                  onChange={(e) => setCity(e.target.value)}
                  placeholder="City"
                  disabled={!isUnlocked}
                />
                <Input
                  value={province}
                  onChange={(e) => setProvince(e.target.value)}
                  placeholder="Province / State"
                  disabled={!isUnlocked}
                />
                <Input
                  value={postalCode}
                  onChange={(e) => setPostalCode(e.target.value)}
                  placeholder="Postal code"
                  disabled={!isUnlocked}
                />
              </div>
              <div className="grid gap-2 md:grid-cols-2">
                <Input
                  value={phone}
                  onChange={(e) => setPhone(e.target.value)}
                  placeholder="Phone number"
                  disabled={!isUnlocked}
                />
                <Input
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="Email"
                  disabled={!isUnlocked}
                />
              </div>
              <div className="grid gap-2 md:grid-cols-2">
                <Input
                  value={logoUrl}
                  onChange={(e) => setLogoUrl(e.target.value)}
                  placeholder="Logo URL"
                  disabled={!isUnlocked}
                />
                <Input
                  type="file"
                  accept="image/*"
                  onChange={handleLogoUpload}
                  disabled={!isUnlocked}
                />
              </div>
              <Button
                onClick={handleGenerateLogo}
                variant="secondary"
                className="mt-1"
                disabled={!isUnlocked}
              >
                Generate logo with AI
              </Button>
              {logoUrl && (
                <img
                  src={logoUrl}
                  alt="Logo"
                  className="mt-2 h-20 w-32 rounded bg-white p-1 object-contain"
                />
              )}
            </div>
          </section>

          {/* Billing + workflow */}
          <div className="grid gap-6 md:grid-cols-2">
            <section className="space-y-3 rounded-xl border border-border bg-card p-4">
              <h2 className="text-sm font-semibold text-neutral-50">
                Billing defaults
              </h2>
              <div className="grid gap-2 md:grid-cols-2 text-sm">
                <Input
                  value={laborRate}
                  onChange={(e) => setLaborRate(e.target.value)}
                  placeholder="Labor rate ($/hr)"
                  disabled={!isUnlocked}
                />
                <Input
                  value={suppliesPercent}
                  onChange={(e) => setSuppliesPercent(e.target.value)}
                  placeholder="Shop supplies (%)"
                  disabled={!isUnlocked}
                />
                <Input
                  value={diagnosticFee}
                  onChange={(e) => setDiagnosticFee(e.target.value)}
                  placeholder="Diagnostic fee ($)"
                  disabled={!isUnlocked}
                />
                <Input
                  value={taxRate}
                  onChange={(e) => setTaxRate(e.target.value)}
                  placeholder="Tax rate (%)"
                  disabled={!isUnlocked}
                />
              </div>
            </section>

            <section className="space-y-3 rounded-xl border border-border bg-card p-4">
              <h2 className="text-sm font-semibold text-neutral-50">
                Workflow
              </h2>
              <label className="flex items-center gap-2 text-sm text-neutral-200">
                <input
                  type="checkbox"
                  checked={useAi}
                  onChange={(e) => setUseAi(e.target.checked)}
                  disabled={!isUnlocked}
                />
                Use AI features
              </label>
              <label className="flex items-center gap-2 text-sm text-neutral-200">
                <input
                  type="checkbox"
                  checked={requireCauseCorrection}
                  onChange={(e) =>
                    setRequireCauseCorrection(e.target.checked)
                  }
                  disabled={!isUnlocked}
                />
                Require cause / correction on lines
              </label>
              <label className="flex items-center gap-2 text-sm text-neutral-200">
                <input
                  type="checkbox"
                  checked={requireAuthorization}
                  onChange={(e) =>
                    setRequireAuthorization(e.target.checked)
                  }
                  disabled={!isUnlocked}
                />
                Require customer authorization
              </label>
            </section>
          </div>

          {/* Communication */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Communication & branding
            </h2>
            <Input
              value={invoiceTerms}
              onChange={(e) => setInvoiceTerms(e.target.value)}
              placeholder="Invoice terms"
              disabled={!isUnlocked}
            />
            <Input
              value={invoiceFooter}
              onChange={(e) => setInvoiceFooter(e.target.value)}
              placeholder="Invoice footer note"
              disabled={!isUnlocked}
            />
            <label className="flex items-center gap-2 text-sm text-neutral-200">
              <input
                type="checkbox"
                checked={emailOnComplete}
                onChange={(e) => setEmailOnComplete(e.target.checked)}
                disabled={!isUnlocked}
              />
              Email customer when job is complete
            </label>
          </section>

          {/* Automation */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Automation
            </h2>
            <label className="flex items-center gap-2 text-sm text-neutral-200">
              <input
                type="checkbox"
                checked={autoGeneratePdf}
                onChange={(e) => setAutoGeneratePdf(e.target.checked)}
                disabled={!isUnlocked}
              />
              Auto-generate quote PDF
            </label>
            <label className="flex items-center gap-2 text-sm text-neutral-200">
              <input
                type="checkbox"
                checked={autoSendQuoteEmail}
                onChange={(e) => setAutoSendQuoteEmail(e.target.checked)}
                disabled={!isUnlocked}
              />
              Auto-send quote email
            </label>
          </section>

          {/* Hours */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <div className="flex items-center justify-between gap-3">
              <h2 className="text-sm font-semibold text-neutral-50">
                Hours (controls public booking slots)
              </h2>
              <Button onClick={saveHours} disabled={!isUnlocked} size="sm">
                Save hours
              </Button>
            </div>

            <div className="grid gap-2 md:grid-cols-7">
              {hours.map((row, idx) => {
                const closed = !!row.closed;
                return (
                  <div
                    key={row.weekday}
                    className="rounded border border-neutral-800 bg-neutral-900 p-2 text-xs"
                  >
                    <div className="mb-1 flex items-center justify-between text-[11px] font-semibold text-orange-300">
                      <span>{WEEKDAYS[row.weekday]}</span>
                      <label className="flex items-center gap-1 text-[10px] text-neutral-300">
                        <input
                          type="checkbox"
                          checked={closed}
                          onChange={(e) => {
                            const isClosed = e.target.checked;
                            setHours((prev) => {
                              const copy = [...prev];
                              copy[idx] = { ...copy[idx], closed: isClosed };
                              return copy;
                            });
                          }}
                          disabled={!isUnlocked}
                        />
                        Closed
                      </label>
                    </div>
                    <label className="mb-1 block text-[10px] text-neutral-400">
                      Open
                    </label>
                    <input
                      type="time"
                      className="mb-2 w-full rounded bg-neutral-950 px-2 py-1 text-xs disabled:opacity-40"
                      value={row.open_time}
                      onChange={(e) => {
                        const v = e.target.value;
                        setHours((prev) => {
                          const copy = [...prev];
                          copy[idx] = { ...copy[idx], open_time: v };
                          return copy;
                        });
                      }}
                      disabled={!isUnlocked || closed}
                    />
                    <label className="mb-1 block text-[10px] text-neutral-400">
                      Close
                    </label>
                    <input
                      type="time"
                      className="w-full rounded bg-neutral-950 px-2 py-1 text-xs disabled:opacity-40"
                      value={row.close_time}
                      onChange={(e) => {
                        const v = e.target.value;
                        setHours((prev) => {
                          const copy = [...prev];
                          copy[idx] = { ...copy[idx], close_time: v };
                          return copy;
                        });
                      }}
                      disabled={!isUnlocked || closed}
                    />
                  </div>
                );
              })}
            </div>
          </section>

          {/* Time off */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Time off / blackouts
            </h2>

            <div className="grid gap-2 md:grid-cols-4">
              <input
                type="datetime-local"
                className="rounded bg-neutral-900 px-3 py-2 text-sm"
                value={newOffStart}
                onChange={(e) => setNewOffStart(e.target.value)}
                disabled={!isUnlocked}
              />
              <input
                type="datetime-local"
                className="rounded bg-neutral-900 px-3 py-2 text-sm"
                value={newOffEnd}
                onChange={(e) => setNewOffEnd(e.target.value)}
                disabled={!isUnlocked}
              />
              <Input
                placeholder="Reason (optional)"
                value={newOffReason}
                onChange={(e) => setNewOffReason(e.target.value)}
                disabled={!isUnlocked}
              />
              <Button onClick={addTimeOff} disabled={!isUnlocked}>
                Add
              </Button>
            </div>

            {timeOff.length === 0 ? (
              <p className="text-xs text-neutral-500">
                No time-off entries.
              </p>
            ) : (
              <ul className="space-y-2">
                {timeOff.map((t) => {
                  const start = new Date(t.starts_at);
                  const end = new Date(t.ends_at);
                  return (
                    <li
                      key={t.id}
                      className="flex items-center justify-between rounded border border-neutral-800 bg-neutral-900 px-3 py-2 text-sm"
                    >
                      <div>
                        <div className="text-neutral-100">
                          {start.toLocaleString()} → {end.toLocaleString()}
                        </div>
                        {t.reason && (
                          <div className="text-xs text-neutral-400">
                            Reason: {t.reason}
                          </div>
                        )}
                      </div>
                      <Button
                        variant="secondary"
                        size="sm"
                        onClick={() => void deleteTimeOff(t.id)}
                        disabled={!isUnlocked}
                      >
                        Remove
                      </Button>
                    </li>
                  );
                })}
              </ul>
            )}
          </section>
        </div>

        {/* RIGHT COLUMN */}
        <div className="w-full space-y-6 lg:w-80">
          {shopId && (
            <ShopPublicProfileSection
              shopId={shopId}
              isUnlocked={isUnlocked}
            />
          )}

          {/* Invoice preview */}
          <section className="space-y-2 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Invoice preview
            </h2>
            <div className="space-y-2 rounded bg-white p-3 text-xs text-black shadow">
              {logoUrl && (
                <img
                  src={logoUrl}
                  alt="Logo"
                  className="h-12 object-contain"
                />
              )}
              <div className="font-semibold">
                {shopName || "Your shop name"}
              </div>
              <div>
                {address}
                {address && ","} {city} {province} {postalCode}
              </div>
              <div>
                {phone} {phone && email && "•"} {email}
              </div>
              <hr className="my-2" />
              <div className="font-semibold text-black">Invoice terms</div>
              <p>{invoiceTerms || "—"}</p>
              <div className="font-semibold text-black">Footer</div>
              <p>{invoiceFooter || "—"}</p>
            </div>
          </section>

          {shopId && (
            <section className="space-y-3 rounded-xl border border-border bg-card p-4">
              <h2 className="text-sm font-semibold text-neutral-50">
                Customer reviews
              </h2>
              <p className="text-[11px] text-neutral-400">
                Recent reviews for your shop. Owners/admins/managers can reply
                directly.
              </p>
              <ReviewsList shopId={shopId} />
            </section>
          )}
        </div>
      </div>

      <OwnerPinModal
        shopId={shopId}
        open={pinModalOpen}
        onClose={() => setPinModalOpen(false)}
        onVerified={(iso: string | undefined) => setPinExpiresAt(iso)}
      />
    </div>
  );
}

/* =============================== */
/* FILE: features/dashboard/app/dashboard/advisor/page.tsx */
/* =============================== */

"use client"

import Link from "next/link";

type TileProps = { href: string; title: string; subtitle?: string; cta?: string };

function Tile({ href, title, subtitle, cta }: TileProps) {
  return (
    <Link
      href={href}
      className="block rounded-lg border border-white/10 bg-neutral-900 p-4 transition hover:-translate-y-0.5 hover:border-orange-500 hover:shadow-lg hover:shadow-orange-500/10"
      aria-label={title}
    >
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-white">{title}</h2>
        {cta ? <span className="rounded bg-orange-500 px-3 py-1 text-sm font-semibold text-black">{cta}</span> : null}
      </div>
      {subtitle ? <p className="mt-1 text-sm text-white/70">{subtitle}</p> : null}
    </Link>
  );
}

export default function AdvisorDashboardPage() {
  return (
    <div className="mx-auto max-w-5xl px-4 py-8 text-white">
      <h1 className="mb-6 text-3xl font-bold text-orange-400">Advisor Dashboard</h1>

      {/* Work Orders */}
      <h2 className="mb-3 text-xl font-semibold">Work Orders</h2>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
        <Tile href="/work-orders/create" title="Create Work Order" subtitle="Start a new job for a vehicle" cta="+" />
        <Tile href="/work-orders/customer" title="Customer Work Order Request" subtitle="Capture a customer request" />
        <Tile href="/work-orders/queue" title="Job Queue" subtitle="Active, paused, and in-progress jobs" />
        <Tile href="/work-orders/quote-review" title="Quote Review" subtitle="Review and send estimates" />
        <Tile href="/work-orders" title="View Work Orders" subtitle="Find & open specific work orders" />
        <Tile href="/work-orders" title="Open Work Order by ID" subtitle="Use list to select a specific ID" />
      </div>

      {/* Inspections */}
      <h2 className="mt-8 mb-3 text-xl font-semibold">Inspections</h2>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
        <Tile href="/inspections/templates" title="Templates" subtitle="Browse inspection templates" />
        <Tile href="/inspections/custom-inspection" title="Custom Inspection" subtitle="Build a custom checklist" />
        <Tile href="/inspections/created" title="Recently Created" subtitle="Newly started inspections" />
        <Tile href="/inspections/saved" title="Saved" subtitle="Draft inspections in progress" />
        <Tile href="/inspections/summary" title="Summaries" subtitle="Review inspection summaries" />
        <Tile href="/inspections/customer-vehicle" title="Customer & Vehicle" subtitle="Start from basic info" />
        <Tile href="/inspections" title="Open Inspection by ID" subtitle="Use list to select a specific ID" />
      </div>

      {/* Booking */}
      <h2 className="mt-8 mb-3 text-xl font-semibold">Booking</h2>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
        <Tile href="/dashboard/advisor/bookings" title="Bookings" subtitle="View & manage appointments" />
      </div>
    </div>
  );
}



/* =============================== */
/* FILE: features/ai/api/chatbot/route.ts */
/* =============================== */

// app/api/chatbot/route.ts
import { NextResponse } from "next/server";
import { openai } from "lib/server/openai";

type Variant = "marketing" | "full";
type ChatMessage = { role: "system" | "user" | "assistant"; content: string };

function guardrailSystem(variant: Variant): string {
  if (variant === "marketing") {
    return `You are TechBot for ProFixIQ on the public landing page.
Answer ONLY questions about ProFixIQ: features, pricing, plans, roles, onboarding, and how the app works.
Refuse anything about private data, diagnostics for a specific car, or taking actions inside the product.
Keep answers brief and helpful.`;
  }
  return `You are TechBot for ProFixIQ inside the app.
Help with diagnostics, inspections, work orders, quotes, parts, and app navigation.
When relevant, suggest the next action within the app. Keep answers clear and mechanic-friendly.`;
}

export async function POST(req: Request) {
  try {
    const body = (await req.json()) as { messages?: ChatMessage[]; variant?: Variant };

    // ✅ Only allow the marketing bot to use this endpoint
    const variant: Variant = body?.variant === "marketing" ? "marketing" : "full";
    if (variant !== "marketing") {
      return NextResponse.json({ error: "This assistant is only available on the landing page." }, { status: 403 });
    }

    const messages = Array.isArray(body?.messages) ? body.messages : [];
    const safeMsgs: ChatMessage[] = [
      { role: "system", content: guardrailSystem("marketing") },
      ...messages.filter(m => m && typeof m.content === "string").map(m => ({ role: m.role, content: m.content })),
    ];

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: safeMsgs,
      temperature: 0.4,
      max_tokens: 600,
    });

    const reply = completion.choices?.[0]?.message?.content?.trim() || "Sorry, I couldn't generate a response.";
    return NextResponse.json({ reply });
  } catch {
    return NextResponse.json({ error: "The assistant is not available right now." }, { status: 500 });
  }
}

export const runtime = "nodejs";

/* =============================== */
/* FILE: features/ai/components/Chatbot.tsx */
/* =============================== */

"use client";

import { useEffect, useRef, useState } from "react";
import { FaPaperPlane, FaRobot } from "react-icons/fa";
import Image from "next/image";
import Link from "next/link";

type Variant = "marketing" | "full";

function systemPromptFor(variant: Variant) {
  if (variant === "marketing") {
    return `You are TechBot for ProFixIQ on the public landing page.
Answer ONLY questions about ProFixIQ: features, pricing, plans, roles, onboarding, and how the app works.
Do NOT discuss private user data, shop workflows, or take actions. Keep answers brief and helpful.`;
  }
  return `You are TechBot for ProFixIQ inside the app.
Help with diagnostics, inspections, work orders, quotes, parts, and app navigation.
When relevant, suggest next actions in the product. Keep answers clear and mechanic-friendly.`;
}

export default function Chatbot({ variant = "full" }: { variant?: Variant }) {
  const [open, setOpen] = useState(false);
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState([
    { role: "system", content: systemPromptFor(variant) },
  ]);
  const [loading, setLoading] = useState(false);
  const bottomRef = useRef<HTMLDivElement | null>(null);

  // allow external “Ask AI” buttons to open this modal
  useEffect(() => {
    const handler = () => setOpen(true);
    window.addEventListener("open-chatbot", handler as EventListener);
    return () => window.removeEventListener("open-chatbot", handler as EventListener);
  }, []);

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  useEffect(() => {
    setMessages([{ role: "system", content: systemPromptFor(variant) }]);
  }, [variant]);

  const sendMessage = async () => {
    if (!input.trim()) return;
    const updated = [...messages, { role: "user", content: input }];
    setMessages(updated);
    setInput("");
    setLoading(true);

    try {
      const res = await fetch("/api/chatbot", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messages: updated, variant }),
      });
      const data = await res.json();
      setMessages([
        ...updated,
        { role: "assistant", content: data.reply || "Sorry, something went wrong." },
      ]);
    } catch {
      setMessages([
        ...updated,
        { role: "assistant", content: "Connection error. Please try again." },
      ]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <button
        id="chatbot-button"
        onClick={() => setOpen((o) => !o)}
        title="Ask TechBot"
        className="fixed bottom-6 right-6 bg-orange-600 hover:bg-orange-700 text-white p-3 rounded-full shadow-lg z-50"
      >
        <FaRobot size={20} />
      </button>

      {open && (
        <div className="fixed bottom-20 right-6 w-80 bg-black border border-neutral-700 text-white rounded-lg shadow-xl flex flex-col z-50">
          <div className="flex items-center gap-2 p-3 border-b border-neutral-700 bg-neutral-900 rounded-t">
            <Link href="/" title="Go to Home">
              <Image src="/logo.png" alt="ProFixIQ" width={28} height={28} priority />
            </Link>
            <span className="font-bold text-orange-400">
              {variant === "marketing" ? "TechBot (About ProFixIQ)" : "TechBot Assistant"}
            </span>
          </div>

          <div className="flex-1 overflow-y-auto p-3 space-y-2 max-h-96 text-sm">
            {messages.slice(1).map((m, i) => (
              <div
                key={i}
                className={`p-2 rounded whitespace-pre-wrap ${
                  m.role === "user"
                    ? "bg-orange-600 text-black self-end ml-auto"
                    : "bg-neutral-800 text-white self-start mr-auto"
                }`}
              >
                {m.content}
              </div>
            ))}
            <div ref={bottomRef} />
          </div>

          <form
            onSubmit={(e) => {
              e.preventDefault();
              void sendMessage();
            }}
            className="flex items-center border-t border-neutral-700 p-2 bg-neutral-900"
          >
            <input
              type="text"
              className="flex-1 bg-transparent outline-none px-2 text-white placeholder-gray-400"
              placeholder={variant === "marketing" ? "Ask about ProFixIQ…" : "Ask TechBot…"}
              value={input}
              onChange={(e) => setInput(e.target.value)}
              disabled={loading}
            />
            <button
              type="submit"
              className="text-orange-500 hover:text-orange-400 disabled:opacity-50"
              disabled={loading}
            >
              <FaPaperPlane />
            </button>
          </form>
        </div>
      )}
    </>
  );
}

/* =============================== */
/* FILE: features/admin/components/AdminQuickPanel.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

// ---- Lite shapes (kept independent from exact DB types) ----
type ActivityLog = {
  id: string;
  event?: string | null;
  actor_id?: string | null;
  created_at?: string | null;
  details?: string | null;
};

type Certification = {
  id: string;
  name?: string | null;
  user_id?: string | null;
  expires_at?: string | null;
};

type Profile = {
  id: string;
  full_name?: string | null;
  role?: string | null;
  created_at?: string | null;
};

type WorkOrder = {
  id: string;
  status?: string | null;
  created_at?: string | null;
  customer_id?: string | null;
  quote_url?: string | null;
};

type WorkOrderLine = {
  id: string;
  work_order_id?: string | null;
  status?: string | null;
  job_type?: string | null;
  assigned_to?: string | null;
  created_at?: string | null;
  hold_reason?: string | null;
  punched_in_at?: string | null;
  punched_out_at?: string | null;
};

type PartsRequest = {
  id: string;
  status?: string | null;
  created_at?: string | null;
  needed_by?: string | null;
  work_order_id?: string | null;
};

type EmailLog = {
  id: string;
  created_at?: string | null;
  recipient?: string | null;
  subject?: string | null;
  error?: string | null;
};

type Shop = {
  id: string;
  name?: string | null;
  active_user_count?: number | null;
  user_limit?: number | null;
  phone_number?: string | null;
  email?: string | null;
  address?: string | null;
  city?: string | null;
  province?: string | null;
  postal_code?: string | null;
  geo_lat?: number | null;
  geo_lng?: number | null;
  timezone?: string | null;
};

type Vehicle = {
  id: string;
  customer_id?: string | null;
  vin?: string | null;
  year?: number | null;
  make?: string | null;
  model?: string | null;
  created_at?: string | null;
};

type VehiclePhoto = {
  id: string;
  vehicle_id?: string | null;
  created_at?: string | null;
  uploaded_by?: string | null;
  reviewed?: boolean | null;
};

// ---- helpers ----
const fmtDate = (iso?: string | null) => {
  if (!iso) return "—";
  const d = new Date(iso);
  return Number.isNaN(d.getTime())
    ? "—"
    : d.toLocaleDateString(undefined, { month: "short", day: "numeric" });
};

export default function AdminQuickPanel() {
  const supabase = useMemo(() => createClientComponentClient<Database>(), []);

  // state for cards
  const [activity, setActivity] = useState<ActivityLog[] | null>(null);
  const [expiringCerts, setExpiringCerts] = useState<Certification[] | null>(null);
  const [profilesNeedingRole, setProfilesNeedingRole] = useState<Profile[] | null>(null);

  const [openHolds24h, setOpenHolds24h] = useState<WorkOrderLine[] | null>(null);
  const [unassignedJobs, setUnassignedJobs] = useState<WorkOrderLine[] | null>(null);
  const [punchAnomalies, setPunchAnomalies] = useState<WorkOrderLine[] | null>(null);

  const [pendingQuotes, setPendingQuotes] = useState<WorkOrder[] | null>(null);
  const [openPartsRequests] = useState<PartsRequest[] | null>(null);
  const [emailFailures, setEmailFailures] = useState<EmailLog[] | null>(null);

  const [shopUtil, setShopUtil] = useState<Shop | null>(null);
  const [shopMissingFields, setShopMissingFields] = useState<string[] | null>(null);

  const [vehiclesMissingVin, setVehiclesMissingVin] = useState<Vehicle[] | null>(null);
  const [unreviewedPhotos, setUnreviewedPhotos] = useState<VehiclePhoto[] | null>(null);

  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let cancelled = false;

    (async () => {
      setLoading(true);

      // Run everything we can in parallel
      const now = new Date();
      const in30 = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
      const last7 = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

      const [
        activityRes,
        certsRes,
        rolesRes,
        holdsRes,
        unassignedRes,
        punchedRes,
        woRes,
        emailsRes,
        shopRes,
        vehiclesRes,
        photosRes,
      ] = await Promise.allSettled([
        supabase
          .from("activity_logs")
          .select("id,event,actor_id,created_at,details")
          .order("created_at", { ascending: false })
          .limit(5),

        supabase
          .from("certifications")
          .select("id,name,user_id,expires_at")
          .gte("expires_at", now.toISOString())
          .lte("expires_at", in30.toISOString())
          .order("expires_at", { ascending: true })
          .limit(5),

        supabase
          .from("profiles")
          .select("id,full_name,role,created_at")
          .is("role", null)
          .order("created_at", { ascending: false })
          .limit(5),

        supabase
          .from("work_order_lines")
          .select("id,work_order_id,status,hold_reason,created_at")
          .eq("status", "on_hold")
          .gte("created_at", last7.toISOString())
          .order("created_at", { ascending: false })
          .limit(20),

        supabase
          .from("work_order_lines")
          .select("id,work_order_id,status,job_type,assigned_to,created_at")
          .in("status", ["awaiting", "in_progress"])
          .is("assigned_to", null)
          .order("created_at", { ascending: false })
          .limit(10),

        supabase
          .from("work_order_lines")
          .select("id,work_order_id,status,job_type,created_at,punched_in_at,punched_out_at")
          .not("punched_in_at", "is", null)
          .is("punched_out_at", null)
          .order("punched_in_at", { ascending: false })
          .limit(25),

        supabase
          .from("work_orders")
          .select("id,status,created_at,quote_url")
          .is("quote_url", null)
          .order("created_at", { ascending: false })
          .limit(15),

        supabase
          .from("parts_requests")
          .select("id,status,created_at,needed_by,work_order_id")
          .neq("status", "fulfilled")
          .order("created_at", { ascending: false })
          .limit(5),

        supabase
          .from("email_logs")
          .select("id,created_at,recipient,subject,error")
          .not("error", "is", null)
          .order("created_at", { ascending: false })
          .limit(10),

        supabase
          .from("shops")
          .select(
            "id,name,active_user_count,user_limit,phone_number,email,address,city,province,postal_code,geo_lat,geo_lng,timezone"
          )
          .limit(1)
          .single(),

        supabase
          .from("vehicles")
          .select("id,customer_id,vin,year,make,model,created_at")
          .is("vin", null)
          .order("created_at", { ascending: false })
          .limit(5),

        supabase
          .from("vehicle_photos")
          .select("id,vehicle_id,created_at,uploaded_by,reviewed")
          .or("reviewed.is.null,reviewed.eq.false")
          .order("created_at", { ascending: false })
          .limit(6),
      ]);

      if (cancelled) return;

      const get = <T,>(r: PromiseSettledResult<{ data: any }>) =>
        r.status === "fulfilled" ? ((r.value.data as unknown as T[]) ?? []) : [];

      // Simple lists
      setActivity(get<ActivityLog>(activityRes));
      setExpiringCerts(get<Certification>(certsRes));
      setProfilesNeedingRole(get<Profile>(rolesRes));
      setUnassignedJobs(get<WorkOrderLine>(unassignedRes));
      setEmailFailures(get<EmailLog>(emailsRes));
      setVehiclesMissingVin(get<Vehicle>(vehiclesRes));
      setUnreviewedPhotos(get<VehiclePhoto>(photosRes));

      // Holds > 24h
      const holds = get<WorkOrderLine>(holdsRes);
      const dayAgoMs = Date.now() - 24 * 60 * 60 * 1000;
      setOpenHolds24h(
        holds.filter((j) => j.created_at && new Date(j.created_at).getTime() < dayAgoMs)
      );

      // Punch anomalies > 8h
      const punched = get<WorkOrderLine>(punchedRes);
      const eightHours = 8 * 60 * 60 * 1000;
      setPunchAnomalies(
        punched.filter((j) => {
          const pi = j.punched_in_at ? new Date(j.punched_in_at).getTime() : 0;
          return pi && Date.now() - pi > eightHours;
        })
      );

      // Shop utilization + missing pieces
      if (shopRes.status === "fulfilled" && shopRes.value.data) {
        const s = (shopRes.value.data as unknown as Shop) ?? null;
        setShopUtil(s);
        if (s) {
          const missing: string[] = [];
          if (!s.phone_number) missing.push("phone");
          if (!s.email) missing.push("email");
          if (!s.address || !s.city || !s.province || !s.postal_code) missing.push("address");
          if (s.geo_lat == null || s.geo_lng == null) missing.push("map coords");
          if (!s.timezone) missing.push("timezone");
          setShopMissingFields(missing.length ? missing : null);
        } else {
          setShopMissingFields(null);
        }
      } else {
        setShopUtil(null);
        setShopMissingFields(null);
      }

      // Pending quotes = WOs with no quote_url AND at least one tech-suggested job
      const candidateWOs = get<WorkOrder>(woRes);
      const withSuggestions: WorkOrder[] = [];
      for (const w of candidateWOs) {
        // Stop once we have 5 to keep it light
        if (withSuggestions.length >= 5) break;
        const { data: lines } = await supabase
          .from("work_order_lines")
          .select("id")
          .eq("work_order_id", w.id)
          .eq("job_type", "tech-suggested")
          .limit(1);
        if ((lines as any[])?.length) withSuggestions.push(w);
      }
      setPendingQuotes(withSuggestions);

      setLoading(false);
    })();

    return () => {
      cancelled = true;
    };
  }, [supabase]);

  // ---- skeleton ----
  if (loading) {
    return (
      <div className="grid grid-cols-1 gap-4 lg:grid-cols-3">
        {Array.from({ length: 6 }).map((_, i) => (
          <div
            key={i}
            className="rounded-xl border border-neutral-800 bg-neutral-900 p-4 animate-pulse"
          >
            <div className="h-5 w-40 bg-neutral-800 rounded mb-3" />
            <div className="space-y-2">
              <div className="h-4 w-full bg-neutral-800 rounded" />
              <div className="h-4 w-5/6 bg-neutral-800 rounded" />
              <div className="h-4 w-4/6 bg-neutral-800 rounded" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  const cards: JSX.Element[] = [];

  // Recent activity
  if (activity?.length) {
    cards.push(
      <div key="activity" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Recent Activity</h3>
          <Link href="/dashboard/admin/audit" className="text-xs text-orange-400 underline">
            View all
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {activity.map((a) => (
            <li key={a.id} className="flex items-start gap-2">
              <span className="mt-0.5 h-1.5 w-1.5 rounded-full bg-orange-500" />
              <div>
                <div className="text-white">{a.event ?? "Activity"}</div>
                <div className="text-xs text-neutral-400">{fmtDate(a.created_at)}</div>
              </div>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Cert expirations
  if (expiringCerts?.length) {
    cards.push(
      <div key="certs" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">
            Certifications Expiring (30 days)
          </h3>
          <Link href="/dashboard/admin/certifications" className="text-xs text-orange-400 underline">
            Manage
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {expiringCerts.map((c) => (
            <li key={c.id} className="flex items-center justify-between gap-2">
              <div className="text-white">{c.name ?? "Certification"}</div>
              <div className="text-xs text-red-400">{fmtDate(c.expires_at)}</div>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Users needing role
  if (profilesNeedingRole?.length) {
    cards.push(
      <div key="roles" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Users Need Role Assignment</h3>
          <Link href="/dashboard/admin/roles" className="text-xs text-orange-400 underline">
            Assign
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {profilesNeedingRole.map((p) => (
            <li key={p.id} className="flex items-center justify-between gap-2">
              <div className="text-white">{p.full_name || p.id.slice(0, 8)}</div>
              <div className="text-xs text-neutral-400">{fmtDate(p.created_at)}</div>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // On-hold > 24h
  if (openHolds24h?.length) {
    cards.push(
      <div key="holds" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Jobs on Hold &gt; 24h</h3>
          <Link href="/work-orders/queue" className="text-xs text-orange-400 underline">
            Queue
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {openHolds24h.map((j) => (
            <li key={j.id} className="flex items-center justify-between gap-2">
              <span className="text-white">#{j.work_order_id?.slice(0, 8) ?? "—"}</span>
              <span className="text-xs text-neutral-400">{j.hold_reason || "On hold"}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Unassigned jobs
  if (unassignedJobs?.length) {
    cards.push(
      <div key="unassigned" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Unassigned Jobs</h3>
          <Link href="/dashboard/manager" className="text-xs text-orange-400 underline">
            Assign
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {unassignedJobs.map((j) => (
            <li key={j.id} className="flex items-center justify-between gap-2">
              <span className="text-white">#{j.work_order_id?.slice(0, 8) ?? "—"}</span>
              <span className="text-xs text-neutral-400">{j.job_type || "job"}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Punch anomalies > 8h
  if (punchAnomalies?.length) {
    cards.push(
      <div key="punch" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Punched In &gt; 8h (Check)</h3>
          <Link href="/tech/queue" className="text-xs text-orange-400 underline">
            View
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {punchAnomalies.map((j) => (
            <li key={j.id} className="flex items-center justify-between gap-2">
              <span className="text-white">#{j.work_order_id?.slice(0, 8) ?? "—"}</span>
              <span className="text-xs text-neutral-400">{j.job_type || "job"}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Pending quotes
  if (pendingQuotes?.length) {
    cards.push(
      <div key="quotes" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Quotes To Generate</h3>
          <Link href="/work-orders/queue" className="text-xs text-orange-400 underline">
            Queue
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {pendingQuotes.map((w) => (
            <li key={w.id} className="flex items-center justify-between gap-2">
              <span className="text-white">WO #{w.id.slice(0, 8)}</span>
              <span className="text-xs text-neutral-400">{fmtDate(w.created_at)}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Parts requests
  if (openPartsRequests?.length) {
    cards.push(
      <div key="parts" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Open Parts Requests</h3>
          <Link href="/parts" className="text-xs text-orange-400 underline">
            Parts
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {openPartsRequests.map((pr) => (
            <li key={pr.id} className="flex items-center justify-between gap-2">
              <span className="text-white">WO #{pr.work_order_id?.slice(0, 8) ?? "—"}</span>
              <span className="text-xs text-neutral-400">{pr.status || "open"}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Email failures
  if (emailFailures?.length) {
    cards.push(
      <div key="email" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Email Delivery Issues</h3>
          <Link href="/dashboard/admin/audit" className="text-xs text-orange-400 underline">
            Logs
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {emailFailures.slice(0, 5).map((e) => (
            <li key={e.id} className="flex items-center justify-between gap-2">
              <span className="text-white">{e.recipient || "recipient"}</span>
              <span className="text-xs text-red-400">{fmtDate(e.created_at)}</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Shop utilization + setup completeness
  if (shopUtil) {
    const used = shopUtil.active_user_count ?? 0;
    const cap = shopUtil.user_limit ?? 0;
    const pct = cap ? Math.min(100, Math.round((used / cap) * 100)) : 0;

    cards.push(
      <div key="shop" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">
            {shopUtil.name || "Shop"} Utilization
          </h3>
        </div>
        <div className="text-sm">
          Users {used}/{cap || "—"} {cap ? `(${pct}%)` : ""}
        </div>
        {shopMissingFields?.length ? (
          <div className="mt-2 text-xs text-yellow-400">
            Missing: {shopMissingFields.join(", ")}
          </div>
        ) : null}
        <div className="mt-2">
          <Link href="/dashboard/owner/settings" className="text-xs text-orange-400 underline">
            Settings
          </Link>
        </div>
      </div>
    );
  }

  // Vehicles missing VIN
  if (vehiclesMissingVin?.length) {
    cards.push(
      <div key="vin" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Vehicles Missing VIN</h3>
          <Link href="/portal/vehicles" className="text-xs text-orange-400 underline">
            Fix
          </Link>
        </div>
        <ul className="space-y-2 text-sm">
          {vehiclesMissingVin.map((v) => (
            <li key={v.id} className="flex items-center justify-between gap-2">
              <span className="text-white">
                {[v.year, v.make, v.model].filter(Boolean).join(" ") || v.id.slice(0, 8)}
              </span>
              <span className="text-xs text-neutral-400">No VIN</span>
            </li>
          ))}
        </ul>
      </div>
    );
  }

  // Unreviewed vehicle photos
  if (unreviewedPhotos?.length) {
    cards.push(
      <div key="photos" className="rounded-xl border border-neutral-800 bg-neutral-900 p-4">
        <div className="mb-2 flex items-center justify-between">
          <h3 className="text-sm font-semibold text-neutral-300">Unreviewed Vehicle Photos</h3>
          <Link href="/parts" className="text-xs text-orange-400 underline">
            Gallery
          </Link>
        </div>
        <div className="text-sm text-neutral-300">
          {unreviewedPhotos.length} photo{unreviewedPhotos.length === 1 ? "" : "s"} need review
        </div>
      </div>
    );
  }

  if (!cards.length) {
    return (
      <div className="rounded-xl border border-neutral-800 bg-neutral-900 p-6 text-sm text-neutral-400">
        Nothing to review right now.
      </div>
    );
  }

  return <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-3">{cards}</div>;
}

/* =============================== */
/* FILE: features/inspections/lib/inspection/matchToMenuItem.ts */
/* =============================== */

// features/inspections/lib/inspection/matchToMenuItem.ts
import type {
  InspectionSession,
  InspectionItem,
  QuoteLineItem,
} from "./types";
import { serviceMenu } from "@shared/lib/menuItems";
import { v4 as uuidv4 } from "uuid";

export default function matchToMenuItem(
  session: InspectionSession,
  item: InspectionItem,
): InspectionSession {
  // Only create quote lines for actionable statuses
  if (!item || !item.status || !["fail", "recommend"].includes(item.status)) {
    return session;
  }

  const newQuoteLines: QuoteLineItem[] = [];

  // Try the primary name + any recommended follow-ups
  const namesToMatch = [item.name, ...(item.recommend ?? [])];

  namesToMatch.forEach((term) => {
    if (!term) return;

    const match = serviceMenu.find((menuItem) =>
      term.toLowerCase().includes(menuItem.name.toLowerCase()),
    );

    if (match) {
      // Guard the status to the allowed set
      const statusSafe: QuoteLineItem["status"] =
        item.status === "ok" ||
        item.status === "fail" ||
        item.status === "na" ||
        item.status === "recommend"
          ? item.status
          : "ok";

      const quoteLine: QuoteLineItem = {
        id: uuidv4(),
        // display + identifiers
        item: match.name,
        name: "", // optional helper field in some UIs
        description: match.name,

        // status/notes
        status: statusSafe,
        notes: item.notes ?? "",

        // pricing (total can be computed elsewhere; keep price present)
        price: 0,
        laborTime: match.laborHours || 1,
        parts: [
          {
            name: match.name,
            price: match.partCost || 0,
          },
        ],
        totalCost:
          (match.partCost ?? 0) + (match.laborHours ?? 1) * 120,

        // provenance + misc helpers used around the app
        source: "inspection",
        partName: "",
      };

      newQuoteLines.push(quoteLine);
    }
  });

  return {
    ...session,
    quote: [...(session.quote ?? []), ...newQuoteLines],
  };
}

/* =============================== */
/* FILE: features/inspections/lib/inspection/types.ts */
/* =============================== */

/** ---------- Item / Section ---------- */
export type InspectionItemStatus = "ok" | "fail" | "na" | "recommend";
export type BrakeType = "air" | "hydraulic";

export interface InspectionItem {
  /** Primary label. Some code uses `item`, some uses `name` — support both. */
  item?: string;
  name?: string;

  status?: InspectionItemStatus;
  notes?: string;
  /** Some AI/normalizers use singular `note`. */
  note?: string;

  value?: string | number | null;
  unit?: string | null;

  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionCategory {
  title: string;
  items: InspectionItem[];
}

/** Many places import `InspectionSection`; keep it as an alias. */
export type InspectionSection = InspectionCategory;

/** ---------- Parsed voice/AI commands (support both shapes) ---------- */
/** Older, name-based command shape used by dispatchCommand/interpreter */
export type ParsedCommandNameBased =
  | { type: "status"; section: string; item: string; status: InspectionItemStatus }
  | { type: "add"; section: string; item: string; note: string }
  | { type: "recommend"; section: string; item: string; note: string }
  | {
      type: "measurement";
      section: string;
      item: string;
      value: number | string;
      unit?: string;
    };

/** Newer, index-based command shape used by convertParsedCommands.ts */
export type ParsedCommandIndexed = {
  command:
    | "update_status"
    | "update_value"
    | "add_note"
    | "recommend"
    | "complete_item"
    | "skip_item"
    | "pause_inspection"
    | "finish_inspection";
  sectionIndex?: number;
  itemIndex?: number;
  status?: InspectionItemStatus;
  value?: string | number;
  unit?: string;
  notes?: string;
  recommend?: string;
};

/** Unified ParsedCommand covering both shapes */
export type ParsedCommand = ParsedCommandNameBased | ParsedCommandIndexed;

/**
 * Commands consumed by dispatchCommand (older name-based shape),
 * plus a simple "pause" variant used in a few places.
 */
export type InspectionCommand =
  | ParsedCommandNameBased
  | { type: "pause"; section?: string; item?: string };

/** ---------- Runtime command objects (AI → actions) ---------- */
export type Command =
  | {
      type: "update_status";
      sectionIndex: number;
      itemIndex: number;
      status: InspectionItemStatus;
    }
  | {
      type: "update_value";
      sectionIndex: number;
      itemIndex: number;
      value: string | number;
      unit?: string;
    }
  | {
      type: "add_note";
      sectionIndex: number;
      itemIndex: number;
      notes: string;
    }
  | {
      type: "recommend";
      sectionIndex: number;
      itemIndex: number;
      recommendation: string;
    }
  | {
      type: "complete";
      sectionIndex: number;
      itemIndex: number;
    }
  | {
      type: "skip";
      sectionIndex: number;
      itemIndex: number;
    }
  | { type: "pause" }
  | { type: "finish" };

/** ---------- Quote shapes ---------- */
/** Rich source descriptor for where a line came from. */
export type QuoteSource = "inspection" | "manual" | string;

/**
 * Lightweight line produced by AI generators / costing flows.
 * Extended to include fields your costing + menu matching code writes.
 */
export interface QuoteLine {
  /** Core */
  description: string;

  /** IDs / provenance */
  id?: string;
  source?: QuoteSource;

  /** Names used across flows */
  item?: string;             // selected service/menu name
  name?: string;             // occasional alias
  inspectionItem?: string;   // originating inspection item text

  /** Status / notes */
  status?: InspectionItemStatus;
  notes?: string;

  /** Time & rates */
  hours?: number;
  rate?: number;
  total?: number;
  laborHours?: number | null;
  laborTime?: number;        // alias used on some screens
  laborRate?: number;

  /** Parts */
  parts?: Array<{ name?: string; number?: string; price?: number; type?: string }>;
  partNumber?: string | null;
  partName?: string;
  unitPrice?: number | null;

  /** Roll-up / pricing */
  qty?: number;
  price?: number;            // some code writes final line price here
  totalCost?: number;
}

/** Detailed line used by PDF/store. */
export interface QuoteLineItem {
  id: string;

  /** Some places map description into both `item` and `name`. */
  item?: string;
  name?: string;
  description: string;

  status: InspectionItemStatus;
  notes?: string;

  /** Unified commercial fields */
  price: number; // line price/total
  laborHours?: number;
  /** Additional variants used in some flows */
  laborTime?: number; // alias used on some pages
  laborRate?: number;

  /** Item-level measurement value (rare) */
  value?: string | number | null;

  /** Parts can be object or split fields */
  part?: { name: string; price: number };
  partName?: string;
  partPrice?: number | null;

  /** Old-style fields occasionally present */
  qty?: number;
  unitPrice?: number | null;

  /** Misc UI helpers */
  photoUrls?: string[];
  editable?: boolean;
  source?: QuoteSource;

  /** Collections used by some UIs */
  parts?: Array<{ name?: string; number?: string; price?: number }>;
  totalCost?: number;

  /** Optional back-reference to the inspection item */
  inspectionItem?: string;

  /** Optional AI suggestion metadata */
  ai?: {
    summary: string;
    confidence?: string;
    parts?: { name: string; qty?: number; cost?: number; notes?: string }[];
  };

  /** UI-only: track AI enrichment progress for this line */
  aiState?: "idle" | "loading" | "done" | "error";
}

/** ---------- Inspection Summary ---------- */
export interface SummaryItem {
  section: string;
  item: string;
  status: InspectionItemStatus;
  note?: string;
  value?: string | number | null;
  unit?: string | null;
  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionSummary {
  templateName?: string | null;
  date: string;
  items: SummaryItem[];
  summaryText: string;
}

/** ---------- Session (customer/vehicle) ---------- */
export interface SessionCustomer {
  first_name: string | null;
  last_name: string | null;
  phone: string | null;
  email: string | null;
  address: string | null;
  city: string | null;
  province: string | null;
  postal_code: string | null;
}

export interface SessionVehicle {
  year: string | null;
  make: string | null;
  model: string | null;
  vin: string | null;
  license_plate: string | null;
  mileage: string | null;
  color: string | null;
  /** Added for your form */
  unit_number?: string | null;
  engine_hours?: string | null;
}

/** ---------- Session status ---------- */
export type InspectionStatus = "not_started" | "in_progress" | "paused" | "completed";

/** ---------- Full session ---------- */
export interface InspectionSession {
  id?: string;

  /** Links to other records */
  customerId?: string | null;
  vehicleId?: string | null;
  workOrderId?: string | null;

  /** Template meta */
  templateId?: string | null;
  templateName?: string | null;
  /** Legacy alias still used by some pages */
  templateitem?: string | null;

  /** Selected brake system for rendering/units */
  brakeType?: BrakeType;

  location?: string | null;

  /** Progress */
  currentSectionIndex: number;
  currentItemIndex: number;

  /** Voice */
  transcript?: string;
  isListening: boolean;

  /** Lifecycle */
  status: InspectionStatus;
  started: boolean;
  completed: boolean;
  isPaused: boolean;

  /** Audit */
  lastUpdated?: string;

  /** Entities */
  customer?: SessionCustomer | null;
  vehicle?: SessionVehicle | null;

  /** Content */
  sections: InspectionCategory[];

  /** Quotes can be DB-sourced or UI-generated — accept both */
  quote?: Array<QuoteLine | QuoteLineItem>;
}

/* =============================== */
/* FILE: features/inspections/lib/inspection/inspectionState.ts */
/* =============================== */

import {
  InspectionSession,
  InspectionItemStatus,
  QuoteLine,
} from "@inspections/lib/inspection/types";

export function updateItemStatus(
  session: InspectionSession,
  sectionIndex: number,
  itemIndex: number,
  status: InspectionItemStatus,
): InspectionSession {
  const updated = { ...session };
  updated.sections = [...session.sections];
  const section = { ...updated.sections[sectionIndex] };
  const item = { ...section.items[itemIndex], status };

  // Reset photoUrls and note if status changes
  if (status !== "fail" && status !== "recommend") {
    item.photoUrls = [];
    item.notes = "";
  }

  section.items = [...section.items];
  section.items[itemIndex] = item;
  updated.sections[sectionIndex] = section;
  return updated;
}
export function updateItemValue(
  session: InspectionSession,
  sectionIndex: number,
  itemIndex: number,
  value: number | string,
): InspectionSession {
  const updated = { ...session };
  const sections = [...updated.sections];
  const section = { ...sections[sectionIndex] };
  const item = { ...section.items[itemIndex], value };

  section.items[itemIndex] = item;
  sections[sectionIndex] = section;

  return { ...updated, sections };
}

export function updateItemNote(
  session: InspectionSession,
  sectionIndex: number,
  itemIndex: number,
  note: string,
): InspectionSession {
  const updated = { ...session };
  updated.sections = [...session.sections];
  const section = { ...updated.sections[sectionIndex] };
  const item = { ...section.items[itemIndex], note };
  section.items = [...section.items];
  section.items[itemIndex] = item;
  updated.sections[sectionIndex] = section;
  return updated;
}

export function addPhotoUrl(
  session: InspectionSession,
  sectionIndex: number,
  itemIndex: number,
  photoUrl: string,
): InspectionSession {
  const updated = { ...session };
  updated.sections = [...session.sections];
  const section = { ...updated.sections[sectionIndex] };
  const item = { ...section.items[itemIndex] };

  item.photoUrls = [...(item.photoUrls || []), photoUrl];

  section.items = [...section.items];
  section.items[itemIndex] = item;
  updated.sections[sectionIndex] = section;
  return updated;
}

export function updateQuoteLines(
  session: InspectionSession,
  quoteLines: QuoteLine[],
): InspectionSession {
  return { ...session, quote: quoteLines };
}


/* =============================== */
/* FILE: features/inspections/lib/inspection/aiQuote.ts */
/* =============================== */

// features/inspections/lib/inspection/aiQuote.ts
export type AISuggestion = {
  parts: { name: string; qty?: number; cost?: number; notes?: string }[];
  laborHours: number;
  laborRate?: number;
  summary: string;
  confidence?: "low" | "medium" | "high";
  price?: number;
  notes?: string;
  title?: string;
};

export async function requestQuoteSuggestion(args: {
  item: string;
  notes?: string;
  section: string;
  status: string;
  value?: string;
  unit?: string;
  vehicle?: Record<string, any>;
}): Promise<AISuggestion | null> {
  try {
    const res = await fetch("/api/ai/quote-suggest", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(args),
    });
    if (!res.ok) return null;
    const data = await res.json();
    return (data?.suggestion ?? null) as AISuggestion | null;
  } catch (e) {
    console.error("requestQuoteSuggestion error:", e);
    return null;
  }
}

/* =============================== */
/* FILE: features/inspections/api/inspection/submit/route.ts */
/* =============================== */

// app/api/inspections/submit/route.ts
import { NextRequest, NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";

import { generateQuoteFromInspection } from "@quotes/lib/quote/generateQuoteFromInspection";
import { generateQuotePDFBytes } from "@work-orders/lib/work-orders/generateQuotePdf";
import { sendQuoteEmail } from "@shared/lib/email/email/sendQuoteEmail";
import { generateInspectionSummary } from "@inspections/lib/inspection/generateInspectionSummary";

import type { Database } from "@shared/types/types/supabase";
import type {
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

export const runtime = "nodejs";

export async function POST(req: NextRequest) {
  const body = await req.json();
  const {
    inspectionSession,
    workOrderId,
    customerEmail,
  }: {
    inspectionSession: InspectionSession;
    workOrderId: string;
    customerEmail: string;
  } = body;

  if (!inspectionSession || !workOrderId || !customerEmail) {
    return NextResponse.json({ error: "Missing input" }, { status: 400 });
  }

  try {
    const supabase = createRouteHandlerClient<Database>({ cookies });

    // 1) Structured inspection summary
    const summary = generateInspectionSummary(inspectionSession);
    const summaryText =
      typeof summary === "string" ? summary : summary?.summaryText ?? "";

    // 2) Flatten inspection items and create a quote (new lightweight shape)
    const allItems = inspectionSession.sections.flatMap((s) => s.items);
    const { quote } = await generateQuoteFromInspection(allItems);

    // 3) Normalize new QuoteLine -> QuoteLineItem for PDF generation
    const quoteItems: QuoteLineItem[] = quote.map((line, index) => ({
      id: `${index}-${line.description}`,
      item: line.description,
      name: line.description,
      description: line.description,
      status: "fail",
      notes: "",
      laborHours: line.hours,
      price: line.hours * line.rate,
      part: undefined,
      partName: "",
      partPrice: null,
      photoUrls: [],
    }));

    // 4) Generate PDF bytes
    const pdfBytes = await generateQuotePDFBytes(quoteItems, summaryText);

    // 5) Upload to Supabase storage
    const fileName = `quotes/${workOrderId}-${Date.now()}.pdf`;
    const { error: uploadError } = await supabase.storage
      .from("quotes")
      .upload(fileName, pdfBytes, {
        contentType: "application/pdf",
        upsert: true,
      });

    if (uploadError) {
      throw new Error("PDF upload failed: " + uploadError.message);
    }

    const { data } = supabase.storage.from("quotes").getPublicUrl(fileName);
    const publicUrl = data?.publicUrl ?? null;

    // 6) Email the quote (URL + attachment)
    await sendQuoteEmail({
      to: customerEmail,
      workOrderId,
      pdfBuffer: Buffer.from(pdfBytes).toString("base64"),
      pdfUrl: publicUrl ?? undefined,
    });

    return NextResponse.json({ success: true, quoteUrl: publicUrl });
  } catch (error) {
    console.error("🚨 Error generating and sending quote:", error);
    return NextResponse.json(
      { error: "Failed to generate and send quote" },
      { status: 500 },
    );
  }
}

/* =============================== */
/* FILE: features/inspections/screens/Maintenance50Screen.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/lib/inspection/ui/CornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* ---------- Props for screen usage (modal + page) ---------- */
type ScreenProps = {
  embed?: boolean;
  template?: string;
  params?: Record<string, string | number | boolean | null | undefined>;
};

/* ---------- Sections ---------- */
function buildHydraulicMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Hydraulic)",
    items: [
      { item: "LF Tire Pressure", unit: "psi", value: "" },
      { item: "RF Tire Pressure", unit: "psi", value: "" },
      { item: "LR Tire Pressure", unit: "psi", value: "" },
      { item: "RR Tire Pressure", unit: "psi", value: "" },
      { item: "LF Tire Tread", unit: "mm", value: "" },
      { item: "RF Tire Tread", unit: "mm", value: "" },
      { item: "LR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "LR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "LF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "LR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "Wheel Torque (after road test)", unit: "ft·lb", value: "" },
    ],
  };
}
function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}
function buildBrakesSection(): InspectionSection {
  return {
    title: "Brakes",
    items: [
      { item: "Front brake pads" },
      { item: "Rear brake pads" },
      { item: "Brake fluid level" },
      { item: "Brake lines and hoses" },
      { item: "ABS wiring / sensors" },
      { item: "Brake warning lights" },
    ],
  };
}
function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
    ],
  };
}
function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "CV shafts / joints" },
      { item: "Transmission leaks / mounts" },
      { item: "Transfer case leaks / mounts" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* ---------- Units helpers ---------- */
function unitForHydraulic(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tire tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad thickness")) return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}
function applyUnitsHydraulic(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    if ((s.title || "").toLowerCase().includes("measurements")) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForHydraulic(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }
    return s;
  });
}

/* ---------- Screen (component) ---------- */
export default function Maintenance50Screen(props: ScreenProps): JSX.Element {
  const searchParams = useSearchParams();
  const p = props.params ?? {};
  const rootRef = useRef<HTMLDivElement | null>(null);

  const get = (k: string): string => {
    const v = p[k];
    if (v !== undefined && v !== null) return String(v);
    return searchParams.get(k) ?? "";
  };

  // 🔸 only mobile companion gets voice
  const isMobileView =
    (get("view") || "").toLowerCase() === "mobile";

  const isEmbed =
    !!props.embed ||
    ["1", "true", "yes"].includes(
      (get("embed") || get("compact")).toLowerCase()
    );

  const workOrderLineId = get("workOrderLineId") || null;
  const workOrderId = get("workOrderId") || null;
  const inspectionId = useMemo<string>(
    () => get("inspectionId") || uuidv4(),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string = props.template || get("template") || "Maintenance 50";

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      sections: [],
    }),
    [inspectionId, templateName]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  // ---- AI submit guarding ----
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // ---- boot/restore ----
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // persist
  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        localStorage.setItem(key, JSON.stringify(session ?? initialSession));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // build sections once
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;
    const next: InspectionSection[] = [
      buildHydraulicMeasurementsSection(),
      buildLightsSection(),
      buildBrakesSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsHydraulic(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  // re-apply units
  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsHydraulic(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  // transcript → commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // speech
  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };
  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  /* 🧹 embed-safe scrubber (remove full-screen / overflow locks) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  /* 🔐 focus trap while embedded (keep Tab inside) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-sm text-neutral-300">Loading inspection…</div>;
  }

  const isMeasurements = (t?: string): boolean =>
    (t || "").toLowerCase().includes("measurements");

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const Body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Maintenance 50"}
          </div>
        </div>
      </div>

      {/* Controls */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              try {
                recognitionRef.current?.stop();
              } catch {}
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              recognitionRef.current = startVoiceRecognition(handleTranscript);
            }}
            recognitionInstance={
              recognitionRef.current as unknown as SpeechRecognition | null
            }
            onTranscript={handleTranscript}
            setRecognitionRef={(instance: SpeechRecognition | null): void => {
              (
                recognitionRef as React.MutableRefObject<SpeechRecognition | null>
              ).current = instance ?? null;
            }}
          />
        )}

        {/* Unit toggle on all views */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      {/* Sections */}
      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isMeasurements(section.title) && (
              <span className={hint}>
                {unit === "metric"
                  ? "Enter mm / kPa / N·m"
                  : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className="mt-4">
              {isMeasurements(section.title) ? (
                <CornerGrid sectionIndex={sectionIndex} items={section.items} />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes
                  showPhotos
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(
                    secIdx: number,
                    itemIdx: number,
                    note: string
                  ): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(
                    photoUrl: string,
                    secIdx: number,
                    itemIdx: number
                  ): void => {
                    const prev =
                      session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, {
                      photoUrls: [...prev, photoUrl],
                    });
                  }}
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) =>
                    void submitAIForItem(secIdx, itemIdx)
                  }
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      {/* Footer */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Maintenance 50"}
      description="Quick 50-point hydraulic brake maintenance inspection."
    >
      {Body}
    </PageShell>
  );
}

/* =============================== */
/* FILE: features/inspections/screens/GenericInspectionScreen.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import AxlesCornerGrid from "@inspections/lib/inspection/ui/AxlesCornerGrid";

import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* -------------------------- helpers -------------------------- */

function toHeaderCustomer(c?: SessionCustomer | null) {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}
function toHeaderVehicle(v?: SessionVehicle | null) {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/** Try to give a sensible unit hint for common labels */
function unitHintGeneric(label: string, mode: "metric" | "imperial"): string {
  const l = (label || "").toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad") || l.includes("lining") || l.includes("shoe"))
    return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor") || l.includes("drum")) return mode === "metric" ? "mm" : "in";
  if (l.includes("push rod")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  if (l.includes("leak rate")) return mode === "metric" ? "kPa/min" : "psi/min";
  if (l.includes("gov cut") || l.includes("warning")) return mode === "metric" ? "kPa" : "psi";
  return "";
}

/** Safe reader for sessionStorage JSON */
function readStaged<T>(key: string): T | null {
  try {
    if (typeof window === "undefined") return null;
    const raw = sessionStorage.getItem(key);
    return raw ? (JSON.parse(raw) as T) : null;
  } catch {
    return null;
  }
}

/** Normalize + merge sections (copy name→item; merge same titles; dedupe items) */
function normalizeSections(input: unknown): InspectionSection[] {
  try {
    const arr = Array.isArray(input) ? input : [];
    const byTitle = new Map<string, InspectionSection>();

    for (const s of arr as any[]) {
      const title = String(s?.title ?? "").trim();
      if (!title) continue;

      const itemsRaw = Array.isArray(s?.items) ? s.items : [];
      const items = itemsRaw
        .map((it: any) => {
          const label = String(it?.item ?? it?.name ?? "").trim();
          if (!label) return null;
          return {
            ...it,
            item: label,
            unit: it?.unit ?? null,
          };
        })
        .filter(Boolean);

      if (!byTitle.has(title)) byTitle.set(title, { title, items: [] });
      const bucket = byTitle.get(title)!;
      const seen = new Set((bucket.items ?? []).map((x) => (x.item ?? "").toLowerCase()));
      for (const it of items as any[]) {
        const key = (it.item ?? "").toLowerCase();
        if (!seen.has(key)) {
          bucket.items = [...(bucket.items ?? []), it];
          seen.add(key);
        }
      }
    }

    return Array.from(byTitle.values()).filter((s) => (s.items?.length ?? 0) > 0);
  } catch {
    return [];
  }
}

/* -------- smarter corner-grid detector -------- */

const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const HYD_FULL_RE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

function shouldRenderCornerGrid(
  title: string | undefined,
  items: { item?: string | null }[] = []
): boolean {
  const t = (title || "").toLowerCase();

  if (
    t.includes("corner grid") ||
    t.includes("tires & brakes — truck") ||
    t.includes("tires & brakes — air") ||
    t.includes("axle grid")
  ) {
    return true;
  }

  if (!items || items.length < 4) return false;

  const hasStrongPattern = items.some((it) => {
    const label = it.item ?? "";
    return AIR_RE.test(label) || HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label);
  });

  const measurementKeywords = [
    "tread",
    "pressure",
    "lining",
    "shoe",
    "drum",
    "rotor",
    "push rod",
    "pad",
    "torque",
  ];
  const measurementLikeCount = items.reduce((count, it) => {
    const label = (it.item || "").toLowerCase();
    const isMeasurement = measurementKeywords.some((kw) => label.includes(kw));
    return count + (isMeasurement ? 1 : 0);
  }, 0);

  const enoughMeasurements = measurementLikeCount >= Math.floor(items.length / 2);

  const titleSuggestsMeasurement =
    t.includes("tire") ||
    t.includes("tires") ||
    t.includes("brake") ||
    t.includes("measurement") ||
    t.includes("axle");

  return hasStrongPattern || (titleSuggestsMeasurement && enoughMeasurements);
}

/* -------------------------------------------------------------------- */
/* Component                                                            */
/* -------------------------------------------------------------------- */

export default function GenericInspectionScreen(): JSX.Element {
  const sp = useSearchParams();
  const rootRef = useRef<HTMLDivElement | null>(null);

  // 🔸 only the mobile companion should use voice
  const isMobileView =
    (sp.get("view") || "").toLowerCase() === "mobile";

  // Embed for iframe/modal
  const isEmbed = useMemo(
    () =>
      ["1", "true", "yes"].includes(
        (sp.get("embed") || sp.get("compact") || "").toLowerCase()
      ),
    [sp]
  );

  const workOrderId = sp.get("workOrderId") || null;
  const workOrderLineId = sp.get("workOrderLineId") || "";
  const templateName =
    (typeof window !== "undefined" ? sessionStorage.getItem("inspection:title") : null) ||
    (sp.get("template") || "Inspection");

  const customer: SessionCustomer = {
    first_name: sp.get("first_name") || "",
    last_name: sp.get("last_name") || "",
    phone: sp.get("phone") || "",
    email: sp.get("email") || "",
    address: sp.get("address") || "",
    city: sp.get("city") || "",
    province: sp.get("province") || "",
    postal_code: sp.get("postal_code") || "",
  };
  const vehicle: SessionVehicle = {
    year: sp.get("year") || "",
    make: sp.get("make") || "",
    model: sp.get("model") || "",
    vin: sp.get("vin") || "",
    license_plate: sp.get("license_plate") || "",
    mileage: sp.get("mileage") || "",
    color: sp.get("color") || "",
    unit_number: sp.get("unit_number") || "",
    engine_hours: sp.get("engine_hours") || "",
  };

  const bootSections = useMemo<InspectionSection[]>(() => {
    const staged = readStaged<InspectionSection[]>("inspection:sections");
    if (Array.isArray(staged) && staged.length) return normalizeSections(staged);

    try {
      const legacy =
        typeof window !== "undefined"
          ? sessionStorage.getItem("customInspection:sections")
          : null;
      if (legacy) {
        const parsed = JSON.parse(legacy) as InspectionSection[];
        const norm = normalizeSections(parsed);
        return norm;
      }
    } catch {}

    return [
      {
        title: "General",
        items: [{ item: "Visual walkaround" }, { item: "Record warning lights" }],
      },
    ];
  }, [sp]);

  const inspectionId = useMemo(
    () => sp.get("inspectionId") || uuidv4(),
    [sp]
  );

  // 🔸 try to hydrate from localStorage
  const persistedSession = useMemo(() => {
    if (typeof window === "undefined") return null;
    const raw = localStorage.getItem(`inspection-${inspectionId}`);
    if (!raw) return null;
    try {
      return JSON.parse(raw) as InspectionSession;
    } catch {
      return null;
    }
  }, [inspectionId]);

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState(false);
  const [isPaused, setIsPaused] = useState(false);

  // 🔴 wake-word state
  const [wakeActive, setWakeActive] = useState(false);
  const wakeTimeoutRef = useRef<number | null>(null);

  // openai realtime refs
  const wsRef = useRef<WebSocket | null>(null);
  const mediaRef = useRef<MediaStream | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(persistedSession ?? initialSession);

  // start
  useEffect(() => {
    if (persistedSession) {
      startSession(persistedSession);
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [persistedSession]);
  useEffect(() => {
    if (session && (session.sections?.length ?? 0) === 0) {
      updateInspection({ sections: bootSections });
    }
  }, [session, bootSections, updateInspection]);

  // persist
  useEffect(() => {
    if (!session) return;
    const key = `inspection-${inspectionId}`;
    localStorage.setItem(key, JSON.stringify(session));
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // 🔸 turn final text into inspection commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess = session;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // 🔔 wake-word helper
  function maybeHandleWakeWord(raw: string): string | null {
    const lower = raw.toLowerCase().trim();
    const WAKE_WORDS = ["hey techy", "hey techie", "hey teki", "hey tekky"];

    if (!wakeActive) {
      const hit = WAKE_WORDS.find((w) => lower.startsWith(w));
      if (hit) {
        setWakeActive(true);
        if (wakeTimeoutRef.current) window.clearTimeout(wakeTimeoutRef.current);
        wakeTimeoutRef.current = window.setTimeout(() => {
          setWakeActive(false);
        }, 8000);
        return lower.slice(hit.length).trim();
      }
      return null;
    }

    if (wakeTimeoutRef.current) window.clearTimeout(wakeTimeoutRef.current);
    wakeTimeoutRef.current = window.setTimeout(() => {
      setWakeActive(false);
    }, 8000);

    return raw;
  }

  // 🔊 openai realtime start (used only when mobile buttons are visible)
  const startListening = async (): Promise<void> => {
    if (isListening) return;
    try {
      const res = await fetch("/api/openai/realtime-token");
      const { apiKey } = (await res.json()) as { apiKey: string };
      if (!apiKey) throw new Error("Missing OpenAI key");

      const ws = new WebSocket("wss://api.openai.com/v1/realtime?intent=transcription");
      wsRef.current = ws;

      ws.onopen = async () => {
        ws.send(
          JSON.stringify({
            type: "authorization",
            authorization: `Bearer ${apiKey}`,
          })
        );

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRef.current = stream;

        const mr = new MediaRecorder(stream, { mimeType: "audio/webm" });
        mediaRecorderRef.current = mr;
        mr.ondataavailable = (evt) => {
          if (evt.data.size > 0 && ws.readyState === WebSocket.OPEN) {
            ws.send(evt.data);
          }
        };
        mr.start(250);

        setIsListening(true);
      };

      ws.onmessage = async (evt) => {
        if (typeof evt.data !== "string") return;
        try {
          const msg = JSON.parse(evt.data);
          const text: string =
            msg.text || msg.transcript || msg.output || msg.content || "";
          if (!text) return;

          const maybeText = maybeHandleWakeWord(text);
          if (!maybeText) return;

          const lower = maybeText.toLowerCase();
          if (lower === "stop listening" || lower === "go to sleep") {
            setWakeActive(false);
            return;
          }

          await handleTranscript(maybeText);
        } catch {
          // ignore parse errors
        }
      };

      ws.onerror = (err) => {
        console.error("realtime ws error", err);
        toast.error("Voice connection error");
        stopListening();
      };

      ws.onclose = () => {
        stopListening();
      };
    } catch (e: any) {
      console.error(e);
      toast.error(e?.message || "Unable to start voice");
      stopListening();
    }
  };

  const stopListening = (): void => {
    mediaRecorderRef.current?.stop();
    mediaRecorderRef.current = null;

    mediaRef.current?.getTracks().forEach((t) => t.stop());
    mediaRef.current = null;

    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.close();
    }
    wsRef.current = null;
    setIsListening(false);
    setWakeActive(false);
    if (wakeTimeoutRef.current) {
      window.clearTimeout(wakeTimeoutRef.current);
      wakeTimeoutRef.current = null;
    }
  };

  useEffect(() => {
    return () => {
      stopListening();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // AI submit flow
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? (it as any).name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // 🧹 embed-safe scrubber (for iframe / modal host)
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child as HTMLElement);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  // 🔐 Focus trap so Tab stays inside the inspection when embedded in modal
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      // If focus is already outside the root, jump to first
      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        // Shift+Tab: if we're on first, loop to last
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        // Tab forward: if we're on last, loop to first
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return (
      <div className="p-4 text-sm text-neutral-300">
        Loading inspection…
      </div>
    );
  }

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header card */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Inspection"}
          </div>
        </div>

        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      {/* Controls row */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {/* Voice only in mobile companion */}
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              stopListening();
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              void startListening();
            }}
            recognitionInstance={null}
            onTranscript={handleTranscript}
            setRecognitionRef={(): void => {
              /* noop – using OpenAI now */
            }}
          />
        )}

        {/* Unit toggle stays on both desktop + mobile */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => {
          const itemsWithHints = section.items.map((it) => ({
            ...it,
            unit: it.unit || unitHintGeneric(it.item ?? "", unit),
          }));

          const useGrid = shouldRenderCornerGrid(section.title, itemsWithHints);

          return (
            <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
              <h2 className={sectionTitle}>{section.title}</h2>
              {useGrid && (
                <span className={hint}>
                  {unit === "metric"
                    ? "Enter mm / kPa / N·m"
                    : "Enter in / psi / ft·lb"}
                </span>
              )}

              <div className="mt-4">
                {useGrid ? (
                  <AxlesCornerGrid
                    sectionIndex={sectionIndex}
                    items={itemsWithHints}
                  />
                ) : (
                  <SectionDisplay
                    title=""
                    section={{ ...section, items: itemsWithHints }}
                    sectionIndex={sectionIndex}
                    showNotes
                    showPhotos
                    onUpdateStatus={(
                      secIdx: number,
                      itemIdx: number,
                      status: InspectionItemStatus
                    ) => {
                      updateItem(secIdx, itemIdx, { status });
                    }}
                    onUpdateNote={(secIdx, itemIdx, note) => {
                      updateItem(secIdx, itemIdx, { notes: note });
                    }}
                    onUpload={(photoUrl, secIdx, itemIdx) => {
                      const prev =
                        session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                      updateItem(secIdx, itemIdx, {
                        photoUrls: [...prev, photoUrl],
                      });
                    }}
                    requireNoteForAI
                    onSubmitAI={(secIdx, itemIdx) => {
                      void submitAIForItem(secIdx, itemIdx);
                    }}
                    isSubmittingAI={isSubmittingAI}
                  />
                )}
              </div>
            </div>
          );
        })}
      </InspectionFormCtx.Provider>

      {/* Footer actions */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton session={session} workOrderLineId={workOrderLineId} />
          <FinishInspectionButton session={session} workOrderLineId={workOrderLineId} />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Inspection"}
      description="Run guided inspections, capture notes, and push items into work orders."
    >
      {body}
    </PageShell>
  );
}

/* =============================== */
/* FILE: features/inspections/screens/Maintenance50AirScreen.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/lib/inspection/ui/CornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* ---------- Props for screen usage (modal + page) ---------- */
type ScreenProps = {
  embed?: boolean;
  template?: string;
  params?: Record<string, string | number | boolean | null | undefined>;
};

/* ---------- Sections ---------- */
function buildHydraulicMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Hydraulic)",
    items: [
      { item: "LF Tire Pressure", unit: "psi", value: "" },
      { item: "RF Tire Pressure", unit: "psi", value: "" },
      { item: "LR Tire Pressure", unit: "psi", value: "" },
      { item: "RR Tire Pressure", unit: "psi", value: "" },
      { item: "LF Tire Tread", unit: "mm", value: "" },
      { item: "RF Tire Tread", unit: "mm", value: "" },
      { item: "LR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "LR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "LF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "LR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "Wheel Torque (after road test)", unit: "ft·lb", value: "" },
    ],
  };
}
function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}
function buildBrakesSection(): InspectionSection {
  return {
    title: "Brakes",
    items: [
      { item: "Front brake pads" },
      { item: "Rear brake pads" },
      { item: "Brake fluid level" },
      { item: "Brake lines and hoses" },
      { item: "ABS wiring / sensors" },
      { item: "Brake warning lights" },
    ],
  };
}
function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
    ],
  };
}
function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "CV shafts / joints" },
      { item: "Transmission leaks / mounts" },
      { item: "Transfer case leaks / mounts" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* ---------- Units helpers ---------- */
function unitForHydraulic(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tire tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad thickness")) return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}
function applyUnitsHydraulic(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    if ((s.title || "").toLowerCase().includes("measurements")) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForHydraulic(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }
    return s;
  });
}

/* ---------- Screen (component) ---------- */
export default function Maintenance50Screen(props: ScreenProps): JSX.Element {
  const searchParams = useSearchParams();
  const p = props.params ?? {};
  const rootRef = useRef<HTMLDivElement | null>(null);

  const get = (k: string): string => {
    const v = p[k];
    if (v !== undefined && v !== null) return String(v);
    return searchParams.get(k) ?? "";
  };

  // 🔸 only mobile companion gets voice
  const isMobileView =
    (get("view") || "").toLowerCase() === "mobile";

  const isEmbed =
    !!props.embed ||
    ["1", "true", "yes"].includes(
      (get("embed") || get("compact")).toLowerCase()
    );

  const workOrderLineId = get("workOrderLineId") || null;
  const workOrderId = get("workOrderId") || null;
  const inspectionId = useMemo<string>(
    () => get("inspectionId") || uuidv4(),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string = props.template || get("template") || "Maintenance 50";

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      sections: [],
    }),
    [inspectionId, templateName]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  // ---- AI submit guarding ----
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // ---- boot/restore ----
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // persist
  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        localStorage.setItem(key, JSON.stringify(session ?? initialSession));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // build sections once
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;
    const next: InspectionSection[] = [
      buildHydraulicMeasurementsSection(),
      buildLightsSection(),
      buildBrakesSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsHydraulic(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  // re-apply units
  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsHydraulic(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  // transcript → commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // speech
  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };
  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  /* 🧹 embed-safe scrubber (remove full-screen / overflow locks) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  /* 🔐 focus trap while embedded (keep Tab inside) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-sm text-neutral-300">Loading inspection…</div>;
  }

  const isMeasurements = (t?: string): boolean =>
    (t || "").toLowerCase().includes("measurements");

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const Body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Maintenance 50"}
          </div>
        </div>
      </div>

      {/* Controls */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              try {
                recognitionRef.current?.stop();
              } catch {}
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              recognitionRef.current = startVoiceRecognition(handleTranscript);
            }}
            recognitionInstance={
              recognitionRef.current as unknown as SpeechRecognition | null
            }
            onTranscript={handleTranscript}
            setRecognitionRef={(instance: SpeechRecognition | null): void => {
              (
                recognitionRef as React.MutableRefObject<SpeechRecognition | null>
              ).current = instance ?? null;
            }}
          />
        )}

        {/* Unit toggle on all views */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      {/* Sections */}
      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isMeasurements(section.title) && (
              <span className={hint}>
                {unit === "metric"
                  ? "Enter mm / kPa / N·m"
                  : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className="mt-4">
              {isMeasurements(section.title) ? (
                <CornerGrid sectionIndex={sectionIndex} items={section.items} />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes
                  showPhotos
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(
                    secIdx: number,
                    itemIdx: number,
                    note: string
                  ): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(
                    photoUrl: string,
                    secIdx: number,
                    itemIdx: number
                  ): void => {
                    const prev =
                      session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, {
                      photoUrls: [...prev, photoUrl],
                    });
                  }}
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) =>
                    void submitAIForItem(secIdx, itemIdx)
                  }
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      {/* Footer */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Maintenance 50"}
      description="Quick 50-point hydraulic brake maintenance inspection."
    >
      {Body}
    </PageShell>
  );
}

/* =============================== */
/* FILE: features/inspections/app/inspection/summary/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";

import type { Database } from "@shared/types/types/supabase";
import { Button } from "@shared/components/ui/Button";

import useInspectionSession from "@inspections/hooks/useInspectionSession";
import { generateInspectionPDF } from "@inspections/lib/inspection/pdf";
import { generateQuoteFromInspection } from "@quotes/lib/quote/generateQuoteFromInspection";

import QuoteViewer from "@quotes/components/QuoteViewer";
import PreviousPageButton from "@shared/components/ui/PreviousPageButton";
import HomeButton from "@shared/components/ui/HomeButton";

import type {
  InspectionItem,
  InspectionSection,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";
import type { QuoteLine } from "@quotes/lib/quote/generateQuoteFromInspection";

export default function SummaryPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = useMemo(() => createClientComponentClient<Database>(), []);

  const inspectionId = searchParams.get("inspectionId");
  const workOrderIdFromUrl = searchParams.get("workOrderId");
  const mode = searchParams.get("mode");
  const isCustomerView = mode === "customer";

  const { session, updateItem, updateQuoteLines } = useInspectionSession();

  const [quoteLines, setQuoteLines] = useState<QuoteLine[]>([]);
  const [summaryText, setSummaryText] = useState("");
  const [workOrderId, setWorkOrderId] = useState<string | null>(
    workOrderIdFromUrl || null,
  );
  const [isAddingToWorkOrder, setIsAddingToWorkOrder] = useState(false);
  const [downloading, setDownloading] = useState(false);
  const [aiError, setAiError] = useState<string | null>(null);

  const didGenRef = useRef(false);

  // ---- Derived flags ----
  const hasSections = session.sections && session.sections.length > 0;

  const hasFailedItems = hasSections
    ? session.sections.some((section: InspectionSection) =>
        section.items.some(
          (item: InspectionItem) =>
            item.status === "fail" || item.status === "recommend",
        ),
      )
    : false;

  // ---- AI quote generation on first load with data ----
  useEffect(() => {
    if (didGenRef.current) return;
    if (!hasSections) return;
    didGenRef.current = true;

    (async () => {
      try {
        const allItems: InspectionItem[] = session.sections.flatMap(
          (s: InspectionSection) => s.items,
        );

        const { summary, quote } = await generateQuoteFromInspection(allItems);

        setSummaryText(summary);
        setQuoteLines(quote);

        // Push quote lines into inspection session so they’re editable later
        updateQuoteLines(
          quote.map(
            (line): QuoteLineItem => ({
              id: uuidv4(),
              name: line.description,
              description: line.description,
              notes: "",
              status: "fail",
              laborHours: line.hours ?? 0,
              price: line.total ?? 0,
              part: { name: "", price: 0 },
              photoUrls: [],
            }),
          ),
        );

        // Persist AI output into inspections row if we have an ID
        if (inspectionId) {
          await supabase
            .from("inspections")
            .update({ quote, summary })
            .eq("id", inspectionId);
        }
      } catch (err: any) {
        console.error("Quote generation failed:", err);
        setAiError(
          isCustomerView
            ? "We were unable to generate smart suggestions for this inspection. The results below still reflect the technician’s findings."
            : err?.message
            ? `AI quote generation error: ${err.message}`
            : "AI quote generation is unavailable (likely missing API key). You can still review and submit the inspection.",
        );
      }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [hasSections, inspectionId, isCustomerView]);

  // ---- Field updates (tech/owner only) ----
  const handleFieldChange = (
    sectionIndex: number,
    itemIndex: number,
    field: keyof InspectionItem,
    value: string,
  ) => {
    if (isCustomerView) return; // no edits in customer mode

    if (field === "status") {
      updateItem(sectionIndex, itemIndex, {
        status: value as InspectionItem["status"],
      });
    } else if (field === "notes") {
      updateItem(sectionIndex, itemIndex, { notes: value });
    } else if (field === "value") {
      updateItem(sectionIndex, itemIndex, { value });
    } else if (field === "unit") {
      updateItem(sectionIndex, itemIndex, { unit: value });
    }
  };

  // ---- Work order helpers (internal only) ----
  const createWorkOrderIfNoneExists = async (): Promise<string | null> => {
    if (isCustomerView) return null; // customers never create WOs
    if (workOrderId) return workOrderId;

    const newId = uuidv4();

    const { error } = await supabase
      .from("work_orders")
      .insert([
        {
          id: newId,
          vehicle_id: session.vehicleId ?? null,
          inspection_id: inspectionId ?? null,
          status: "queued",
        } as Database["public"]["Tables"]["work_orders"]["Insert"],
      ]);

    if (error) {
      console.error("Error creating work order:", error);
      toast.error("Failed to create work order.");
      return null;
    }

    setWorkOrderId(newId);
    return newId;
  };

  const handleAddToWorkOrder = async () => {
    if (isCustomerView) return;
    setIsAddingToWorkOrder(true);
    try {
      const id = await createWorkOrderIfNoneExists();
      if (!id || !inspectionId) {
        toast.error("Missing work order or inspection ID.");
        return;
      }

      const response = await fetch("/api/work-orders/from-inspection", {
        method: "POST",
        body: JSON.stringify({
          inspectionId,
          workOrderId: id,
          vehicleId: session.vehicleId,
        }),
      });

      if (!response.ok) throw new Error("Failed to add jobs to work order.");

      window.dispatchEvent(new CustomEvent("wo:line-added"));
      toast.success("Jobs added to work order.");
    } catch (e) {
      console.error(e);
      toast.error(
        e instanceof Error ? e.message : "Failed to add jobs to work order.",
      );
    } finally {
      setIsAddingToWorkOrder(false);
    }
  };

  // ---- Submit / PDF ----
  const handleSubmit = async () => {
    try {
      setDownloading(true);
      const pdfBytes: Uint8Array = await generateInspectionPDF(session);
      const blob = new Blob([pdfBytes as BlobPart], {
        type: "application/pdf",
      });

      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "inspection_summary.pdf";
      link.click();
      URL.revokeObjectURL(url);

      if (!isCustomerView) {
        // internal flow → clear local storage + return to menu
        localStorage.removeItem("inspectionCustomer");
        localStorage.removeItem("inspectionVehicle");
        router.push("/inspection/menu");
      }
    } catch (error) {
      console.error("Submission error:", error);
      toast.error("Failed to generate inspection PDF.");
    } finally {
      setDownloading(false);
    }
  };

  const customer = (session as any).customer;
  const vehicle = (session as any).vehicle;

  return (
    <div
      className={`min-h-screen px-4 pb-24 pt-4 ${
        isCustomerView
          ? "bg-slate-950 text-slate-50"
          : "bg-background text-foreground"
      }`}
    >
      {/* Top nav (hidden for customer view) */}
      {!isCustomerView && (
        <div className="mb-4 flex justify-between gap-2">
          <PreviousPageButton to="/inspection/menu" />
          <HomeButton />
        </div>
      )}

      {/* AI banner */}
      {aiError && (
        <div className="mb-4 rounded-lg border border-amber-500/60 bg-amber-500/10 px-3 py-2 text-sm text-amber-100">
          {aiError}
        </div>
      )}

      {/* Summary header card */}
      <div className="mb-4 rounded-xl border border-border bg-card/80 px-4 py-3">
        <div className="flex flex-wrap items-center justify-between gap-3">
          <div>
            <h1 className="text-lg font-semibold text-orange-400">
              {isCustomerView
                ? "Inspection Report"
                : "Inspection Summary"}
            </h1>
            <p className="text-xs text-muted-foreground">
              {isCustomerView
                ? "Here’s a summary of the inspection our technician performed on your vehicle."
                : "Review results, photos, and AI-generated quote before sending to the customer."}
            </p>
          </div>
          {hasFailedItems && (
            <div className="rounded-full border border-red-500/40 bg-red-500/10 px-3 py-1 text-xs text-red-200">
              {isCustomerView
                ? "Some items need attention"
                : "Issues found — work order recommended"}
            </div>
          )}
        </div>
      </div>

      {/* Customer & Vehicle info */}
      <div className="mb-6 grid gap-4 rounded-xl border border-border bg-card p-4 md:grid-cols-2">
        <div>
          <h2 className="mb-2 text-sm font-semibold text-neutral-50">
            Customer
          </h2>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Name:{" "}
            </span>
            {customer
              ? `${customer.first_name ?? ""} ${customer.last_name ?? ""}`
              : "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Phone:{" "}
            </span>
            {customer?.phone || "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Email:{" "}
            </span>
            {customer?.email || "—"}
          </p>
        </div>

        <div>
          <h2 className="mb-2 text-sm font-semibold text-neutral-50">
            Vehicle
          </h2>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Year / Make / Model:{" "}
            </span>
            {vehicle
              ? `${vehicle.year ?? ""} ${vehicle.make ?? ""} ${
                  vehicle.model ?? ""
                }`
              : "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              VIN:{" "}
            </span>
            {vehicle?.vin || "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Plate:{" "}
            </span>
            {vehicle?.license_plate || "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Mileage:{" "}
            </span>
            {vehicle?.mileage || "—"}
          </p>
          <p className="text-sm">
            <span className="text-xs uppercase text-muted-foreground">
              Color:{" "}
            </span>
            {vehicle?.color || "—"}
          </p>
        </div>
      </div>

      {/* Sections & items */}
      {hasSections ? (
        session.sections.map(
          (section: InspectionSection, sectionIndex: number) => (
            <div
              key={sectionIndex}
              className="mb-6 overflow-hidden rounded-xl border border-border bg-card"
            >
              <div className="bg-muted px-4 py-2 text-sm font-semibold text-neutral-100">
                {section.title}
              </div>
              <div className="space-y-6 p-4">
                {section.items.map(
                  (item: InspectionItem, itemIndex: number) => {
                    const status = item.status ?? "";
                    const statusClass =
                      status === "ok"
                        ? "bg-emerald-500/10 text-emerald-300 border border-emerald-500/40"
                        : status === "fail"
                        ? "bg-red-500/10 text-red-300 border border-red-500/40"
                        : status === "recommend"
                        ? "bg-amber-500/10 text-amber-200 border border-amber-500/40"
                        : "bg-slate-500/10 text-slate-200 border border-slate-500/40";

                    return (
                      <div
                        key={itemIndex}
                        className="space-y-3 border-b border-border/40 pb-4 last:border-b-0 last:pb-0"
                      >
                        <div className="flex items-center justify-between gap-2">
                          <div className="font-semibold">
                            {item.item ?? (item as any).name}
                          </div>
                          {status && (
                            <span
                              className={`rounded-full px-2 py-0.5 text-[11px] uppercase tracking-wide ${statusClass}`}
                            >
                              {status.toUpperCase()}
                            </span>
                          )}
                        </div>

                        {isCustomerView ? (
                          // CUSTOMER READ-ONLY LAYOUT
                          <div className="space-y-1 text-xs md:text-sm text-muted-foreground">
                            {item.notes && (
                              <p>
                                <span className="font-semibold text-foreground">
                                  Notes:{" "}
                                </span>
                                {item.notes}
                              </p>
                            )}
                            {(item.value || item.unit) && (
                              <p>
                                <span className="font-semibold text-foreground">
                                  Measurement:{" "}
                                </span>
                                {item.value ?? "—"}{" "}
                                {item.unit ? item.unit : ""}
                              </p>
                            )}
                          </div>
                        ) : (
                          // INTERNAL EDITABLE LAYOUT
                          <div className="grid grid-cols-1 gap-4 md:grid-cols-4">
                            <label className="flex flex-col gap-1 text-xs md:text-sm">
                              Status
                              <select
                                className="rounded border border-border bg-background px-2 py-1 text-sm"
                                value={item?.status ?? ""}
                                onChange={(e) =>
                                  handleFieldChange(
                                    sectionIndex,
                                    itemIndex,
                                    "status",
                                    e.target.value,
                                  )
                                }
                              >
                                <option value="">Select</option>
                                <option value="ok">OK</option>
                                <option value="fail">Fail</option>
                                <option value="na">N/A</option>
                                <option value="recommend">
                                  Recommend
                                </option>
                              </select>
                            </label>

                            <label className="flex flex-col gap-1 text-xs md:text-sm">
                              Note
                              <input
                                className="rounded border border-border bg-background px-2 py-1 text-sm"
                                value={item?.notes || ""}
                                onChange={(e) =>
                                  handleFieldChange(
                                    sectionIndex,
                                    itemIndex,
                                    "notes",
                                    e.target.value,
                                  )
                                }
                              />
                            </label>

                            <label className="flex flex-col gap-1 text-xs md:text-sm">
                              Value
                              <input
                                className="rounded border border-border bg-background px-2 py-1 text-sm"
                                value={(item?.value as string) || ""}
                                onChange={(e) =>
                                  handleFieldChange(
                                    sectionIndex,
                                    itemIndex,
                                    "value",
                                    e.target.value,
                                  )
                                }
                              />
                            </label>

                            <label className="flex flex-col gap-1 text-xs md:text-sm">
                              Unit
                              <input
                                className="rounded border border-border bg-background px-2 py-1 text-sm"
                                value={item?.unit || ""}
                                onChange={(e) =>
                                  handleFieldChange(
                                    sectionIndex,
                                    itemIndex,
                                    "unit",
                                    e.target.value,
                                  )
                                }
                              />
                            </label>
                          </div>
                        )}

                        {Array.isArray(item?.photoUrls) &&
                          item.photoUrls.length > 0 && (
                            <div className="mt-2 flex flex-wrap gap-2">
                              {item.photoUrls.map(
                                (url: string, i: number) => (
                                  <img
                                    key={i}
                                    src={url}
                                    alt="Uploaded"
                                    className="max-h-32 rounded border border-border/60 object-cover"
                                  />
                                ),
                              )}
                            </div>
                          )}
                      </div>
                    );
                  },
                )}
              </div>
            </div>
          ),
        )
      ) : (
        <div className="mb-6 rounded-xl border border-dashed border-border bg-card/60 p-4 text-sm text-muted-foreground">
          No inspection sections found in this session. Go back and start an
          inspection again.
        </div>
      )}

      {/* Quote viewer */}
      {quoteLines.length > 0 && (
        <div className="my-6 rounded-xl border border-border bg-card p-4">
          <QuoteViewer summary={summaryText} quote={quoteLines} />
        </div>
      )}

      {/* Sticky footer actions */}
      <div className="fixed inset-x-0 bottom-0 border-t border-border bg-background/95 px-4 py-3 backdrop-blur">
        <div className="mx-auto flex max-w-3xl flex-col gap-2 sm:flex-row">
          {!isCustomerView && hasFailedItems && (
            <Button
              variant="default"
              className="w-full bg-orange-600 hover:bg-orange-500"
              onClick={handleAddToWorkOrder}
              disabled={!hasFailedItems || isAddingToWorkOrder}
            >
              {isAddingToWorkOrder
                ? "Adding to work order…"
                : "Add failed items to work order"}
            </Button>
          )}

          <Button
            variant={isCustomerView ? "default" : "outline"}
            className={`w-full ${
              isCustomerView
                ? "bg-green-600 text-white hover:bg-green-500"
                : "border-emerald-500/60 text-emerald-300 hover:bg-emerald-500/10"
            }`}
            onClick={handleSubmit}
            disabled={downloading}
          >
            {downloading
              ? "Preparing PDF…"
              : isCustomerView
              ? "Download inspection PDF"
              : "Submit inspection & download PDF"}
          </Button>
        </div>
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/inspections/app/inspection/maintenance50/page.tsx */
/* =============================== */

// features/inspections/app/inspection/maintenance50/page.tsx
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/lib/inspection/ui/CornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";

import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import toast from "react-hot-toast";

/* Header adapters */
type HeaderCustomer = {
  first_name: string;
  last_name: string;
  phone: string;
  email: string;
  address: string;
  city: string;
  province: string;
  postal_code: string;
};

type HeaderVehicle = {
  year: string;
  make: string;
  model: string;
  vin: string;
  license_plate: string;
  mileage: string;
  color: string;
  unit_number: string;
  engine_hours: string;
};

function toHeaderCustomer(c?: SessionCustomer | null): HeaderCustomer {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}

function toHeaderVehicle(v?: SessionVehicle | null): HeaderVehicle {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/* Sections */
function buildHydraulicMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Hydraulic)",
    items: [
      { item: "LF Tire Pressure", unit: "psi", value: "" },
      { item: "RF Tire Pressure", unit: "psi", value: "" },
      { item: "LR Tire Pressure", unit: "psi", value: "" },
      { item: "RR Tire Pressure", unit: "psi", value: "" },
      { item: "LF Tire Tread", unit: "mm", value: "" },
      { item: "RF Tire Tread", unit: "mm", value: "" },
      { item: "LR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "LR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "LF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "LR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "Wheel Torque (after road test)", unit: "ft·lb", value: "" },
    ],
  };
}
function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}
function buildBrakesSection(): InspectionSection {
  return {
    title: "Brakes",
    items: [
      { item: "Front brake pads" },
      { item: "Rear brake pads" },
      { item: "Brake fluid level" },
      { item: "Brake lines and hoses" },
      { item: "ABS wiring / sensors" },
      { item: "Brake warning lights" },
    ],
  };
}
function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
    ],
  };
}
function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "CV shafts / joints" },
      { item: "Transmission leaks / mounts" },
      { item: "Transfer case leaks / mounts" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* Units helpers */
function unitForHydraulic(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tire tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad thickness")) return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}
function applyUnitsHydraulic(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    if ((s.title || "").toLowerCase().includes("measurements")) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForHydraulic(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }
    return s;
  });
}

/* Page */
export default function Maintenance50HydraulicPage(): JSX.Element {
  const searchParams = useSearchParams();

  // embed mode in iframe
  const isEmbed = useMemo(
    () =>
      ["1", "true", "yes"].includes(
        (searchParams.get("embed") || searchParams.get("compact") || "").toLowerCase()
      ),
    [searchParams]
  );

  const workOrderLineId = searchParams.get("workOrderLineId") || null;
  const workOrderId = searchParams.get("workOrderId") || null;
  const inspectionId = useMemo<string>(
    () => searchParams.get("inspectionId") || uuidv4(),
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string =
    searchParams.get("template") || "Maintenance 50 (Hydraulic)";

  const customer: SessionCustomer = {
    first_name: searchParams.get("first_name") || "",
    last_name: searchParams.get("last_name") || "",
    phone: searchParams.get("phone") || "",
    email: searchParams.get("email") || "",
    address: searchParams.get("address") || "",
    city: searchParams.get("city") || "",
    province: searchParams.get("province") || "",
    postal_code: searchParams.get("postal_code") || "",
  };

  const vehicle: SessionVehicle = {
    year: searchParams.get("year") || "",
    make: searchParams.get("make") || "",
    model: searchParams.get("model") || "",
    vin: searchParams.get("vin") || "",
    license_plate: searchParams.get("license_plate") || "",
    mileage: searchParams.get("mileage") || "",
    color: searchParams.get("color") || "",
    unit_number: searchParams.get("unit_number") || "",
    engine_hours: searchParams.get("engine_hours") || "",
  };

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  // prevent duplicate AI submits
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      // 1) placeholder for local quote UI
      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      // 2) AI suggestion with vehicle context
      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      // 3) Persist to WO (awaiting approval)
      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // Boot / restore
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Persist session
  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  // Persist on unload/visibility
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // Build sections on first load
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;
    const next: InspectionSection[] = [
      buildHydraulicMeasurementsSection(),
      buildLightsSection(),
      buildBrakesSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsHydraulic(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  // Apply units when toggled
  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsHydraulic(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  // Header backfill via API when launched from FocusedJobModal
  useEffect(() => {
    (async () => {
      if (!session || !workOrderId) return;
      const haveName =
        (session.customer?.first_name || session.customer?.last_name || "").trim().length > 0;
      const haveVehicle =
        (session.vehicle?.make || session.vehicle?.model || "").trim().length > 0;
      if (haveName && haveVehicle) return;

      try {
        const res = await fetch(`/api/work-orders/header?id=${workOrderId}`);
        if (!res.ok) return;

        const j = (await res.json()) as {
          customer?: Partial<SessionCustomer>;
          vehicle?: Partial<SessionVehicle>;
        };

        const nextCust: Partial<SessionCustomer> = {
          ...(session.customer ?? {}),
          ...(j.customer ?? {}),
        };
        const nextVeh: Partial<SessionVehicle> = {
          ...(session.vehicle ?? {}),
          ...(j.vehicle ?? {}),
        };

        updateInspection({
          customer: nextCust,
          vehicle: nextVeh,
        } as Partial<InspectionSession>);
      } catch {
        // silent fail
      }
    })();
  }, [session, workOrderId, updateInspection]);

  // Transcript handler
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;

    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // Start listening
  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };

  // stop on unmount
  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-white">Loading inspection…</div>;
  }

  const isMeasurements = (t?: string): boolean =>
    (t || "").toLowerCase().includes("measurements");

  // ------- Bare embed: NO app chrome when isEmbed -------
  const shell = isEmbed ? "mx-auto max-w-[1100px] px-3 pb-8" : "px-4 pb-14";
  const controlsGap = "mb-4 grid grid-cols-3 gap-2";
  const card =
    "rounded-lg border border-zinc-800 bg-zinc-900 " +
    (isEmbed ? "p-3 mb-6" : "p-4 mb-8");
  const sectionTitle = "text-xl font-semibold text-orange-400 text-center";
  const hint = "text-xs text-zinc-400" + (isEmbed ? " mt-1 block text-center" : "");

  // ----- BODY -----
  const Body = (
    <div className={shell}>
      {/* Hide global chrome if embedded */}
      {isEmbed && (
        <>
          {/* Add marker classes + robust, persistent chrome hider */}
          <script
            dangerouslySetInnerHTML={{
              __html: `
                (function(){
                  var html = document.documentElement;
                  var body = document.body || document.getElementsByTagName('body')[0];
                  html && html.classList.add('inspection-embed');
                  body && body.classList.add('inspection-embed');

                  var CSS = \`
                    html.inspection-embed, body.inspection-embed { background:#000 !important; overflow:auto !important; }

                    /* Hide common app chrome */
                    .inspection-embed header,
                    .inspection-embed nav,
                    .inspection-embed aside,
                    .inspection-embed footer,
                    .inspection-embed [data-app-chrome],
                    .inspection-embed [data-app-header],
                    .inspection-embed [data-app-nav],
                    .inspection-embed [data-app-sidebar],
                    .inspection-embed [data-app-footer],
                    .inspection-embed .app-shell,
                    .inspection-embed .app-shell-nav,
                    .inspection-embed .app-shell-header,
                    .inspection-embed .app-shell-footer,
                    .inspection-embed .app-sidebar,
                    .inspection-embed .app-topbar,
                    .inspection-embed .nav-tabs,
                    .inspection-embed .tabs-bar,
                    .inspection-embed .dashboard-tabs,
                    .inspection-embed .global-nav,
                    .inspection-embed .global-header,
                    .inspection-embed .global-footer {
                      display: none !important;
                      visibility: hidden !important;
                    }

                    /* Let the page content expand edge-to-edge */
                    .inspection-embed main,
                    .inspection-embed [data-app-content],
                    .inspection-embed .app-content,
                    .inspection-embed #__next > *:not(main) {
                      margin: 0 !important;
                      padding: 0 !important;
                      width: 100% !important;
                      max-width: none !important;
                    }

                    /* Guard against fixed headers/footers */
                    .inspection-embed *[style*="position: fixed"],
                    .inspection-embed *[style*="position:sticky"] {
                      display: none !important;
                    }
                  \`;

                  var s = document.createElement('style');
                  s.setAttribute('data-inspection-embed-style','1');
                  s.type = 'text/css';
                  s.appendChild(document.createTextNode(CSS));
                  document.head.appendChild(s);

                  /* MutationObserver to re-hide chrome if layouts mount late */
                  var targets = [
                    document.body,
                    document.querySelector('#__next'),
                    document.documentElement
                  ].filter(Boolean);

                  var again = function() {
                    if (!document.querySelector('style[data-inspection-embed-style]')) {
                      var s2 = document.createElement('style');
                      s2.setAttribute('data-inspection-embed-style','1');
                      s2.type = 'text/css';
                      s2.appendChild(document.createTextNode(CSS));
                      document.head.appendChild(s2);
                    }
                  };

                  var mo = new MutationObserver(function() { again(); });
                  targets.forEach(function(t){
                    try { mo.observe(t, { childList: true, subtree: true, attributes: true }); } catch(e){}
                  });
                })();
              `,
            }}
          />
        </>
      )}

      <div className={card}>
        <div className="text-center text-lg font-semibold text-orange-400">
          {templateName}
        </div>
        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      <div className={controlsGap}>
        <StartListeningButton
          isListening={isListening}
          setIsListening={setIsListening}
          onStart={startListening}
        />
        <PauseResumeButton
          isPaused={isPaused}
          isListening={isListening}
          setIsListening={setIsListening}
          onPause={(): void => {
            setIsPaused(true);
            pauseSession();
            try {
              recognitionRef.current?.stop();
            } catch {}
          }}
          onResume={(): void => {
            setIsPaused(false);
            resumeSession();
            recognitionRef.current = startVoiceRecognition(handleTranscript);
          }}
          recognitionInstance={recognitionRef.current as unknown as SpeechRecognition | null}
          onTranscript={handleTranscript}
          setRecognitionRef={(instance: SpeechRecognition | null): void => {
            (recognitionRef as React.MutableRefObject<SpeechRecognition | null>).current =
              instance ?? null;
          }}
        />
        <button
          onClick={(): void => setUnit(unit === "metric" ? "imperial" : "metric")}
          className="w-full rounded bg-zinc-700 py-2 text-white hover:bg-zinc-600"
        >
          Unit: {unit === "metric" ? "Metric" : "Imperial"}
        </button>
      </div>

      <ProgressTracker
        currentItem={session.currentItemIndex}
        currentSection={session.currentSectionIndex}
        totalSections={session.sections.length}
        totalItems={session.sections[session.currentSectionIndex]?.items.length || 0}
      />

      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={card}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isMeasurements(section.title) && (
              <span className={hint}>
                {unit === "metric" ? "Enter mm / kPa / N·m" : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className={isEmbed ? "mt-3" : "mt-4"}>
              {isMeasurements(section.title) ? (
                <CornerGrid sectionIndex={sectionIndex} items={section.items} />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes={true}
                  showPhotos={true}
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    // Only update status here — AI flow moved to explicit Submit
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(secIdx: number, itemIdx: number, note: string): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(photoUrl: string, secIdx: number, itemIdx: number): void => {
                    const prev = session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, { photoUrls: [...prev, photoUrl] });
                  }}
                  /* require note + explicit submit to run AI */
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) => {
                    void submitAIForItem(secIdx, itemIdx);
                  }}
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      <div
        className={
          "flex items-center justify-between gap-4 " + (isEmbed ? "mt-6" : "mt-8")
        }
      >
        {/* Pass workOrderLineId down; disable when missing */}
        <div className="flex items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
        </div>

        {!workOrderLineId && (
          <div className="text-xs text-red-400">
            Missing <code>workOrderLineId</code> in URL — save/finish will be blocked.
          </div>
        )}

        <div className="ml-auto text-xs text-zinc-400">
          P = PASS, F = FAIL, NA = Not Applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;
  return Body;
}

/* =============================== */
/* FILE: features/inspections/app/inspection/maintenance50-air/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import AirCornerGrid from "@inspections/lib/inspection/ui/AirCornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";

import { buildAirAxleItems } from "@inspections/lib/inspection/builders/addAxleHelpers";
import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* ------------------------------ Header adapters ------------------------------ */
type HeaderCustomer = {
  first_name: string;
  last_name: string;
  phone: string;
  email: string;
  address: string;
  city: string;
  province: string;
  postal_code: string;
};

type HeaderVehicle = {
  year: string;
  make: string;
  model: string;
  vin: string;
  license_plate: string;
  mileage: string;
  color: string;
  unit_number: string;
  engine_hours: string;
};

function toHeaderCustomer(c?: SessionCustomer | null): HeaderCustomer {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}

function toHeaderVehicle(v?: SessionVehicle | null): HeaderVehicle {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/* ------------------------------ Section builders (AIR) ------------------------------ */
function buildAirCornerMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Air – Corner Checks)",
    items: [
      { item: "Steer 1 Left Tire Pressure", unit: "psi", value: "" },
      { item: "Steer 1 Right Tire Pressure", unit: "psi", value: "" },

      { item: "Steer 1 Left Tread Depth", unit: "mm", value: "" },
      { item: "Steer 1 Right Tread Depth", unit: "mm", value: "" },

      { item: "Steer 1 Left Lining/Shoe Thickness", unit: "mm", value: "" },
      { item: "Steer 1 Right Lining/Shoe Thickness", unit: "mm", value: "" },

      { item: "Steer 1 Left Drum/Rotor Condition", unit: "", value: "" },
      { item: "Steer 1 Right Drum/Rotor Condition", unit: "", value: "" },

      { item: "Steer 1 Left Push Rod Travel", unit: "in", value: "" },
      { item: "Steer 1 Right Push Rod Travel", unit: "in", value: "" },
    ],
  };
}

function buildAirSystemMeasurementsSection(): InspectionSection {
  return {
    title: "Air System Measurements",
    items: [
      { item: "Air Build Time (90→120)", unit: "sec", value: "" },
      { item: "Gov Cut-In", unit: "psi", value: "" },
      { item: "Gov Cut-Out", unit: "psi", value: "" },
      { item: "Leak Rate @ Cut-Out", unit: "psi/min", value: "" },
      { item: "Low Air Warning Activates", unit: "psi", value: "" },
      { item: "Compressor Cut-Out Ref", unit: "psi", value: "" },
      { item: "Torque Reference", unit: "ft·lb", value: "" },
    ],
  };
}

function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}

function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension / Steering",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
      { item: "Tie-rods / drag link / steering gear leaks" },
    ],
  };
}

function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline / Axles",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* ------------------------------ Units helpers (AIR) ------------------------------ */
function unitForAir(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("tire pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("lining") || l.includes("shoe")) return mode === "metric" ? "mm" : "in";
  if (l.includes("drum") || l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("push rod")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}

function applyUnitsAir(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    const isCorner = (s.title || "").toLowerCase().includes("corner");
    const isAirMeas = (s.title || "").toLowerCase().includes("air system");

    if (isCorner) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForAir(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }

    if (isAirMeas) {
      const items = s.items.map((it) => {
        const label = (it.item ?? "").toLowerCase();
        if (label.includes("build time")) return { ...it, unit: "sec" };
        if (label.includes("leak"))
          return { ...it, unit: mode === "metric" ? "kPa/min" : "psi/min" };
        if (label.includes("gov") || label.includes("warning") || label.includes("compressor"))
          return { ...it, unit: mode === "metric" ? "kPa" : "psi" };
        if (label.includes("torque")) return { ...it, unit: mode === "metric" ? "N·m" : "ft·lb" };
        return it;
      });
      return { ...s, items };
    }

    return s;
  });
}

/* ------------------------------ Page (Screen) ------------------------------ */
export default function Maintenance50AirPage(): JSX.Element {
  const searchParams = useSearchParams();
  const rootRef = useRef<HTMLDivElement | null>(null);

  // 🔸 voice only on mobile companion
  const isMobileView =
    (searchParams.get("view") || "").toLowerCase() === "mobile";

  const isEmbed = useMemo(() => {
    const flag =
      ["1", "true", "yes"].includes(
        (searchParams.get("embed") || searchParams.get("compact") || "").toLowerCase()
      );
    const inIframe =
      typeof window !== "undefined" && window.self !== window.top;
    return flag || inIframe;
  }, [searchParams]);

  const workOrderLineId = searchParams.get("workOrderLineId") || null;
  const workOrderId = searchParams.get("workOrderId") || null;

  const inspectionId = useMemo<string>(
    () => searchParams.get("inspectionId") || uuidv4(),
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string =
    searchParams.get("template") || "Maintenance 50 (Air Brake CVIP)";

  const customer: SessionCustomer = {
    first_name: searchParams.get("first_name") || "",
    last_name: searchParams.get("last_name") || "",
    phone: searchParams.get("phone") || "",
    email: searchParams.get("email") || "",
    address: searchParams.get("address") || "",
    city: searchParams.get("city") || "",
    province: searchParams.get("province") || "",
    postal_code: searchParams.get("postal_code") || "",
  };

  const vehicle: SessionVehicle = {
    year: searchParams.get("year") || "",
    make: searchParams.get("make") || "",
    model: searchParams.get("model") || "",
    vin: searchParams.get("vin") || "",
    license_plate: searchParams.get("license_plate") || "",
    mileage: searchParams.get("mileage") || "",
    color: searchParams.get("color") || "",
    unit_number: searchParams.get("unit_number") || "",
    engine_hours: searchParams.get("engine_hours") || "",
  };

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  /* ---------- AI submit flow ---------- */
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  /* ---------- hydrate / persist ---------- */
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };

    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };

    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);

    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  /* ---------- sections + unit toggle ---------- */
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;

    const next: InspectionSection[] = [
      buildAirCornerMeasurementsSection(),
      buildAirSystemMeasurementsSection(),
      buildLightsSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsAir(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsAir(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  /* ---------- speech → commands ---------- */
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;

    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };

  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  /* 🧹 embed-safe scrubber */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  /* 🔐 focus trap when embedded */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-white">Loading inspection…</div>;
  }

  const isCorner = (t?: string): boolean =>
    (t || "").toLowerCase().includes("corner");

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const Body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Maintenance 50 – Air Brake CVIP"}
          </div>
        </div>
        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      {/* Controls */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              try {
                recognitionRef.current?.stop();
              } catch {}
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              recognitionRef.current = startVoiceRecognition(handleTranscript);
            }}
            recognitionInstance={
              recognitionRef.current as unknown as SpeechRecognition | null
            }
            onTranscript={handleTranscript}
            setRecognitionRef={(instance: SpeechRecognition | null): void => {
              (
                recognitionRef as React.MutableRefObject<SpeechRecognition | null>
              ).current = instance ?? null;
            }}
          />
        )}

        {/* Unit toggle always available */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      {/* Sections */}
      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isCorner(section.title) && (
              <span className={hint}>
                {unit === "metric"
                  ? "Enter mm / kPa / N·m"
                  : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className="mt-4">
              {isCorner(section.title) ? (
                <AirCornerGrid
                  sectionIndex={sectionIndex}
                  items={section.items}
                  unitHint={(label: string) => unitForAir(label, unit)}
                  onAddAxle={(axleLabel: string) => {
                    const extra = buildAirAxleItems(axleLabel);
                    updateSection(sectionIndex, {
                      items: [...section.items, ...extra],
                    });
                  }}
                />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes
                  showPhotos
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(
                    secIdx: number,
                    itemIdx: number,
                    note: string
                  ): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(
                    photoUrl: string,
                    secIdx: number,
                    itemIdx: number
                  ): void => {
                    const prev =
                      session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, {
                      photoUrls: [...prev, photoUrl],
                    });
                  }}
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) => {
                    void submitAIForItem(secIdx, itemIdx);
                  }}
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      {/* Footer */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Maintenance 50 – Air Brake CVIP"}
      description="Air-brake CVIP multi-axle inspection."
    >
      {Body}
    </PageShell>
  );
}

/* =============================== */
/* FILE: features/inspections/components/inspection/FinishInspectionButton.tsx */
/* =============================== */

// features/inspections/components/inspection/FinishInspectionButton.tsx
"use client";

import { useState } from "react";
import { toast } from "sonner";
import { Button } from "@shared/components/ui/Button";

type Props = {
  session: any;
  workOrderLineId?: string | null;
};

export default function FinishInspectionButton({
  session,
  workOrderLineId,
}: Props) {
  const [busy, setBusy] = useState(false);

  function buildCorrectionFromSession(s: any): {
    cause: string;
    correction: string;
  } {
    const raw = s?.quote;
    const items: any[] = Array.isArray(raw) ? raw : raw ? [raw] : [];

    const failed = items.filter(
      (i) => (i?.status ?? "").toLowerCase() === "fail",
    );
    const recommended = items.filter(
      (i) => (i?.status ?? "").toLowerCase() === "recommend",
    );

    if (failed.length === 0 && recommended.length === 0) {
      return {
        cause: "Inspection completed.",
        correction:
          "Inspection completed. No failed or recommended items were recorded.",
      };
    }

    const parts: string[] = [];

    if (failed.length) {
      parts.push(
        `Failed items: ${failed
          .map((f) => f?.description || f?.notes || "Item")
          .join("; ")}.`,
      );
    }

    if (recommended.length) {
      parts.push(
        `Recommended items: ${recommended
          .map((r) => r?.description || r?.notes || "Item")
          .join("; ")}.`,
      );
    }

    return {
      cause: "Inspection found items requiring attention.",
      correction: parts.join(" "),
    };
  }

  const handleFinish = async () => {
    if (!workOrderLineId) {
      toast.error("Missing work order line id — can’t finish.");
      return;
    }
    if (busy) return;
    setBusy(true);

    const { cause, correction } = buildCorrectionFromSession(session);

    try {
      const res = await fetch(
        `/api/work-orders/lines/${workOrderLineId}/finish`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ cause, correction }),
        },
      );

      const json = await res.json().catch(() => null);
      if (!res.ok) {
        throw new Error(json?.error || "Failed to finish inspection");
      }

      if (typeof window !== "undefined") {
        window.dispatchEvent(
          new CustomEvent("inspection:completed", {
            detail: {
              workOrderLineId,
              cause,
              correction,
            },
          }),
        );
      }

      toast.success("Inspection finished.");
    } catch (e: any) {
      toast.error(e?.message ?? "Unable to finish inspection");
    } finally {
      setBusy(false);
    }
  };

  return (
    <Button
      onClick={handleFinish}
      disabled={busy}
      variant="orange"
      size="md"
      type="button"
      className="font-semibold"
    >
      {busy ? "Finishing…" : "Finish inspection"}
    </Button>
  );
}

/* =============================== */
/* FILE: features/inspections/components/inspection/quote.ts */
/* =============================== */

// lib/inspection/quote.ts

export type InspectionItemStatus = "ok" | "fail" | "na" | "recommend";

export interface QuoteLine {
  id: string;
  inspectionItemId?: string;
  sectionId?: string;
  status?: InspectionItemStatus;
  description?: string;
  note?: string;
  notes?: string;
  laborTime?: number; // in hours
  laborRate?: number; // shop-configured or default
  parts?: {
    name: string;
    price: number;
  }[];
  type?: "economy" | "premium" | "oem" | "custom";
  price?: number;
  totalCost?: number;
  editable?: boolean;
}


/* =============================== */
/* FILE: features/inspections/hooks/useInspectionSession.ts */
/* =============================== */

"use client";

import { useState } from "react";
import {
  InspectionItem,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,      // ⬅️ use only QuoteLineItem here
  BrakeType,
} from "@inspections/lib/inspection/types";

type AxleLayoutConfig = { axleCount: number; brakeType: BrakeType };

function generateAxleSections({ axleCount, brakeType }: AxleLayoutConfig): InspectionSection[] {
  const sections: InspectionSection[] = [];

  for (let i = 1; i <= axleCount; i++) {
    const title = `Axle ${i}`;
    const items: InspectionItem[] = [
      { item: "Left Tread Depth",  name: "Left Tread Depth",  value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Right Tread Depth", name: "Right Tread Depth", value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Left Tire Pressure",  name: "Left Tire Pressure",  value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Right Tire Pressure", name: "Right Tire Pressure", value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Left Lining Thickness",  name: "Left Lining Thickness",  value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Right Lining Thickness", name: "Right Lining Thickness", value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Wheel Torque", name: "Wheel Torque", value: null, unit: "ft lbs", notes: "", photoUrls: [] },
    ];

    if (brakeType === "air") {
      items.push(
        { item: "Left Push Rod Travel",  name: "Left Push Rod Travel",  value: null, unit: "in", notes: "", photoUrls: [] },
        { item: "Right Push Rod Travel", name: "Right Push Rod Travel", value: null, unit: "in", notes: "", photoUrls: [] },
      );
    }

    sections.push({ title, items });
  }

  return sections;
}

export default function useInspectionSession(initialSession?: Partial<InspectionSession>) {
  const [session, setSession] = useState<InspectionSession>(() => ({
    id: "",
    vehicleId: "",
    customerId: "",
    workOrderId: "",
    templateId: "",
    templateName: "",
    location: "",
    currentSectionIndex: 0,
    currentItemIndex: 0,
    transcript: "",
    status: "not_started",
    started: false,
    completed: false,
    isListening: false,
    isPaused: false,
    quote: [],                                 // ⬅️ QuoteLineItem[]
    lastUpdated: new Date().toISOString(),
    customer: {
      first_name: "",
      last_name: "",
      phone: "",
      email: "",
      address: "",
      city: "",
      province: "",
      postal_code: "",
    },
    vehicle: {
      year: "",
      make: "",
      model: "",
      vin: "",
      license_plate: "",
      mileage: "",
      color: "",
    },
    sections: [],
    ...initialSession,
  }));

  const stamp = () => ({ lastUpdated: new Date().toISOString() });

  const updateInspection = (updates: Partial<InspectionSession>) =>
    setSession(prev => ({ ...prev, ...updates, ...stamp() }));

  const updateSection = (sectionIndex: number, updates: Partial<InspectionSection>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      sections[sectionIndex] = { ...sections[sectionIndex], ...updates };
      return { ...prev, sections, ...stamp() };
    });

  const updateItem = (sectionIndex: number, itemIndex: number, updates: Partial<InspectionItem>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      const items = [...sections[sectionIndex].items];
      items[itemIndex] = { ...items[itemIndex], ...updates };
      sections[sectionIndex] = { ...sections[sectionIndex], items };
      return { ...prev, sections, ...stamp() };
    });

  // ✅ strictly QuoteLineItem (the normalized/store+PDF shape)
  const addQuoteLine = (line: QuoteLineItem) =>
    setSession(prev => ({ ...prev, quote: [...(prev.quote ?? []), line], ...stamp() }));

  const updateQuoteLines = (lines: QuoteLineItem[]) =>
    setSession(prev => ({ ...prev, quote: lines, ...stamp() }));

  // ✅ targeted updater for enriching a single line (AI merge, edits, etc.)
  const updateQuoteLine = (id: string, patch: Partial<QuoteLineItem>) =>
    setSession(prev => ({
      ...prev,
      quote: (prev.quote ?? []).map((l) => (l.id === id ? { ...l, ...patch } : l)),
      ...stamp(),
    }));

  const startSession = (sessionData: Partial<InspectionSession> & { axleConfig?: AxleLayoutConfig }) => {
    const { axleConfig, ...rest } = sessionData;
    const newSections =
      axleConfig?.axleCount && axleConfig?.brakeType
        ? generateAxleSections(axleConfig)
        : sessionData.sections || session.sections;

    setSession(prev => ({
      ...prev,
      ...rest,
      sections: newSections,
      currentSectionIndex: 0,
      currentItemIndex: 0,
      transcript: "",
      started: true,
      completed: false,
      status: "in_progress",
      isPaused: false,
      ...stamp(),
    }));
  };

  const pauseSession  = () => updateInspection({ isPaused: true,  status: "paused" });
  const resumeSession = () => updateInspection({ isPaused: false, status: "in_progress" });
  const finishSession = () => updateInspection({ completed: true, status: "completed", isPaused: false });
  const setIsListening = (value: boolean) => updateInspection({ isListening: value });

  return {
    session,
    updateInspection,
    updateSection,
    updateItem,
    addQuoteLine,
    updateQuoteLines,
    updateQuoteLine,   // ⬅️ expose the targeted updater
    startSession,
    pauseSession,
    resumeSession,
    finishSession,
    setIsListening,
    isPaused: session.isPaused,
  };
}

/* =============================== */
/* FILE: features/shared/config/tiles.ts */
/* =============================== */

// features/shared/config/tiles.ts
export type Role =
  | "owner"
  | "admin"
  | "manager"
  | "advisor"
  | "mechanic"
  | "parts";

export type Scope =
  | "work_orders"
  | "inspections"
  | "parts"
  | "tech"
  | "management"
  | "settings"
  | "appointments"
  | "all";

export type Tile = {
  href: string;
  title: string;
  subtitle?: string;
  cta?: string;
  roles: Role[];
  scopes: Scope[];
  section?: string; // for sidebar grouping, e.g. "Operations"
};

export const TILES: Tile[] = [
  // --- Work Orders ---
  {
    href: "/work-orders/create?autostart=1",
    title: "Create Work Order",
    subtitle: "Start a new job",
    cta: "+",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/work-orders/view",
    title: "View Work Orders",
    subtitle: "Browse & manage",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/work-orders/queue",
    title: "Job Queue",
    subtitle: "Active & in-progress",
    roles: ["mechanic", "manager", "owner", "admin"],
    scopes: ["work_orders", "tech", "all"],
    section: "Operations",
  },
  {
    href: "/work-orders/quote-review",
    title: "Quote Review",
    subtitle: "Review & send estimates",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/menu",
    title: "Service Menu",
    subtitle: "Saved services & presets",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/work-orders/history",
    title: "History",
    subtitle: "Completed work",
    roles: ["owner", "admin", "manager", "advisor", "mechanic"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },
  {
    href: "/billing",
    title: "Billing",
    subtitle: "Ready to invoice",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
    section: "Operations",
  },

  // --- Appointments (new admin page you wanted) ---
  {
    href: "/dashboard/admin/appointments",
    title: "Appointments",
    subtitle: "Schedule & manage",
    roles: ["owner", "admin", "manager", "advisor"],
    scopes: ["appointments", "management", "all"],
    section: "Operations",
  },

  // --- Inspections ---
  {
    href: "/inspections/maintenance50",
    title: "Maintenance 50",
    subtitle: "Quick checklist",
    roles: ["advisor", "manager", "owner", "admin", "mechanic"],
    scopes: ["inspections", "all"],
    section: "Inspections",
  },
  {
    href: "/inspections/maintenance50-air",
    title: "Maintenance 50 – Air",
    subtitle: "CVIP-style",
    roles: ["advisor", "manager", "owner", "admin", "mechanic"],
    scopes: ["inspections", "all"],
    section: "Inspections",
  },
  {
    href: "/inspections/custom-inspection",
    title: "Custom Builder",
    subtitle: "Design your own",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
    section: "Inspections",
  },
  {
    href: "/inspections/saved",
    title: "Saved Inspections",
    subtitle: "Recent & drafts",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
    section: "Inspections",
  },

  // --- Parts ---
  {
    href: "/parts",
    title: "Parts Dashboard",
    subtitle: "Orders & receiving",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
    section: "Parts",
  },
  {
    href: "/parts/requests",
    title: "Requests",
    subtitle: "View requests",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
    section: "Parts",
  },
  {
    href: "/parts/inventory",
    title: "Inventory",
    subtitle: "On-hand stock",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
    section: "Parts",
  },
  {
    href: "/parts/po",
    title: "Purchase Orders",
    subtitle: "Create & manage POs",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
    section: "Parts",
  },
  {
    href: "/parts/vendors",
    title: "Vendor Integrations",
    subtitle: "API keys for suppliers",
    roles: ["owner", "admin", "manager", "parts"],
    scopes: ["parts", "settings", "all"],
    section: "Parts",
  },

  // --- Admin / Management ---
  {
    href: "/dashboard/owner/create-user",
    title: "Create User",
    subtitle: "Add team members",
    roles: ["owner", "admin"],
    scopes: ["management", "all"],
    section: "Admin",
  },
  {
    href: "/dashboard/admin/scheduling",
    title: "Scheduling",
    subtitle: "Calendar & bookings",
    roles: ["owner", "admin", "manager", "advisor"],
    scopes: ["management", "all"],
    section: "Admin",
  },
  {
    href: "/dashboard/admin/shops",
    title: "Shops",
    subtitle: "Locations & hours",
    roles: ["owner", "admin"],
    scopes: ["management", "all"],
    section: "Admin",
  },
  {
    href: "/dashboard/admin/billing",
    title: "Billing",
    subtitle: "Subscriptions",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
    section: "Admin",
  },
  {
    href: "/dashboard/admin/audit",
    title: "Audit Logs",
    subtitle: "Security",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
    section: "Admin",
  },
  {
    href: "/ai/assistant",
    title: "AI Assistant",
    subtitle: "Help & automation",
    roles: ["owner", "admin", "manager", "advisor", "mechanic", "parts"],
    scopes: ["tech", "all"],
    section: "Tools",
  },
];

/* =============================== */
/* FILE: features/shared/lib/email/email/sendQuoteEmail.ts */
/* =============================== */

// @shared/lib/email/email/sendQuoteEmail.ts
import { createClient } from "@supabase/supabase-js";

/**
 * NOTE: keep this module server-only. Do not import it in client components.
 */
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!, // server-only key
);

export type SendQuoteEmailParams = {
  to: string;
  workOrderId: string;
  /** Base64-encoded PDF bytes (optional). */
  pdfBuffer?: string;
  /** Public URL to the PDF (optional). */
  pdfUrl?: string | null;
};

export async function sendQuoteEmail({
  to,
  workOrderId,
  pdfBuffer,
  pdfUrl,
}: SendQuoteEmailParams): Promise<void> {
  const subject = `Inspection Summary & Quote – Work Order ${workOrderId}`;

  const linkLine = pdfUrl ? `\n\nView your quote online: ${pdfUrl}` : "";
  const text =
    `Attached is your inspection summary and quote for Work Order ${workOrderId}.` +
    (pdfBuffer ? "" : "\n\n(No attachment was included.)") +
    linkLine;

  // Build the payload conditionally
  const body: Record<string, unknown> = {
    to,
    subject,
    text,
  };

  if (pdfBuffer) {
    body.attachments = [
      {
        filename: `Inspection_Summary_${workOrderId}.pdf`,
        content: pdfBuffer, // base64 string
      },
    ];
  }

  const { error } = await supabase.functions.invoke("send-email", { body });

  if (error) {
    console.error("Failed to send quote email:", error);
    throw error;
  }
}

/* =============================== */
/* FILE: features/shared/lib/plan/features.ts */
/* =============================== */

// Types for access control by plan
export type FeatureAccess = {
  diy: boolean;
  pro: boolean;
  proPlus: boolean;
  addOnAvailable?: boolean;
};

export type FeatureKey =
  | "ai_diagnosis"
  | "inspection_flow"
  | "photo_to_quote"
  | "work_orders"
  | "chatbot"
  | "smart_scheduling"
  | "customer_portal"
  | "voice_input"
  | "parts_lookup"
  | "deferred_work_tracking";

export type Feature = {
  key: FeatureKey;
  title: string;
  description: string;
  access: FeatureAccess;
};

// Full feature config list
export const features: Feature[] = [
  {
    key: "ai_diagnosis",
    title: "AI Diagnosis",
    description:
      "Use image and text to identify mechanical problems automatically.",
    access: { diy: false, pro: true, proPlus: true, addOnAvailable: true },
  },
  {
    key: "inspection_flow",
    title: "Inspection Flow",
    description:
      "Voice-guided inspections, summary review, and quote generation.",
    access: { diy: false, pro: true, proPlus: true, addOnAvailable: true },
  },
  {
    key: "photo_to_quote",
    title: "Photo to Quote",
    description: "Take photos and let the AI generate repair quotes.",
    access: { diy: false, pro: true, proPlus: true, addOnAvailable: true },
  },
  {
    key: "work_orders",
    title: "Work Orders",
    description: "Create, track, and complete work orders in real time.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "chatbot",
    title: "AI Chatbot",
    description:
      "Talk to an AI mechanic assistant for help diagnosing and learning.",
    access: { diy: false, pro: true, proPlus: true, addOnAvailable: true },
  },
  {
    key: "smart_scheduling",
    title: "Smart Scheduling",
    description:
      "Optimize your shop’s schedule with AI-based job priority logic.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "customer_portal",
    title: "Customer Portal",
    description: "Let customers view quotes, photos, and approve work online.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "voice_input",
    title: "Voice Input",
    description:
      "Add repairs, inspections, and job notes hands-free using voice.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "parts_lookup",
    title: "Parts Lookup",
    description:
      "Search and price parts in real time through connected suppliers.",
    access: { diy: false, pro: true, proPlus: true },
  },
  {
    key: "deferred_work_tracking",
    title: "Deferred Tracking",
    description: "Automatically track declined work for follow-up.",
    access: { diy: false, pro: true, proPlus: true },
  },
];

// Optional: key-to-feature lookup
export const featureMap = Object.fromEntries(
  features.map((f) => [f.key, f]),
) as { [k in FeatureKey]: Feature };


/* =============================== */
/* FILE: features/shared/lib/routeMeta.ts */
/* =============================== */

// src/routeMeta.ts

export type UserRole = "owner" | "admin" | "service" | "tech" | "viewer";

export type PersistMeta = {
  scroll?: boolean;          // remember scroll position
  inputs?: boolean;          // remember input/textarea/select values
  keyParams?: string[];      // dynamic params to scope storage key (e.g., ["id"])
};

export type RouteMeta = {
  title: (href: string) => string;
  icon?: string;
  showInTabs?: boolean;      // default true
  persist?: PersistMeta;     // optional overrides (defaults applied globally)
  roles?: UserRole[];        // NEW: restrict visibility by role
};

// ---- Global defaults: APPLY TO ALL ROUTES (opt-out per route) ----
const PERSIST_DEFAULTS: PersistMeta = { scroll: true, inputs: true };

// If you want a global default role set (i.e., everyone can see unless specified)
// leave undefined to mean "all roles"
const ALL_ROLES: UserRole[] | undefined = undefined;

// Define only titles/icons and any per-route overrides or opt-outs.
export const ROUTE_META: Record<string, RouteMeta> = {
  "/dashboard": { title: () => "Dashboard", icon: "🏠", roles: ALL_ROLES },

  // Work Orders
  "/work-orders":              { title: () => "Work Orders",       icon: "📋", roles: ["owner", "admin", "service", "tech"] },
  "/work-orders/view":         { title: () => "View Work Orders",  icon: "📋", roles: ["owner", "admin", "service"] },
  "/work-orders/create":       { title: () => "New Work Order",    icon: "➕", roles: ["owner", "admin", "service"] },
  "/work-orders/queue":        { title: () => "Job Queue",         icon: "🧰", roles: ["owner", "admin", "service", "tech"] },
  "/work-orders/editor":       { title: () => "Work Order Editor", icon: "✍️", roles: ["owner", "admin", "service"] },
  "/work-orders/quote-review": { title: () => "Quote Review",      icon: "✅", roles: ["owner", "admin", "service"] },

  // Per-WO tab (plural): scope persistence by id
  "/work-orders/[id]": {
    title: (href) => `WO #${href.split("/").pop()?.slice(0, 8) ?? "…"}`,
    icon: "🔧",
    persist: { keyParams: ["id"] },
    roles: ["owner", "admin", "service", "tech"],
  },

  // OPTIONAL (singular) detail route you mentioned:
  // If you created /work-order/view/[id], include it too. Hidden from tabs.
  "/work-orders/view/[id]": {
    title: (href) => `Work Order ${href.split("/").pop()?.slice(0, 8) ?? "…"}`,
    icon: "🔧",
    showInTabs: false,
    persist: { keyParams: ["id"] },
    roles: ["owner", "admin", "service", "tech"],
  },

  // Inspections
  "/inspection":                   { title: () => "Inspection Menu",      icon: "📝", roles: ["owner", "admin", "service", "tech"] },
  "/maintenance50":                { title: () => "Maintenance 50",       icon: "🧰", roles: ["owner", "admin", "service", "tech"] },
  // NEW: Maintenance 50 (Air)
  "/maintenance50-air": { title: () => "Maintenance 50 (Air)", icon: "🧰", roles: ["owner", "admin", "service", "tech"] },

  "/inspection/custom-inspection": { title: () => "Custom Builder",       icon: "🧩", roles: ["owner", "admin", "service", "tech"] },
  "/inspection/saved":             { title: () => "Saved Inspections",    icon: "💾", roles: ["owner", "admin", "service", "tech"] },
  "/inspection/templates":         { title: () => "Templates",            icon: "🗂️", roles: ["owner", "admin", "service", "tech"] },
  "/inspection/created":           { title: () => "Created Inspections",  icon: "📤", roles: ["owner", "admin", "service", "tech"] },
  "/inspection/summaries":         { title: () => "Inspection Summaries", icon: "📊", roles: ["owner", "admin", "service"] },

  // Parts
  "/parts":            { title: () => "Parts Dashboard", icon: "📦", roles: ["owner", "admin", "service"] },
  "/parts/inventory":  { title: () => "Inventory",       icon: "📦", roles: ["owner", "admin", "service"] },
  "/parts/returns":    { title: () => "Returns",         icon: "↩️", roles: ["owner", "admin", "service"] },
  "/parts/warranties": { title: () => "Warranties",      icon: "🛡️", roles: ["owner", "admin", "service"] },

  // Management / Settings
  "/dashboard/owner/create-user": { title: () => "Create User",    icon: "➕", roles: ["owner"] },
  "/dashboard/owner/reports":     { title: () => "Reports",        icon: "📈", roles: ["owner"] },
  "/dashboard/owner/settings":    { title: () => "Owner Settings", icon: "⚙️", roles: ["owner"] },

  // Scheduling (Admin)
  "/dashboard/admin/scheduling":  { title: () => "Scheduling",     icon: "📅", roles: ["owner", "admin"] },

  // AI & Messaging
  "/ai/assistant": { title: () => "AI Assistant", icon: "🤖", roles: ["owner", "admin", "service", "tech"] },
  "/chat":         { title: () => "Team Chat",    icon: "💬", roles: ["owner", "admin", "service", "tech"] },

  // ----- Hide these from Tabs (but they still persist unless you override persist) -----
  "/":            { title: () => "Home",        showInTabs: false, roles: ALL_ROLES },
  "/sign-in":     { title: () => "Sign In",     showInTabs: false, persist: { scroll: false, inputs: false }, roles: ALL_ROLES },
  "/signup":      { title: () => "Sign Up",     showInTabs: false, persist: { scroll: false, inputs: false }, roles: ALL_ROLES },
  "/onboarding":  { title: () => "Onboarding",  showInTabs: false, roles: ["owner", "admin"] },
  "/subscribe":   { title: () => "Plans",       showInTabs: false, roles: ["owner"] },
  "/compare":     { title: () => "Compare",     showInTabs: false, roles: ALL_ROLES },

  // Leave visible if you want it in tabs
  "/compare-plans": { title: () => "Plan & Billing", icon: "💳", roles: ["owner"] },
};

// Utility to merge defaults for any route (and for unknown routes)
// NOTE: now accepts `role` to filter visibility
export function metaFor(
  href: string,
  _params?: Record<string, string>,
  role?: UserRole
): { title: string; icon?: string; show: boolean; persist: PersistMeta } {
  const keys = Object.keys(ROUTE_META).sort((a, b) => b.length - a.length);
  for (const key of keys) {
    const isDyn = key.includes("[");
    const keyPrefix = key.replace(/\[.*?\]/g, "");
    if ((isDyn && href.startsWith(keyPrefix)) || (!isDyn && href === key)) {
      const m = ROUTE_META[key];

      // role check
      const allowed =
        !m.roles || m.roles.length === 0 || role === undefined || m.roles.includes(role);

      return {
        title: m.title(href),
        icon: m.icon,
        show: allowed && (m.showInTabs !== false),
        persist: { ...PERSIST_DEFAULTS, ...(m.persist ?? {}) },
      };
    }
  }
  // Fallback for routes not listed: show in tabs + apply global defaults
  const last = href.split("?")[0].split("/").filter(Boolean).pop() ?? href;
  const nice = last.replace(/[-_]+/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
  return {
    title: nice || "Page",
    icon: "📄",
    show: true,
    persist: { ...PERSIST_DEFAULTS },
  };
}

/* =============================== */
/* FILE: features/shared/components/RoleHubTiles/tiles.ts */
/* =============================== */

export type Role =
  | "owner"
  | "admin"
  | "manager"
  | "advisor"
  | "mechanic"
  | "parts";

export type Scope =
  | "work_orders"
  | "inspections"
  | "parts"
  | "tech"
  | "management"
  | "settings"
  | "all";

export type Tile = {
  href: string;
  title: string;
  subtitle?: string;
  cta?: string;
  roles: Role[];
  scopes: Scope[];
};

export const TILES: Tile[] = [
  // --- Work Orders ---
  {
    href: "/work-orders/create?autostart=1", // ✅ auto-start work order draft
    title: "Create Work Order",
    subtitle: "Start a new job",
    cta: "+",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/work-orders/view",
    title: "View Work Orders",
    subtitle: "Browse & manage",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/work-orders/queue",
    title: "Job Queue",
    subtitle: "Active & in-progress",
    roles: ["mechanic", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/work-orders/quote-review",
    title: "Quote Review",
    subtitle: "Review & send estimates",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/menu",
    title: "Service Menu",
    subtitle: "Saved services & presets",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },
  {
    href: "/work-orders/history",
    title: "History",
    subtitle: "Completed Work Orders & Invoices",
    roles: ["owner", "admin", "manager", "advisor", "mechanic"],
    scopes: ["work_orders", "all"],
  },
  // NEW: Billing (Ready to invoice)
  {
    href: "/billing",
    title: "Billing",
    subtitle: "Ready to invoice",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["work_orders", "all"],
  },

  // --- Inspections ---
  {
    href: "/inspections/maintenance50",
    title: "Maintenance 50",
    subtitle: "Quick checklist",
    roles: ["advisor", "manager", "owner", "admin", "mechanic"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/maintenance50-air",
    title: "Maintenance 50 – Air",
    subtitle: "CVIP-style (air brakes)",
    roles: ["advisor", "manager", "owner", "admin", "mechanic"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/custom-inspection",
    title: "Custom Builder",
    subtitle: "Design your own",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/saved",
    title: "Saved Inspections",
    subtitle: "Recent & drafts",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/templates",
    title: "Templates",
    subtitle: "Reusable inspection sets",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
  },
  {
    href: "/inspections/summary",
    title: "Inspection Summaries",
    subtitle: "Overview & results",
    roles: ["advisor", "manager", "owner", "admin"],
    scopes: ["inspections", "all"],
  },

  // --- Parts ---
  {
    href: "/parts",
    title: "Parts Dashboard",
    subtitle: "Orders & receiving",
    roles: ["parts", "manager", "owner", "admin" ],
    scopes: ["parts", "all"],
  },
  {
    href: "/parts/requests",
    title: "Requests",
    subtitle: "View requests",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  {
    href: "/parts/inventory",
    title: "Inventory",
    subtitle: "On-hand stock",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  // NEW: Purchase Orders list
  {
    href: "/parts/po",
    title: "Purchase Orders",
    subtitle: "Create & manage POs",
    cta: "+",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  // NEW: Scan-to-Receive entry
  {
    href: "/parts/receive",
    title: "Scan to Receive",
    subtitle: "Camera or manual entry",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  // Optional: vendor API keys / integrations page
  {
    href: "/parts/vendors",
    title: "Vendor Integrations",
    subtitle: "API keys for suppliers",
    roles: ["owner", "admin", "manager", "parts"],
    scopes: ["parts", "settings", "all"],
  },
  {
    href: "/parts/returns",
    title: "Returns",
    subtitle: "Manage RMAs",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },
  {
    href: "/parts/warranties",
    title: "Warranties",
    subtitle: "Track claims",
    roles: ["parts", "manager", "owner", "admin"],
    scopes: ["parts", "all"],
  },

  // --- Management ---
  {
    href: "/dashboard/owner/create-user",
    title: "Create User",
    subtitle: "Add team members",
    roles: ["owner", "admin"],
    scopes: ["management", "all"],
  },
  {
    href: "/dashboard/admin/scheduling",
    title: "Scheduling",
    subtitle: "Calendar & bookings",
    roles: ["owner", "admin", "manager", "advisor"],
    scopes: ["management", "all"],
  },
  {
    href: "/portal/appointments",
    title: "Appointments",
    subtitle: "Customer bookings calendar",
    roles: ["owner", "admin", "manager", "advisor"],
    scopes: ["management", "all"],
  },

  // --- Settings & Reports ---
  {
    href: "/dashboard/owner/reports",
    title: "Reports",
    subtitle: "Business insights",
    roles: ["owner", "admin", "manager"],
    scopes: ["settings", "all"],
  },
  {
    href: "/dashboard/owner/settings",
    title: "Settings",
    subtitle: "Account & shop settings",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
  },
  {
    href: "/dashboard/owner/import-customers",
    title: "Import Customers",
    subtitle: "CSV import",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
  },
  {
    href: "/compare-plans",
    title: "Plan & Billing",
    subtitle: "Subscription",
    roles: ["owner", "admin"],
    scopes: ["settings", "all"],
  },

  // --- AI & Tech ---
  {
    href: "/tech/queue",
    title: "Tech Job Queue",
    subtitle: "My assigned work",
    roles: ["mechanic", "manager", "owner", "admin"],
    scopes: ["tech", "all"],
  },
];

/* =============================== */
/* FILE: features/shared/components/ui/WhySection.tsx */
/* =============================== */

"use client";

import Section from "./Section";

export default function WhySection() {
  return (
    <Section id="why" className="bg-neutral-950 text-white">
      <div className="max-w-5xl mx-auto text-center">
        <h2 className="text-3xl font-blackops text-orange-400 mb-6 drop-shadow">
          Why ProFixIQ?
        </h2>

        <p className="text-lg text-gray-300 leading-relaxed mb-8">
          ProFixIQ was built by a technician who lived shop life — not by a
          committee. The goal is simple: <em>less screen time, faster answers,
          cleaner documentation</em>. From AI-assisted diagnostics to shareable
          quotes and role-based work management, ProFixIQ removes the friction
          that slows techs and advisors down.
        </p>

        <div className="grid gap-4 sm:grid-cols-2 text-left">
          {[
            "Cut diagnostic guesswork with AI suggestions and symptom guides.",
            "Speed up inspections with reusable templates, photos, and voice notes.",
            "Turn findings into quotes and work orders with accurate labor estimates.",
            "Keep everyone on the same page with roles, permissions, and status.",
          ].map((line, i) => (
            <div
              key={i}
              className="rounded border border-neutral-800 bg-black/40 p-4"
            >
              <span className="text-orange-400 mr-2">✓</span>
              <span className="text-gray-200">{line}</span>
            </div>
          ))}
        </div>
      </div>
    </Section>
  );
}

/* =============================== */
/* FILE: features/shared/components/ui/QuoteViewer.tsx */
/* =============================== */

"use client";



interface QuoteLine {
  description: string;
  parts: { name: string; price: number }[];
  laborHours: number;
  laborCost: number;
  shopSupplies: number;
  total: number;
  category: string;
}

interface QuoteViewerProps {
  quote: QuoteLine[];
}

export default function QuoteViewer({ quote }: QuoteViewerProps) {
  if (!quote || quote.length === 0) {
    return (
      <div className="text-center text-sm text-gray-400">
        No quote items available.
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {quote.map((line, index) => (
        <div
          key={index}
          className="rounded-xl bg-black/30 p-6 shadow-md border border-white/10 backdrop-blur-md transition hover:shadow-xl"
        >
          <h3 className="text-lg font-blackopsone text-orange-400 mb-1 capitalize">
            {line.category}
          </h3>
          <p className="text-sm text-white/90 italic mb-2">
            {line.description}
          </p>

          {line.parts.length > 0 && (
            <div className="text-sm text-white/80 mb-2">
              <span className="font-semibold text-orange-300">Parts:</span>
              <ul className="list-disc ml-5 mt-1 space-y-1">
                {line.parts.map((part, i) => (
                  <li key={i}>
                    {part.name} – ${part.price.toFixed(2)}
                  </li>
                ))}
              </ul>
            </div>
          )}

          <div className="text-sm text-white/80 space-y-1 mt-3">
            <p>
              <span className="font-semibold">Labor:</span> {line.laborHours}{" "}
              hrs – ${line.laborCost.toFixed(2)}
            </p>
            <p>
              <span className="font-semibold">Shop Supplies:</span> $
              {line.shopSupplies.toFixed(2)}
            </p>
          </div>

          <div className="text-md font-bold text-green-400 mt-4 border-t border-white/10 pt-3">
            Total: ${line.total.toFixed(2)}
          </div>
        </div>
      ))}
    </div>
  );
}


/* =============================== */
/* FILE: features/shared/components/ui/FeaturesSection.tsx */
/* =============================== */

"use client";

import FeatureCard from "@shared/components/ui/FeatureCard";

type FeaturesSectionProps = {
  showHeading?: boolean;
};

export default function FeaturesSection({ showHeading = false }: FeaturesSectionProps) {
  return (
    <div>
      {showHeading && (
        <h2
          className="text-center text-4xl md:text-5xl text-orange-400 mb-10"
          style={{ fontFamily: "var(--font-blackops)" }}
        >
          Powerful Features
        </h2>
      )}

      <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
        <FeatureCard
          title="AI-Powered Diagnostics"
          description="Narrow down likely causes before you touch a tool. Ask follow-ups to confirm symptoms and next steps."
          available
        />
        <FeatureCard
          title="Inspections Your Way"
          description="Photo capture, notes, voice input, tags—everything techs need to document and share clearly."
          available
        />
        <FeatureCard
          title="Work Orders & Quotes"
          description="Estimate labor, parts, and taxes; assign jobs; generate shareable quotes and invoices in a click."
          available
        />
        <FeatureCard
          title="Voice + Photos"
          description="Add line items by voice, markup images, and keep evidence tidy for customers and insurance."
          available
        />
        <FeatureCard
          title="Team & Roles"
          description="Owner, Admin, Manager, Advisor, Parts, Tech. Give each role the tools (and permissions) they need."
          available
        />
        <FeatureCard
          title="Priority Support"
          description="Pro+ adds priority help and optional extra seats as your shop grows."
          available
        />
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/shared/types/types/supabase.ts */
/* =============================== */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "12.2.3 (519615d)"
  }
  public: {
    Tables: {
      activity_logs: {
        Row: {
          action: string | null
          context: Json | null
          id: string
          target_id: string | null
          target_table: string | null
          timestamp: string | null
          user_id: string | null
        }
        Insert: {
          action?: string | null
          context?: Json | null
          id?: string
          target_id?: string | null
          target_table?: string | null
          timestamp?: string | null
          user_id?: string | null
        }
        Update: {
          action?: string | null
          context?: Json | null
          id?: string
          target_id?: string | null
          target_table?: string | null
          timestamp?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      agent_attachments: {
        Row: {
          agent_request_id: string
          caption: string | null
          created_at: string
          created_by: string
          id: string
          kind: string
          public_url: string
          storage_path: string
        }
        Insert: {
          agent_request_id: string
          caption?: string | null
          created_at?: string
          created_by: string
          id?: string
          kind?: string
          public_url: string
          storage_path: string
        }
        Update: {
          agent_request_id?: string
          caption?: string | null
          created_at?: string
          created_by?: string
          id?: string
          kind?: string
          public_url?: string
          storage_path?: string
        }
        Relationships: [
          {
            foreignKeyName: "agent_attachments_agent_request_id_fkey"
            columns: ["agent_request_id"]
            isOneToOne: false
            referencedRelation: "agent_requests"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "agent_attachments_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      agent_events: {
        Row: {
          content: Json
          created_at: string
          id: string
          kind: string
          run_id: string
          step: number
        }
        Insert: {
          content: Json
          created_at?: string
          id?: string
          kind: string
          run_id: string
          step: number
        }
        Update: {
          content?: Json
          created_at?: string
          id?: string
          kind?: string
          run_id?: string
          step?: number
        }
        Relationships: [
          {
            foreignKeyName: "agent_events_run_id_fkey"
            columns: ["run_id"]
            isOneToOne: false
            referencedRelation: "agent_runs"
            referencedColumns: ["id"]
          },
        ]
      }
      agent_knowledge: {
        Row: {
          body: string
          created_at: string
          created_by: string
          id: string
          shop_id: string | null
          slug: string
          tags: string[] | null
          title: string
        }
        Insert: {
          body: string
          created_at?: string
          created_by: string
          id?: string
          shop_id?: string | null
          slug: string
          tags?: string[] | null
          title: string
        }
        Update: {
          body?: string
          created_at?: string
          created_by?: string
          id?: string
          shop_id?: string | null
          slug?: string
          tags?: string[] | null
          title?: string
        }
        Relationships: [
          {
            foreignKeyName: "agent_knowledge_created_by_fkey"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      agent_requests: {
        Row: {
          created_at: string
          description: string
          github_branch: string | null
          github_commit_sha: string | null
          github_issue_number: number | null
          github_issue_url: string | null
          github_pr_number: number | null
          github_pr_url: string | null
          id: string
          intent: Database["public"]["Enums"]["agent_request_intent"] | null
          llm_confidence: number | null
          llm_model: string | null
          llm_notes: string | null
          normalized_json: Json | null
          reporter_id: string | null
          reporter_role: string | null
          run_id: string | null
          shop_id: string | null
          status: Database["public"]["Enums"]["agent_request_status"]
          updated_at: string
        }
        Insert: {
          created_at?: string
          description: string
          github_branch?: string | null
          github_commit_sha?: string | null
          github_issue_number?: number | null
          github_issue_url?: string | null
          github_pr_number?: number | null
          github_pr_url?: string | null
          id?: string
          intent?: Database["public"]["Enums"]["agent_request_intent"] | null
          llm_confidence?: number | null
          llm_model?: string | null
          llm_notes?: string | null
          normalized_json?: Json | null
          reporter_id?: string | null
          reporter_role?: string | null
          run_id?: string | null
          shop_id?: string | null
          status?: Database["public"]["Enums"]["agent_request_status"]
          updated_at?: string
        }
        Update: {
          created_at?: string
          description?: string
          github_branch?: string | null
          github_commit_sha?: string | null
          github_issue_number?: number | null
          github_issue_url?: string | null
          github_pr_number?: number | null
          github_pr_url?: string | null
          id?: string
          intent?: Database["public"]["Enums"]["agent_request_intent"] | null
          llm_confidence?: number | null
          llm_model?: string | null
          llm_notes?: string | null
          normalized_json?: Json | null
          reporter_id?: string | null
          reporter_role?: string | null
          run_id?: string | null
          shop_id?: string | null
          status?: Database["public"]["Enums"]["agent_request_status"]
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "agent_requests_reporter_id_fkey"
            columns: ["reporter_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "agent_requests_run_id_fkey"
            columns: ["run_id"]
            isOneToOne: false
            referencedRelation: "agent_runs"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "agent_requests_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "agent_requests_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      agent_runs: {
        Row: {
          created_at: string
          goal: string
          id: string
          idempotency_key: string | null
          shop_id: string
          status: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          goal: string
          id?: string
          idempotency_key?: string | null
          shop_id: string
          status: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          goal?: string
          id?: string
          idempotency_key?: string | null
          shop_id?: string
          status?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      ai_events: {
        Row: {
          created_at: string
          entity_id: string | null
          entity_table: string | null
          event_type: string
          id: string
          payload: Json
          shop_id: string | null
          source_id: string | null
          training_source:
            | Database["public"]["Enums"]["ai_training_source"]
            | null
          user_id: string | null
          vehicle_ymm: string | null
        }
        Insert: {
          created_at?: string
          entity_id?: string | null
          entity_table?: string | null
          event_type: string
          id?: string
          payload: Json
          shop_id?: string | null
          source_id?: string | null
          training_source?:
            | Database["public"]["Enums"]["ai_training_source"]
            | null
          user_id?: string | null
          vehicle_ymm?: string | null
        }
        Update: {
          created_at?: string
          entity_id?: string | null
          entity_table?: string | null
          event_type?: string
          id?: string
          payload?: Json
          shop_id?: string | null
          source_id?: string | null
          training_source?:
            | Database["public"]["Enums"]["ai_training_source"]
            | null
          user_id?: string | null
          vehicle_ymm?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_events_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_events_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      ai_requests: {
        Row: {
          created_at: string | null
          id: string
          prompt: string | null
          response: string | null
          tool_used: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          prompt?: string | null
          response?: string | null
          tool_used?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          prompt?: string | null
          response?: string | null
          tool_used?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_requests_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_requests_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      ai_training_data: {
        Row: {
          content: string
          created_at: string
          embedding: string | null
          id: string
          shop_id: string | null
          source_event_id: string | null
        }
        Insert: {
          content: string
          created_at?: string
          embedding?: string | null
          id?: string
          shop_id?: string | null
          source_event_id?: string | null
        }
        Update: {
          content?: string
          created_at?: string
          embedding?: string | null
          id?: string
          shop_id?: string | null
          source_event_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_training_data_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_training_data_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_training_data_source_event_id_fkey"
            columns: ["source_event_id"]
            isOneToOne: false
            referencedRelation: "ai_events"
            referencedColumns: ["id"]
          },
        ]
      }
      ai_training_events: {
        Row: {
          created_at: string
          id: string
          payload: Json
          shop_id: string
          source: string
          vehicle_ymm: string | null
        }
        Insert: {
          created_at?: string
          id?: string
          payload?: Json
          shop_id: string
          source: string
          vehicle_ymm?: string | null
        }
        Update: {
          created_at?: string
          id?: string
          payload?: Json
          shop_id?: string
          source?: string
          vehicle_ymm?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "ai_training_events_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "ai_training_events_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      api_keys: {
        Row: {
          api_key: string | null
          created_at: string | null
          id: string
          label: string | null
          user_id: string | null
        }
        Insert: {
          api_key?: string | null
          created_at?: string | null
          id?: string
          label?: string | null
          user_id?: string | null
        }
        Update: {
          api_key?: string | null
          created_at?: string | null
          id?: string
          label?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      apps: {
        Row: {
          default_route: string
          icon_url: string | null
          id: string
          is_enabled: boolean
          name: string
          slug: string
        }
        Insert: {
          default_route: string
          icon_url?: string | null
          id?: string
          is_enabled?: boolean
          name: string
          slug: string
        }
        Update: {
          default_route?: string
          icon_url?: string | null
          id?: string
          is_enabled?: boolean
          name?: string
          slug?: string
        }
        Relationships: []
      }
      audit_logs: {
        Row: {
          action: string
          actor_id: string | null
          created_at: string
          id: string
          metadata: Json | null
          target: string | null
        }
        Insert: {
          action: string
          actor_id?: string | null
          created_at?: string
          id?: string
          metadata?: Json | null
          target?: string | null
        }
        Update: {
          action?: string
          actor_id?: string | null
          created_at?: string
          id?: string
          metadata?: Json | null
          target?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "audit_logs_actor_id_fkey"
            columns: ["actor_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      bookings: {
        Row: {
          created_at: string
          created_by: string | null
          customer_id: string | null
          ends_at: string
          id: string
          notes: string | null
          shop_id: string | null
          starts_at: string
          status: string
          vehicle_id: string | null
        }
        Insert: {
          created_at?: string
          created_by?: string | null
          customer_id?: string | null
          ends_at: string
          id?: string
          notes?: string | null
          shop_id?: string | null
          starts_at: string
          status?: string
          vehicle_id?: string | null
        }
        Update: {
          created_at?: string
          created_by?: string | null
          customer_id?: string | null
          ends_at?: string
          id?: string
          notes?: string | null
          shop_id?: string | null
          starts_at?: string
          status?: string
          vehicle_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "bookings_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      chat_participants: {
        Row: {
          chat_id: string | null
          id: string
          joined_at: string | null
          profile_id: string | null
          role: string | null
        }
        Insert: {
          chat_id?: string | null
          id?: string
          joined_at?: string | null
          profile_id?: string | null
          role?: string | null
        }
        Update: {
          chat_id?: string | null
          id?: string
          joined_at?: string | null
          profile_id?: string | null
          role?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "chat_participants_chat_id_fkey"
            columns: ["chat_id"]
            isOneToOne: false
            referencedRelation: "chats"
            referencedColumns: ["id"]
          },
        ]
      }
      chats: {
        Row: {
          context_id: string | null
          created_at: string | null
          created_by: string | null
          id: string
          title: string | null
          type: string
        }
        Insert: {
          context_id?: string | null
          created_at?: string | null
          created_by?: string | null
          id?: string
          title?: string | null
          type: string
        }
        Update: {
          context_id?: string | null
          created_at?: string | null
          created_by?: string | null
          id?: string
          title?: string | null
          type?: string
        }
        Relationships: []
      }
      conversation_participants: {
        Row: {
          added_at: string | null
          conversation_id: string | null
          id: string
          role: string | null
          user_id: string | null
        }
        Insert: {
          added_at?: string | null
          conversation_id?: string | null
          id?: string
          role?: string | null
          user_id?: string | null
        }
        Update: {
          added_at?: string | null
          conversation_id?: string | null
          id?: string
          role?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "conversation_participants_conversation_id_fkey"
            columns: ["conversation_id"]
            isOneToOne: false
            referencedRelation: "conversations"
            referencedColumns: ["id"]
          },
        ]
      }
      conversations: {
        Row: {
          context_id: string | null
          context_type: string | null
          created_at: string | null
          created_by: string | null
          id: string
          is_group: boolean | null
          title: string | null
        }
        Insert: {
          context_id?: string | null
          context_type?: string | null
          created_at?: string | null
          created_by?: string | null
          id?: string
          is_group?: boolean | null
          title?: string | null
        }
        Update: {
          context_id?: string | null
          context_type?: string | null
          created_at?: string | null
          created_by?: string | null
          id?: string
          is_group?: boolean | null
          title?: string | null
        }
        Relationships: []
      }
      customer_bookings: {
        Row: {
          created_at: string | null
          customer_email: string | null
          customer_name: string | null
          customer_phone: string | null
          id: string
          labor_hours_estimated: number | null
          preferred_date: string | null
          preferred_time: string | null
          selected_services: Json | null
          shop_id: string | null
          status: string | null
          vehicle_make: string | null
          vehicle_model: string | null
          vehicle_year: string | null
          vin: string | null
        }
        Insert: {
          created_at?: string | null
          customer_email?: string | null
          customer_name?: string | null
          customer_phone?: string | null
          id?: string
          labor_hours_estimated?: number | null
          preferred_date?: string | null
          preferred_time?: string | null
          selected_services?: Json | null
          shop_id?: string | null
          status?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: string | null
          vin?: string | null
        }
        Update: {
          created_at?: string | null
          customer_email?: string | null
          customer_name?: string | null
          customer_phone?: string | null
          id?: string
          labor_hours_estimated?: number | null
          preferred_date?: string | null
          preferred_time?: string | null
          selected_services?: Json | null
          shop_id?: string | null
          status?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: string | null
          vin?: string | null
        }
        Relationships: []
      }
      customer_portal_invites: {
        Row: {
          created_at: string | null
          customer_id: string
          email: string
          id: string
          token: string
        }
        Insert: {
          created_at?: string | null
          customer_id: string
          email: string
          id?: string
          token: string
        }
        Update: {
          created_at?: string | null
          customer_id?: string
          email?: string
          id?: string
          token?: string
        }
        Relationships: [
          {
            foreignKeyName: "customer_portal_invites_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
        ]
      }
      customer_quotes: {
        Row: {
          created_at: string | null
          customer_email: string | null
          customer_name: string | null
          estimated_total: number | null
          id: string
          preferred_date: string | null
          selected_services: Json | null
          shop_id: string | null
          vehicle_make: string | null
          vehicle_model: string | null
          vehicle_year: number | null
        }
        Insert: {
          created_at?: string | null
          customer_email?: string | null
          customer_name?: string | null
          estimated_total?: number | null
          id?: string
          preferred_date?: string | null
          selected_services?: Json | null
          shop_id?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: number | null
        }
        Update: {
          created_at?: string | null
          customer_email?: string | null
          customer_name?: string | null
          estimated_total?: number | null
          id?: string
          preferred_date?: string | null
          selected_services?: Json | null
          shop_id?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: number | null
        }
        Relationships: []
      }
      customer_settings: {
        Row: {
          comm_email_enabled: boolean
          comm_sms_enabled: boolean
          customer_id: string
          language: string | null
          marketing_opt_in: boolean
          preferred_contact: string | null
          timezone: string | null
          units: string | null
          updated_at: string
        }
        Insert: {
          comm_email_enabled?: boolean
          comm_sms_enabled?: boolean
          customer_id: string
          language?: string | null
          marketing_opt_in?: boolean
          preferred_contact?: string | null
          timezone?: string | null
          units?: string | null
          updated_at?: string
        }
        Update: {
          comm_email_enabled?: boolean
          comm_sms_enabled?: boolean
          customer_id?: string
          language?: string | null
          marketing_opt_in?: boolean
          preferred_contact?: string | null
          timezone?: string | null
          units?: string | null
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "customer_settings_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: true
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
        ]
      }
      customers: {
        Row: {
          address: string | null
          business_name: string | null
          city: string | null
          created_at: string | null
          email: string | null
          first_name: string | null
          id: string
          is_fleet: boolean
          last_name: string | null
          name: string | null
          notes: string | null
          phone: string | null
          phone_number: string | null
          postal_code: string | null
          province: string | null
          shop_id: string | null
          street: string | null
          user_id: string | null
          vehicle: string | null
        }
        Insert: {
          address?: string | null
          business_name?: string | null
          city?: string | null
          created_at?: string | null
          email?: string | null
          first_name?: string | null
          id?: string
          is_fleet?: boolean
          last_name?: string | null
          name?: string | null
          notes?: string | null
          phone?: string | null
          phone_number?: string | null
          postal_code?: string | null
          province?: string | null
          shop_id?: string | null
          street?: string | null
          user_id?: string | null
          vehicle?: string | null
        }
        Update: {
          address?: string | null
          business_name?: string | null
          city?: string | null
          created_at?: string | null
          email?: string | null
          first_name?: string | null
          id?: string
          is_fleet?: boolean
          last_name?: string | null
          name?: string | null
          notes?: string | null
          phone?: string | null
          phone_number?: string | null
          postal_code?: string | null
          province?: string | null
          shop_id?: string | null
          street?: string | null
          user_id?: string | null
          vehicle?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "customers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "customers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      decoded_vins: {
        Row: {
          created_at: string | null
          decoded: Json | null
          id: string
          user_id: string | null
          vin: string
        }
        Insert: {
          created_at?: string | null
          decoded?: Json | null
          id?: string
          user_id?: string | null
          vin: string
        }
        Update: {
          created_at?: string | null
          decoded?: Json | null
          id?: string
          user_id?: string | null
          vin?: string
        }
        Relationships: []
      }
      defective_parts: {
        Row: {
          id: string
          part_id: string | null
          quantity: number
          reason: string | null
          reported_at: string | null
          reported_by: string | null
          shop_id: string | null
        }
        Insert: {
          id?: string
          part_id?: string | null
          quantity?: number
          reason?: string | null
          reported_at?: string | null
          reported_by?: string | null
          shop_id?: string | null
        }
        Update: {
          id?: string
          part_id?: string | null
          quantity?: number
          reason?: string | null
          reported_at?: string | null
          reported_by?: string | null
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "defective_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "defective_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      dtc_logs: {
        Row: {
          created_at: string | null
          description: string | null
          dtc_code: string | null
          id: string
          severity: string | null
          user_id: string | null
          vehicle_id: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          dtc_code?: string | null
          id?: string
          severity?: string | null
          user_id?: string | null
          vehicle_id?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          dtc_code?: string | null
          id?: string
          severity?: string | null
          user_id?: string | null
          vehicle_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "dtc_logs_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      email_logs: {
        Row: {
          created_at: string | null
          email: string
          error: string | null
          event_type: string
          id: string
          sg_event_id: string | null
          status: string | null
          timestamp: string
        }
        Insert: {
          created_at?: string | null
          email: string
          error?: string | null
          event_type: string
          id?: string
          sg_event_id?: string | null
          status?: string | null
          timestamp: string
        }
        Update: {
          created_at?: string | null
          email?: string
          error?: string | null
          event_type?: string
          id?: string
          sg_event_id?: string | null
          status?: string | null
          timestamp?: string
        }
        Relationships: []
      }
      email_suppressions: {
        Row: {
          email: string
          reason: string | null
          suppressed: boolean | null
          updated_at: string | null
        }
        Insert: {
          email: string
          reason?: string | null
          suppressed?: boolean | null
          updated_at?: string | null
        }
        Update: {
          email?: string
          reason?: string | null
          suppressed?: boolean | null
          updated_at?: string | null
        }
        Relationships: []
      }
      employee_documents: {
        Row: {
          bucket_id: string
          doc_type: string
          expires_at: string | null
          file_path: string
          id: string
          shop_id: string
          status: string
          uploaded_at: string
          user_id: string
        }
        Insert: {
          bucket_id?: string
          doc_type: string
          expires_at?: string | null
          file_path: string
          id?: string
          shop_id: string
          status?: string
          uploaded_at?: string
          user_id: string
        }
        Update: {
          bucket_id?: string
          doc_type?: string
          expires_at?: string | null
          file_path?: string
          id?: string
          shop_id?: string
          status?: string
          uploaded_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "employee_documents_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employee_documents_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "employee_documents_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      feature_reads: {
        Row: {
          feature_slug: string
          id: string
          last_read_at: string
          user_id: string
        }
        Insert: {
          feature_slug: string
          id?: string
          last_read_at?: string
          user_id: string
        }
        Update: {
          feature_slug?: string
          id?: string
          last_read_at?: string
          user_id?: string
        }
        Relationships: []
      }
      fleet_program_tasks: {
        Row: {
          created_at: string
          default_labor_hours: number | null
          description: string
          display_order: number
          id: string
          job_type: string
          program_id: string
          section_key: string | null
        }
        Insert: {
          created_at?: string
          default_labor_hours?: number | null
          description: string
          display_order?: number
          id?: string
          job_type?: string
          program_id: string
          section_key?: string | null
        }
        Update: {
          created_at?: string
          default_labor_hours?: number | null
          description?: string
          display_order?: number
          id?: string
          job_type?: string
          program_id?: string
          section_key?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fleet_program_tasks_program_id_fkey"
            columns: ["program_id"]
            isOneToOne: false
            referencedRelation: "fleet_programs"
            referencedColumns: ["id"]
          },
        ]
      }
      fleet_programs: {
        Row: {
          base_template_slug: string | null
          cadence: Database["public"]["Enums"]["fleet_program_cadence"]
          created_at: string
          fleet_id: string
          id: string
          include_custom_inspection: boolean
          interval_days: number | null
          interval_hours: number | null
          interval_km: number | null
          name: string
          notes: string | null
        }
        Insert: {
          base_template_slug?: string | null
          cadence: Database["public"]["Enums"]["fleet_program_cadence"]
          created_at?: string
          fleet_id: string
          id?: string
          include_custom_inspection?: boolean
          interval_days?: number | null
          interval_hours?: number | null
          interval_km?: number | null
          name: string
          notes?: string | null
        }
        Update: {
          base_template_slug?: string | null
          cadence?: Database["public"]["Enums"]["fleet_program_cadence"]
          created_at?: string
          fleet_id?: string
          id?: string
          include_custom_inspection?: boolean
          interval_days?: number | null
          interval_hours?: number | null
          interval_km?: number | null
          name?: string
          notes?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fleet_programs_fleet_id_fkey"
            columns: ["fleet_id"]
            isOneToOne: false
            referencedRelation: "fleets"
            referencedColumns: ["id"]
          },
        ]
      }
      fleet_vehicles: {
        Row: {
          active: boolean
          custom_interval_days: number | null
          custom_interval_hours: number | null
          custom_interval_km: number | null
          fleet_id: string
          nickname: string | null
          vehicle_id: string
        }
        Insert: {
          active?: boolean
          custom_interval_days?: number | null
          custom_interval_hours?: number | null
          custom_interval_km?: number | null
          fleet_id: string
          nickname?: string | null
          vehicle_id: string
        }
        Update: {
          active?: boolean
          custom_interval_days?: number | null
          custom_interval_hours?: number | null
          custom_interval_km?: number | null
          fleet_id?: string
          nickname?: string | null
          vehicle_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "fleet_vehicles_fleet_id_fkey"
            columns: ["fleet_id"]
            isOneToOne: false
            referencedRelation: "fleets"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fleet_vehicles_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      fleets: {
        Row: {
          contact_email: string | null
          contact_name: string | null
          created_at: string
          id: string
          name: string
          notes: string | null
          shop_id: string
        }
        Insert: {
          contact_email?: string | null
          contact_name?: string | null
          created_at?: string
          id?: string
          name: string
          notes?: string | null
          shop_id: string
        }
        Update: {
          contact_email?: string | null
          contact_name?: string | null
          created_at?: string
          id?: string
          name?: string
          notes?: string | null
          shop_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "fleets_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "fleets_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      followups: {
        Row: {
          created_at: string | null
          customer_id: string | null
          feature: string | null
          id: string
          send_at: string | null
          sent: boolean | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          customer_id?: string | null
          feature?: string | null
          id?: string
          send_at?: string | null
          sent?: boolean | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          customer_id?: string | null
          feature?: string | null
          id?: string
          send_at?: string | null
          sent?: boolean | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "followups_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
        ]
      }
      history: {
        Row: {
          created_at: string | null
          customer_id: string
          description: string | null
          id: string
          notes: string | null
          service_date: string
          vehicle_id: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          customer_id: string
          description?: string | null
          id?: string
          notes?: string | null
          service_date?: string
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          customer_id?: string
          description?: string | null
          id?: string
          notes?: string | null
          service_date?: string
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "history_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "history_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "history_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_items: {
        Row: {
          created_at: string | null
          id: string
          inspection_id: string | null
          label: string | null
          notes: string | null
          section: string | null
          status: string | null
          value: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          inspection_id?: string | null
          label?: string | null
          notes?: string | null
          section?: string | null
          status?: string | null
          value?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          inspection_id?: string | null
          label?: string | null
          notes?: string | null
          section?: string | null
          status?: string | null
          value?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "inspection_items_inspection_id_fkey"
            columns: ["inspection_id"]
            isOneToOne: false
            referencedRelation: "inspections"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_photos: {
        Row: {
          created_at: string | null
          id: string
          image_url: string
          inspection_id: string | null
          item_name: string | null
          notes: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          image_url: string
          inspection_id?: string | null
          item_name?: string | null
          notes?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          image_url?: string
          inspection_id?: string | null
          item_name?: string | null
          notes?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      inspection_result_items: {
        Row: {
          created_at: string
          item_label: string | null
          notes: string | null
          photo_urls: Json | null
          result_id: string
          section_title: string | null
          status: Database["public"]["Enums"]["inspection_item_status"] | null
          unit: string | null
          value: string | null
        }
        Insert: {
          created_at?: string
          item_label?: string | null
          notes?: string | null
          photo_urls?: Json | null
          result_id: string
          section_title?: string | null
          status?: Database["public"]["Enums"]["inspection_item_status"] | null
          unit?: string | null
          value?: string | null
        }
        Update: {
          created_at?: string
          item_label?: string | null
          notes?: string | null
          photo_urls?: Json | null
          result_id?: string
          section_title?: string | null
          status?: Database["public"]["Enums"]["inspection_item_status"] | null
          unit?: string | null
          value?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "inspection_result_items_result_id_fkey"
            columns: ["result_id"]
            isOneToOne: false
            referencedRelation: "inspection_results"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_results: {
        Row: {
          created_at: string
          customer: Json | null
          finished_at: string
          id: string
          quote: Json | null
          sections: Json
          session_id: string
          template_name: string | null
          vehicle: Json | null
          work_order_line_id: string
        }
        Insert: {
          created_at?: string
          customer?: Json | null
          finished_at?: string
          id?: string
          quote?: Json | null
          sections: Json
          session_id: string
          template_name?: string | null
          vehicle?: Json | null
          work_order_line_id: string
        }
        Update: {
          created_at?: string
          customer?: Json | null
          finished_at?: string
          id?: string
          quote?: Json | null
          sections?: Json
          session_id?: string
          template_name?: string | null
          vehicle?: Json | null
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "inspection_results_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_session_payloads: {
        Row: {
          payload: Json
          session_id: string
          updated_at: string
        }
        Insert: {
          payload: Json
          session_id: string
          updated_at?: string
        }
        Update: {
          payload?: Json
          session_id?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "inspection_session_payloads_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: true
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_sessions: {
        Row: {
          completed_at: string | null
          created_by: string | null
          customer_id: string | null
          id: string
          state: Json | null
          status: string
          template: string | null
          updated_at: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_id: string | null
          work_order_line_id: string | null
        }
        Insert: {
          completed_at?: string | null
          created_by?: string | null
          customer_id?: string | null
          id?: string
          state?: Json | null
          status?: string
          template?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
          work_order_line_id?: string | null
        }
        Update: {
          completed_at?: string | null
          created_by?: string | null
          customer_id?: string | null
          id?: string
          state?: Json | null
          status?: string
          template?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
          work_order_line_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "inspection_sessions_created_by_fk"
            columns: ["created_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_fk"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_line_fk"
            columns: ["work_order_line_id"]
            isOneToOne: true
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_line_fk"
            columns: ["work_order_line_id"]
            isOneToOne: true
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: true
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspection_sessions_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: true
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      inspection_templates: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          is_public: boolean | null
          labor_hours: number | null
          sections: Json
          tags: string[] | null
          template_name: string
          updated_at: string | null
          user_id: string | null
          vehicle_type: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          is_public?: boolean | null
          labor_hours?: number | null
          sections: Json
          tags?: string[] | null
          template_name: string
          updated_at?: string | null
          user_id?: string | null
          vehicle_type?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          is_public?: boolean | null
          labor_hours?: number | null
          sections?: Json
          tags?: string[] | null
          template_name?: string
          updated_at?: string | null
          user_id?: string | null
          vehicle_type?: string | null
        }
        Relationships: []
      }
      inspections: {
        Row: {
          ai_summary: string | null
          completed: boolean | null
          created_at: string | null
          id: string
          inspection_type: string | null
          is_draft: boolean | null
          location: string | null
          notes: string | null
          pdf_url: string | null
          photo_urls: string[] | null
          quote_id: string | null
          shop_id: string | null
          started_at: string | null
          status: string | null
          summary: Json | null
          template_id: string | null
          updated_at: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_id: string | null
        }
        Insert: {
          ai_summary?: string | null
          completed?: boolean | null
          created_at?: string | null
          id?: string
          inspection_type?: string | null
          is_draft?: boolean | null
          location?: string | null
          notes?: string | null
          pdf_url?: string | null
          photo_urls?: string[] | null
          quote_id?: string | null
          shop_id?: string | null
          started_at?: string | null
          status?: string | null
          summary?: Json | null
          template_id?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          ai_summary?: string | null
          completed?: boolean | null
          created_at?: string | null
          id?: string
          inspection_type?: string | null
          is_draft?: boolean | null
          location?: string | null
          notes?: string | null
          pdf_url?: string | null
          photo_urls?: string[] | null
          quote_id?: string | null
          shop_id?: string | null
          started_at?: string | null
          status?: string | null
          summary?: Json | null
          template_id?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "inspections_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "inspection_templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspections_user_fk"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspections_vehicle_fk"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspections_work_order_fk"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "inspections_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      integration_logs: {
        Row: {
          action: string
          created_at: string
          error_message: string | null
          id: string
          provider: string
          request: Json | null
          response: Json | null
          shop_id: string | null
          success: boolean
        }
        Insert: {
          action: string
          created_at?: string
          error_message?: string | null
          id?: string
          provider: string
          request?: Json | null
          response?: Json | null
          shop_id?: string | null
          success?: boolean
        }
        Update: {
          action?: string
          created_at?: string
          error_message?: string | null
          id?: string
          provider?: string
          request?: Json | null
          response?: Json | null
          shop_id?: string | null
          success?: boolean
        }
        Relationships: [
          {
            foreignKeyName: "integration_logs_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "integration_logs_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      integrations: {
        Row: {
          config: Json | null
          created_at: string
          id: string
          provider: string
          shop_id: string | null
          status: string
          updated_at: string
        }
        Insert: {
          config?: Json | null
          created_at?: string
          id?: string
          provider: string
          shop_id?: string | null
          status?: string
          updated_at?: string
        }
        Update: {
          config?: Json | null
          created_at?: string
          id?: string
          provider?: string
          shop_id?: string | null
          status?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "integrations_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "integrations_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      media_uploads: {
        Row: {
          analysis_summary: string | null
          audio_url: string | null
          created_at: string | null
          file_type: string | null
          file_url: string | null
          id: string
          inspection_id: string | null
          user_id: string | null
          work_order_id: string | null
        }
        Insert: {
          analysis_summary?: string | null
          audio_url?: string | null
          created_at?: string | null
          file_type?: string | null
          file_url?: string | null
          id?: string
          inspection_id?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          analysis_summary?: string | null
          audio_url?: string | null
          created_at?: string | null
          file_type?: string | null
          file_url?: string | null
          id?: string
          inspection_id?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "media_uploads_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      menu_item_parts: {
        Row: {
          created_at: string | null
          id: string
          menu_item_id: string
          name: string
          quantity: number
          unit_cost: number
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          menu_item_id: string
          name: string
          quantity?: number
          unit_cost?: number
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          menu_item_id?: string
          name?: string
          quantity?: number
          unit_cost?: number
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "menu_item_parts_menu_item_id_fkey"
            columns: ["menu_item_id"]
            isOneToOne: false
            referencedRelation: "menu_items"
            referencedColumns: ["id"]
          },
        ]
      }
      menu_items: {
        Row: {
          category: string | null
          cause: string | null
          complaint: string | null
          correction: string | null
          created_at: string | null
          description: string | null
          id: string
          inspection_template_id: string | null
          is_active: boolean | null
          labor_hours: number | null
          labor_time: number | null
          name: string | null
          part_cost: number | null
          shop_id: string | null
          tools: string | null
          total_price: number | null
          user_id: string | null
        }
        Insert: {
          category?: string | null
          cause?: string | null
          complaint?: string | null
          correction?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          inspection_template_id?: string | null
          is_active?: boolean | null
          labor_hours?: number | null
          labor_time?: number | null
          name?: string | null
          part_cost?: number | null
          shop_id?: string | null
          tools?: string | null
          total_price?: number | null
          user_id?: string | null
        }
        Update: {
          category?: string | null
          cause?: string | null
          complaint?: string | null
          correction?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          inspection_template_id?: string | null
          is_active?: boolean | null
          labor_hours?: number | null
          labor_time?: number | null
          name?: string | null
          part_cost?: number | null
          shop_id?: string | null
          tools?: string | null
          total_price?: number | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "menu_items_inspection_template_id_fkey"
            columns: ["inspection_template_id"]
            isOneToOne: false
            referencedRelation: "inspection_templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "menu_items_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "menu_items_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      menu_pricing: {
        Row: {
          created_at: string | null
          description: string | null
          estimated_labor_minutes: number | null
          id: string
          labor_rate: number | null
          part_cost: number | null
          service_name: string | null
          user_id: string | null
          vehicle_make: string | null
          vehicle_model: string | null
          vehicle_year: number | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          estimated_labor_minutes?: number | null
          id?: string
          labor_rate?: number | null
          part_cost?: number | null
          service_name?: string | null
          user_id?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: number | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          estimated_labor_minutes?: number | null
          id?: string
          labor_rate?: number | null
          part_cost?: number | null
          service_name?: string | null
          user_id?: string | null
          vehicle_make?: string | null
          vehicle_model?: string | null
          vehicle_year?: number | null
        }
        Relationships: []
      }
      message_reads: {
        Row: {
          conversation_id: string
          id: string
          last_read_at: string
          user_id: string
        }
        Insert: {
          conversation_id: string
          id?: string
          last_read_at?: string
          user_id: string
        }
        Update: {
          conversation_id?: string
          id?: string
          last_read_at?: string
          user_id?: string
        }
        Relationships: []
      }
      messages: {
        Row: {
          attachments: Json
          content: string
          conversation_id: string | null
          created_at: string
          deleted_at: string | null
          edited_at: string | null
          id: string
          metadata: Json
          recipients: string[]
          reply_to: string | null
          sender_id: string | null
          sent_at: string | null
        }
        Insert: {
          attachments?: Json
          content: string
          conversation_id?: string | null
          created_at?: string
          deleted_at?: string | null
          edited_at?: string | null
          id?: string
          metadata?: Json
          recipients?: string[]
          reply_to?: string | null
          sender_id?: string | null
          sent_at?: string | null
        }
        Update: {
          attachments?: Json
          content?: string
          conversation_id?: string | null
          created_at?: string
          deleted_at?: string | null
          edited_at?: string | null
          id?: string
          metadata?: Json
          recipients?: string[]
          reply_to?: string | null
          sender_id?: string | null
          sent_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "messages_conversation_id_fkey"
            columns: ["conversation_id"]
            isOneToOne: false
            referencedRelation: "conversations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_reply_to_fkey"
            columns: ["reply_to"]
            isOneToOne: false
            referencedRelation: "messages"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_reply_to_fkey"
            columns: ["reply_to"]
            isOneToOne: false
            referencedRelation: "v_my_messages"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_sender_id_fkey"
            columns: ["sender_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      notifications: {
        Row: {
          body: string | null
          created_at: string | null
          data: Json | null
          id: string
          is_read: boolean | null
          kind: string
          title: string
          user_id: string
        }
        Insert: {
          body?: string | null
          created_at?: string | null
          data?: Json | null
          id?: string
          is_read?: boolean | null
          kind: string
          title: string
          user_id: string
        }
        Update: {
          body?: string | null
          created_at?: string | null
          data?: Json | null
          id?: string
          is_read?: boolean | null
          kind?: string
          title?: string
          user_id?: string
        }
        Relationships: []
      }
      part_barcodes: {
        Row: {
          barcode: string
          id: string
          kind: string | null
          part_id: string
        }
        Insert: {
          barcode: string
          id?: string
          kind?: string | null
          part_id: string
        }
        Update: {
          barcode?: string
          id?: string
          kind?: string | null
          part_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "part_barcodes_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_barcodes_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      part_compatibility: {
        Row: {
          created_at: string | null
          id: string
          make: string
          model: string
          part_id: string | null
          shop_id: string | null
          year_range: unknown
        }
        Insert: {
          created_at?: string | null
          id?: string
          make: string
          model: string
          part_id?: string | null
          shop_id?: string | null
          year_range?: unknown
        }
        Update: {
          created_at?: string | null
          id?: string
          make?: string
          model?: string
          part_id?: string | null
          shop_id?: string | null
          year_range?: unknown
        }
        Relationships: [
          {
            foreignKeyName: "part_compatibility_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_compatibility_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      part_purchases: {
        Row: {
          id: string
          part_id: string | null
          purchase_price: number | null
          purchased_at: string | null
          quantity: number
          shop_id: string | null
          supplier_id: string | null
        }
        Insert: {
          id?: string
          part_id?: string | null
          purchase_price?: number | null
          purchased_at?: string | null
          quantity: number
          shop_id?: string | null
          supplier_id?: string | null
        }
        Update: {
          id?: string
          part_id?: string | null
          purchase_price?: number | null
          purchased_at?: string | null
          quantity?: number
          shop_id?: string | null
          supplier_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "part_purchases_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_purchases_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_purchases_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "part_suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      part_request_items: {
        Row: {
          approved: boolean
          description: string
          id: string
          markup_pct: number | null
          part_id: string | null
          qty: number
          quoted_price: number | null
          request_id: string
          vendor: string | null
          work_order_line_id: string | null
        }
        Insert: {
          approved?: boolean
          description: string
          id?: string
          markup_pct?: number | null
          part_id?: string | null
          qty: number
          quoted_price?: number | null
          request_id: string
          vendor?: string | null
          work_order_line_id?: string | null
        }
        Update: {
          approved?: boolean
          description?: string
          id?: string
          markup_pct?: number | null
          part_id?: string | null
          qty?: number
          quoted_price?: number | null
          request_id?: string
          vendor?: string | null
          work_order_line_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "part_request_items_request_id_fkey"
            columns: ["request_id"]
            isOneToOne: false
            referencedRelation: "part_requests"
            referencedColumns: ["id"]
          },
        ]
      }
      part_request_lines: {
        Row: {
          created_at: string
          id: string
          request_id: string
          work_order_line_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          request_id: string
          work_order_line_id: string
        }
        Update: {
          created_at?: string
          id?: string
          request_id?: string
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "part_request_lines_request_id_fkey"
            columns: ["request_id"]
            isOneToOne: false
            referencedRelation: "part_requests"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_request_lines_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_request_lines_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      part_requests: {
        Row: {
          assigned_to: string | null
          created_at: string
          id: string
          notes: string | null
          requested_by: string | null
          shop_id: string
          status: Database["public"]["Enums"]["part_request_status"]
          work_order_id: string | null
        }
        Insert: {
          assigned_to?: string | null
          created_at?: string
          id?: string
          notes?: string | null
          requested_by?: string | null
          shop_id: string
          status?: Database["public"]["Enums"]["part_request_status"]
          work_order_id?: string | null
        }
        Update: {
          assigned_to?: string | null
          created_at?: string
          id?: string
          notes?: string | null
          requested_by?: string | null
          shop_id?: string
          status?: Database["public"]["Enums"]["part_request_status"]
          work_order_id?: string | null
        }
        Relationships: []
      }
      part_returns: {
        Row: {
          id: string
          part_id: string | null
          quantity: number
          reason: string | null
          returned_at: string | null
          returned_by: string | null
          shop_id: string | null
        }
        Insert: {
          id?: string
          part_id?: string | null
          quantity?: number
          reason?: string | null
          returned_at?: string | null
          returned_by?: string | null
          shop_id?: string | null
        }
        Update: {
          id?: string
          part_id?: string | null
          quantity?: number
          reason?: string | null
          returned_at?: string | null
          returned_by?: string | null
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "part_returns_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_returns_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      part_stock: {
        Row: {
          id: string
          location_id: string
          part_id: string
          qty_on_hand: number
          qty_reserved: number
          reorder_point: number | null
          reorder_qty: number | null
        }
        Insert: {
          id?: string
          location_id: string
          part_id: string
          qty_on_hand?: number
          qty_reserved?: number
          reorder_point?: number | null
          reorder_qty?: number | null
        }
        Update: {
          id?: string
          location_id?: string
          part_id?: string
          qty_on_hand?: number
          qty_reserved?: number
          reorder_point?: number | null
          reorder_qty?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "part_stock_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_stock_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_stock_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      part_suppliers: {
        Row: {
          contact_info: string | null
          created_at: string | null
          id: string
          name: string
          shop_id: string | null
        }
        Insert: {
          contact_info?: string | null
          created_at?: string | null
          id?: string
          name: string
          shop_id?: string | null
        }
        Update: {
          contact_info?: string | null
          created_at?: string | null
          id?: string
          name?: string
          shop_id?: string | null
        }
        Relationships: []
      }
      part_warranties: {
        Row: {
          coverage_details: string | null
          created_at: string | null
          id: string
          part_id: string | null
          shop_id: string | null
          warranty_period_months: number | null
          warranty_provider: string | null
        }
        Insert: {
          coverage_details?: string | null
          created_at?: string | null
          id?: string
          part_id?: string | null
          shop_id?: string | null
          warranty_period_months?: number | null
          warranty_provider?: string | null
        }
        Update: {
          coverage_details?: string | null
          created_at?: string | null
          id?: string
          part_id?: string | null
          shop_id?: string | null
          warranty_period_months?: number | null
          warranty_provider?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "part_warranties_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_warranties_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      parts: {
        Row: {
          category: string | null
          cost: number | null
          created_at: string | null
          default_cost: number | null
          default_price: number | null
          description: string | null
          id: string
          low_stock_threshold: number | null
          name: string
          part_number: string | null
          price: number | null
          shop_id: string | null
          sku: string | null
          subcategory: string | null
          supplier: string | null
          taxable: boolean | null
          unit: string | null
          warranty_months: number | null
        }
        Insert: {
          category?: string | null
          cost?: number | null
          created_at?: string | null
          default_cost?: number | null
          default_price?: number | null
          description?: string | null
          id?: string
          low_stock_threshold?: number | null
          name: string
          part_number?: string | null
          price?: number | null
          shop_id?: string | null
          sku?: string | null
          subcategory?: string | null
          supplier?: string | null
          taxable?: boolean | null
          unit?: string | null
          warranty_months?: number | null
        }
        Update: {
          category?: string | null
          cost?: number | null
          created_at?: string | null
          default_cost?: number | null
          default_price?: number | null
          description?: string | null
          id?: string
          low_stock_threshold?: number | null
          name?: string
          part_number?: string | null
          price?: number | null
          shop_id?: string | null
          sku?: string | null
          subcategory?: string | null
          supplier?: string | null
          taxable?: boolean | null
          unit?: string | null
          warranty_months?: number | null
        }
        Relationships: []
      }
      parts_barcodes: {
        Row: {
          barcode: string
          code: string | null
          created_at: string
          id: string
          part_id: string
          shop_id: string
          supplier_id: string | null
        }
        Insert: {
          barcode: string
          code?: string | null
          created_at?: string
          id?: string
          part_id: string
          shop_id: string
          supplier_id?: string | null
        }
        Update: {
          barcode?: string
          code?: string | null
          created_at?: string
          id?: string
          part_id?: string
          shop_id?: string
          supplier_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_barcodes_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "parts_barcodes_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_barcodes_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_messages: {
        Row: {
          created_at: string | null
          id: string
          message: string
          recipient_role: string | null
          request_id: string | null
          sender_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          message: string
          recipient_role?: string | null
          request_id?: string | null
          sender_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          message?: string
          recipient_role?: string | null
          request_id?: string | null
          sender_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_messages_request_id_fkey"
            columns: ["request_id"]
            isOneToOne: false
            referencedRelation: "parts_requests"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_quote_requests: {
        Row: {
          created_at: string
          id: string
          notes: string | null
          requested_by: string | null
          status: Database["public"]["Enums"]["quote_request_status"]
          updated_at: string
          work_order_id: string
          work_order_line_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          notes?: string | null
          requested_by?: string | null
          status?: Database["public"]["Enums"]["quote_request_status"]
          updated_at?: string
          work_order_id: string
          work_order_line_id: string
        }
        Update: {
          created_at?: string
          id?: string
          notes?: string | null
          requested_by?: string | null
          status?: Database["public"]["Enums"]["quote_request_status"]
          updated_at?: string
          work_order_id?: string
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "parts_quote_requests_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_quote_requests_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_quote_requests_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_quotes: {
        Row: {
          created_at: string | null
          id: string
          part_name: string | null
          part_number: string | null
          price: number | null
          quantity: number | null
          source: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          part_name?: string | null
          part_number?: string | null
          price?: number | null
          quantity?: number | null
          source?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          part_name?: string | null
          part_number?: string | null
          price?: number | null
          quantity?: number | null
          source?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_quotes_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_request_messages: {
        Row: {
          created_at: string | null
          id: string
          message: string
          request_id: string | null
          sender_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          message: string
          request_id?: string | null
          sender_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          message?: string
          request_id?: string | null
          sender_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_request_messages_request_id_fkey"
            columns: ["request_id"]
            isOneToOne: false
            referencedRelation: "parts_requests"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_requests: {
        Row: {
          archived: boolean | null
          created_at: string | null
          fulfilled_at: string | null
          id: string
          job_id: string | null
          notes: string | null
          part_name: string
          photo_url: string | null
          photo_urls: string[] | null
          quantity: number
          requested_by: string | null
          sent_at: string | null
          urgency: string | null
          viewed: boolean | null
          viewed_at: string | null
          work_order_id: string | null
        }
        Insert: {
          archived?: boolean | null
          created_at?: string | null
          fulfilled_at?: string | null
          id?: string
          job_id?: string | null
          notes?: string | null
          part_name: string
          photo_url?: string | null
          photo_urls?: string[] | null
          quantity?: number
          requested_by?: string | null
          sent_at?: string | null
          urgency?: string | null
          viewed?: boolean | null
          viewed_at?: string | null
          work_order_id?: string | null
        }
        Update: {
          archived?: boolean | null
          created_at?: string | null
          fulfilled_at?: string | null
          id?: string
          job_id?: string | null
          notes?: string | null
          part_name?: string
          photo_url?: string | null
          photo_urls?: string[] | null
          quantity?: number
          requested_by?: string | null
          sent_at?: string | null
          urgency?: string | null
          viewed?: boolean | null
          viewed_at?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "parts_requests_job_id_fkey"
            columns: ["job_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_requests_job_id_fkey"
            columns: ["job_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_requests_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      parts_suppliers: {
        Row: {
          api_base_url: string | null
          api_key: string | null
          created_at: string | null
          id: string
          shop_id: string | null
          supplier_name: string
        }
        Insert: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          shop_id?: string | null
          supplier_name: string
        }
        Update: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          shop_id?: string | null
          supplier_name?: string
        }
        Relationships: [
          {
            foreignKeyName: "parts_suppliers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "parts_suppliers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_deductions: {
        Row: {
          amount: number
          created_at: string | null
          deduction_type: string
          id: string
          timecard_id: string | null
        }
        Insert: {
          amount: number
          created_at?: string | null
          deduction_type: string
          id?: string
          timecard_id?: string | null
        }
        Update: {
          amount?: number
          created_at?: string | null
          deduction_type?: string
          id?: string
          timecard_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "payroll_deductions_timecard_id_fkey"
            columns: ["timecard_id"]
            isOneToOne: false
            referencedRelation: "payroll_timecards"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_export_log: {
        Row: {
          created_at: string | null
          id: string
          message: string | null
          pay_period_id: string | null
          provider_id: string | null
          status: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          message?: string | null
          pay_period_id?: string | null
          provider_id?: string | null
          status: string
        }
        Update: {
          created_at?: string | null
          id?: string
          message?: string | null
          pay_period_id?: string | null
          provider_id?: string | null
          status?: string
        }
        Relationships: [
          {
            foreignKeyName: "payroll_export_log_pay_period_id_fkey"
            columns: ["pay_period_id"]
            isOneToOne: false
            referencedRelation: "payroll_pay_periods"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_export_log_provider_id_fkey"
            columns: ["provider_id"]
            isOneToOne: false
            referencedRelation: "payroll_providers"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_pay_periods: {
        Row: {
          created_at: string | null
          end_date: string
          id: string
          processed: boolean | null
          shop_id: string | null
          start_date: string
        }
        Insert: {
          created_at?: string | null
          end_date: string
          id?: string
          processed?: boolean | null
          shop_id?: string | null
          start_date: string
        }
        Update: {
          created_at?: string | null
          end_date?: string
          id?: string
          processed?: boolean | null
          shop_id?: string | null
          start_date?: string
        }
        Relationships: [
          {
            foreignKeyName: "payroll_pay_periods_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_pay_periods_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_providers: {
        Row: {
          api_base_url: string | null
          api_key: string | null
          created_at: string | null
          id: string
          provider_name: string
          shop_id: string | null
        }
        Insert: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          provider_name: string
          shop_id?: string | null
        }
        Update: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          provider_name?: string
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "payroll_providers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_providers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      payroll_timecards: {
        Row: {
          clock_in: string
          clock_out: string | null
          created_at: string | null
          hours_worked: number | null
          id: string
          shop_id: string | null
          user_id: string | null
        }
        Insert: {
          clock_in: string
          clock_out?: string | null
          created_at?: string | null
          hours_worked?: number | null
          id?: string
          shop_id?: string | null
          user_id?: string | null
        }
        Update: {
          clock_in?: string
          clock_out?: string | null
          created_at?: string | null
          hours_worked?: number | null
          id?: string
          shop_id?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "payroll_timecards_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_timecards_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "payroll_timecards_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      profiles: {
        Row: {
          agent_role: string | null
          business_name: string | null
          city: string | null
          completed_onboarding: boolean
          created_at: string | null
          created_by: string | null
          email: string | null
          full_name: string | null
          id: string
          last_active_at: string | null
          must_change_password: boolean
          phone: string | null
          plan: Database["public"]["Enums"]["plan_t"] | null
          postal_code: string | null
          province: string | null
          role: string | null
          shop_id: string | null
          shop_name: string | null
          street: string | null
          updated_at: string | null
          user_id: string | null
          username: string | null
        }
        Insert: {
          agent_role?: string | null
          business_name?: string | null
          city?: string | null
          completed_onboarding?: boolean
          created_at?: string | null
          created_by?: string | null
          email?: string | null
          full_name?: string | null
          id: string
          last_active_at?: string | null
          must_change_password?: boolean
          phone?: string | null
          plan?: Database["public"]["Enums"]["plan_t"] | null
          postal_code?: string | null
          province?: string | null
          role?: string | null
          shop_id?: string | null
          shop_name?: string | null
          street?: string | null
          updated_at?: string | null
          user_id?: string | null
          username?: string | null
        }
        Update: {
          agent_role?: string | null
          business_name?: string | null
          city?: string | null
          completed_onboarding?: boolean
          created_at?: string | null
          created_by?: string | null
          email?: string | null
          full_name?: string | null
          id?: string
          last_active_at?: string | null
          must_change_password?: boolean
          phone?: string | null
          plan?: Database["public"]["Enums"]["plan_t"] | null
          postal_code?: string | null
          province?: string | null
          role?: string | null
          shop_id?: string | null
          shop_name?: string | null
          street?: string | null
          updated_at?: string | null
          user_id?: string | null
          username?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      punch_events: {
        Row: {
          created_at: string | null
          event_type: string
          id: string
          note: string | null
          profile_id: string | null
          shift_id: string | null
          timestamp: string
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          event_type: string
          id?: string
          note?: string | null
          profile_id?: string | null
          shift_id?: string | null
          timestamp?: string
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          event_type?: string
          id?: string
          note?: string | null
          profile_id?: string | null
          shift_id?: string | null
          timestamp?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "punch_events_shift_id_fkey"
            columns: ["shift_id"]
            isOneToOne: false
            referencedRelation: "tech_shifts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "punch_events_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      purchase_order_items: {
        Row: {
          description: string | null
          id: string
          location_id: string | null
          part_id: string
          po_id: string
          qty_ordered: number
          qty_received: number
          unit_cost: number
        }
        Insert: {
          description?: string | null
          id?: string
          location_id?: string | null
          part_id: string
          po_id: string
          qty_ordered: number
          qty_received?: number
          unit_cost?: number
        }
        Update: {
          description?: string | null
          id?: string
          location_id?: string | null
          part_id?: string
          po_id?: string
          qty_ordered?: number
          qty_received?: number
          unit_cost?: number
        }
        Relationships: [
          {
            foreignKeyName: "purchase_order_items_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "purchase_order_items_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "purchase_order_items_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "purchase_order_items_po_id_fkey"
            columns: ["po_id"]
            isOneToOne: false
            referencedRelation: "purchase_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      purchase_order_lines: {
        Row: {
          created_at: string
          description: string | null
          id: string
          location_id: string | null
          part_id: string | null
          po_id: string
          qty: number
          received_qty: number
          sku: string | null
          unit_cost: number | null
        }
        Insert: {
          created_at?: string
          description?: string | null
          id?: string
          location_id?: string | null
          part_id?: string | null
          po_id: string
          qty: number
          received_qty?: number
          sku?: string | null
          unit_cost?: number | null
        }
        Update: {
          created_at?: string
          description?: string | null
          id?: string
          location_id?: string | null
          part_id?: string | null
          po_id?: string
          qty?: number
          received_qty?: number
          sku?: string | null
          unit_cost?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "purchase_order_lines_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "purchase_order_lines_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "purchase_order_lines_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "purchase_order_lines_po_id_fkey"
            columns: ["po_id"]
            isOneToOne: false
            referencedRelation: "purchase_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      purchase_orders: {
        Row: {
          created_at: string
          created_by: string | null
          expected_at: string | null
          id: string
          ordered_at: string | null
          received_at: string | null
          shipping_total: number | null
          shop_id: string
          status: string
          subtotal: number | null
          supplier_id: string
          tax_total: number | null
          total: number | null
        }
        Insert: {
          created_at?: string
          created_by?: string | null
          expected_at?: string | null
          id?: string
          ordered_at?: string | null
          received_at?: string | null
          shipping_total?: number | null
          shop_id: string
          status?: string
          subtotal?: number | null
          supplier_id: string
          tax_total?: number | null
          total?: number | null
        }
        Update: {
          created_at?: string
          created_by?: string | null
          expected_at?: string | null
          id?: string
          ordered_at?: string | null
          received_at?: string | null
          shipping_total?: number | null
          shop_id?: string
          status?: string
          subtotal?: number | null
          supplier_id?: string
          tax_total?: number | null
          total?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "purchase_orders_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      quote_lines: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          item: string | null
          labor_rate: number | null
          labor_time: number | null
          name: string | null
          notes: string | null
          part: Json | null
          part_name: string | null
          part_price: number | null
          parts_cost: number | null
          photo_urls: string[] | null
          price: number | null
          quantity: number | null
          status: string | null
          title: string
          total: number | null
          updated_at: string | null
          user_id: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          item?: string | null
          labor_rate?: number | null
          labor_time?: number | null
          name?: string | null
          notes?: string | null
          part?: Json | null
          part_name?: string | null
          part_price?: number | null
          parts_cost?: number | null
          photo_urls?: string[] | null
          price?: number | null
          quantity?: number | null
          status?: string | null
          title: string
          total?: number | null
          updated_at?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          item?: string | null
          labor_rate?: number | null
          labor_time?: number | null
          name?: string | null
          notes?: string | null
          part?: Json | null
          part_name?: string | null
          part_price?: number | null
          parts_cost?: number | null
          photo_urls?: string[] | null
          price?: number | null
          quantity?: number | null
          status?: string | null
          title?: string
          total?: number | null
          updated_at?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "quote_lines_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      saved_menu_items: {
        Row: {
          created_at: string
          id: string
          labor_time: number | null
          make: string
          model: string
          parts: Json
          title: string
          updated_at: string
          year_bucket: string
        }
        Insert: {
          created_at?: string
          id?: string
          labor_time?: number | null
          make: string
          model: string
          parts?: Json
          title: string
          updated_at?: string
          year_bucket: string
        }
        Update: {
          created_at?: string
          id?: string
          labor_time?: number | null
          make?: string
          model?: string
          parts?: Json
          title?: string
          updated_at?: string
          year_bucket?: string
        }
        Relationships: []
      }
      shop_ai_profiles: {
        Row: {
          last_refreshed_at: string
          shop_id: string
          summary: Json
        }
        Insert: {
          last_refreshed_at?: string
          shop_id: string
          summary: Json
        }
        Update: {
          last_refreshed_at?: string
          shop_id?: string
          summary?: Json
        }
        Relationships: [
          {
            foreignKeyName: "shop_ai_profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: true
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_ai_profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: true
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_hours: {
        Row: {
          close_time: string
          id: string
          open_time: string
          shop_id: string | null
          weekday: number
        }
        Insert: {
          close_time: string
          id?: string
          open_time: string
          shop_id?: string | null
          weekday: number
        }
        Update: {
          close_time?: string
          id?: string
          open_time?: string
          shop_id?: string | null
          weekday?: number
        }
        Relationships: [
          {
            foreignKeyName: "shop_hours_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_hours_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_parts: {
        Row: {
          created_at: string | null
          id: string
          location: string | null
          part_id: string | null
          quantity: number
          restock_threshold: number | null
          shop_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          location?: string | null
          part_id?: string | null
          quantity?: number
          restock_threshold?: number | null
          shop_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          location?: string | null
          part_id?: string | null
          quantity?: number
          restock_threshold?: number | null
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "shop_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "shop_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_profiles: {
        Row: {
          address_line1: string | null
          address_line2: string | null
          city: string | null
          country: string | null
          created_at: string
          description: string | null
          email: string | null
          hours: Json | null
          images: string[] | null
          latitude: number | null
          longitude: number | null
          phone: string | null
          postal_code: string | null
          province: string | null
          shop_id: string
          tagline: string | null
          updated_at: string
          website: string | null
        }
        Insert: {
          address_line1?: string | null
          address_line2?: string | null
          city?: string | null
          country?: string | null
          created_at?: string
          description?: string | null
          email?: string | null
          hours?: Json | null
          images?: string[] | null
          latitude?: number | null
          longitude?: number | null
          phone?: string | null
          postal_code?: string | null
          province?: string | null
          shop_id: string
          tagline?: string | null
          updated_at?: string
          website?: string | null
        }
        Update: {
          address_line1?: string | null
          address_line2?: string | null
          city?: string | null
          country?: string | null
          created_at?: string
          description?: string | null
          email?: string | null
          hours?: Json | null
          images?: string[] | null
          latitude?: number | null
          longitude?: number | null
          phone?: string | null
          postal_code?: string | null
          province?: string | null
          shop_id?: string
          tagline?: string | null
          updated_at?: string
          website?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "shop_profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: true
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_profiles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: true
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_ratings: {
        Row: {
          comment: string | null
          created_at: string
          customer_id: string
          id: string
          score: number
          shop_id: string
          updated_at: string
        }
        Insert: {
          comment?: string | null
          created_at?: string
          customer_id: string
          id?: string
          score: number
          shop_id: string
          updated_at?: string
        }
        Update: {
          comment?: string | null
          created_at?: string
          customer_id?: string
          id?: string
          score?: number
          shop_id?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "shop_ratings_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_ratings_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_ratings_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_reviews: {
        Row: {
          comment: string | null
          created_at: string
          customer_id: string | null
          id: string
          rating: number
          replied_at: string | null
          reviewer_user_id: string
          shop_id: string
          shop_owner_reply: string | null
          updated_at: string
        }
        Insert: {
          comment?: string | null
          created_at?: string
          customer_id?: string | null
          id?: string
          rating: number
          replied_at?: string | null
          reviewer_user_id: string
          shop_id: string
          shop_owner_reply?: string | null
          updated_at?: string
        }
        Update: {
          comment?: string | null
          created_at?: string
          customer_id?: string | null
          id?: string
          rating?: number
          replied_at?: string | null
          reviewer_user_id?: string
          shop_id?: string
          shop_owner_reply?: string | null
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "shop_reviews_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_reviews_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_reviews_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_schedules: {
        Row: {
          booked_by: string | null
          created_at: string | null
          date: string
          id: string
          is_booked: boolean | null
          shop_id: string | null
          time_slot: string
        }
        Insert: {
          booked_by?: string | null
          created_at?: string | null
          date: string
          id?: string
          is_booked?: boolean | null
          shop_id?: string | null
          time_slot: string
        }
        Update: {
          booked_by?: string | null
          created_at?: string | null
          date?: string
          id?: string
          is_booked?: boolean | null
          shop_id?: string | null
          time_slot?: string
        }
        Relationships: [
          {
            foreignKeyName: "shop_schedules_booked_by_fkey"
            columns: ["booked_by"]
            isOneToOne: false
            referencedRelation: "customer_bookings"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_settings: {
        Row: {
          allow_customer_quotes: boolean | null
          allow_self_booking: boolean | null
          created_at: string | null
          id: string
          province: string | null
          timezone: string | null
          user_id: string | null
        }
        Insert: {
          allow_customer_quotes?: boolean | null
          allow_self_booking?: boolean | null
          created_at?: string | null
          id?: string
          province?: string | null
          timezone?: string | null
          user_id?: string | null
        }
        Update: {
          allow_customer_quotes?: boolean | null
          allow_self_booking?: boolean | null
          created_at?: string | null
          id?: string
          province?: string | null
          timezone?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      shop_tax_overrides: {
        Row: {
          created_at: string | null
          id: string
          override_rate: number
          shop_id: string | null
          tax_rate_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          override_rate: number
          shop_id?: string | null
          tax_rate_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          override_rate?: number
          shop_id?: string | null
          tax_rate_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "shop_tax_overrides_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_tax_overrides_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_tax_overrides_tax_rate_id_fkey"
            columns: ["tax_rate_id"]
            isOneToOne: false
            referencedRelation: "tax_rates"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_time_off: {
        Row: {
          ends_at: string
          id: string
          reason: string | null
          shop_id: string | null
          starts_at: string
        }
        Insert: {
          ends_at: string
          id?: string
          reason?: string | null
          shop_id?: string | null
          starts_at: string
        }
        Update: {
          ends_at?: string
          id?: string
          reason?: string | null
          shop_id?: string | null
          starts_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "shop_time_off_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_time_off_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      shop_time_slots: {
        Row: {
          created_at: string | null
          end_time: string
          id: string
          is_booked: boolean | null
          shop_id: string | null
          start_time: string
        }
        Insert: {
          created_at?: string | null
          end_time: string
          id?: string
          is_booked?: boolean | null
          shop_id?: string | null
          start_time: string
        }
        Update: {
          created_at?: string | null
          end_time?: string
          id?: string
          is_booked?: boolean | null
          shop_id?: string | null
          start_time?: string
        }
        Relationships: []
      }
      shops: {
        Row: {
          accepts_online_booking: boolean | null
          active_user_count: number | null
          address: string | null
          auto_generate_pdf: boolean | null
          auto_send_quote_email: boolean | null
          business_name: string | null
          city: string | null
          created_at: string | null
          created_by: string | null
          diagnostic_fee: number | null
          email: string | null
          email_on_complete: boolean | null
          geo_lat: number | null
          geo_lng: number | null
          id: string
          images: string[] | null
          invoice_footer: string | null
          invoice_terms: string | null
          labor_rate: number | null
          logo_url: string | null
          max_lead_days: number | null
          min_notice_minutes: number | null
          name: string | null
          owner_id: string
          owner_pin: string | null
          owner_pin_hash: string | null
          phone_number: string | null
          pin: string | null
          plan: string | null
          postal_code: string | null
          province: string | null
          rating: number | null
          require_authorization: boolean | null
          require_cause_correction: boolean | null
          shop_name: string | null
          slug: string | null
          street: string | null
          supplies_percent: number | null
          tax_rate: number | null
          timezone: string | null
          updated_at: string | null
          use_ai: boolean | null
          user_limit: number | null
        }
        Insert: {
          accepts_online_booking?: boolean | null
          active_user_count?: number | null
          address?: string | null
          auto_generate_pdf?: boolean | null
          auto_send_quote_email?: boolean | null
          business_name?: string | null
          city?: string | null
          created_at?: string | null
          created_by?: string | null
          diagnostic_fee?: number | null
          email?: string | null
          email_on_complete?: boolean | null
          geo_lat?: number | null
          geo_lng?: number | null
          id?: string
          images?: string[] | null
          invoice_footer?: string | null
          invoice_terms?: string | null
          labor_rate?: number | null
          logo_url?: string | null
          max_lead_days?: number | null
          min_notice_minutes?: number | null
          name?: string | null
          owner_id: string
          owner_pin?: string | null
          owner_pin_hash?: string | null
          phone_number?: string | null
          pin?: string | null
          plan?: string | null
          postal_code?: string | null
          province?: string | null
          rating?: number | null
          require_authorization?: boolean | null
          require_cause_correction?: boolean | null
          shop_name?: string | null
          slug?: string | null
          street?: string | null
          supplies_percent?: number | null
          tax_rate?: number | null
          timezone?: string | null
          updated_at?: string | null
          use_ai?: boolean | null
          user_limit?: number | null
        }
        Update: {
          accepts_online_booking?: boolean | null
          active_user_count?: number | null
          address?: string | null
          auto_generate_pdf?: boolean | null
          auto_send_quote_email?: boolean | null
          business_name?: string | null
          city?: string | null
          created_at?: string | null
          created_by?: string | null
          diagnostic_fee?: number | null
          email?: string | null
          email_on_complete?: boolean | null
          geo_lat?: number | null
          geo_lng?: number | null
          id?: string
          images?: string[] | null
          invoice_footer?: string | null
          invoice_terms?: string | null
          labor_rate?: number | null
          logo_url?: string | null
          max_lead_days?: number | null
          min_notice_minutes?: number | null
          name?: string | null
          owner_id?: string
          owner_pin?: string | null
          owner_pin_hash?: string | null
          phone_number?: string | null
          pin?: string | null
          plan?: string | null
          postal_code?: string | null
          province?: string | null
          rating?: number | null
          require_authorization?: boolean | null
          require_cause_correction?: boolean | null
          shop_name?: string | null
          slug?: string | null
          street?: string | null
          supplies_percent?: number | null
          tax_rate?: number | null
          timezone?: string | null
          updated_at?: string | null
          use_ai?: boolean | null
          user_limit?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "shops_owner_fk"
            columns: ["owner_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      stock_locations: {
        Row: {
          code: string
          id: string
          name: string
          shop_id: string
        }
        Insert: {
          code: string
          id?: string
          name: string
          shop_id: string
        }
        Update: {
          code?: string
          id?: string
          name?: string
          shop_id?: string
        }
        Relationships: []
      }
      stock_moves: {
        Row: {
          created_at: string
          created_by: string | null
          id: string
          location_id: string
          part_id: string
          qty_change: number
          reason: Database["public"]["Enums"]["stock_move_reason"]
          reference_id: string | null
          reference_kind: string | null
          shop_id: string
        }
        Insert: {
          created_at?: string
          created_by?: string | null
          id?: string
          location_id: string
          part_id: string
          qty_change: number
          reason: Database["public"]["Enums"]["stock_move_reason"]
          reference_id?: string | null
          reference_kind?: string | null
          shop_id: string
        }
        Update: {
          created_at?: string
          created_by?: string | null
          id?: string
          location_id?: string
          part_id?: string
          qty_change?: number
          reason?: Database["public"]["Enums"]["stock_move_reason"]
          reference_id?: string | null
          reference_kind?: string | null
          shop_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "stock_moves_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "stock_moves_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "stock_moves_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "stock_moves_shop_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "stock_moves_shop_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      supplier_catalog_items: {
        Row: {
          brand: string | null
          compatibility: Json | null
          cost: number | null
          description: string | null
          external_sku: string
          id: string
          price: number | null
          supplier_id: string | null
          updated_at: string | null
        }
        Insert: {
          brand?: string | null
          compatibility?: Json | null
          cost?: number | null
          description?: string | null
          external_sku: string
          id?: string
          price?: number | null
          supplier_id?: string | null
          updated_at?: string | null
        }
        Update: {
          brand?: string | null
          compatibility?: Json | null
          cost?: number | null
          description?: string | null
          external_sku?: string
          id?: string
          price?: number | null
          supplier_id?: string | null
          updated_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "supplier_catalog_items_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "parts_suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      supplier_orders: {
        Row: {
          created_at: string | null
          external_order_id: string | null
          id: string
          items: Json | null
          shop_id: string | null
          status: string
          supplier_id: string | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          external_order_id?: string | null
          id?: string
          items?: Json | null
          shop_id?: string | null
          status: string
          supplier_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          external_order_id?: string | null
          id?: string
          items?: Json | null
          shop_id?: string | null
          status?: string
          supplier_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "supplier_orders_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "supplier_orders_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "supplier_orders_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "parts_suppliers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "supplier_orders_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      supplier_price_history: {
        Row: {
          catalog_item_id: string | null
          changed_at: string | null
          id: string
          new_price: number | null
          old_price: number | null
        }
        Insert: {
          catalog_item_id?: string | null
          changed_at?: string | null
          id?: string
          new_price?: number | null
          old_price?: number | null
        }
        Update: {
          catalog_item_id?: string | null
          changed_at?: string | null
          id?: string
          new_price?: number | null
          old_price?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "supplier_price_history_catalog_item_id_fkey"
            columns: ["catalog_item_id"]
            isOneToOne: false
            referencedRelation: "supplier_catalog_items"
            referencedColumns: ["id"]
          },
        ]
      }
      suppliers: {
        Row: {
          account_no: string | null
          created_at: string
          created_by: string | null
          email: string | null
          id: string
          is_active: boolean
          name: string
          notes: string | null
          phone: string | null
          shop_id: string
        }
        Insert: {
          account_no?: string | null
          created_at?: string
          created_by?: string | null
          email?: string | null
          id?: string
          is_active?: boolean
          name: string
          notes?: string | null
          phone?: string | null
          shop_id: string
        }
        Update: {
          account_no?: string | null
          created_at?: string
          created_by?: string | null
          email?: string | null
          id?: string
          is_active?: boolean
          name?: string
          notes?: string | null
          phone?: string | null
          shop_id?: string
        }
        Relationships: []
      }
      tax_calculation_log: {
        Row: {
          breakdown: Json | null
          created_at: string | null
          gst: number | null
          hst: number | null
          id: string
          jurisdiction_id: string | null
          pst: number | null
          quote_id: string | null
          shop_id: string | null
          total_tax: number
          work_order_id: string | null
        }
        Insert: {
          breakdown?: Json | null
          created_at?: string | null
          gst?: number | null
          hst?: number | null
          id?: string
          jurisdiction_id?: string | null
          pst?: number | null
          quote_id?: string | null
          shop_id?: string | null
          total_tax: number
          work_order_id?: string | null
        }
        Update: {
          breakdown?: Json | null
          created_at?: string | null
          gst?: number | null
          hst?: number | null
          id?: string
          jurisdiction_id?: string | null
          pst?: number | null
          quote_id?: string | null
          shop_id?: string | null
          total_tax?: number
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "tax_calculation_log_jurisdiction_id_fkey"
            columns: ["jurisdiction_id"]
            isOneToOne: false
            referencedRelation: "tax_jurisdictions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_calculation_log_quote_id_fkey"
            columns: ["quote_id"]
            isOneToOne: false
            referencedRelation: "customer_quotes"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_calculation_log_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_calculation_log_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_calculation_log_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      tax_jurisdictions: {
        Row: {
          code: string
          created_at: string | null
          id: string
          name: string
        }
        Insert: {
          code: string
          created_at?: string | null
          id?: string
          name: string
        }
        Update: {
          code?: string
          created_at?: string | null
          id?: string
          name?: string
        }
        Relationships: []
      }
      tax_providers: {
        Row: {
          api_base_url: string | null
          api_key: string | null
          created_at: string | null
          id: string
          provider_name: string
          shop_id: string | null
        }
        Insert: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          provider_name: string
          shop_id?: string | null
        }
        Update: {
          api_base_url?: string | null
          api_key?: string | null
          created_at?: string | null
          id?: string
          provider_name?: string
          shop_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "tax_providers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tax_providers_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      tax_rates: {
        Row: {
          created_at: string | null
          effective_from: string
          effective_to: string | null
          id: string
          jurisdiction_id: string | null
          rate: number
          tax_type: string
        }
        Insert: {
          created_at?: string | null
          effective_from: string
          effective_to?: string | null
          id?: string
          jurisdiction_id?: string | null
          rate: number
          tax_type: string
        }
        Update: {
          created_at?: string | null
          effective_from?: string
          effective_to?: string | null
          id?: string
          jurisdiction_id?: string | null
          rate?: number
          tax_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "tax_rates_jurisdiction_id_fkey"
            columns: ["jurisdiction_id"]
            isOneToOne: false
            referencedRelation: "tax_jurisdictions"
            referencedColumns: ["id"]
          },
        ]
      }
      tech_sessions: {
        Row: {
          ended_at: string | null
          id: string
          inspection_id: string | null
          started_at: string | null
          user_id: string | null
          work_order_id: string | null
        }
        Insert: {
          ended_at?: string | null
          id?: string
          inspection_id?: string | null
          started_at?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          ended_at?: string | null
          id?: string
          inspection_id?: string | null
          started_at?: string | null
          user_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "tech_sessions_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      tech_shifts: {
        Row: {
          created_at: string | null
          end_time: string | null
          id: string
          start_time: string
          status: string
          type: string
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          end_time?: string | null
          id?: string
          start_time?: string
          status?: string
          type?: string
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          end_time?: string | null
          id?: string
          start_time?: string
          status?: string
          type?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "tech_shifts_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      template_items: {
        Row: {
          id: string
          input_type: string | null
          label: string | null
          section: string | null
          template_id: string | null
        }
        Insert: {
          id?: string
          input_type?: string | null
          label?: string | null
          section?: string | null
          template_id?: string | null
        }
        Update: {
          id?: string
          input_type?: string | null
          label?: string | null
          section?: string | null
          template_id?: string | null
        }
        Relationships: []
      }
      usage_logs: {
        Row: {
          feature: string | null
          id: string
          used_at: string | null
          user_id: string | null
        }
        Insert: {
          feature?: string | null
          id?: string
          used_at?: string | null
          user_id?: string | null
        }
        Update: {
          feature?: string | null
          id?: string
          used_at?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      user_app_layouts: {
        Row: {
          id: string
          layout: Json
          updated_at: string | null
          user_id: string
          wallpaper: string | null
        }
        Insert: {
          id?: string
          layout: Json
          updated_at?: string | null
          user_id: string
          wallpaper?: string | null
        }
        Update: {
          id?: string
          layout?: Json
          updated_at?: string | null
          user_id?: string
          wallpaper?: string | null
        }
        Relationships: []
      }
      user_plans: {
        Row: {
          created_at: string | null
          features: Json | null
          id: string
          plan_name: string
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          features?: Json | null
          id?: string
          plan_name: string
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          features?: Json | null
          id?: string
          plan_name?: string
          user_id?: string | null
        }
        Relationships: []
      }
      user_widget_layouts: {
        Row: {
          id: string
          layout: Json
          updated_at: string | null
          user_id: string
        }
        Insert: {
          id?: string
          layout: Json
          updated_at?: string | null
          user_id: string
        }
        Update: {
          id?: string
          layout?: Json
          updated_at?: string | null
          user_id?: string
        }
        Relationships: []
      }
      vehicle_media: {
        Row: {
          created_at: string | null
          filename: string | null
          id: string
          shop_id: string | null
          storage_path: string
          type: string
          uploaded_by: string | null
          url: string | null
          vehicle_id: string | null
        }
        Insert: {
          created_at?: string | null
          filename?: string | null
          id?: string
          shop_id?: string | null
          storage_path: string
          type: string
          uploaded_by?: string | null
          url?: string | null
          vehicle_id?: string | null
        }
        Update: {
          created_at?: string | null
          filename?: string | null
          id?: string
          shop_id?: string | null
          storage_path?: string
          type?: string
          uploaded_by?: string | null
          url?: string | null
          vehicle_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "vehicle_media_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_media_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_media_uploaded_by_fkey"
            columns: ["uploaded_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_media_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      vehicle_photos: {
        Row: {
          caption: string | null
          created_at: string | null
          id: string
          shop_id: string | null
          uploaded_by: string | null
          url: string
          vehicle_id: string
        }
        Insert: {
          caption?: string | null
          created_at?: string | null
          id?: string
          shop_id?: string | null
          uploaded_by?: string | null
          url: string
          vehicle_id: string
        }
        Update: {
          caption?: string | null
          created_at?: string | null
          id?: string
          shop_id?: string | null
          uploaded_by?: string | null
          url?: string
          vehicle_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "vehicle_photos_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_photos_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_photos_uploaded_by_fkey"
            columns: ["uploaded_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_photos_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      vehicle_recalls: {
        Row: {
          campaign_number: string
          component: string | null
          consequence: string | null
          created_at: string
          id: string
          make: string | null
          manufacturer: string | null
          model: string | null
          model_year: string | null
          nhtsa_campaign: string | null
          notes: string | null
          remedy: string | null
          report_date: string | null
          report_received_date: string | null
          shop_id: string | null
          summary: string | null
          user_id: string | null
          vehicle_id: string | null
          vin: string
        }
        Insert: {
          campaign_number: string
          component?: string | null
          consequence?: string | null
          created_at?: string
          id?: string
          make?: string | null
          manufacturer?: string | null
          model?: string | null
          model_year?: string | null
          nhtsa_campaign?: string | null
          notes?: string | null
          remedy?: string | null
          report_date?: string | null
          report_received_date?: string | null
          shop_id?: string | null
          summary?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          vin: string
        }
        Update: {
          campaign_number?: string
          component?: string | null
          consequence?: string | null
          created_at?: string
          id?: string
          make?: string | null
          manufacturer?: string | null
          model?: string | null
          model_year?: string | null
          nhtsa_campaign?: string | null
          notes?: string | null
          remedy?: string | null
          report_date?: string | null
          report_received_date?: string | null
          shop_id?: string | null
          summary?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          vin?: string
        }
        Relationships: [
          {
            foreignKeyName: "vehicle_recalls_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_recalls_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicle_recalls_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      vehicles: {
        Row: {
          color: string | null
          created_at: string | null
          customer_id: string | null
          engine_hours: number | null
          id: string
          license_plate: string | null
          make: string | null
          mileage: string | null
          model: string | null
          shop_id: string | null
          unit_number: string | null
          user_id: string | null
          vin: string | null
          year: number | null
        }
        Insert: {
          color?: string | null
          created_at?: string | null
          customer_id?: string | null
          engine_hours?: number | null
          id?: string
          license_plate?: string | null
          make?: string | null
          mileage?: string | null
          model?: string | null
          shop_id?: string | null
          unit_number?: string | null
          user_id?: string | null
          vin?: string | null
          year?: number | null
        }
        Update: {
          color?: string | null
          created_at?: string | null
          customer_id?: string | null
          engine_hours?: number | null
          id?: string
          license_plate?: string | null
          make?: string | null
          mileage?: string | null
          model?: string | null
          shop_id?: string | null
          unit_number?: string | null
          user_id?: string | null
          vin?: string | null
          year?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "vehicles_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vehicles_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      vendor_part_numbers: {
        Row: {
          id: string
          part_id: string
          shop_id: string
          supplier_id: string | null
          vendor_sku: string
        }
        Insert: {
          id?: string
          part_id: string
          shop_id: string
          supplier_id?: string | null
          vendor_sku: string
        }
        Update: {
          id?: string
          part_id?: string
          shop_id?: string
          supplier_id?: string | null
          vendor_sku?: string
        }
        Relationships: [
          {
            foreignKeyName: "vendor_part_numbers_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "vendor_part_numbers_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vendor_part_numbers_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "suppliers"
            referencedColumns: ["id"]
          },
        ]
      }
      vin_decodes: {
        Row: {
          created_at: string | null
          decoded_data: Json | null
          engine: string | null
          id: string
          make: string | null
          model: string | null
          trim: string | null
          user_id: string | null
          vin: string
          year: string | null
        }
        Insert: {
          created_at?: string | null
          decoded_data?: Json | null
          engine?: string | null
          id?: string
          make?: string | null
          model?: string | null
          trim?: string | null
          user_id?: string | null
          vin: string
          year?: string | null
        }
        Update: {
          created_at?: string | null
          decoded_data?: Json | null
          engine?: string | null
          id?: string
          make?: string | null
          model?: string | null
          trim?: string | null
          user_id?: string | null
          vin?: string
          year?: string | null
        }
        Relationships: []
      }
      warranties: {
        Row: {
          created_at: string
          customer_id: string | null
          expires_at: string
          id: string
          installed_at: string
          notes: string | null
          part_id: string
          shop_id: string
          supplier_id: string | null
          vehicle_id: string | null
          warranty_months: number
          work_order_id: string | null
          work_order_line_id: string | null
        }
        Insert: {
          created_at?: string
          customer_id?: string | null
          expires_at: string
          id: string
          installed_at: string
          notes?: string | null
          part_id: string
          shop_id: string
          supplier_id?: string | null
          vehicle_id?: string | null
          warranty_months?: number
          work_order_id?: string | null
          work_order_line_id?: string | null
        }
        Update: {
          created_at?: string
          customer_id?: string | null
          expires_at?: string
          id?: string
          installed_at?: string
          notes?: string | null
          part_id?: string
          shop_id?: string
          supplier_id?: string | null
          vehicle_id?: string | null
          warranty_months?: number
          work_order_id?: string | null
          work_order_line_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "warranties_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "warranties_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_supplier_id_fkey"
            columns: ["supplier_id"]
            isOneToOne: false
            referencedRelation: "suppliers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "warranties_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      warranty_claims: {
        Row: {
          created_at: string
          id: string
          notes: string | null
          opened_at: string
          status: string
          supplier_rma: string | null
          warranty_id: string
        }
        Insert: {
          created_at?: string
          id: string
          notes?: string | null
          opened_at?: string
          status: string
          supplier_rma?: string | null
          warranty_id: string
        }
        Update: {
          created_at?: string
          id?: string
          notes?: string | null
          opened_at?: string
          status?: string
          supplier_rma?: string | null
          warranty_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "warranty_claims_warranty_id_fkey"
            columns: ["warranty_id"]
            isOneToOne: false
            referencedRelation: "warranties"
            referencedColumns: ["id"]
          },
        ]
      }
      widget_instances: {
        Row: {
          config: Json
          created_at: string | null
          id: string
          user_id: string
          widget_slug: string
        }
        Insert: {
          config?: Json
          created_at?: string | null
          id?: string
          user_id: string
          widget_slug: string
        }
        Update: {
          config?: Json
          created_at?: string | null
          id?: string
          user_id?: string
          widget_slug?: string
        }
        Relationships: [
          {
            foreignKeyName: "widget_instances_widget_slug_fkey"
            columns: ["widget_slug"]
            isOneToOne: false
            referencedRelation: "widgets"
            referencedColumns: ["slug"]
          },
        ]
      }
      widgets: {
        Row: {
          allowed_sizes: string[]
          default_route: string
          default_size: string
          id: string
          name: string
          slug: string
        }
        Insert: {
          allowed_sizes?: string[]
          default_route: string
          default_size?: string
          id?: string
          name: string
          slug: string
        }
        Update: {
          allowed_sizes?: string[]
          default_route?: string
          default_size?: string
          id?: string
          name?: string
          slug?: string
        }
        Relationships: []
      }
      work_order_approvals: {
        Row: {
          approved_at: string | null
          approved_by: string | null
          id: string
          method: string | null
          work_order_id: string | null
        }
        Insert: {
          approved_at?: string | null
          approved_by?: string | null
          id?: string
          method?: string | null
          work_order_id?: string | null
        }
        Update: {
          approved_at?: string | null
          approved_by?: string | null
          id?: string
          method?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_order_approvals_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_line_history: {
        Row: {
          created_at: string
          id: string
          line_id: string | null
          reason: string
          snapshot: Json
          status: string | null
          work_order_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          line_id?: string | null
          reason?: string
          snapshot: Json
          status?: string | null
          work_order_id: string
        }
        Update: {
          created_at?: string
          id?: string
          line_id?: string | null
          reason?: string
          snapshot?: Json
          status?: string | null
          work_order_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "work_order_line_history_line_id_fkey"
            columns: ["line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_history_line_id_fkey"
            columns: ["line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_history_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_line_technicians: {
        Row: {
          assigned_at: string
          assigned_by: string | null
          id: string
          technician_id: string
          work_order_line_id: string
        }
        Insert: {
          assigned_at?: string
          assigned_by?: string | null
          id?: string
          technician_id: string
          work_order_line_id: string
        }
        Update: {
          assigned_at?: string
          assigned_by?: string | null
          id?: string
          technician_id?: string
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "work_order_line_technicians_assigned_by_fkey"
            columns: ["assigned_by"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_technicians_technician_id_fkey"
            columns: ["technician_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_technicians_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_line_technicians_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_lines: {
        Row: {
          approval_at: string | null
          approval_by: string | null
          approval_note: string | null
          approval_state: string | null
          assigned_tech_id: string | null
          assigned_to: string | null
          cause: string | null
          complaint: string | null
          correction: string | null
          created_at: string | null
          description: string | null
          hold_reason: string | null
          id: string
          inspection_session_id: string | null
          inspection_template_id: string | null
          job_type: string | null
          labor_time: number | null
          line_no: number | null
          line_status: string | null
          notes: string | null
          on_hold_since: string | null
          parts: string | null
          parts_needed: Json | null
          parts_received: Json | null
          parts_required: Json | null
          price_estimate: number | null
          priority: number | null
          punchable: boolean | null
          punched_in_at: string | null
          punched_out_at: string | null
          quoted_at: string | null
          shop_id: string | null
          status: string | null
          template_id: string | null
          tools: string | null
          updated_at: string | null
          urgency: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_id: string | null
        }
        Insert: {
          approval_at?: string | null
          approval_by?: string | null
          approval_note?: string | null
          approval_state?: string | null
          assigned_tech_id?: string | null
          assigned_to?: string | null
          cause?: string | null
          complaint?: string | null
          correction?: string | null
          created_at?: string | null
          description?: string | null
          hold_reason?: string | null
          id?: string
          inspection_session_id?: string | null
          inspection_template_id?: string | null
          job_type?: string | null
          labor_time?: number | null
          line_no?: number | null
          line_status?: string | null
          notes?: string | null
          on_hold_since?: string | null
          parts?: string | null
          parts_needed?: Json | null
          parts_received?: Json | null
          parts_required?: Json | null
          price_estimate?: number | null
          priority?: number | null
          punchable?: boolean | null
          punched_in_at?: string | null
          punched_out_at?: string | null
          quoted_at?: string | null
          shop_id?: string | null
          status?: string | null
          template_id?: string | null
          tools?: string | null
          updated_at?: string | null
          urgency?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Update: {
          approval_at?: string | null
          approval_by?: string | null
          approval_note?: string | null
          approval_state?: string | null
          assigned_tech_id?: string | null
          assigned_to?: string | null
          cause?: string | null
          complaint?: string | null
          correction?: string | null
          created_at?: string | null
          description?: string | null
          hold_reason?: string | null
          id?: string
          inspection_session_id?: string | null
          inspection_template_id?: string | null
          job_type?: string | null
          labor_time?: number | null
          line_no?: number | null
          line_status?: string | null
          notes?: string | null
          on_hold_since?: string | null
          parts?: string | null
          parts_needed?: Json | null
          parts_received?: Json | null
          parts_required?: Json | null
          price_estimate?: number | null
          priority?: number | null
          punchable?: boolean | null
          punched_in_at?: string | null
          punched_out_at?: string | null
          quoted_at?: string | null
          shop_id?: string | null
          status?: string | null
          template_id?: string | null
          tools?: string | null
          updated_at?: string | null
          urgency?: string | null
          user_id?: string | null
          vehicle_id?: string | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_order_lines_assigned_tech_id_fkey"
            columns: ["assigned_tech_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_session_fk"
            columns: ["inspection_session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_session_id_fkey"
            columns: ["inspection_session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_template_id_fkey"
            columns: ["inspection_template_id"]
            isOneToOne: false
            referencedRelation: "inspection_templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_media: {
        Row: {
          created_at: string | null
          id: string
          kind: string | null
          shop_id: string
          url: string
          user_id: string | null
          work_order_id: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          kind?: string | null
          shop_id: string
          url: string
          user_id?: string | null
          work_order_id: string
        }
        Update: {
          created_at?: string | null
          id?: string
          kind?: string | null
          shop_id?: string
          url?: string
          user_id?: string | null
          work_order_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "work_order_media_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_media_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_media_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_part_allocations: {
        Row: {
          created_at: string
          id: string
          location_id: string
          part_id: string
          qty: number
          stock_move_id: string | null
          unit_cost: number
          work_order_id: string | null
          work_order_line_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          location_id: string
          part_id: string
          qty: number
          stock_move_id?: string | null
          unit_cost?: number
          work_order_id?: string | null
          work_order_line_id: string
        }
        Update: {
          created_at?: string
          id?: string
          location_id?: string
          part_id?: string
          qty?: number
          stock_move_id?: string | null
          unit_cost?: number
          work_order_id?: string | null
          work_order_line_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "wopa_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_stock_move_id_fkey"
            columns: ["stock_move_id"]
            isOneToOne: false
            referencedRelation: "stock_moves"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "v_quote_queue"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_part_allocations_work_order_line_id_fkey"
            columns: ["work_order_line_id"]
            isOneToOne: false
            referencedRelation: "work_order_lines"
            referencedColumns: ["id"]
          },
        ]
      }
      work_order_parts: {
        Row: {
          created_at: string | null
          id: string
          part_id: string | null
          quantity: number
          shop_id: string | null
          total_price: number | null
          unit_price: number | null
          work_order_id: string | null
        }
        Insert: {
          created_at?: string | null
          id?: string
          part_id?: string | null
          quantity?: number
          shop_id?: string | null
          total_price?: number | null
          unit_price?: number | null
          work_order_id?: string | null
        }
        Update: {
          created_at?: string | null
          id?: string
          part_id?: string | null
          quantity?: number
          shop_id?: string | null
          total_price?: number | null
          unit_price?: number | null
          work_order_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_order_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "work_order_parts_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_parts_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
        ]
      }
      work_orders: {
        Row: {
          approval_state: string | null
          assigned_tech: string | null
          created_at: string | null
          created_by: string | null
          custom_id: string | null
          customer_approval_at: string | null
          customer_approval_signature_path: string | null
          customer_approval_signature_url: string | null
          customer_approved_by: string | null
          customer_id: string | null
          customer_name: string | null
          id: string
          inspection_id: string | null
          inspection_pdf_url: string | null
          inspection_type: string | null
          invoice_total: number | null
          invoice_url: string | null
          labor_total: number | null
          notes: string | null
          parts_total: number | null
          priority: number | null
          quote: Json | null
          quote_url: string | null
          shop_id: string | null
          status: string | null
          type: string | null
          updated_at: string | null
          user_id: string | null
          vehicle_color: string | null
          vehicle_engine_hours: number | null
          vehicle_id: string | null
          vehicle_info: string | null
          vehicle_mileage: number | null
          vehicle_unit_number: string | null
        }
        Insert: {
          approval_state?: string | null
          assigned_tech?: string | null
          created_at?: string | null
          created_by?: string | null
          custom_id?: string | null
          customer_approval_at?: string | null
          customer_approval_signature_path?: string | null
          customer_approval_signature_url?: string | null
          customer_approved_by?: string | null
          customer_id?: string | null
          customer_name?: string | null
          id?: string
          inspection_id?: string | null
          inspection_pdf_url?: string | null
          inspection_type?: string | null
          invoice_total?: number | null
          invoice_url?: string | null
          labor_total?: number | null
          notes?: string | null
          parts_total?: number | null
          priority?: number | null
          quote?: Json | null
          quote_url?: string | null
          shop_id?: string | null
          status?: string | null
          type?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_color?: string | null
          vehicle_engine_hours?: number | null
          vehicle_id?: string | null
          vehicle_info?: string | null
          vehicle_mileage?: number | null
          vehicle_unit_number?: string | null
        }
        Update: {
          approval_state?: string | null
          assigned_tech?: string | null
          created_at?: string | null
          created_by?: string | null
          custom_id?: string | null
          customer_approval_at?: string | null
          customer_approval_signature_path?: string | null
          customer_approval_signature_url?: string | null
          customer_approved_by?: string | null
          customer_id?: string | null
          customer_name?: string | null
          id?: string
          inspection_id?: string | null
          inspection_pdf_url?: string | null
          inspection_type?: string | null
          invoice_total?: number | null
          invoice_url?: string | null
          labor_total?: number | null
          notes?: string | null
          parts_total?: number | null
          priority?: number | null
          quote?: Json | null
          quote_url?: string | null
          shop_id?: string | null
          status?: string | null
          type?: string | null
          updated_at?: string | null
          user_id?: string | null
          vehicle_color?: string | null
          vehicle_engine_hours?: number | null
          vehicle_id?: string | null
          vehicle_info?: string | null
          vehicle_mileage?: number | null
          vehicle_unit_number?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_orders_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      part_stock_summary: {
        Row: {
          category: string | null
          move_count: number | null
          name: string | null
          on_hand: number | null
          part_id: string | null
          price: number | null
          shop_id: string | null
          sku: string | null
        }
        Relationships: []
      }
      shop_public_profiles: {
        Row: {
          city: string | null
          geo_lat: number | null
          geo_lng: number | null
          id: string | null
          images: string[] | null
          logo_url: string | null
          name: string | null
          province: string | null
          rating: number | null
        }
        Insert: {
          city?: string | null
          geo_lat?: number | null
          geo_lng?: number | null
          id?: string | null
          images?: string[] | null
          logo_url?: string | null
          name?: string | null
          province?: string | null
          rating?: number | null
        }
        Update: {
          city?: string | null
          geo_lat?: number | null
          geo_lng?: number | null
          id?: string | null
          images?: string[] | null
          logo_url?: string | null
          name?: string | null
          province?: string | null
          rating?: number | null
        }
        Relationships: []
      }
      shop_reviews_public: {
        Row: {
          comment: string | null
          created_at: string | null
          id: string | null
          rating: number | null
          replied_at: string | null
          shop_id: string | null
          shop_owner_reply: string | null
        }
        Insert: {
          comment?: string | null
          created_at?: string | null
          id?: string | null
          rating?: number | null
          replied_at?: string | null
          shop_id?: string | null
          shop_owner_reply?: never
        }
        Update: {
          comment?: string | null
          created_at?: string | null
          id?: string | null
          rating?: number | null
          replied_at?: string | null
          shop_id?: string | null
          shop_owner_reply?: never
        }
        Relationships: [
          {
            foreignKeyName: "shop_reviews_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "shop_reviews_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
        ]
      }
      stock_balances: {
        Row: {
          location_id: string | null
          on_hand: number | null
          part_id: string | null
        }
        Relationships: [
          {
            foreignKeyName: "stock_moves_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "stock_moves_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "stock_moves_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      v_my_conversation_ids: {
        Row: {
          conversation_id: string | null
        }
        Relationships: []
      }
      v_my_messages: {
        Row: {
          content: string | null
          conversation_id: string | null
          created_at: string | null
          id: string | null
          sender_id: string | null
          sent_at: string | null
        }
        Insert: {
          content?: string | null
          conversation_id?: string | null
          created_at?: string | null
          id?: string | null
          sender_id?: string | null
          sent_at?: string | null
        }
        Update: {
          content?: string | null
          conversation_id?: string | null
          created_at?: string | null
          id?: string | null
          sender_id?: string | null
          sent_at?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "messages_conversation_id_fkey"
            columns: ["conversation_id"]
            isOneToOne: false
            referencedRelation: "conversations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "messages_sender_id_fkey"
            columns: ["sender_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      v_part_stock: {
        Row: {
          location_id: string | null
          part_id: string | null
          qty_available: number | null
          qty_on_hand: number | null
          qty_reserved: number | null
        }
        Insert: {
          location_id?: string | null
          part_id?: string | null
          qty_available?: never
          qty_on_hand?: number | null
          qty_reserved?: number | null
        }
        Update: {
          location_id?: string | null
          part_id?: string | null
          qty_available?: never
          qty_on_hand?: number | null
          qty_reserved?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "part_stock_location_id_fkey"
            columns: ["location_id"]
            isOneToOne: false
            referencedRelation: "stock_locations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "part_stock_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "part_stock_summary"
            referencedColumns: ["part_id"]
          },
          {
            foreignKeyName: "part_stock_part_id_fkey"
            columns: ["part_id"]
            isOneToOne: false
            referencedRelation: "parts"
            referencedColumns: ["id"]
          },
        ]
      }
      v_quote_queue: {
        Row: {
          approval_at: string | null
          approval_by: string | null
          approval_note: string | null
          approval_state: string | null
          assigned_tech_id: string | null
          assigned_to: string | null
          cause: string | null
          complaint: string | null
          correction: string | null
          created_at: string | null
          description: string | null
          hold_reason: string | null
          id: string | null
          inspection_session_id: string | null
          job_type: string | null
          labor_time: number | null
          line_status: string | null
          notes: string | null
          on_hold_since: string | null
          parts: string | null
          parts_needed: Json | null
          parts_received: Json | null
          parts_required: Json | null
          price_estimate: number | null
          priority: number | null
          punched_in_at: string | null
          punched_out_at: string | null
          shop_id: string | null
          status: string | null
          template_id: string | null
          tools: string | null
          updated_at: string | null
          urgency: string | null
          user_id: string | null
          vehicle_id: string | null
          work_order_custom_id: string | null
          work_order_customer_id: string | null
          work_order_id: string | null
          work_order_vehicle_id: string | null
        }
        Relationships: [
          {
            foreignKeyName: "work_order_lines_assigned_tech_id_fkey"
            columns: ["assigned_tech_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_session_fk"
            columns: ["inspection_session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_inspection_session_id_fkey"
            columns: ["inspection_session_id"]
            isOneToOne: false
            referencedRelation: "inspection_sessions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shop_public_profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_shop_id_fkey"
            columns: ["shop_id"]
            isOneToOne: false
            referencedRelation: "shops"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_vehicle_id_fkey"
            columns: ["vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_order_lines_work_order_id_fkey"
            columns: ["work_order_id"]
            isOneToOne: false
            referencedRelation: "work_orders"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_customer_id_fkey"
            columns: ["work_order_customer_id"]
            isOneToOne: false
            referencedRelation: "customers"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "work_orders_vehicle_id_fkey"
            columns: ["work_order_vehicle_id"]
            isOneToOne: false
            referencedRelation: "vehicles"
            referencedColumns: ["id"]
          },
        ]
      }
      v_shift_rollups: {
        Row: {
          shift_id: string | null
          user_id: string | null
          worked_seconds: number | null
        }
        Relationships: [
          {
            foreignKeyName: "punch_events_shift_id_fkey"
            columns: ["shift_id"]
            isOneToOne: false
            referencedRelation: "tech_shifts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "punch_events_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Functions: {
      _ensure_same_shop: { Args: { _wo: string }; Returns: boolean }
      agent_can_start: { Args: never; Returns: boolean }
      apply_stock_move: {
        Args: {
          p_loc: string
          p_part: string
          p_qty: number
          p_reason: string
          p_ref_id: string
          p_ref_kind: string
        }
        Returns: {
          created_at: string
          created_by: string | null
          id: string
          location_id: string
          part_id: string
          qty_change: number
          reason: Database["public"]["Enums"]["stock_move_reason"]
          reference_id: string | null
          reference_kind: string | null
          shop_id: string
        }
        SetofOptions: {
          from: "*"
          to: "stock_moves"
          isOneToOne: true
          isSetofReturn: false
        }
      }
      approve_lines: {
        Args: {
          _approved_ids: string[]
          _approver?: string
          _decline_unchecked?: boolean
          _declined_ids?: string[]
          _wo: string
        }
        Returns: undefined
      }
      assign_unassigned_lines: {
        Args: { tech_id: string; wo_id: string }
        Returns: undefined
      }
      can_manage_profile: {
        Args: { target_profile_id: string }
        Returns: boolean
      }
      chat_participants_key: {
        Args: { _recipients: string[]; _sender: string }
        Returns: string
      }
      chat_post_message: {
        Args: { _chat_id?: string; _content: string; _recipients: string[] }
        Returns: string
      }
      check_plan_limit: { Args: { _feature: string }; Returns: boolean }
      clear_auth: { Args: never; Returns: undefined }
      create_part_request: {
        Args: { p_items: Json; p_notes: string; p_work_order: string }
        Returns: string
      }
      current_shop_id: { Args: never; Returns: string }
      first_segment_uuid: { Args: { p: string }; Returns: string }
      has_column: { Args: { col: string; tab: unknown }; Returns: boolean }
      increment_user_limit: {
        Args: { increment_by?: number; input_shop_id: string }
        Returns: undefined
      }
      is_customer: { Args: { _customer: string }; Returns: boolean }
      is_shop_member: { Args: { p_shop: string }; Returns: boolean }
      is_staff_for_shop: { Args: { _shop: string }; Returns: boolean }
      mark_active: { Args: never; Returns: undefined }
      recompute_work_order_status: {
        Args: { p_wo: string }
        Returns: undefined
      }
      seed_default_hours: { Args: { shop_id: string }; Returns: undefined }
      send_for_approval: {
        Args: { _line_ids: string[]; _set_wo_status?: boolean; _wo: string }
        Returns: undefined
      }
      set_authenticated: { Args: { uid: string }; Returns: undefined }
      set_current_shop_id: { Args: { p_shop_id: string }; Returns: undefined }
      set_last_active_now: { Args: never; Returns: undefined }
      set_part_request_status: {
        Args: {
          p_request: string
          p_status: Database["public"]["Enums"]["part_request_status"]
        }
        Returns: undefined
      }
      shop_id_for: { Args: { uid: string }; Returns: string }
      show_limit: { Args: never; Returns: number }
      show_trgm: { Args: { "": string }; Returns: string[] }
      update_part_quote: {
        Args: {
          p_item: string
          p_price: number
          p_request: string
          p_vendor: string
        }
        Returns: undefined
      }
    }
    Enums: {
      agent_request_intent:
        | "feature_request"
        | "bug_report"
        | "inspection_catalog_add"
        | "service_catalog_add"
        | "refactor"
      agent_request_status:
        | "submitted"
        | "in_progress"
        | "awaiting_approval"
        | "approved"
        | "rejected"
        | "failed"
        | "merged"
      ai_training_source:
        | "quote"
        | "appointment"
        | "inspection"
        | "work_order"
        | "customer"
        | "vehicle"
      fleet_program_cadence:
        | "monthly"
        | "quarterly"
        | "mileage_based"
        | "hours_based"
      inspection_item_status: "ok" | "fail" | "na" | "recommend"
      inspection_status:
        | "new"
        | "in_progress"
        | "paused"
        | "completed"
        | "aborted"
      job_type_enum: "diagnosis" | "inspection" | "maintenance" | "repair"
      part_request_status:
        | "requested"
        | "quoted"
        | "approved"
        | "fulfilled"
        | "rejected"
        | "cancelled"
      plan_t: "free" | "diy" | "pro" | "pro_plus"
      punch_event_type:
        | "start"
        | "break_start"
        | "break_end"
        | "lunch_start"
        | "lunch_end"
        | "end"
      quote_request_status: "pending" | "in_progress" | "done"
      shift_status: "active" | "ended"
      stock_move_reason:
        | "receive"
        | "adjust"
        | "consume"
        | "return"
        | "transfer_out"
        | "transfer_in"
        | "wo_allocate"
        | "wo_release"
        | "seed"
      user_role_enum:
        | "owner"
        | "admin"
        | "manager"
        | "mechanic"
        | "advisor"
        | "parts"
        | "customer"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {
      agent_request_intent: [
        "feature_request",
        "bug_report",
        "inspection_catalog_add",
        "service_catalog_add",
        "refactor",
      ],
      agent_request_status: [
        "submitted",
        "in_progress",
        "awaiting_approval",
        "approved",
        "rejected",
        "failed",
        "merged",
      ],
      ai_training_source: [
        "quote",
        "appointment",
        "inspection",
        "work_order",
        "customer",
        "vehicle",
      ],
      fleet_program_cadence: [
        "monthly",
        "quarterly",
        "mileage_based",
        "hours_based",
      ],
      inspection_item_status: ["ok", "fail", "na", "recommend"],
      inspection_status: [
        "new",
        "in_progress",
        "paused",
        "completed",
        "aborted",
      ],
      job_type_enum: ["diagnosis", "inspection", "maintenance", "repair"],
      part_request_status: [
        "requested",
        "quoted",
        "approved",
        "fulfilled",
        "rejected",
        "cancelled",
      ],
      plan_t: ["free", "diy", "pro", "pro_plus"],
      punch_event_type: [
        "start",
        "break_start",
        "break_end",
        "lunch_start",
        "lunch_end",
        "end",
      ],
      quote_request_status: ["pending", "in_progress", "done"],
      shift_status: ["active", "ended"],
      stock_move_reason: [
        "receive",
        "adjust",
        "consume",
        "return",
        "transfer_out",
        "transfer_in",
        "wo_allocate",
        "wo_release",
        "seed",
      ],
      user_role_enum: [
        "owner",
        "admin",
        "manager",
        "mechanic",
        "advisor",
        "parts",
        "customer",
      ],
    },
  },
} as const


/* =============================== */
/* FILE: features/agent/tools/generateInvoiceHtml.ts */
/* =============================== */

import { z } from "zod";
import { getServerSupabase } from "../server/supabase";
import type { ToolDef } from "../lib/toolTypes";

const In = z.object({ workOrderId: z.string().uuid() });
export type GenerateInvoiceHtmlIn = z.infer<typeof In>;

const Out = z.object({ html: z.string() });
export type GenerateInvoiceHtmlOut = z.infer<typeof Out>;

type WorkOrderRow = { id: string; created_at: string | null; status: string | null; shop_id: string | null; vehicle_id: string | null; customer_id: string | null; };
type VehicleRow   = { year: number | null; make: string | null; model: string | null; vin: string | null; license_plate: string | null; };
type CustomerRow  = { name: string | null; email: string | null; };
type QuoteLineRow = { id: string; title: string | null; description: string | null; labor_rate: number | null; labor_time: number | null; parts_cost: number | null; quantity: number | null; total: number | null; part_price: number | null; name: string | null; };

function isWorkOrderRow(x: unknown): x is WorkOrderRow { return !!x && typeof (x as { id?: unknown }).id === "string"; }
function isVehicleRow(x: unknown): x is VehicleRow { return !!x && "vin" in (x as object); }
function isCustomerRow(x: unknown): x is CustomerRow { return !!x && ("name" in (x as object) || "email" in (x as object)); }
function isQuoteLineArray(x: unknown): x is QuoteLineRow[] { return Array.isArray(x); }
function fmtDate(iso: string | null): string { if (!iso) return ""; try { return new Date(iso).toLocaleString(); } catch { return ""; } }

export const toolGenerateInvoiceHtml: ToolDef<GenerateInvoiceHtmlIn, GenerateInvoiceHtmlOut> = {
  name: "generate_invoice_html",
  description: "Builds a styled HTML invoice for a work order from quote_lines.",
  inputSchema: In,
  outputSchema: Out,
  async run(input, ctx) {
    const supabase = getServerSupabase();

    const woRes = await supabase
      .from("work_orders")
      .select("id, created_at, status, shop_id, vehicle_id, customer_id")
      .eq("id", input.workOrderId)
      .eq("shop_id", ctx.shopId)
      .single();
    if (woRes.error || !isWorkOrderRow(woRes.data)) throw new Error(woRes.error?.message ?? "work order not found");
    const wo = woRes.data;

    let vehicle: VehicleRow | null = null;
    if (wo.vehicle_id) {
      const v = await supabase.from("vehicles").select("year, make, model, vin, license_plate").eq("id", wo.vehicle_id).maybeSingle();
      if (v.error) throw new Error(v.error.message);
      vehicle = v.data && isVehicleRow(v.data) ? v.data : null;
    }

    let customer: CustomerRow | null = null;
    if (wo.customer_id) {
      const c = await supabase.from("customers").select("name, email").eq("id", wo.customer_id).maybeSingle();
      if (c.error) throw new Error(c.error.message);
      customer = c.data && isCustomerRow(c.data) ? c.data : null;
    }

    const q = await supabase
      .from("quote_lines")
      .select("id, title, description, labor_rate, labor_time, parts_cost, quantity, total, part_price, name")
      .eq("work_order_id", wo.id)
      .order("created_at", { ascending: true });
    if (q.error) throw new Error(q.error.message);
    const lines: QuoteLineRow[] = isQuoteLineArray(q.data) ? q.data : [];

    const num = (x: number | null | undefined) => (typeof x === "number" ? x : 0);
    const rows = lines.map(l => {
      const labor = num(l.labor_rate) * num(l.labor_time);
      const parts = num(l.parts_cost) > 0 ? num(l.parts_cost) : num(l.part_price) * num(l.quantity);
      const total = typeof l.total === "number" ? l.total : labor + parts;
      return {
        title: l.title ?? l.name ?? "Line",
        description: l.description ?? "",
        laborHours: num(l.labor_time),
        laborRate: num(l.labor_rate),
        partsCost: parts,
        total
      };
    });

    const laborTotal = rows.reduce((s, r) => s + r.laborRate * r.laborHours, 0);
    const partsTotal = rows.reduce((s, r) => s + r.partsCost, 0);
    const grandTotal = rows.reduce((s, r) => s + r.total, 0) || (laborTotal + partsTotal);

    const woHeader = (fmtDate(wo.created_at) ? `Work Order: ${wo.id} • ${fmtDate(wo.created_at)}` : `Work Order: ${wo.id}`);
    const vehicleLine = `${vehicle?.year ?? ""} ${vehicle?.make ?? ""} ${vehicle?.model ?? ""}`.trim();

    const html =
      '<!doctype html>' +
      '<html><head><meta charset="utf-8" />' +
      `<title>Invoice #${wo.id}</title>` +
      '<style>' +
      'body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;padding:24px;background:#f6f7f9;}' +
      '.card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:24px;max-width:720px;margin:auto;}' +
      '.row{display:flex;gap:16px;flex-wrap:wrap}.muted{color:#6b7280;font-size:12px}' +
      'table{width:100%;border-collapse:collapse;margin-top:12px}th,td{border-bottom:1px solid #e5e7eb;padding:8px;text-align:left}.total{font-weight:700}' +
      '</style></head><body>' +
      '<div class="card">' +
      '<h2>Invoice</h2>' +
      `<div class="muted">${woHeader}</div>` +
      '<div class="row" style="margin-top:12px">' +
      `<div><strong>Customer</strong><br/>${customer?.name ?? ""}<br/>${customer?.email ?? ""}</div>` +
      `<div><strong>Vehicle</strong><br/>${vehicleLine}<br/>VIN: ${vehicle?.vin ?? ""} • Plate: ${vehicle?.license_plate ?? ""}</div>` +
      '</div>' +
      '<table><thead><tr><th>Description</th><th>Labor</th><th>Parts</th><th>Line Total</th></tr></thead><tbody>' +
      rows.map(l =>
        '<tr>' +
        `<td><div><strong>${l.title}</strong></div><div class="muted">${l.description}</div></td>` +
        `<td>${l.laborHours.toFixed(2)}h @ $${l.laborRate.toFixed(2)}/h = $${(l.laborRate*l.laborHours).toFixed(2)}</td>` +
        `<td>$${l.partsCost.toFixed(2)}</td>` +
        `<td>$${l.total.toFixed(2)}</td>` +
        '</tr>'
      ).join("") +
      '</tbody><tfoot>' +
      `<tr><td></td><td class="total">Labor</td><td></td><td class="total">$${laborTotal.toFixed(2)}</td></tr>` +
      `<tr><td></td><td class="total">Parts</td><td></td><td class="total">$${partsTotal.toFixed(2)}</td></tr>` +
      `<tr><td></td><td class="total">Total</td><td></td><td class="total">$${grandTotal.toFixed(2)}</td></tr>` +
      '</tfoot></table>' +
      `<p class="muted">Status: ${wo.status ?? ""}</p>` +
      '</div></body></html>';

    return { html };
  }
};


/* =============================== */
/* FILE: features/quotes/lib/quote/matchToMenuItem.ts */
/* =============================== */

import type { InspectionItem } from "@inspections/lib/inspection/types";
import { serviceMenu } from "@shared/lib/menuItems";
import { generateLaborTimeEstimate } from "@ai/lib/ai/generateLaborTimeEstimate";

/** Shape expected by QuoteViewer (summary page) */
export interface QuoteLine {
  description: string;
  hours: number;
  rate: number;
  total: number;
  job_type: "repair" | "maintenance";
}

/** Narrower filter to satisfy TS when collapsing optional strings */
const isNonEmptyString = (v: unknown): v is string =>
  typeof v === "string" && v.length > 0;

/**
 * Generate a quote and summary from inspection items
 */
export async function generateQuoteFromInspection(
  results: InspectionItem[],
): Promise<{ summary: string; quote: QuoteLine[] }> {
  const failed: InspectionItem[] = [];
  const recommended: InspectionItem[] = [];

  for (const item of results) {
    const status =
      item.status === "fail" || item.status === "recommend"
        ? item.status
        : "ok";

    if (status === "fail") {
      failed.push({ ...item, status });
    } else if (status === "recommend") {
      recommended.push({ ...item, status });
    }
  }

  const summary = [
    "Completed Vehicle Inspection.",
    failed.length > 0 ? `⚠️ Failed Items:\n` : undefined,
    ...failed.map(
      (item) => `- ${item.item}: ${item.notes || ""} *Requires attention*`,
    ),
    recommended.length > 0 ? `\n🟠 Recommended Items:\n` : undefined,
    ...recommended.map(
      (item) => `- ${item.item}: ${item.notes || ""} *Suggested repair*`,
    ),
  ]
    .filter(isNonEmptyString)
    .join("\n");

  const quote: QuoteLine[] = [];
  const RATE = 120;

  for (const itm of [...failed, ...recommended]) {
    const term = String(itm.item ?? itm.name ?? "");

    // 1) Try to match a known service menu item
    const menuMatch = serviceMenu.find((m) =>
      term.toLowerCase().includes(m.name.toLowerCase()),
    );

    if (menuMatch) {
      const hours = menuMatch.laborHours ?? 1;
      const partsCost = menuMatch.partCost ?? 0;
      const total = Number((hours * RATE + partsCost).toFixed(2));

      quote.push({
        description: menuMatch.name,
        hours,
        rate: RATE,
        total,
        job_type: "repair",
      });
      continue;
    }

    // 2) Fall back to AI labor estimate
    const labor = await generateLaborTimeEstimate(term, "repair");
    if (typeof labor === "number" && labor > 0) {
      quote.push({
        description: term,
        hours: labor,
        rate: RATE,
        total: Number((labor * RATE).toFixed(2)),
        job_type: "repair",
      });
    }
  }

  return { summary, quote };
}

/* =============================== */
/* FILE: features/quotes/lib/quote/generateQuoteFromInspection.ts */
/* =============================== */

import type { InspectionItem } from "@inspections/lib/inspection/types";
import { serviceMenu } from "@shared/lib/menuItems";
import { generateLaborTimeEstimate } from "@ai/lib/ai/generateLaborTimeEstimate";

/** Shape expected by QuoteViewer (summary page) */
export interface QuoteLine {
  description: string;
  hours: number;
  rate: number;
  total: number;
  job_type: "repair" | "maintenance";
}

/**
 * Generate a quote and summary from inspection items
 */
export async function generateQuoteFromInspection(
  results: InspectionItem[],
): Promise<{ summary: string; quote: QuoteLine[] }> {
  const failed: InspectionItem[] = [];
  const recommended: InspectionItem[] = [];

  for (const item of results) {
    const status =
      item.status === "fail" || item.status === "recommend"
        ? item.status
        : "ok";

    if (status === "fail") {
      failed.push({ ...item, status });
    } else if (status === "recommend") {
      recommended.push({ ...item, status });
    }
    // "ok" items are not included in the quote
  }

  const summary = [
    "Completed Vehicle Inspection.",
    failed.length > 0 ? `⚠️ Failed Items:\n` : null,
    ...failed.map(
      (item) => `- ${item.item}: ${item.notes || ""} *Requires attention*`,
    ),
    recommended.length > 0 ? `\n🟠 Recommended Items:\n` : null,
    ...recommended.map(
      (item) => `- ${item.item}: ${item.notes || ""} *Suggested repair*`,
    ),
  ]
    .filter(Boolean)
    .join("\n");

  const quote: QuoteLine[] = [];
  const RATE = 120;

  for (const itm of [...failed, ...recommended]) {
    const term = (itm.item ?? itm.name ?? "").toString();

    // 1) Try to match a known service menu item
    const menuMatch = serviceMenu.find((m) =>
      term.toLowerCase().includes(m.name.toLowerCase()),
    );

    if (menuMatch) {
      const hours = menuMatch.laborHours ?? 1;
      const partsCost = menuMatch.partCost ?? 0;
      const total = Number((hours * RATE + partsCost).toFixed(2));

      quote.push({
        description: menuMatch.name,
        hours,
        rate: RATE,
        total,
        job_type: "repair",
      });
      continue;
    }

    // 2) Fall back to AI labor estimate
    const labor = await generateLaborTimeEstimate(term, "repair");
    if (labor && labor > 0) {
      quote.push({
        description: term,
        hours: labor,
        rate: RATE,
        total: Number((labor * RATE).toFixed(2)),
        job_type: "repair",
      });
    }
  }

  return { summary, quote };
}

/* =============================== */
/* FILE: features/quotes/lib/quote/mapItemToQuote.ts */
/* =============================== */

// features/quotes/lib/quote/mapItemToQuote.ts
import type { InspectionItem, QuoteLineItem } from "@inspections/lib/inspection/types";

export function toQuoteLineItem(item: InspectionItem): QuoteLineItem {
  const name = item.item ?? item.name ?? "Inspection Item";
  return {
    id: crypto.randomUUID(),
    item: name,
    name,
    description: item.notes || name,
    status: (item.status ?? "fail"),
    notes: item.notes,
    price: 0,          // let UI or service lookup fill these
    laborHours: 0.5,
    photoUrls: item.photoUrls ?? [],
    part: { name: "", price: 0 },
    partName: "",
    partPrice: null,
  };
}

/* =============================== */
/* FILE: features/quotes/lib/quote/normalizeQuoteLine.ts */
/* =============================== */

import { QuoteLineItem } from "@inspections/lib/inspection/types";
import { QuoteLine } from "./generateQuoteFromInspection";
import { inferPartName } from "@ai/lib/ai/inferPartName";

/**
 * Normalize a QuoteLine into a QuoteLineItem with inferred part info.
 */
export async function normalizeQuoteLine(
  quote: QuoteLine,
): Promise<QuoteLineItem> {
  let partName: string | null = null;

  try {
    // Try to infer part name using AI based on the description
    partName = await inferPartName(quote.description);
  } catch (err) {
    console.warn("AI inference failed:", err);
  }

  const fallbackPartName = quote.description.toLowerCase().includes("brake")
    ? "Brake Pad"
    : quote.description.toLowerCase().includes("oil")
      ? "Oil Filter"
      : quote.description.toLowerCase().includes("battery")
        ? "Battery"
        : "General Replacement Part";

  const name = partName?.trim() || fallbackPartName;

  return {
    id: crypto.randomUUID(), // ✅ Required unique ID
    item: quote.description,
    name: quote.description,
    description: quote.description,
    status: "fail", // Default; override if needed
    price: quote.total,
    partName: name,
    partPrice: 0,
    part: {
      name,
      price: 0,
    },
    laborHours: quote.hours,
    photoUrls: [],
    notes: "",
  };
}


/* =============================== */
/* FILE: features/quotes/lib/quote/quoteMenu.ts */
/* =============================== */

export interface QuoteMenuItem {
  triggerPhrases: string[];
  parts: {
    name: string;
    sku?: string;
    supplier?: string;
    cost: number;
  }[];
  laborHours: number;
  category: "diagnose" | "repair" | "maintenance";
  notes?: string;
}

export const quoteMenu: QuoteMenuItem[] = [
  {
    triggerPhrases: [
      "front brakes worn",
      "brakes pads low",
      "brakes squealing",
      "brake pad thin",
      "brake pad fail",
      "brake pads 2mm",
    ],
    parts: [
      {
        name: "Front Brake Pads",
        sku: "FORD-BRKPAD5-F",
        supplier: "Ford OEM",
        cost: 85,
      },
    ],
    laborHours: 1.5,
    category: "repair",
    notes: "Typical replacement includes pads, rotor inspection.",
  },
  {
    triggerPhrases: [
      "check engine light",
      "CEL on",
      "engine light is on",
      "trouble code",
    ],
    parts: [],
    laborHours: 0.5,
    category: "diagnose",
    notes: "Initial scan and diagnosis of engine light causes.",
  },
  {
    triggerPhrases: ["oil change", "needs an oil change", "engine oil service"],
    parts: [
      {
        name: "5W-20 Synthetic Blend Oil",
        supplier: "Ford OEM",
        cost: 40,
      },
      {
        name: "Oil Filter",
        supplier: "Ford OEM",
        cost: 12,
      },
    ],
    laborHours: 0.3,
    category: "maintenance",
    notes: "Includes oil, filter, and disposal.",
  },
];


/* =============================== */
/* FILE: features/quotes/api/quote/route.ts */
/* =============================== */

// app/api/quote/route.ts
import { NextRequest, NextResponse } from "next/server";
import { generateQuoteFromInspection } from "@quotes/lib/quote/generateQuoteFromInspection";
import { InspectionItem } from "@inspections/lib/inspection/types";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const results: InspectionItem[] = body.results;

    if (!results || !Array.isArray(results)) {
      return NextResponse.json(
        { error: "Invalid or missing results." },
        { status: 400 },
      );
    }

    const { summary, quote } = await generateQuoteFromInspection(results);
    return NextResponse.json({ summary, quote });
  } catch (err) {
    console.error("Quote generation failed:", err);
    return NextResponse.json(
      { error: "Internal error generating quote." },
      { status: 500 },
    );
  }
}


/* =============================== */
/* FILE: features/quotes/components/QuoteViewer.tsx */
/* =============================== */

"use client";

import { useEffect, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { generateQuotePDFBytes } from "@work-orders/lib/work-orders/generateQuotePdf";
import type { QuoteLine } from "@quotes/lib/quote/generateQuoteFromInspection";
import type { QuoteLineItem as BaseQuoteLineItem } from "@inspections/lib/inspection/types";
import { searchPartsByKeyword } from "@parts/lib/parts/searchParts";
import { inferPartName } from "@ai/lib/ai/inferPartName";

/** What the UI edits; keep part compatible with your QuoteLineItem type */
type EditableQuoteLineItem = Omit<BaseQuoteLineItem, "part"> & {
  /** allow null while editing */
  part?: { name: string; price: number | null } | null;
  partName: string;
  partPrice?: number | null;
};

interface QuoteViewerProps {
  summary: string;
  quote: (QuoteLine | BaseQuoteLineItem)[];
}

const supabase = createClientComponentClient<Database>();

/** Minimal inline save; adjust table/columns if yours differ */
async function updateQuoteLine(item: EditableQuoteLineItem) {
  const { error } = await supabase
    .from("quote_lines")
    .upsert(
      {
        id: item.id,
        name: item.name ?? item.description ?? "",
        description: item.description ?? "",
        labor_hours: item.laborHours ?? 0,
        parts_cost: item.part?.price ?? item.partPrice ?? 0,
        total_price: item.price ?? 0,
        part_name: item.part?.name ?? item.partName,
        part_price: item.part?.price ?? item.partPrice ?? 0,
        created_at: new Date().toISOString(),
      },
      { onConflict: "id" },
    );

  if (error) throw error;
}

async function normalizeQuoteLine(
  line: QuoteLine | BaseQuoteLineItem,
): Promise<EditableQuoteLineItem> {
  if ("laborHours" in line && "price" in line && "part" in line) {
    const li = line as BaseQuoteLineItem;
    const ensuredName = li.part?.name ?? "";
    const ensuredPrice =
      typeof li.part?.price === "number" ? li.part!.price : li.part?.price ?? null;

    return {
      ...li,
      part: { name: ensuredName, price: ensuredPrice },
      partName: ensuredName,
      partPrice: ensuredPrice ?? 0,
    };
  }

  const legacy = line as QuoteLine;
  const inferred = (await inferPartName(legacy.description)) ?? "";

  return {
    id: crypto.randomUUID(),
    item: legacy.description,
    name: legacy.description,
    description: legacy.description,
    status: "fail",
    price: legacy.total,
    laborHours: legacy.hours,
    part: { name: inferred, price: 0 },
    partName: inferred,
    partPrice: 0,
    photoUrls: [],
    notes: "",
  };
}

export default function QuoteViewer({ summary, quote }: QuoteViewerProps) {
  const [quoteState, setQuoteState] = useState<EditableQuoteLineItem[]>([]);
  const [lookupResults, setLookupResults] = useState<Record<number, string[]>>({});

  useEffect(() => {
    (async () => {
      const result = await Promise.all(quote.map(normalizeQuoteLine));
      setQuoteState(result);
    })();
  }, [quote]);

  const handleChange = (
    idx: number,
    field: keyof EditableQuoteLineItem | "partName" | "partPrice",
    value: string | number,
  ) => {
    setQuoteState((prev) =>
      prev.map((item, i) => {
        if (i !== idx) return item;
        let next: EditableQuoteLineItem = { ...item, [field]: value as any };
        const ensurePart = () => next.part ?? { name: item.partName ?? "", price: null };

        if (field === "partName") {
          const name = String(value);
          next.partName = name;
          next.part = { ...ensurePart(), name };
        } else if (field === "partPrice") {
          const price = Number(value);
          const safe = Number.isFinite(price) ? price : 0;
          next.partPrice = safe;
          next.part = { ...ensurePart(), price: safe };
        }
        return next;
      }),
    );
  };

  const handlePhotoUpload = (idx: number, files: FileList | null) => {
    if (!files?.length) return;
    const urls = Array.from(files).map((file) => URL.createObjectURL(file));
    setQuoteState((prev) =>
      prev.map((item, i) =>
        i === idx
          ? { ...item, photoUrls: [...(item.photoUrls ?? []), ...urls] }
          : item,
      ),
    );
  };

  const handlePartSearch = async (idx: number, query: string) => {
    const results = await searchPartsByKeyword(query);
    setLookupResults((prev) => ({ ...prev, [idx]: results }));
  };

  const handleSave = async (item: EditableQuoteLineItem) => {
    try {
      await updateQuoteLine(item);
      alert("Quote line saved!");
    } catch (err) {
      console.error(err);
      alert("Error saving quote line.");
    }
  };

  const handleExportPDF = async () => {
    const bytes = await generateQuotePDFBytes(quoteState, summary);
    const blob = new Blob([bytes.buffer as ArrayBuffer], { type: "application/pdf" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "quote.pdf";
    link.click();
  };

  const grouped: Record<string, EditableQuoteLineItem[]> = {};
  for (const item of quoteState) {
    const key = item.status ?? "unknown";
    (grouped[key] ??= []).push(item);
  }

  return (
    <div className="bg-black/30 text-white rounded-lg p-6 shadow-xl backdrop-blur-lg border border-white/10">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl font-bold text-orange-400">Inspection Summary</h2>
        <button onClick={handleExportPDF} className="bg-blue-600 px-3 py-1 rounded text-sm">
          Export PDF
        </button>
      </div>

      <pre className="whitespace-pre-wrap text-white/80 mb-6">{summary}</pre>

      {Object.entries(grouped).map(([group, items]) => (
        <div key={group} className="mb-6">
          <h3 className="text-xl font-semibold capitalize text-white mb-2">
            {group} Items
          </h3>

          {items.map((item, idx) => {
            const labor = typeof item.price === "number" ? item.price : 0;
            const partPrice =
              typeof item.partPrice === "number"
                ? item.partPrice
                : typeof item.part?.price === "number"
                  ? item.part.price
                  : 0;

            return (
              <div key={item.id} className="border border-white/10 bg-white/5 p-4 rounded-md space-y-2">
                <div className="flex flex-col md:flex-row md:items-center gap-4">
                  <input
                    className="bg-black/20 text-white p-1 rounded w-full md:w-1/3"
                    value={item.description ?? ""}
                    onChange={(e) => handleChange(idx, "description", e.target.value)}
                    placeholder="Description"
                  />
                  <input
                    type="text"
                    className="bg-black/20 text-white p-1 rounded w-full md:w-1/4"
                    value={item.partName ?? item.part?.name ?? ""}
                    onChange={(e) => handleChange(idx, "partName", e.target.value)}
                    onBlur={() =>
                      handlePartSearch(idx, (item.partName ?? item.part?.name ?? "").toString())
                    }
                    placeholder="Part name"
                  />
                  <input
                    type="number"
                    className="bg-black/20 text-white p-1 rounded w-full md:w-1/6"
                    value={item.partPrice ?? item.part?.price ?? 0}
                    onChange={(e) => handleChange(idx, "partPrice", e.target.value)}
                    placeholder="Part cost"
                  />
                  <input
                    type="number"
                    className="bg-black/20 text-white p-1 rounded w-full md:w-1/6"
                    value={item.price ?? 0}
                    onChange={(e) => handleChange(idx, "price", parseFloat(e.target.value))}
                    placeholder="Labor price"
                  />
                </div>

                <textarea
                  className="bg-black/20 text-white p-1 rounded w-full"
                  value={item.notes ?? ""}
                  onChange={(e) => handleChange(idx, "notes", e.target.value)}
                  placeholder="Notes"
                />

                <p className="text-sm text-white/70">
                  Labor: ${labor.toFixed(2)} | Part: ${partPrice.toFixed(2)}
                </p>

                <div className="text-sm text-white/70 mt-2">
                  Suggested Parts:{" "}
                  {lookupResults[idx]?.length
                    ? lookupResults[idx].slice(0, 3).join(", ")
                    : "None yet"}
                </div>

                <input
                  type="file"
                  multiple
                  onChange={(e) => handlePhotoUpload(idx, e.target.files)}
                  className="text-sm"
                />

                <div className="flex flex-wrap gap-2 mt-2">
                  {item.photoUrls?.map((url, i) => (
                    <img
                      key={i}
                      src={url}
                      className="max-h-24 border border-white/20 rounded"
                      alt="Quote Attachment"
                    />
                  ))}
                </div>

                <div className="flex justify-end mt-2">
                  <button
                    onClick={() => handleSave(item)}
                    className="bg-green-600 px-4 py-1 rounded text-sm"
                  >
                    Save
                  </button>
                </div>
              </div>
            );
          })}
        </div>
      ))}

      <div className="border-t border-white/10 pt-4 text-right text-white font-semibold text-lg">
        Quote Total: $
        {quoteState
          .reduce((sum, i) => sum + (i.price || 0) + (i.part?.price || 0), 0)
          .toFixed(2)}
      </div>
    </div>
  );
}

/* =============================== */
/* FILE: features/integrations/ai/index.ts */
/* =============================== */

import { openai } from "lib/server/openai";
import { createAdminSupabase } from "@/features/shared/lib/supabase/server";

/* ========================================================================== */
/*  QUOTE ENGINE – CENTRAL AI ENTRYPOINT                                      */
/* ========================================================================== */

export type QuoteEnginePart = {
  partId?: string | null;
  description: string;
  qty?: number;
  price?: number;
};

export type QuoteEngineSuggestion = {
  parts: QuoteEnginePart[];
  laborHours: number;
  confidence: number; // 0–1
};

type SuggestQuoteArgs = {
  shopId: string;
  vehicleYmm?: string | null;
  complaint: string;
};

export const ProFixAI = {
  /**
   * LLM-backed quote suggestion.
   * Returns null on any parsing / API failure so callers can fall back.
   */
  async suggestQuote(
    args: SuggestQuoteArgs,
  ): Promise<QuoteEngineSuggestion | null> {
    const { shopId, vehicleYmm, complaint } = args;

    const system = [
      "You are an auto repair quote assistant.",
      "Given a vehicle (Y/M/M) and a complaint, you must return JSON ONLY.",
      "The JSON must be an object with:",
      "- parts: array of { description, qty, price, partId },",
      "- laborHours: number (0.1–8),",
      "- confidence: number between 0 and 1.",
      "Keep parts realistic; at most 10 parts.",
      "Do not include any prose or markdown, only raw JSON.",
    ].join(" ");

    const userContext = [
      `Shop: ${shopId}`,
      `Vehicle: ${vehicleYmm ?? "Unknown vehicle"}`,
      `Complaint: ${complaint}`,
    ].join("\n");

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      temperature: 0.4,
      max_tokens: 600,
      messages: [
        { role: "system", content: system },
        { role: "user", content: userContext },
      ],
    });

    const raw = completion.choices[0]?.message?.content ?? "{}";

    let parsed: unknown;
    try {
      parsed = JSON.parse(raw);
    } catch {
      // Model gave non-JSON; let caller fall back.
      return null;
    }

    const out: QuoteEngineSuggestion = {
      parts: [],
      laborHours: 0.5,
      confidence: 0.4,
    };

    // --- parts ---
    const partsArr = Array.isArray((parsed as any)?.parts)
      ? (parsed as any).parts
      : [];

    const normalizedParts: QuoteEnginePart[] = [];
    for (const rawPart of partsArr) {
      if (typeof rawPart !== "object" || rawPart === null) continue;
      const p = rawPart as Record<string, unknown>;

      const description =
        typeof p.description === "string" && p.description.trim().length > 0
          ? p.description.trim()
          : null;
      if (!description) continue;

      const qtyRaw = p.qty;
      const qty =
        typeof qtyRaw === "number" && Number.isFinite(qtyRaw) && qtyRaw > 0
          ? qtyRaw
          : undefined;

      const priceRaw = p.price;
      const price =
        typeof priceRaw === "number" &&
        Number.isFinite(priceRaw) &&
        priceRaw >= 0
          ? priceRaw
          : undefined;

      const partIdRaw = p.partId;
      const partId =
        typeof partIdRaw === "string" && partIdRaw.trim().length > 0
          ? partIdRaw.trim()
          : null;

      const part: QuoteEnginePart = {
        description,
      };

      if (qty !== undefined) part.qty = qty;
      if (price !== undefined) part.price = price;
      if (partId !== null) part.partId = partId;

      normalizedParts.push(part);
    }

    out.parts = normalizedParts.slice(0, 10);

    // --- laborHours ---
    const lh = (parsed as any)?.laborHours;
    if (typeof lh === "number" && Number.isFinite(lh) && lh > 0 && lh <= 8) {
      out.laborHours = lh;
    }

    // --- confidence ---
    const c = (parsed as any)?.confidence;
    if (typeof c === "number" && Number.isFinite(c) && c >= 0 && c <= 1) {
      out.confidence = c;
    }

    return out;
  },
};

/* ========================================================================== */
/*  TRAINING EVENT LOGGING                                                    */
/* ========================================================================== */

/**
 * Narrow string sources so we don't end up with random ad-hoc values.
 * These map roughly to the things we care about training:
 * - apply_ai_quote: AI suggestion applied to a quote/line
 * - invoice_review: AI work-order / invoice review
 * - inspection_to_quote: inspection → quote pipeline
 * - menu_learning: future menu-learning events
 * - chat: future TechBot / InspectionBot chat turns
 */
export type AIRecordSource =
  | "apply_ai_quote"
  | "invoice_review"
  | "inspection_to_quote"
  | "menu_learning"
  | "chat";

/**
 * Minimal, DB-agnostic training event shape that callers work with.
 */
export interface AITrainingEvent {
  id?: string;
  source: AIRecordSource;
  shopId: string;
  vehicleYmm?: string | null;
  payload: Record<string, unknown>;
  createdAt?: string;
}

async function insertTrainingEvent(event: AITrainingEvent): Promise<void> {
  const supabase = createAdminSupabase();

  const { id, source, shopId, vehicleYmm, payload, createdAt } = event;

  const { error } = await supabase.from("ai_training_events").insert({
    id,
    source,
    shop_id: shopId,
    vehicle_ymm: vehicleYmm ?? null,
    payload,
    created_at: createdAt ?? new Date().toISOString(),
  } as any);

  if (error) {
    // Never block the user flow on training errors; just log.
    // eslint-disable-next-line no-console
    console.error("[AI] Failed to insert training event", {
      source,
      shopId,
      error,
    });
  }
}

/* ---------- QUOTE TRAINING – APPLY AI QUOTE ---------- */

export type RecordQuoteTrainingInput = {
  quoteId: string;
  shopId: string;
  vehicleYmm?: string | null;
  workOrderId?: string | null;
  workOrderLineId?: string | null;
  payload: Record<string, unknown>;
  createdAt?: string;
};

export async function recordQuoteTraining(
  input: RecordQuoteTrainingInput,
): Promise<void> {
  const {
    quoteId,
    shopId,
    vehicleYmm,
    workOrderId,
    workOrderLineId,
    payload,
    createdAt,
  } = input;

  await insertTrainingEvent({
    source: "apply_ai_quote",
    shopId,
    vehicleYmm: vehicleYmm ?? null,
    createdAt,
    payload: {
      kind: "apply_ai_quote",
      quoteId,
      workOrderId: workOrderId ?? null,
      workOrderLineId: workOrderLineId ?? null,
      ...(payload ?? {}),
    },
  });
}

/* ---------- WORK ORDER TRAINING – INVOICE / JOB REVIEW ---------- */

export type RecordWorkOrderTrainingInput = {
  workOrderId: string;
  workOrderLineId?: string | null;
  shopId: string;
  vehicleYmm?: string | null;
  payload: Record<string, unknown>;
  createdAt?: string;
};

export async function recordWorkOrderTraining(
  input: RecordWorkOrderTrainingInput,
): Promise<void> {
  const {
    workOrderId,
    workOrderLineId,
    shopId,
    vehicleYmm,
    payload,
    createdAt,
  } = input;

  await insertTrainingEvent({
    source: "invoice_review",
    shopId,
    vehicleYmm: vehicleYmm ?? null,
    createdAt,
    payload: {
      kind: "invoice_review",
      workOrderId,
      workOrderLineId: workOrderLineId ?? null,
      ...(payload ?? {}),
    },
  });
}

/* ---------- INSPECTION → QUOTE TRAINING ---------- */

export type RecordInspectionToQuoteTrainingInput = {
  shopId: string;
  vehicleYmm?: string | null;
  payload: Record<string, unknown>;
  createdAt?: string;
};

export async function recordInspectionToQuoteTraining(
  input: RecordInspectionToQuoteTrainingInput,
): Promise<void> {
  const { shopId, vehicleYmm, payload, createdAt } = input;

  await insertTrainingEvent({
    source: "inspection_to_quote",
    shopId,
    vehicleYmm: vehicleYmm ?? null,
    createdAt,
    payload: {
      kind: "inspection_to_quote",
      ...(payload ?? {}),
    },
  });
}

/* =============================== */
/* FILE: features/work-orders/mobile/MobileWorkOrderLines.tsx */
/* =============================== */

//Features/work-orders/mobile/MobileWorkOrderLines.tsx
"use client";

import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type WorkOrderLineRow = DB["public"]["Tables"]["work_order_lines"]["Row"];

type Props = {
  lines: WorkOrderLineRow[];
  workOrderId: string | null;
  onDelete: (lineId: string) => Promise<void> | void;
};

export function MobileWorkOrderLines({
  lines,
  workOrderId,
  onDelete,
}: Props) {
  if (!workOrderId) {
    return null;
  }

  if (!lines.length) {
    return (
      <div className="rounded-xl border border-dashed border-neutral-700 bg-neutral-950/60 px-3 py-3 text-xs text-neutral-400">
        No jobs added yet. Use{" "}
        <span className="font-semibold text-neutral-200">
          Add job line
        </span>{" "}
        below to start the quote.
      </div>
    );
  }

  return (
    <div className="space-y-2 rounded-xl border border-neutral-800 bg-neutral-950 p-3">
      <div className="mb-1 flex items-center justify-between">
        <h2 className="text-xs font-semibold uppercase tracking-wide text-neutral-400">
          Jobs on this work order
        </h2>
        <span className="text-[10px] text-neutral-500">
          {lines.length} line{lines.length === 1 ? "" : "s"}
        </span>
      </div>

      <ul className="space-y-2">
        {lines.map((line) => {
          const label =
            line.description ||
            line.complaint ||
            "Job line";

          return (
            <li
              key={line.id}
              className="flex items-start justify-between gap-2 rounded-lg border border-neutral-800 bg-neutral-900 px-3 py-2 text-xs"
            >
              <div className="min-w-0">
                <div className="truncate text-[0.8rem] font-medium text-neutral-50">
                  {label}
                </div>
                {line.complaint && (
                  <div className="mt-0.5 line-clamp-2 text-[0.7rem] text-neutral-400">
                    {line.complaint}
                  </div>
                )}
                {line.status && (
                  <div className="mt-1 text-[0.65rem] uppercase tracking-wide text-neutral-500">
                    {line.status.replaceAll("_", " ")}
                  </div>
                )}
              </div>
              <button
                type="button"
                onClick={() => onDelete(line.id)}
                className="shrink-0 rounded-full border border-red-500/60 px-2 py-0.5 text-[0.7rem] text-red-200 hover:bg-red-900/30"
              >
                Delete
              </button>
            </li>
          );
        })}
      </ul>
    </div>
  );
}

/* =============================== */
/* FILE: features/work-orders/mobile/MobileWorkOrderClient.tsx */
/* =============================== */

"use client";

import { 
  useCallback,
  useEffect,
  useMemo,
  useState,
  type JSX,
} from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { format } from "date-fns";
import { toast } from "sonner";
import dynamic from "next/dynamic";

import { supabaseBrowser as supabase } from "@/features/shared/lib/supabase/client";
import type { Database } from "@shared/types/types/supabase";

import PreviousPageButton from "@shared/components/ui/PreviousPageButton";
import { UsePartButton } from "@work-orders/components/UsePartButton";
import VoiceContextSetter from "@/features/shared/voice/VoiceContextSetter";
import VoiceButton from "@/features/shared/voice/VoiceButton";
import { useTabState } from "@/features/shared/hooks/useTabState";
import PartsDrawer from "@/features/parts/components/PartsDrawer";

// assign-mechanic modal
import AssignTechModal from "@/features/work-orders/components/workorders/extras/AssignTechModal";

// inspection modal
const InspectionModal = dynamic(
  () => import("@/features/inspections/components/InspectionModal"),
  { ssr: false }
);

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];
type Customer = DB["public"]["Tables"]["customers"]["Row"];
type Profile = DB["public"]["Tables"]["profiles"]["Row"];
type AllocationRow =
  DB["public"]["Tables"]["work_order_part_allocations"]["Row"] & {
    parts?: { name: string | null } | null;
  };
type LineTechRow =
  DB["public"]["Tables"]["work_order_line_technicians"]["Row"];

const looksLikeUuid = (s: string) => s.includes("-") && s.length >= 36;

function splitCustomId(raw: string): { prefix: string; n: number | null } {
  const m = raw.toUpperCase().match(/^([A-Z]+)\s*0*?(\d+)?$/);
  if (!m) return { prefix: raw.toUpperCase(), n: null };
  const n = m[2] ? parseInt(m[2], 10) : null;
  return { prefix: m[1], n: Number.isFinite(n!) ? n : null };
}

/* ---------------------------- Badges & Row Tints ---------------------------- */

type KnownStatus =
  | "awaiting_approval"
  | "awaiting"
  | "queued"
  | "in_progress"
  | "on_hold"
  | "planned"
  | "new"
  | "completed"
  | "ready_to_invoice"
  | "invoiced";

const BASE_BADGE =
  "inline-flex items-center whitespace-nowrap rounded border px-2 py-0.5 text-xs font-medium";

const BADGE: Record<KnownStatus, string> = {
  awaiting_approval: "bg-blue-900/20 border-blue-500/40 text-blue-300",
  awaiting: "bg-sky-900/20  border-sky-500/40  text-sky-300",
  queued: "bg-indigo-900/20 border-indigo-500/40 text-indigo-300",
  in_progress: "bg-orange-900/20 border-orange-500/40 text-orange-300",
  on_hold: "bg-amber-900/20  border-amber-500/40  text-amber-300",
  planned: "bg-purple-900/20 border-purple-500/40 text-purple-300",
  new: "bg-neutral-800   border-neutral-600   text-neutral-200",
  completed: "bg-green-900/20  border-green-500/40 text-green-300",
  ready_to_invoice: "bg-emerald-900/20 border-emerald-500/40 text-emerald-300",
  invoiced: "bg-teal-900/20    border-teal-500/40    text-teal-300",
};

const chip = (s: string | null | undefined): string => {
  const key = (s ?? "awaiting")
    .toLowerCase()
    .replaceAll(" ", "_") as KnownStatus;
  return `${BASE_BADGE} ${BADGE[key] ?? BADGE.awaiting}`;
};

const statusBorder: Record<string, string> = {
  awaiting: "border-l-4 border-slate-400",
  queued: "border-l-4 border-indigo-400",
  in_progress: "border-l-4 border-orange-500",
  on_hold: "border-l-4 border-amber-500",
  completed: "border-l-4 border-green-500",
  awaiting_approval: "border-l-4 border-blue-500",
  planned: "border-l-4 border-purple-500",
  new: "border-l-4 border-gray-400",
};

const statusRowTint: Record<string, string> = {
  awaiting: "bg-neutral-950",
  queued: "bg-neutral-950",
  in_progress: "bg-neutral-950",
  on_hold: "bg-amber-900/30",
  completed: "bg-green-900/30",
  awaiting_approval: "bg-neutral-950",
  planned: "bg-neutral-950",
  new: "bg-neutral-950",
};

// roles allowed to assign
const ASSIGN_ROLES = new Set(["owner", "admin", "manager", "advisor"]);

/* ------------------------------------------------------------------------- */

export default function MobileWorkOrderClient({
  routeId,
}: {
  routeId: string;
}): JSX.Element {
  const router = useRouter();

  const [wo, setWo] = useTabState<WorkOrder | null>("m:wo:id:wo", null);
  const [lines, setLines] = useTabState<WorkOrderLine[]>(
    "m:wo:id:lines",
    []
  );
  const [vehicle, setVehicle] = useTabState<Vehicle | null>(
    "m:wo:id:veh",
    null
  );
  const [customer, setCustomer] = useTabState<Customer | null>(
    "m:wo:id:cust",
    null
  );

  const [allocsByLine, setAllocsByLine] = useState<
    Record<string, AllocationRow[]>
  >({});
  const [loading, setLoading] = useState<boolean>(false);
  const [viewError, setViewError] = useState<string | null>(null);

  const [currentUserId, setCurrentUserId] = useTabState<string | null>(
    "m:wo:id:uid",
    null
  );
  const [, setUserId] = useTabState<string | null>(
    "m:wo:id:effectiveUid",
    null
  );
  const [currentUserRole, setCurrentUserRole] = useState<string | null>(null);

  const [showDetails, setShowDetails] = useTabState<boolean>(
    "m:wo:showDetails",
    true
  );
  const [warnedMissing, setWarnedMissing] = useState(false);

  // parts
  const [partsLineId, setPartsLineId] = useState<string | null>(null);
  const [bulkQueue, setBulkQueue] = useState<string[]>([]);
  const [bulkActive, setBulkActive] = useState<boolean>(false);

  // inspection
  const [inspectionOpen, setInspectionOpen] = useState(false);
  const [inspectionSrc, setInspectionSrc] = useState<string | null>(null);

  // assign mechanic
  const [assignOpen, setAssignOpen] = useState(false);
  const [assignLineId, setAssignLineId] = useState<string | null>(null);
  const [assignables, setAssignables] = useState<
    Array<Pick<Profile, "id" | "full_name" | "role">>
  >([]);

  // per-line technicians
  const [lineTechsByLine, setLineTechsByLine] = useState<
    Record<string, string[]>
  >({});

  /* ---------------------- AUTH + assignables ---------------------- */
  useEffect(() => {
    let mounted = true;

    const waitForSession = async () => {
      let {
        data: { session },
      } = await supabase.auth.getSession();

      if (!session) {
        for (let i = 0; i < 8; i++) {
          await new Promise((r) => setTimeout(r, 150 * (i + 1)));
          const res = await supabase.auth.getSession();
          session = res.data.session;
          if (session) break;
        }
      }

      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!mounted) return;

      const uid = user?.id ?? null;
      setCurrentUserId(uid);
      setUserId(uid);

      if (uid) {
        const { data: prof } = await supabase
          .from("profiles")
          .select("role")
          .eq("id", uid)
          .maybeSingle();
        setCurrentUserRole(prof?.role ?? null);
      }

      try {
        const res = await fetch("/api/assignables");
        const json = await res.json();
        if (res.ok && Array.isArray(json.data)) {
          setAssignables(json.data);
        }
      } catch {
        // ignore
      }

      if (!uid) setLoading(false);
    };

    void waitForSession();

    const { data: sub } = supabase.auth.onAuthStateChange((_evt, s) => {
      if (s?.user) void waitForSession();
      else {
        setCurrentUserId(null);
        setUserId(null);
        setLoading(false);
      }
    });

    return () => {
      mounted = false;
      sub?.subscription?.unsubscribe?.();
    };
  }, [routeId, setCurrentUserId, setUserId]);

  /* ---------------------- FETCH ---------------------- */
  const fetchAll = useCallback(
    async (retry = 0) => {
      if (!routeId) return;
      setLoading(true);
      setViewError(null);

      try {
        let woRow: WorkOrder | null = null;

        // by UUID
        if (looksLikeUuid(routeId)) {
          const { data, error } = await supabase
            .from("work_orders")
            .select("*")
            .eq("id", routeId)
            .maybeSingle();
          if (!error) woRow = (data as WorkOrder | null) ?? null;
        }

        // by custom_id
        if (!woRow) {
          const eqRes = await supabase
            .from("work_orders")
            .select("*")
            .eq("custom_id", routeId)
            .maybeSingle();
          woRow = (eqRes.data as WorkOrder | null) ?? null;

          if (!woRow) {
            const ilikeRes = await supabase
              .from("work_orders")
              .select("*")
              .ilike("custom_id", routeId.toUpperCase())
              .maybeSingle();
            woRow = (ilikeRes.data as WorkOrder | null) ?? null;
          }

          if (!woRow) {
            const { prefix, n } = splitCustomId(routeId);
            if (n !== null) {
              const { data: cands } = await supabase
                .from("work_orders")
                .select("*")
                .ilike("custom_id", `${prefix}%`)
                .limit(50);
              const wanted = `${prefix}${n}`;
              const match = (cands ?? []).find(
                (r) =>
                  (r.custom_id ?? "")
                    .toUpperCase()
                    .replace(/^([A-Z]+)0+/, "$1") === wanted
              );
              if (match) woRow = match as WorkOrder;
            }
          }
        }

        if (!woRow) {
          if (retry < 2) {
            await new Promise((r) => setTimeout(r, 200 * Math.pow(2, retry)));
            return fetchAll(retry + 1);
          }
          setViewError("Work order not visible / not found.");
          setWo(null);
          setLines([]);
          setVehicle(null);
          setCustomer(null);
          setAllocsByLine({});
          setLineTechsByLine({});
          setLoading(false);
          return;
        }

        setWo(woRow);

        if (!warnedMissing && (!woRow.vehicle_id || !woRow.customer_id)) {
          toast.error(
            "This work order is missing vehicle and/or customer. Open the Create form to set them."
          );
          setWarnedMissing(true);
        }

        const [linesRes, vehRes, custRes] = await Promise.all([
          supabase
            .from("work_order_lines")
            .select("*")
            .eq("work_order_id", woRow.id)
            .order("created_at", { ascending: true }),
          woRow.vehicle_id
            ? supabase
                .from("vehicles")
                .select("*")
                .eq("id", woRow.vehicle_id)
                .maybeSingle()
            : Promise.resolve({ data: null, error: null } as const),
          woRow.customer_id
            ? supabase
                .from("customers")
                .select("*")
                .eq("id", woRow.customer_id)
                .maybeSingle()
            : Promise.resolve({ data: null, error: null } as const),
        ]);

        if (linesRes.error) throw linesRes.error;
        const lineRows = (linesRes.data ?? []) as WorkOrderLine[];
        setLines(lineRows);

        if (vehRes?.error) throw vehRes.error;
        setVehicle((vehRes?.data as Vehicle | null) ?? null);

        if (custRes?.error) throw custRes.error;
        setCustomer((custRes?.data as Customer | null) ?? null);

        // allocations + line techs
        if (lineRows.length) {
          const [allocsQuery, lineTechsQuery] = await Promise.all([
            supabase
              .from("work_order_part_allocations")
              .select("*, parts(name)")
              .in(
                "work_order_line_id",
                lineRows.map((l) => l.id)
              ),
            supabase
              .from("work_order_line_technicians")
              .select("work_order_line_id, technician_id")
              .in(
                "work_order_line_id",
                lineRows.map((l) => l.id)
              ),
          ]);

          const byLine: Record<string, AllocationRow[]> = {};
          (allocsQuery.data ?? []).forEach((a) => {
            const key = (a as AllocationRow).work_order_line_id;
            if (!byLine[key]) byLine[key] = [];
            byLine[key].push(a as AllocationRow);
          });
          setAllocsByLine(byLine);

          const techMap: Record<string, string[]> = {};
          (lineTechsQuery.data as LineTechRow[] | null)?.forEach((lt) => {
            const lnId = lt.work_order_line_id;
            const techId = lt.technician_id;
            if (!techMap[lnId]) techMap[lnId] = [];
            if (!techMap[lnId].includes(techId)) {
              techMap[lnId].push(techId);
            }
          });
          setLineTechsByLine(techMap);
        } else {
          setAllocsByLine({});
          setLineTechsByLine({});
        }
      } catch (e: unknown) {
        const msg =
          e instanceof Error ? e.message : "Failed to load work order.";
        setViewError(msg);
        console.error("[Mobile WO id page] load error:", e);
      } finally {
        setLoading(false);
      }
    },
    [routeId, warnedMissing, setWo, setLines, setVehicle, setCustomer]
  );

  useEffect(() => {
    if (!routeId || !currentUserId) return;
    void fetchAll();
  }, [fetchAll, routeId, currentUserId]);

  /* ---------------------- REALTIME ---------------------- */
  useEffect(() => {
    if (!wo?.id) return;

    const ch = supabase
      .channel(`m:wo:${wo.id}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_orders",
          filter: `id=eq.${wo.id}`,
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_lines",
          filter: `work_order_id=eq.${wo.id}`,
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_part_allocations",
        },
        () => fetchAll()
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_line_technicians",
        },
        () => fetchAll()
      )
      .subscribe();

    const local = () => fetchAll();
    window.addEventListener("wo:parts-used", local);

    return () => {
      try {
        supabase.removeChannel(ch);
      } catch {}
      window.removeEventListener("wo:parts-used", local);
    };
  }, [wo?.id, fetchAll]);

  // 🔁 refresh this page when a parts request is submitted from elsewhere
  useEffect(() => {
    const handler = () => {
      void fetchAll();
    };
    window.addEventListener("parts-request:submitted", handler);
    return () => window.removeEventListener("parts-request:submitted", handler);
  }, [fetchAll]);

  /* ----------------------- Derived data ----------------------- */
  const approvalPending = useMemo(
    () => lines.filter((l) => (l.approval_state ?? null) === "pending"),
    [lines]
  );

  const activeJobLines = useMemo(
    () => lines.filter((l) => (l.approval_state ?? null) !== "pending"),
    [lines]
  );

  const sortedLines = useMemo(() => {
    const pr: Record<string, number> = {
      diagnosis: 1,
      inspection: 2,
      maintenance: 3,
      repair: 4,
    };
    return [...activeJobLines].sort((a, b) => {
      const pa = pr[String(a.job_type ?? "repair")] ?? 999;
      const pb = pr[String(b.job_type ?? "repair")] ?? 999;
      if (pa !== pb) return pa - pb;
      const ta = a.created_at ? new Date(a.created_at).getTime() : 0;
      const tb = b.created_at ? new Date(b.created_at).getTime() : 0;
      return ta - tb;
    });
  }, [activeJobLines]);

  const createdAt = wo?.created_at ? new Date(wo.created_at) : null;
  const createdAtText =
    createdAt && !isNaN(createdAt.getTime())
      ? format(createdAt, "PPpp")
      : "—";

  const canAssign = currentUserRole ? ASSIGN_ROLES.has(currentUserRole) : false;

  const assignablesById = useMemo(() => {
    const m: Record<
      string,
      { full_name: string | null; role: string | null }
    > = {};
    assignables.forEach((a) => {
      m[a.id] = { full_name: a.full_name, role: a.role };
    });
    return m;
  }, [assignables]);

  /* ----------------------- line actions ----------------------- */

  const approveLine = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          approval_state: "approved",
          status: "queued",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      toast.success("Line approved");
      void fetchAll();
    },
    [fetchAll]
  );

  const declineLine = useCallback(
    async (lineId: string) => {
      if (!lineId) return;
      const { error } = await supabase
        .from("work_order_lines")
        .update({
          approval_state: "declined",
          status: "awaiting",
        } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", lineId);
      if (error) return toast.error(error.message);
      toast.success("Line declined");
      void fetchAll();
    },
    [fetchAll]
  );

  const sendToParts = useCallback(async (lineId: string) => {
    if (!lineId) return;
    const { error } = await supabase
      .from("work_order_lines")
      .update({
        status: "on_hold",
        hold_reason: "Awaiting parts quote",
      } as DB["public"]["Tables"]["work_order_lines"]["Update"])
      .eq("id", lineId);
    if (error) return toast.error(error.message);
    setPartsLineId(lineId);
    toast.success("Sent to parts for quoting");
  }, []);

  const sendAllPendingToParts = useCallback(async () => {
    if (!approvalPending.length) return;
    const ids = approvalPending.map((l) => l.id);
    const { error } = await supabase
      .from("work_order_lines")
      .update({
        status: "on_hold",
        hold_reason: "Awaiting parts quote",
      } as DB["public"]["Tables"]["work_order_lines"]["Update"])

===== FILE: ./parts-all.txt =====


/* =============================== */
/* FILE: ./app/parts/inventory/page.tsx */
/* =============================== */

"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { v4 as uuidv4 } from "uuid";

/* ----------------------------- Types ----------------------------- */

type DB = Database;
type Part = DB["public"]["Tables"]["parts"]["Row"];
type PartInsert = DB["public"]["Tables"]["parts"]["Insert"];
type PartUpdate = DB["public"]["Tables"]["parts"]["Update"];
type StockLoc = DB["public"]["Tables"]["stock_locations"]["Row"];
type StockMove = DB["public"]["Tables"]["stock_moves"]["Row"];

// app-side view of the enum
type StockMoveReason = "receive" | "adjust" | "consume" | "transfer";

/* --------------------------- UI helpers -------------------------- */

function Modal(props: {
  open: boolean;
  title: string;
  onClose: () => void;
  children: React.ReactNode;
  footer?: React.ReactNode;
  widthClass?: string;
}) {
  const { open, title, onClose, children, footer, widthClass = "max-w-xl" } = props;
  if (!open) return null;
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 p-4">
      <div
        className={`w-full ${widthClass} rounded border border-orange-500 bg-neutral-950 p-4 text-white shadow-xl`}
        onClick={(e) => e.stopPropagation()}
        role="dialog"
        aria-modal="true"
      >
        <div className="mb-3 flex items-center justify-between">
          <h2 className="text-lg font-semibold">{title}</h2>
          <button
            onClick={onClose}
            className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
            aria-label="Close"
          >
            ✕
          </button>
        </div>
        <div>{children}</div>
        {footer ? <div className="mt-4">{footer}</div> : null}
      </div>
    </div>
  );
}

function TextField(props: {
  label: string;
  value: string;
  placeholder?: string;
  onChange: (v: string) => void;
}) {
  const { label, value, placeholder, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <input
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
      />
    </div>
  );
}

function NumberField(props: {
  label: string;
  value: number | "";
  min?: number;
  step?: number;
  onChange: (v: number | "") => void;
}) {
  const { label, value, min = 0, step = 0.01, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <input
        type="number"
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value === "" ? "" : value}
        min={min}
        step={step}
        onChange={(e) => {
          const raw = e.target.value;
          onChange(raw === "" ? "" : Number(raw));
        }}
      />
    </div>
  );
}

function SelectField(props: {
  label: string;
  value: string;
  options: { value: string; label: string }[];
  onChange: (v: string) => void;
}) {
  const { label, value, options, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <select
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value}
        onChange={(e) => onChange(e.target.value)}
      >
        {options.map((o) => (
          <option key={o.value} value={o.value}>
            {o.label}
          </option>
        ))}
      </select>
    </div>
  );
}

/* ---------------------- CSV parsing helper ---------------------- */

function parseCSV(text: string): string[][] {
  const rows: string[][] = [];
  let row: string[] = [];
  let cell = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (inQuotes) {
      if (ch === '"') {
        const next = text[i + 1];
        if (next === '"') {
          cell += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        cell += ch;
      }
    } else {
      if (ch === '"') inQuotes = true;
      else if (ch === ",") {
        row.push(cell.trim());
        cell = "";
      } else if (ch === "\n") {
        row.push(cell.trim());
        rows.push(row);
        row = [];
        cell = "";
      } else if (ch !== "\r") {
        cell += ch;
      }
    }
  }
  if (cell.length > 0 || row.length > 0) {
    row.push(cell.trim());
    rows.push(row);
  }
  return rows.filter((r) => r.length > 0 && r.some((c) => c.length > 0));
}

/* ------------------------- Error helper ------------------------- */
function errMsg(err: unknown): string {
  if (typeof err === "string") return err;
  if (err && typeof err === "object" && "message" in err) {
    return String((err as Record<string, unknown>).message);
  }
  try {
    return JSON.stringify(err);
  } catch {
    return String(err);
  }
}

/* ------------------------- RPC helper --------------------------- */
/** Try 6-arg function first; if schema cache hasn’t picked it up,
 * fall back to the 5-arg legacy shape. Strictly typed; ignores return value.
 */
async function applyStockMoveRPC(
  supabase: ReturnType<typeof createClientComponentClient<DB>>,
  args: {
    p_part: string;
    p_loc: string;
    p_qty: number;
    p_reason: StockMoveReason;
    p_ref_kind: string;
    p_ref_id?: string | null;
  },
): Promise<void> {
  type FnArgs = DB["public"]["Functions"]["apply_stock_move"]["Args"];

  // 6-arg (conditionally include p_ref_id so shapes match)
  const payload6 = {
    p_part: args.p_part,
    p_loc: args.p_loc,
    p_qty: args.p_qty,
    p_reason: args.p_reason as FnArgs extends { p_reason: infer R } ? R : never,
    p_ref_kind: args.p_ref_kind,
    ...(args.p_ref_id !== undefined ? { p_ref_id: args.p_ref_id } : {}),
  } as FnArgs;

  const call6 = await supabase.rpc("apply_stock_move", payload6);
  if (!call6.error) return;

  const msg = (call6.error?.message ?? "").toLowerCase();
  const cacheShapeIssue =
    msg.includes("could not find the function") ||
    msg.includes("schema cache") ||
    msg.includes("function apply_stock_move(");

  if (!cacheShapeIssue) throw new Error(call6.error?.message ?? "apply_stock_move failed");

  // 5-arg (legacy, no p_ref_id)
  const payload5 = {
    p_part: args.p_part,
    p_loc: args.p_loc,
    p_qty: args.p_qty,
    p_reason: args.p_reason as FnArgs extends { p_reason: infer R } ? R : never,
    p_ref_kind: args.p_ref_kind,
  } as FnArgs;

  const call5 = await supabase.rpc("apply_stock_move", payload5);
  if (call5.error) {
    throw new Error(call5.error.message ?? "apply_stock_move failed");
  }
}

/* ---------------------------- Page ---------------------------- */

export default function InventoryPage(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [shopId, setShopId] = useState<string>("");
  const [search, setSearch] = useState<string>("");
  const [parts, setParts] = useState<Part[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  // stock locations
  const [locs, setLocs] = useState<StockLoc[]>([]);

  // on-hand map: partId -> total qty
  const [onHand, setOnHand] = useState<Record<string, number>>({});
  // per-location detail modal
  const [ohOpen, setOhOpen] = useState<boolean>(false);
  const [ohForPart, setOhForPart] = useState<Part | null>(null);
  const [ohLines, setOhLines] = useState<{ location: string; qty: number }[]>([]);

  // add modal
  const [addOpen, setAddOpen] = useState<boolean>(false);
  const [name, setName] = useState<string>("");
  const [sku, setSku] = useState<string>("");
  const [category, setCategory] = useState<string>("");
  const [price, setPrice] = useState<number | "">("");

  // initial receive (optional) for Add
  const [initLoc, setInitLoc] = useState<string>("");
  const [initQty, setInitQty] = useState<number | "">("");

  // edit modal
  const [editOpen, setEditOpen] = useState<boolean>(false);
  const [editPart, setEditPart] = useState<Part | null>(null);
  const [editName, setEditName] = useState<string>("");
  const [editSku, setEditSku] = useState<string>("");
  const [editCategory, setEditCategory] = useState<string>("");
  const [editPrice, setEditPrice] = useState<number | "">("");

  // receive modal (standalone quick receive)
  const [recvOpen, setRecvOpen] = useState<boolean>(false);
  const [recvPart, setRecvPart] = useState<Part | null>(null);
  const [recvLoc, setRecvLoc] = useState<string>("");
  const [recvQty, setRecvQty] = useState<number | "">("");

  // CSV Import
  const [csvOpen, setCsvOpen] = useState<boolean>(false);
  const [csvText, setCsvText] = useState<string>("");
  const [csvRows, setCsvRows] = useState<
    { name: string; sku?: string; category?: string; price?: number; qty?: number }[]
  >([]);
  const [csvPreview, setCsvPreview] = useState<boolean>(false);
  const [csvDefaultLoc, setCsvDefaultLoc] = useState<string>("");

  // ---------- on-hand loader (pass sid directly; avoids first-render zeros)
  const loadOnHand = useCallback(
    async (sid: string, partIds: string[]) => {
      if (!partIds.length) {
        setOnHand({});
        return;
      }
      const { data, error } = await supabase
        .from("stock_moves")
        .select("part_id, qty_change")
        .in("part_id", partIds)
        .eq("shop_id", sid);

      if (error || !data) {
        setOnHand({});
        return;
      }

      const totals: Record<string, number> = {};
      (data as StockMove[]).forEach((m) => {
        const delta = Number(m.qty_change) || 0;
        totals[m.part_id] = (totals[m.part_id] ?? 0) + delta;
      });
      setOnHand(totals);
    },
    [supabase],
  );

  const load = async (sid: string) => {
    setLoading(true);
    const base = supabase
      .from("parts")
      .select("*")
      .eq("shop_id", sid)
      .order("name", { ascending: true });

    const { data, error } = await (search.trim()
      ? base.or(
          [
            `name.ilike.%${search}%`,
            `sku.ilike.%${search}%`,
            `category.ilike.%${search}%`,
          ].join(","),
        )
      : base);

    const partRows = (!error && (data as Part[])) || [];
    setParts(partRows);
    setLoading(false);

    void loadOnHand(sid, partRows.map((p) => p.id));
  };

  // --- on-hand detail (per-location)
  const openOnHandDetail = async (p: Part) => {
    setOhForPart(p);
    const { data, error } = await supabase
      .from("stock_moves")
      .select("location_id, qty_change")
      .eq("part_id", p.id)
      .eq("shop_id", shopId);

    if (error || !data) {
      setOhLines([]);
      setOhOpen(true);
      return;
    }

    const byLoc: Record<string, number> = {};
    (data as StockMove[]).forEach((r) => {
      const loc = r.location_id as string;
      const q = Number(r.qty_change) || 0;
      byLoc[loc] = (byLoc[loc] ?? 0) + q;
    });

    const lines = locs
      .map((l) => ({
        location: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
        qty: byLoc[l.id] ?? 0,
      }))
      .filter((x) => x.qty !== 0);

    setOhLines(lines);
    setOhOpen(true);
  };

  /* boot */
  useEffect(() => {
    (async () => {
      const { data: u } = await supabase.auth.getUser();
      const uid = u.user?.id ?? null;
      if (!uid) return;

      const { data: prof } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("user_id", uid)
        .maybeSingle();

      const sid = (prof?.shop_id as string) || "";
      setShopId(sid);
      if (!sid) return;

      const { data: l } = await supabase
        .from("stock_locations")
        .select("*")
        .eq("shop_id", sid)
        .order("code");

      const locRows = (l as StockLoc[]) ?? [];
      setLocs(locRows);

      const main = locRows.find((x) => (x.code ?? "").toUpperCase() === "MAIN");
      if (main) {
        setInitLoc(main.id);
        setRecvLoc(main.id);
        setCsvDefaultLoc(main.id);
      }

      await load(sid);
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [supabase]);

  /* refetch on search */
  useEffect(() => {
    if (shopId) void load(shopId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [search, shopId]);

  /* ----------------------- CRUD handlers ----------------------- */

  const createPart = async () => {
    if (!shopId || !name.trim()) return;

    const id = uuidv4();
    const insert: PartInsert = {
      id,
      shop_id: shopId,
      name: name.trim(),
      sku: sku.trim() ? sku.trim() : undefined,
      category: category.trim() ? category.trim() : undefined,
      price: typeof price === "number" ? price : undefined,
    };

    const { error } = await supabase.from("parts").insert(insert);
    if (error) {
      alert(error.message);
      return;
    }

    // optional initial receive
    if (initLoc && typeof initQty === "number" && initQty > 0) {
      try {
        await applyStockMoveRPC(supabase, {
          p_part: id,
          p_loc: initLoc,
          p_qty: initQty,
          p_reason: "receive",
          p_ref_kind: "manual_receive",
          p_ref_id: null,
        });
      } catch (err: unknown) {
        alert(`Part created, but stock receive failed: ${errMsg(err)}`);
      }
    }

    setAddOpen(false);
    setName("");
    setSku("");
    setCategory("");
    setPrice("");
    setInitQty("");
    await load(shopId);
  };

  const openEdit = (p: Part) => {
    setEditPart(p);
    setEditName(p.name ?? "");
    setEditSku(p.sku ?? "");
    setEditCategory(p.category ?? "");
    setEditPrice(typeof p.price === "number" ? p.price : "");
    setEditOpen(true);
  };

  const saveEdit = async () => {
    if (!editPart?.id) return;

    const patch: PartUpdate = {
      name: editName.trim() ? editName.trim() : undefined,
      sku: editSku.trim() ? editSku.trim() : undefined,
      category: editCategory.trim() ? editCategory.trim() : undefined,
      price: typeof editPrice === "number" ? editPrice : undefined,
    };

    const { error } = await supabase.from("parts").update(patch).eq("id", editPart.id);
    if (error) {
      alert(error.message);
      return;
    }

    setEditOpen(false);
    await load(shopId);
  };

  const openReceive = (p: Part) => {
    setRecvPart(p);
    setRecvQty("");
    setRecvOpen(true);
  };

  const applyReceive = async () => {
    if (!recvPart?.id || !recvLoc || typeof recvQty !== "number" || recvQty <= 0) return;
    try {
      await applyStockMoveRPC(supabase, {
        p_part: recvPart.id,
        p_loc: recvLoc,
        p_qty: recvQty,
        p_reason: "receive",
        p_ref_kind: "manual_receive",
        p_ref_id: null,
      });
      setRecvOpen(false);
      await load(shopId);
    } catch (err: unknown) {
      alert(errMsg(err));
    }
  };

  /* -------------------------- CSV Import -------------------------- */

  const parseAndPreviewCSV = (raw: string) => {
    const rows = parseCSV(raw);
    if (!rows.length) {
      setCsvRows([]);
      setCsvPreview(false);
      return;
    }
    const header = rows[0].map((h) => h.toLowerCase().trim());
    const idx = {
      name: header.indexOf("name"),
      sku: header.indexOf("sku"),
      category: header.indexOf("category"),
      price: header.indexOf("price"),
      qty: header.indexOf("qty"),
    };

    const out: { name: string; sku?: string; category?: string; price?: number; qty?: number }[] = [];

    for (let r = 1; r < rows.length; r++) {
      const row = rows[r];
      const name = idx.name >= 0 ? row[idx.name] : "";
      if (!name) continue;
      const sku = idx.sku >= 0 ? row[idx.sku] : undefined;
      const category = idx.category >= 0 ? row[idx.category] : undefined;
      const priceStr = idx.price >= 0 ? row[idx.price] : undefined;
      const qtyStr = idx.qty >= 0 ? row[idx.qty] : undefined;

      const price = priceStr && priceStr.length ? Number(priceStr) : undefined;
      const qty = qtyStr && qtyStr.length ? Number(qtyStr) : undefined;

      out.push({
        name,
        sku: sku && sku.length ? sku : undefined,
        category: category && category.length ? category : undefined,
        price: typeof price === "number" && !Number.isNaN(price) ? price : undefined,
        qty: typeof qty === "number" && !Number.isNaN(qty) ? qty : undefined,
      });
    }

    setCsvRows(out);
    setCsvPreview(true);
  };

  const handleCsvFile = async (file: File) => {
    const text = await file.text();
    setCsvText(text);
    parseAndPreviewCSV(text);
  };

  const runCsvImport = async () => {
    if (!shopId || !csvRows.length) return;

    for (const row of csvRows) {
      let partId: string | null = null;

      if (row.sku) {
        const { data: found } = await supabase
          .from("parts")
          .select("id")
          .eq("shop_id", shopId)
          .eq("sku", row.sku)
          .maybeSingle();
        if (found?.id) partId = found.id;
      }

      if (!partId) {
        const id = uuidv4();
        const insert: PartInsert = {
          id,
          shop_id: shopId,
          name: row.name,
          sku: row.sku || undefined,
          category: row.category || undefined,
          price: typeof row.price === "number" ? row.price : undefined,
        };
        const { error } = await supabase.from("parts").insert(insert);
        if (error) {
          console.warn("Insert failed:", row, error.message);
          continue;
        }
        partId = id;
      } else {
        const patch: PartUpdate = {
          name: row.name || undefined,
          sku: row.sku || undefined,
          category: row.category || undefined,
          price: typeof row.price === "number" ? row.price : undefined,
        };
        await supabase.from("parts").update(patch).eq("id", partId);
      }

      if (partId && csvDefaultLoc && typeof row.qty === "number" && row.qty > 0) {
        try {
          await applyStockMoveRPC(supabase, {
            p_part: partId,
            p_loc: csvDefaultLoc,
            p_qty: row.qty,
            p_reason: "receive",
            p_ref_kind: "csv_import",
            p_ref_id: null,
          });
        } catch (err: unknown) {
          console.warn("Stock receive failed for row:", row, errMsg(err));
        }
      }
    }

    setCsvOpen(false);
    setCsvPreview(false);
    setCsvText("");
    setCsvRows([]);
    await load(shopId);
  };

  /* ----------------------------- UI ----------------------------- */

  return (
    <div className="space-y-4 p-6 text-white">
      <div className="flex flex-wrap items-center justify-between gap-3">
        <h1 className="text-2xl font-bold">Inventory</h1>
        <div className="flex items-center gap-2">
          <input
            className="w-64 rounded border border-neutral-700 bg-neutral-900 p-2 text-sm"
            placeholder="Search name / SKU / category"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
          <button
            className="font-header rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
            onClick={() => setAddOpen(true)}
            disabled={!shopId}
          >
            Add Part
          </button>
          <button
            className="font-header rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
            onClick={() => setCsvOpen(true)}
            disabled={!shopId}
          >
            CSV Import
          </button>
        </div>
      </div>

      {loading ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          Loading…
        </div>
      ) : parts.length === 0 ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          No parts yet. Click “Add Part” to create your first item or use CSV Import.
        </div>
      ) : (
        <div className="overflow-hidden rounded border border-neutral-800 bg-neutral-900">
          <table className="w-full text-sm">
            <thead className="bg-neutral-900">
              <tr className="text-left text-neutral-400">
                <th className="p-2">Name</th>
                <th className="p-2">SKU</th>
                <th className="p-2">Category</th>
                <th className="p-2">Price</th>
                <th className="p-2">On hand</th>
                <th className="p-2 w-48 text-right">Actions</th>
              </tr>
            </thead>
            <tbody>
              {parts.map((p) => {
                const total = onHand[p.id] ?? 0;
                return (
                  <tr key={p.id} className="border-t border-neutral-800">
                    <td className="p-2">{p.name}</td>
                    <td className="p-2">{p.sku ?? "—"}</td>
                    <td className="p-2">{p.category ?? "—"}</td>
                    <td className="p-2">
                      {typeof p.price === "number" ? `$${p.price.toFixed(2)}` : "—"}
                    </td>
                    <td className="p-2">
                      <button
                        className="rounded border border-neutral-700 px-2 py-0.5 text-xs hover:bg-neutral-800"
                        onClick={() => openOnHandDetail(p)}
                        title="View per-location balance"
                      >
                        {total}
                      </button>
                    </td>
                    <td className="p-2">
                      <div className="flex justify-end gap-2">
                        <button
                          className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                          onClick={() => openEdit(p)}
                        >
                          Edit
                        </button>
                        <button
                          className="rounded border border-blue-600 px-2 py-1 text-xs text-blue-300 hover:bg-blue-900/20"
                          onClick={() => openReceive(p)}
                        >
                          Receive
                        </button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      )}

      {/* Add Part */}
      <Modal
        open={addOpen}
        title="Add Part"
        onClose={() => setAddOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setAddOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
              onClick={createPart}
              disabled={!name.trim()}
            >
              Save Part
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <div className="sm:col-span-2">
            <TextField label="Name*" value={name} onChange={setName} placeholder="Part name" />
          </div>
          <TextField label="SKU" value={sku} onChange={setSku} placeholder="Optional" />
          <TextField label="Category" value={category} onChange={setCategory} placeholder="Optional" />
          <NumberField
            label="Price"
            value={price}
            onChange={(v) => setPrice(v === "" ? "" : v)}
          />
        </div>

        <div className="mt-4 rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="mb-2 text-sm font-semibold">Initial Stock (optional)</div>
          <div className="grid gap-3 sm:grid-cols-2">
            <SelectField
              label="Location"
              value={initLoc}
              onChange={setInitLoc}
              options={[
                { value: "", label: "— none —" },
                ...locs.map((l) => ({
                  value: l.id,
                  label: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
                })),
              ]}
            />
            <NumberField
              label="Qty"
              value={initQty}
              min={0}
              step={1}
              onChange={(v) => setInitQty(v === "" ? "" : Math.max(0, v))}
            />
          </div>
        </div>
      </Modal>

      {/* Edit Part */}
      <Modal
        open={editOpen}
        title="Edit Part"
        onClose={() => setEditOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setEditOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
              onClick={saveEdit}
              disabled={!editName.trim()}
            >
              Save Changes
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <div className="sm:col-span-2">
            <TextField label="Name*" value={editName} onChange={setEditName} />
          </div>
          <TextField label="SKU" value={editSku} onChange={setEditSku} />
          <TextField label="Category" value={editCategory} onChange={setEditCategory} />
          <NumberField label="Price" value={editPrice} onChange={(v) => setEditPrice(v === "" ? "" : v)} />
        </div>
      </Modal>

      {/* Receive Stock */}
      <Modal
        open={recvOpen}
        title={recvPart ? `Receive — ${recvPart.name}` : "Receive Stock"}
        onClose={() => setRecvOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setRecvOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
              onClick={applyReceive}
              disabled={!recvPart?.id || !recvLoc || typeof recvQty !== "number" || recvQty <= 0}
            >
              Apply Receive
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <SelectField
            label="Location"
            value={recvLoc}
            onChange={setRecvLoc}
            options={locs.map((l) => ({
              value: l.id,
              label: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
            }))}
          />
          <NumberField
            label="Qty"
            value={recvQty}
            min={0}
            step={1}
            onChange={(v) => setRecvQty(v === "" ? "" : Math.max(0, v))}
          />
        </div>
      </Modal>

      {/* On-hand detail */}
      <Modal
        open={ohOpen}
        title={ohForPart ? `On hand — ${ohForPart.name}` : "On hand"}
        onClose={() => setOhOpen(false)}
        widthClass="max-w-lg"
      >
        {ohLines.length === 0 ? (
          <div className="text-sm text-neutral-400">No movement found for this part.</div>
        ) : (
          <div className="rounded border border-neutral-800">
            <table className="w-full text-sm">
              <thead className="text-left text-neutral-400">
                <tr>
                  <th className="p-2">Location</th>
                  <th className="p-2">Qty</th>
                </tr>
              </thead>
              <tbody>
                {ohLines.map((l, i) => (
                  <tr key={i} className="border-t border-neutral-800">
                    <td className="p-2">{l.location}</td>
                    <td className="p-2">{l.qty}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </Modal>

      {/* CSV Import */}
      <Modal
        open={csvOpen}
        title="CSV Import"
        onClose={() => setCsvOpen(false)}
        widthClass="max-w-3xl"
        footer={
          <div className="flex w-full flex-wrap items-center justify-between gap-3">
            <div className="flex items-center gap-2">
              <SelectField
                label="Default receive location (for rows with qty)"
                value={csvDefaultLoc}
                onChange={setCsvDefaultLoc}
                options={[
                  { value: "", label: "— none —" },
                  ...locs.map((l) => ({ value: l.id, label: `${l.code ?? "LOC"} — ${l.name ?? ""}` })),
                ]}
              />
            </div>
            <div className="flex items-center gap-2">
              <button
                className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
                onClick={() => {
                  setCsvPreview(false);
                  setCsvText("");
                  setCsvRows([]);
                  setCsvOpen(false);
                }}
              >
                Close
              </button>
              <button
                className="rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
                onClick={runCsvImport}
                disabled={!csvPreview || csvRows.length === 0}
              >
                Import
              </button>
            </div>
          </div>
        }
      >
        <div className="grid gap-3">
          <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-300">
            Expected headers (case-insensitive): <code>name, sku, category, price, qty</code>. Extra columns are ignored.
          </div>

          <div className="flex flex-wrap items-center gap-2">
            <input
              type="file"
              accept=".csv,text/csv"
              onChange={(e) => {
                const f = e.target.files?.[0];
                if (f) void handleCsvFile(f);
              }}
              className="text-sm"
            />
            <button
              className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
              onClick={() => {
                if (csvText.trim().length) parseAndPreviewCSV(csvText);
              }}
            >
              Parse text
            </button>
          </div>

          <textarea
            rows={8}
            className="w-full rounded border border-neutral-700 bg-neutral-900 p-2 text-sm"
            placeholder={`Paste CSV here… e.g.:
name,sku,category,price,qty
Oil Filter – Ford,OF-FORD-01,Filters,9.95,10
Spark Plug – Iridium,SP-IR-01,Ignition,9.95,24
`}
            value={csvText}
            onChange={(e) => setCsvText(e.target.value)}
          />

          {csvPreview && (
            <div className="rounded border border-neutral-800">
              <table className="w-full text-sm">
                <thead className="text-left text-neutral-400">
                  <tr>
                    <th className="p-2">Name</th>
                    <th className="p-2">SKU</th>
                    <th className="p-2">Category</th>
                    <th className="p-2">Price</th>
                    <th className="p-2">Qty</th>
                  </tr>
                </thead>
                <tbody>
                  {csvRows.map((r, i) => (
                    <tr key={i} className="border-t border-neutral-800">
                      <td className="p-2">{r.name}</td>
                      <td className="p-2">{r.sku ?? "—"}</td>
                      <td className="p-2">{r.category ?? "—"}</td>
                      <td className="p-2">{typeof r.price === "number" ? r.price.toFixed(2) : "—"}</td>
                      <td className="p-2">{typeof r.qty === "number" ? r.qty : "—"}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </Modal>
    </div>
  );
}


/* =============================== */
/* FILE: ./app/parts/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type PartRow = DB["public"]["Tables"]["parts"]["Row"];
type StockMoveRow = DB["public"]["Tables"]["stock_moves"]["Row"];

// ---------- UI helpers ----------
function TrendArrow({ delta }: { delta: number }) {
  if (delta > 0) return <span className="text-emerald-400">▲ {delta}</span>;
  if (delta < 0) return <span className="text-red-400">▼ {Math.abs(delta)}</span>;
  return <span className="text-neutral-400">—</span>;
}

function Sparkline({
  points,
  width = 120,
  height = 28,
}: {
  points: number[];
  width?: number;
  height?: number;
}) {
  if (!points.length) {
    return (
      <svg width={width} height={height} aria-hidden>
        <line x1="0" x2={width} y1={height / 2} y2={height / 2} stroke="currentColor" opacity={0.2} />
      </svg>
    );
  }
  const min = Math.min(...points);
  const max = Math.max(...points);
  const range = max - min || 1;
  const stepX = width / Math.max(1, points.length - 1);
  const path = points
    .map((v, i) => {
      const x = i * stepX;
      const y = height - ((v - min) / range) * height;
      return `${i === 0 ? "M" : "L"} ${x.toFixed(2)} ${y.toFixed(2)}`;
    })
    .join(" ");
  return (
    <svg width={width} height={height} aria-hidden>
      <path d={path} fill="none" stroke="currentColor" />
    </svg>
  );
}

// ---------- Page ----------
export default function PartsDashboardPage(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [loading, setLoading] = useState(true);

  // KPIs
  const [skuTotal, setSkuTotal] = useState<number>(0);
  const [skuNewThis7d, setSkuNewThis7d] = useState<number>(0);
  const [skuTrendVsPrev7d, setSkuTrendVsPrev7d] = useState<number>(0);

  const [moves7dCount, setMoves7dCount] = useState<number>(0);
  const [moves30Spark, setMoves30Spark] = useState<number[]>([]);

  // Recent moves (list)
  const [recentMoves, setRecentMoves] = useState<
    Pick<StockMoveRow, "id" | "created_at" | "reason" | "qty_change" | "part_id">[]
  >([]);

  useEffect(() => {
    (async () => {
      setLoading(true);

      const now = new Date();
      const d7Ago = new Date(now.getTime() - 7 * 24 * 3600 * 1000);
      const d14Ago = new Date(now.getTime() - 14 * 24 * 3600 * 1000);
      const d30Ago = new Date(now.getTime() - 30 * 24 * 3600 * 1000);

      // -------- parts (for SKUs + trend) --------
      const { data: parts, error: perr } = await supabase
        .from("parts")
        .select("id, created_at");
      if (perr) {
        // eslint-disable-next-line no-console
        console.error("[parts] load failed:", perr);
      }
      const partsRows = (parts ?? []) as Pick<PartRow, "id" | "created_at">[];

      setSkuTotal(partsRows.length);

      const createdIn = (start: Date, end: Date) =>
        partsRows.filter((p) => {
          const ts = p.created_at ? new Date(p.created_at) : null;
          return !!ts && ts >= start && ts < end;
        }).length;

      const this7 = createdIn(d7Ago, now);
      const prev7 = createdIn(d14Ago, d7Ago);
      setSkuNewThis7d(this7);
      setSkuTrendVsPrev7d(this7 - prev7);

      // -------- stock_moves (for 7d count + 30d sparkline + list) --------
      const { data: moves, error: merr } = await supabase
        .from("stock_moves")
        .select("id, part_id, qty_change, reason, created_at")
        .gte("created_at", d30Ago.toISOString())
        .order("created_at", { ascending: true });

      if (merr) {
        // eslint-disable-next-line no-console
        console.error("[stock_moves] load failed:", merr);
      }

      const mv = (moves ?? []) as Pick<
        StockMoveRow,
        "id" | "part_id" | "qty_change" | "reason" | "created_at"
      >[];

      // 7d moves count
      setMoves7dCount(
        mv.filter((m) => new Date(m.created_at) >= d7Ago).length
      );

      // 30-day sparkline (daily net qty_change)
      const days = 30;
      const buckets = Array<number>(days).fill(0);
      for (const m of mv) {
        const dt = new Date(m.created_at);
        const idx = Math.min(
          days - 1,
          Math.max(0, Math.floor((dt.getTime() - d30Ago.getTime()) / (24 * 3600 * 1000)))
        );
        buckets[idx] += Number(m.qty_change ?? 0);
      }
      setMoves30Spark(buckets);

      // Recent list (latest 10, descending)
      const recent = [...mv]
        .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
        .slice(0, 10);
      setRecentMoves(recent);

      setLoading(false);
    })();
  }, [supabase]);

  return (
    <div className="p-6 space-y-6 text-white">
      <h1 className="text-2xl font-bold">Parts Dashboard</h1>

      {/* KPIs */}
      <section className="grid gap-3 sm:grid-cols-2 lg:grid-cols-4">
        {/* SKUs */}
        <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
          <div className="text-xs text-neutral-400">SKUs (new last 7d)</div>
          <div className="mt-1 flex items-baseline gap-2">
            <div className="text-xl font-semibold">{skuTotal.toLocaleString()}</div>
            <TrendArrow delta={skuTrendVsPrev7d} />
            <span className="text-xs text-neutral-500">+{skuNewThis7d} this week</span>
          </div>
        </div>

        {/* Low Stock – not available with current schema; placeholder keeps layout */}
        <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
          <div className="text-xs text-neutral-400">Low Stock</div>
          <div className="mt-1 text-xl font-semibold">—</div>
          <div className="text-xs text-neutral-500">requires on-hand/threshold</div>
        </div>

        {/* Inventory Value – depends on on-hand; placeholder for now */}
        <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
          <div className="text-xs text-neutral-400">Inventory Value</div>
          <div className="mt-1 text-xl font-semibold">—</div>
          <div className="text-xs text-neutral-500">needs stock levels</div>
        </div>

        {/* Moves (7d) with 30-day sparkline */}
        <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
          <div className="flex items-center justify-between">
            <div className="text-xs text-neutral-400">Moves (7d)</div>
            <Sparkline points={moves30Spark} />
          </div>
          <div className="mt-1 text-xl font-semibold">{moves7dCount.toLocaleString()}</div>
        </div>
      </section>

      {/* Quick actions */}
      <section className="rounded border border-neutral-800 bg-neutral-900 p-4">
        <h2 className="mb-2 text-lg font-semibold">Quick Actions</h2>
        <div className="flex flex-wrap gap-2">
          <Link className="rounded border border-orange-500 px-3 py-2 text-sm" href="/parts/po">
            Create PO
          </Link>
          <Link className="rounded border border-neutral-700 px-3 py-2 text-sm" href="/parts/inventory">
            Inventory
          </Link>
          <Link className="rounded border border-neutral-700 px-3 py-2 text-sm" href="/parts/receive">
            Scan to Receive
          </Link>
          <Link className="rounded border border-neutral-700 px-3 py-2 text-sm" href="/parts/requests">
            Requests
          </Link>
          <Link className="rounded border border-neutral-700 px-3 py-2 text-sm" href="/parts/vendors">
            Vendors
          </Link>
        </div>
      </section>

      {/* Recent Stock Moves */}
      <section className="rounded border border-neutral-800 bg-neutral-900 p-4">
        <h2 className="mb-2 text-lg font-semibold">Recent Stock Moves</h2>
        {loading ? (
          <div className="text-sm text-neutral-400">Loading…</div>
        ) : recentMoves.length === 0 ? (
          <div className="text-sm text-neutral-400">No recent moves</div>
        ) : (
          <ul className="divide-y divide-neutral-800 text-sm">
            {recentMoves.map((m) => (
              <li key={m.id} className="flex items-center justify-between py-2">
                <div className="min-w-0">
                  <div className="font-medium">
                    {String(m.reason ?? "move").replaceAll("_", " ")}
                  </div>
                  <div className="text-xs text-neutral-500">
                    {new Date(m.created_at as string).toLocaleString()}
                  </div>
                </div>
                <div className="pl-3 font-semibold">
                  {Number(m.qty_change ?? 0) >= 0 ? "+" : ""}
                  {Number(m.qty_change ?? 0)}
                </div>
              </li>
            ))}
          </ul>
        )}
      </section>
    </div>
  );
}


/* =============================== */
/* FILE: ./app/parts/po/[id]/receive/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useParams } from "next/navigation";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { resolveScannedCode } from "@/features/parts/server/scanActions";

// Quagga shim/types
type QuaggaModule = typeof import("@ericblade/quagga2");
type QuaggaResult = { codeResult?: { code?: string | null } | null };
let Quagga: QuaggaModule["default"] | null = null;
if (typeof window !== "undefined") {
  void import("@ericblade/quagga2").then((m) => (Quagga = m.default));
}

type DB = Database;
type PurchaseOrder = DB["public"]["Tables"]["purchase_orders"]["Row"];
type POLine = DB["public"]["Tables"]["purchase_order_lines"]["Row"];
type StockLoc = DB["public"]["Tables"]["stock_locations"]["Row"];

export default function ReceivePOPage(): JSX.Element {
  const { id } = useParams<{ id: string }>();
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);

  const [po, setPO] = useState<PurchaseOrder | null>(null);
  const [lines, setLines] = useState<POLine[]>([]);
  const [locs, setLocs] = useState<StockLoc[]>([]);
  const [selectedLoc, setSelectedLoc] = useState<string>("");

  const [qty, setQty] = useState<number>(1);
  const [lastScan, setLastScan] = useState<string>("");

  const videoRef = useRef<HTMLDivElement | null>(null);
  const [scanning, setScanning] = useState<boolean>(false);

  // load PO + lines + locations
  useEffect(() => {
    if (!id) return;
    (async () => {
      const { data: poRow } = await supabase
        .from("purchase_orders")
        .select("*")
        .eq("id", id)
        .maybeSingle();

      const poTyped = (poRow as PurchaseOrder | null) ?? null;
      setPO(poTyped);

      const [{ data: lineRows }, { data: locRows }] = await Promise.all([
        supabase
          .from("purchase_order_lines")
          .select("*")
          .eq("po_id", id)
          .order("created_at", { ascending: true }),
        poTyped?.shop_id
          ? supabase
              .from("stock_locations")
              .select("*")
              .eq("shop_id", poTyped.shop_id)
              .order("code")
          : Promise.resolve({ data: [] }),
      ]);

      const locsTyped = (locRows ?? []) as StockLoc[];
      setLines((lineRows ?? []) as POLine[]);
      setLocs(locsTyped);
      const main = locsTyped.find((l) => (l.code ?? "").toUpperCase() === "MAIN");
      if (main) setSelectedLoc(main.id);
    })();
  }, [id, supabase]);

  // scanner
  const startScan = async () => {
    if (!Quagga || scanning || !videoRef.current) return;
    setScanning(true);
    Quagga.init(
      {
        inputStream: {
          name: "Live",
          type: "LiveStream",
          target: videoRef.current,
          constraints: { facingMode: "environment" },
        },
        decoder: {
          readers: [
            "upc_reader",
            "upc_e_reader",
            "ean_reader",
            "ean_8_reader",
            "code_128_reader",
          ],
        },
        locate: true,
      },
      (err?: Error) => {
        if (err) {
          // eslint-disable-next-line no-console
          console.error(err);
          setScanning(false);
          return;
        }
        Quagga?.start();
      }
    );

    Quagga.onDetected(async (res: QuaggaResult) => {
      const code = res.codeResult?.code ?? "";
      if (!code || code === lastScan) return;
      setLastScan(code);

      const { part_id } = await resolveScannedCode({
        code,
        supplier_id: po?.supplier_id ?? null,
      });

      if (!part_id) {
        alert(`No part found for "${code}".`);
        return;
      }
      if (!selectedLoc) {
        alert("Select a location first.");
        return;
      }

      await fetch("/api/receive-scan", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          part_id,
          location_id: selectedLoc,
          qty,
          po_id: po?.id ?? null,
        }),
      });

      const locLabel =
        locs.find((l) => l.id === selectedLoc)?.code ?? "LOC";
      alert(`Received ×${qty} to ${locLabel}`);
      window.dispatchEvent(new CustomEvent("parts:received"));
      window.setTimeout(() => setLastScan(""), 1000);
    });
  };

  const stopScan = () => {
    try {
      Quagga?.stop();
    } catch {
      /* ignore */
    }
    setScanning(false);
  };

  useEffect(() => {
    return () => stopScan();
  }, []);

  const remaining = (ln: POLine): number => {
    const ordered = Number(ln.qty ?? 0);
    const received = Number(ln.received_qty ?? 0);
    return Math.max(0, ordered - received);
  };

  return (
    <div className="p-6 space-y-4 text-white">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Receive PO</h1>
        <Link
          href="/parts/po"
          className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
        >
          Back to POs
        </Link>
      </div>

      {po ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm">
          <div className="font-medium">
            {po.id.slice(0, 8)} • {po.status ?? "draft"}
          </div>
          <div className="text-neutral-400">
            Supplier: {po.supplier_id ?? "—"}
          </div>
        </div>
      ) : (
        <div className="text-neutral-400">Loading PO…</div>
      )}

      <div className="rounded border border-neutral-800 bg-neutral-900 p-3 grid gap-3 sm:grid-cols-3">
        <div>
          <div className="text-xs text-neutral-400 mb-1">Location</div>
          <select
            className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
            value={selectedLoc}
            onChange={(e) => setSelectedLoc(e.target.value)}
          >
            {locs.map((l) => (
              <option key={l.id} value={l.id}>
                {l.code ?? "LOC"} — {l.name ?? ""}
              </option>
            ))}
          </select>
        </div>
        <div>
          <div className="text-xs text-neutral-400 mb-1">Quantity</div>
          <input
            type="number"
            min={0.01}
            step="0.01"
            className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
            value={qty}
            onChange={(e) => setQty(Math.max(0, Number(e.target.value || 0)))}
          />
        </div>
      </div>

      <div className="rounded border border-neutral-800 bg-neutral-900 p-3">
        <div className="mb-2 flex items-center gap-2">
          {!scanning ? (
            <button
              onClick={startScan}
              className="rounded border border-orange-500 px-3 py-1.5 text-sm text-orange-300 hover:bg-orange-900/20"
            >
              Start Scanner
            </button>
          ) : (
            <button
              onClick={stopScan}
              className="rounded border border-red-500 px-3 py-1.5 text-sm text-red-300 hover:bg-red-900/20"
            >
              Stop Scanner
            </button>
          )}
          <span className="text-xs text-neutral-400">
            Scan item barcodes to receive against this PO.
          </span>
        </div>
        <div
          ref={videoRef}
          className="aspect-video w-full overflow-hidden rounded border border-neutral-800 bg-black"
        />
      </div>

      <div className="rounded border border-neutral-800 bg-neutral-900">
        <div className="border-b border-neutral-800 p-2 text-sm font-semibold">
          Lines
        </div>
        {lines.length === 0 ? (
          <div className="p-3 text-neutral-400">No lines yet.</div>
        ) : (
          <table className="w-full text-sm">
            <thead>
              <tr className="text-left text-neutral-400">
                <th className="p-2">Part</th>
                <th className="p-2">Ordered</th>
                <th className="p-2">Received</th>
                <th className="p-2">Remaining</th>
              </tr>
            </thead>
            <tbody>
  {lines.map((ln) => (
    <tr key={ln.id} className="border-t border-neutral-800">
      <td className="p-2">{ln.part_id ? ln.part_id.slice(0, 8) : "—"}</td>
      <td className="p-2">{Number(ln.qty ?? 0)}</td>
      <td className="p-2">{Number(ln.received_qty ?? 0)}</td>
      <td className="p-2">{remaining(ln)}</td>
    </tr>
  ))}
</tbody>
          </table>
        )}
      </div>
    </div>
  );
}


/* =============================== */
/* FILE: ./app/parts/po/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { v4 as uuidv4 } from "uuid";

type DB = Database;
type PurchaseOrder = DB["public"]["Tables"]["purchase_orders"]["Row"];
type Supplier = DB["public"]["Tables"]["suppliers"]["Row"];

export default function PurchaseOrdersPage(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const router = useRouter();

  const [shopId, setShopId] = useState<string>("");
  const [loading, setLoading] = useState(true);
  const [pos, setPOs] = useState<PurchaseOrder[]>([]);

  // New PO modal state
  const [open, setOpen] = useState(false);
  const [suppliers, setSuppliers] = useState<Supplier[]>([]);
  const [supplierId, setSupplierId] = useState<string>("");
  const [note, setNote] = useState<string>("");

  useEffect(() => {
    (async () => {
      setLoading(true);
      const { data: userRes } = await supabase.auth.getUser();
      const uid = userRes.user?.id ?? null;
      if (!uid) { setLoading(false); return; }

      const { data: prof } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("user_id", uid)
        .single();

      const sid = prof?.shop_id ?? "";
      setShopId(sid);

      if (sid) {
        const [poRes, supRes] = await Promise.all([
          supabase
            .from("purchase_orders")
            .select("*")
            .eq("shop_id", sid)
            .order("created_at", { ascending: false })
            .limit(100),
          supabase
            .from("suppliers")
            .select("*")
            .eq("shop_id", sid)
            .order("name", { ascending: true }),
        ]);
        setPOs((poRes.data as PurchaseOrder[]) ?? []);
        setSuppliers((supRes.data as Supplier[]) ?? []);
      }

      setLoading(false);
    })();
  }, [supabase]);

  const createPo = async () => {
    if (!shopId) return;
    const id = uuidv4();
    const insert = {
      id,
      shop_id: shopId,
      supplier_id: supplierId || null,
      status: "open" as PurchaseOrder["status"],
      notes: note || null,
    };
    const { error } = await supabase.from("purchase_orders").insert(insert);
    if (!error) {
      setOpen(false);
      setSupplierId("");
      setNote("");
      router.push(`/parts/po/${id}/receive`);
    } else {
      // keep UI minimal for now
      alert(error.message);
    }
  };

  return (
    <div className="p-6 space-y-4 text-white">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Purchase Orders</h1>
        <button
          className="font-header rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
          onClick={() => setOpen(true)}
          disabled={!shopId}
        >
          New PO
        </button>
      </div>

      {loading ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          Loading…
        </div>
      ) : pos.length === 0 ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          No purchase orders yet.
        </div>
      ) : (
        <div className="rounded border border-neutral-800 bg-neutral-900">
          <table className="w-full text-sm">
            <thead>
              <tr className="text-left text-neutral-400">
                <th className="p-2">PO</th>
                <th className="p-2">Supplier</th>
                <th className="p-2">Status</th>
                <th className="p-2">Created</th>
                <th className="p-2"></th>
              </tr>
            </thead>
            <tbody>
              {pos.map((po) => (
                <tr key={po.id} className="border-t border-neutral-800">
                  <td className="p-2 font-mono">{po.id.slice(0, 8)}</td>
                  <td className="p-2">{po.supplier_id ?? "—"}</td>
                  <td className="p-2">{po.status}</td>
                  <td className="p-2">{po.created_at ? new Date(po.created_at).toLocaleString() : "—"}</td>
                  <td className="p-2">
                    <Link
                      href={`/parts/po/${po.id}/receive`}
                      className="rounded border border-neutral-700 px-2 py-1 hover:bg-neutral-800"
                    >
                      Receive
                    </Link>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {/* New PO "modal" (lightweight inline panel to keep dependencies low) */}
      {open && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 p-4">
          <div className="w-full max-w-md rounded border border-orange-500 bg-neutral-950 p-4">
            <div className="mb-3 flex items-center justify-between">
              <h2 className="text-lg font-semibold">New Purchase Order</h2>
              <button
                className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
                onClick={() => setOpen(false)}
              >
                ✕
              </button>
            </div>
            <div className="space-y-3">
              <div>
                <div className="mb-1 text-xs text-neutral-400">Supplier (optional)</div>
                <select
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                  value={supplierId}
                  onChange={(e) => setSupplierId(e.target.value)}
                >
                  <option value="">— none —</option>
                  {suppliers.map((s) => (
                    <option key={s.id} value={s.id}>
                      {s.name ?? s.id.slice(0, 8)}
                    </option>
                  ))}
                </select>
              </div>
              <div>
                <div className="mb-1 text-xs text-neutral-400">Notes</div>
                <textarea
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                  rows={2}
                  value={note}
                  onChange={(e) => setNote(e.target.value)}
                  placeholder="Optional notes for this PO…"
                />
              </div>
              <div className="flex justify-end gap-2">
                <button
                  className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
                  onClick={() => setOpen(false)}
                >
                  Cancel
                </button>
                <button
                  className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
                  onClick={createPo}
                  disabled={!shopId}
                >
                  Create & Receive →
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}


/* =============================== */
/* FILE: ./app/parts/quoting/page.tsx */
/* =============================== */

"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { toast } from "sonner";
import { format } from "date-fns";
import dynamic from "next/dynamic";

import { createBrowserSupabase } from "@/features/shared/lib/supabase/client";
import type { Database } from "@shared/types/types/supabase";
import VoiceContextSetter from "@/features/shared/voice/VoiceContextSetter";
import VoiceButton from "@/features/shared/voice/VoiceButton";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";

const PartsDrawer = dynamic(() => import("@/features/parts/components/PartsDrawer"), {
  ssr: false,
});

type DB = Database;
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];
type Customer = DB["public"]["Tables"]["customers"]["Row"];

type QueueRow = WorkOrderLine & {
  work_order: WorkOrder | null;
  vehicle: Vehicle | null;
  customer: Customer | null;
};

const BASE_BADGE =
  "inline-flex items-center whitespace-nowrap rounded border px-2 py-0.5 text-xs font-medium";
const BADGE: Record<string, string> = {
  awaiting: "bg-sky-900/20 border-sky-500/40 text-sky-300",
  awaiting_approval: "bg-blue-900/20 border-blue-500/40 text-blue-300",
  queued: "bg-indigo-900/20 border-indigo-500/40 text-indigo-300",
  in_progress: "bg-orange-900/20 border-orange-500/40 text-orange-300",
  on_hold: "bg-amber-900/20 border-amber-500/40 text-amber-300",
  completed: "bg-green-900/20 border-green-500/40 text-green-300",
};
const chip = (s: string | null | undefined): string => {
  const k = (s ?? "awaiting").toLowerCase().replaceAll(" ", "_");
  return `${BASE_BADGE} ${BADGE[k] ?? BADGE.awaiting}`;
};

export default function QuotingQueuePage(): JSX.Element {
  const supabase = useMemo(() => createBrowserSupabase(), []);

  const [rows, setRows] = useState<QueueRow[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [err, setErr] = useState<string | null>(null);

  const [selectedId, setSelectedId] = useState<string | null>(null);
  const selected = useMemo(() => rows.find((r) => r.id === selectedId) ?? null, [rows, selectedId]);

  const [bulkQueue, setBulkQueue] = useState<string[]>([]);
  const bulkActive = bulkQueue.length > 0;

  const fetchQueue = useCallback(async () => {
    setLoading(true);
    setErr(null);
    try {
      const { data: lines, error: lerr } = await supabase
        .from("work_order_lines")
        .select("*")
        .eq("approval_state", "pending")
        .order("created_at", { ascending: true });

      if (lerr) throw lerr;

      const wol = (lines ?? []) as WorkOrderLine[];
      if (wol.length === 0) {
        setRows([]);
        setLoading(false);
        return;
      }

      const woIds = [...new Set(wol.map((l) => l.work_order_id).filter(Boolean) as string[])];
      const { data: woRows } = await supabase.from("work_orders").select("*").in("id", woIds);

      const woById = new Map<string, WorkOrder>();
      (woRows ?? []).forEach((w) => woById.set(w.id, w as WorkOrder));

      const vehIds = [...new Set((woRows ?? []).map(w => (w as WorkOrder).vehicle_id).filter(Boolean) as string[])];
      const custIds = [...new Set((woRows ?? []).map(w => (w as WorkOrder).customer_id).filter(Boolean) as string[])];

      const [vehRes, custRes] = await Promise.all([
        vehIds.length ? supabase.from("vehicles").select("*").in("id", vehIds) : Promise.resolve({ data: [] } as const),
        custIds.length
          ? supabase.from("customers").select("*").in("id", custIds)
          : Promise.resolve({ data: [] } as const),
      ]);

      const vById = new Map<string, Vehicle>();
      (vehRes.data ?? []).forEach((v) => vById.set((v as Vehicle).id, v as Vehicle));

      const cById = new Map<string, Customer>();
      (custRes.data ?? []).forEach((c) => cById.set((c as Customer).id, c as Customer));

      const out: QueueRow[] = wol.map((l) => {
        const wo = l.work_order_id ? woById.get(l.work_order_id) ?? null : null;
        const vehicle = wo?.vehicle_id ? vById.get(wo.vehicle_id) ?? null : null;
        const customer = wo?.customer_id ? cById.get(wo.customer_id) ?? null : null;
        return { ...l, work_order: wo, vehicle, customer };
      });

      setRows(out);
    } catch (e) {
      const msg = (e as { message?: string })?.message ?? "Failed to load quoting queue.";
      setErr(msg);
    } finally {
      setLoading(false);
    }
  }, [supabase]);

  useEffect(() => { void fetchQueue(); }, [fetchQueue]);

  useEffect(() => {
    const ch = supabase
      .channel("quote-queue")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "work_order_lines", filter: "approval_state=eq.pending" },
        () => void fetchQueue()
      )
      .subscribe();
    return () => { try { supabase.removeChannel(ch); } catch {} };
  }, [supabase, fetchQueue]);

  const startBulk = useCallback(() => {
    if (!rows.length) return;
    const ids = rows.map((r) => r.id);
    setBulkQueue(ids);
    setSelectedId(ids[0] ?? null);
    toast.message(`Quoting ${ids.length} pending line(s)…`);
  }, [rows]);

  useEffect(() => {
    if (!selectedId) return;
    const evt = `parts-drawer:closed:${selectedId}`;
    const handler = () => {
      if (bulkActive) {
        const [, ...rest] = bulkQueue;
        setBulkQueue(rest);
        setSelectedId(rest[0] ?? null);
        if (rest.length === 0) void fetchQueue();
      } else {
        setSelectedId(null);
        void fetchQueue();
      }
    };
    window.addEventListener(evt, handler as EventListener);
    return () => window.removeEventListener(evt, handler as EventListener);
  }, [selectedId, bulkActive, bulkQueue, fetchQueue]);

  // ---- AI Apply: suggest + server inserts allocations + labor
  const aiApply = useCallback(async (row: QueueRow) => {
    if (!row.id) return;
    toast.loading("AI preparing parts & labor…", { id: `ai-${row.id}` });

    try {
      const suggestion = await requestQuoteSuggestion({
        item: row.description ?? "Job",
        notes: row.notes ?? "",
        section: "Quote Queue",
        status: "recommend",
        vehicle: row.vehicle ?? undefined,
      });

      if (!suggestion) {
        toast.error("AI returned no suggestion.", { id: `ai-${row.id}` });
        return;
      }

      const r = await fetch("/api/quotes/apply-ai", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ workOrderLineId: row.id, suggestion }),
      });

      const j = (await r.json()) as { ok?: boolean; labor_applied?: boolean; unmatched?: { name: string; qty: number }[]; error?: string };
      if (!r.ok || !j?.ok) {
        throw new Error(j?.error || "Apply AI failed");
      }

      if (j.unmatched && j.unmatched.length) {
        const list = j.unmatched.map(u => `${u.qty}× ${u.name}`).join(", ");
        toast.message(`Some parts need manual matching: ${list}`, { id: `ai-${row.id}` });
      } else {
        toast.success("AI parts & labor applied", { id: `ai-${row.id}` });
      }
      await fetchQueue();
    } catch (e) {
      toast.error((e as { message?: string })?.message ?? "AI apply failed", { id: `ai-${row.id}` });
    }
  }, [fetchQueue]);

  // ---- Mark as quoted (still pending approval) + grow Saved Menu
  const markQuoted = useCallback(async (row: QueueRow) => {
    if (!row.id) return;
    toast.loading("Marking as quoted…", { id: `quoted-${row.id}` });

    try {
      // Create/merge Saved Menu record for this Y/M/M + job title
      const r = await fetch("/api/menu-items/upsert-from-line", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ workOrderLineId: row.id }),
      });
      const j = (await r.json()) as { id?: string | null; ok?: boolean; error?: string };
      if (!r.ok || j?.error) {
        throw new Error(j?.error || "Could not upsert saved menu item");
      }

      // Keep status & approval_state unchanged (still pending).
      // You can optionally stamp a small flag in notes that says "quoted".
      const nextNotes = `${row.notes ?? ""}`.includes("[quoted]")
        ? row.notes
        : ([row.notes ?? "", "[quoted]"].filter(Boolean).join(" ").trim());

      const { error: ue } = await supabase
        .from("work_order_lines")
        .update({ notes: nextNotes } as DB["public"]["Tables"]["work_order_lines"]["Update"])
        .eq("id", row.id);
      if (ue) throw ue;

      toast.success("Marked as quoted (awaiting approval). Saved Menu updated.", { id: `quoted-${row.id}` });
      await fetchQueue();
    } catch (e) {
      toast.error((e as { message?: string })?.message ?? "Failed to mark as quoted", { id: `quoted-${row.id}` });
    }
  }, [supabase, fetchQueue]);

  return (
    <div className="p-4 sm:p-6 text-white">
      <VoiceContextSetter currentView="parts_quoting" />

      <div className="mb-4 flex items-center justify-between">
        <h1 className="text-2xl font-semibold">Quoting Queue</h1>
        <div className="flex items-center gap-2">
          <Link href="/parts/inventory" className="text-sm text-orange-400 hover:underline">Open Inventory →</Link>
          <button
            type="button"
            className="rounded bg-blue-600 px-3 py-1.5 text-sm font-semibold text-white hover:bg-blue-500 disabled:opacity-50"
            onClick={startBulk}
            disabled={rows.length === 0}
          >
            Quote all pending ({rows.length})
          </button>
        </div>
      </div>

      {err && <div className="mb-4 rounded border border-red-500/40 bg-red-500/10 p-3 text-red-300">{err}</div>}

      <div className="grid grid-cols-1 gap-6 lg:grid-cols-[420px_1fr]">
        {/* LEFT: queue */}
        <div className="rounded border border-neutral-800 bg-neutral-900">
          <div className="border-b border-neutral-800 p-3 text-sm text-neutral-300">Pending approval lines</div>
          {loading ? (
            <div className="p-3 text-neutral-400">Loading…</div>
          ) : rows.length === 0 ? (
            <div className="p-3 text-neutral-400">Nothing awaiting quoting.</div>
          ) : (
            <ul className="divide-y divide-neutral-800">
              {rows.map((r) => (
                <li key={r.id} className="p-3">
                  <div className="flex items-start justify-between gap-3">
                    <div className="min-w-0">
                      <div className="truncate font-medium">{r.description || r.complaint || "Untitled job"}</div>
                      <div className="mt-0.5 text-xs text-neutral-400">
                        WO: {r.work_order?.custom_id || r.work_order?.id?.slice(0, 8) || "—"} •{" "}
                        {r.vehicle
                          ? `${r.vehicle.year ?? ""} ${r.vehicle.make ?? ""} ${r.vehicle.model ?? ""}`.trim()
                          : "No vehicle"}
                        {" • "}
                        {r.created_at ? format(new Date(r.created_at), "PPp") : "—"}
                      </div>
                      {r.notes && <div className="mt-1 truncate text-xs text-neutral-400">Notes: {r.notes}</div>}
                    </div>

                    <div className="flex shrink-0 items-center gap-2">
                      <span className={chip(r.status)}>{(r.status ?? "awaiting").replaceAll("_", " ")}</span>
                      <button
                        type="button"
                        className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                        onClick={() => void aiApply(r)}
                        title="AI: allocate parts + labor"
                      >
                        AI Apply
                      </button>
                      <button
                        type="button"
                        className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                        onClick={() => setSelectedId(r.id)}
                        title="Open Parts Drawer"
                      >
                        Quote
                      </button>
                      <button
                        type="button"
                        className="rounded bg-emerald-600 px-2 py-1 text-xs font-semibold text-black hover:bg-emerald-500"
                        onClick={() => void markQuoted(r)}
                        title="Mark as quoted (keeps awaiting approval) and grow Saved Menu"
                      >
                        Mark Quoted
                      </button>
                    </div>
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>

        {/* RIGHT: details */}
        <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
          <h2 className="mb-2 text-lg font-semibold">Details</h2>
          {selected ? (
            <div className="space-y-2 text-sm">
              <div className="text-neutral-400">Work Order</div>
              <div className="font-medium">
                {selected.work_order
                  ? selected.work_order.custom_id || selected.work_order.id?.slice(0, 8)
                  : "—"}
              </div>

              <div className="text-neutral-400">Vehicle</div>
              <div className="font-medium">
                {selected.vehicle
                  ? `${selected.vehicle.year ?? ""} ${selected.vehicle.make ?? ""} ${selected.vehicle.model ?? ""}`.trim() ||
                    "—"
                  : "—"}
              </div>

              <div className="text-neutral-400">Customer</div>
              <div className="font-medium">
                {selected.customer
                  ? [selected.customer.first_name ?? "", selected.customer.last_name ?? ""].filter(Boolean).join(" ") ||
                    "—"
                  : "—"}
              </div>

              <div className="text-neutral-400">Description</div>
              <div className="font-medium">{selected.description ?? "—"}</div>

              <div className="text-neutral-400">Notes</div>
              <div className="whitespace-pre-wrap font-medium">{selected.notes ?? "—"}</div>
            </div>
          ) : (
            <div className="text-neutral-400">Select a line on the left to see details.</div>
          )}
        </div>
      </div>

      {/* Parts drawer */}
      {selected && selected.work_order?.id && (
        <PartsDrawer
          open
          workOrderId={selected.work_order.id}
          workOrderLineId={selected.id}
          vehicleSummary={
            selected.vehicle
              ? {
                  year: (selected.vehicle.year as string | number | null)?.toString() ?? null,
                  make: selected.vehicle.make ?? null,
                  model: selected.vehicle.model ?? null,
                }
              : null
          }
          jobDescription={selected.description ?? null}
          jobNotes={selected.notes ?? null}
          closeEventName={`parts-drawer:closed:${selected.id}`}
        />
      )}

      <VoiceButton />
    </div>
  );
}


/* =============================== */
/* FILE: ./app/parts/receive/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { resolveScannedCode } from "@/features/parts/server/scanActions";

// Quagga (typed shim)
type QuaggaModule = typeof import("@ericblade/quagga2");
type QuaggaResult = { codeResult?: { code?: string | null } | null };
let Quagga: QuaggaModule["default"] | null = null;
if (typeof window !== "undefined") {
  void import("@ericblade/quagga2").then((m) => {
    Quagga = m.default;
  });
}

type DB = Database;
type PurchaseOrder = DB["public"]["Tables"]["purchase_orders"]["Row"];
type StockLoc = DB["public"]["Tables"]["stock_locations"]["Row"];

export default function ReceivePage(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [, setShopId] = useState<string>("");
  const [pos, setPOs] = useState<PurchaseOrder[]>([]);
  const [selectedPo, setSelectedPo] = useState<string>("");
  const [selectedLoc, setSelectedLoc] = useState<string>("");
  const [locs, setLocs] = useState<StockLoc[]>([]);
  const [lastScan, setLastScan] = useState<string>("");

  const videoRef = useRef<HTMLDivElement | null>(null);
  const [scanning, setScanning] = useState<boolean>(false);
  const [qty, setQty] = useState<number>(1);

  // bootstrap: shop, POs, locations
  useEffect(() => {
    (async () => {
      const { data: userRes } = await supabase.auth.getUser();
      const uid = userRes.user?.id;
      if (!uid) return;

      const { data: prof } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("user_id", uid)
        .single();

      const sid = prof?.shop_id ?? "";
      setShopId(sid);
      if (!sid) return;

      const [poRes, locRes] = await Promise.all([
        supabase
          .from("purchase_orders")
          .select("*")
          .eq("shop_id", sid)
          .order("created_at", { ascending: false })
          .limit(50),
        supabase
          .from("stock_locations")
          .select("*")
          .eq("shop_id", sid)
          .order("code"),
      ]);

      setPOs((poRes.data ?? []) as PurchaseOrder[]);
      const locRows = (locRes.data ?? []) as StockLoc[];
      setLocs(locRows);
      const main = locRows.find((l) => (l.code ?? "").toUpperCase() === "MAIN");
      if (main) setSelectedLoc(main.id);
    })();
  }, [supabase]);

  // start/stop camera
  const startScan = async () => {
    if (!Quagga || scanning || !videoRef.current) return;
    setScanning(true);

    Quagga.init(
      {
        inputStream: {
          name: "Live",
          type: "LiveStream",
          target: videoRef.current,
          constraints: { facingMode: "environment" },
        },
        decoder: {
          readers: [
            "upc_reader",
            "upc_e_reader",
            "ean_reader",
            "ean_8_reader",
            "code_128_reader",
          ],
        },
        locate: true,
      },
      (err?: Error) => {
        if (err) {
          // eslint-disable-next-line no-console
          console.error(err);
          setScanning(false);
          return;
        }
        Quagga?.start();
      }
    );

    Quagga.onDetected(async (res: QuaggaResult) => {
      const code = res.codeResult?.code ?? "";
      if (!code || code === lastScan) return;
      setLastScan(code);

      const supplierId =
        pos.find((p) => p.id === selectedPo)?.supplier_id ?? null;

      const { part_id } = await resolveScannedCode({
        code,
        supplier_id: supplierId,
      });

      if (!part_id) {
        alert(
          `No part found for "${code}". Map it in Parts → Inventory → Edit → Barcodes.`
        );
        return;
      }

      if (!selectedLoc) {
        alert("Select a location first.");
        return;
      }

      await fetch("/api/receive-scan", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          part_id,
          location_id: selectedLoc,
          qty,
          po_id: selectedPo || null,
        }),
      });

      const locLabel =
        locs.find((l) => l.id === selectedLoc)?.code ?? "LOC";
      alert(`Received ×${qty} to ${locLabel}`);
      window.dispatchEvent(new CustomEvent("parts:received"));
      window.setTimeout(() => setLastScan(""), 1000);
    });
  };

  const stopScan = () => {
    try {
      Quagga?.stop();
    } catch {
      /* ignore */
    }
    setScanning(false);
  };

  useEffect(() => {
    return () => stopScan();
  }, []);

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-2xl font-bold text-white">Scan to Receive</h1>

      <div className="rounded border border-neutral-800 bg-neutral-900 p-3 grid gap-3 sm:grid-cols-3">
        <div className="sm:col-span-1">
          <div className="text-xs text-neutral-400 mb-1">
            Purchase Order (optional)
          </div>
          <select
            className="w-full rounded border border-neutral-700 bg-neutral-900 p-2 text-white"
            value={selectedPo}
            onChange={(e) => setSelectedPo(e.target.value)}
          >
            <option value="">— No PO —</option>
            {pos.map((po) => (
              <option key={po.id} value={po.id}>
                {po.id.slice(0, 8)} • {po.status ?? "draft"}
              </option>
            ))}
          </select>
        </div>

        <div>
          <div className="text-xs text-neutral-400 mb-1">Location</div>
          <select
            className="w-full rounded border border-neutral-700 bg-neutral-900 p-2 text-white"
            value={selectedLoc}
            onChange={(e) => setSelectedLoc(e.target.value)}
          >
            {locs.map((l) => (
              <option key={l.id} value={l.id}>
                {l.code ?? "LOC"} — {l.name ?? ""}
              </option>
            ))}
          </select>
        </div>

        <div>
          <div className="text-xs text-neutral-400 mb-1">Quantity</div>
          <input
            type="number"
            min={0.01}
            step="0.01"
            className="w-full rounded border border-neutral-700 bg-neutral-900 p-2 text-white"
            value={qty}
            onChange={(e) => setQty(Math.max(0, Number(e.target.value || 0)))}
          />
        </div>
      </div>

      <div className="rounded border border-neutral-800 bg-neutral-900 p-3">
        <div className="mb-2 flex items-center gap-2">
          {!scanning ? (
            <button
              onClick={startScan}
              className="rounded border border-orange-500 px-3 py-1.5 text-sm text-orange-300 hover:bg-orange-900/20"
            >
              Start Scanner
            </button>
          ) : (
            <button
              onClick={stopScan}
              className="rounded border border-red-500 px-3 py-1.5 text-sm text-red-300 hover:bg-red-900/20"
            >
              Stop Scanner
            </button>
          )}
          <span className="text-xs text-neutral-400">
            Use mobile camera to scan UPC/EAN/Code128.
          </span>
        </div>
        <div
          ref={videoRef}
          className="aspect-video w-full overflow-hidden rounded border border-neutral-800 bg-black"
        />
      </div>
    </div>
  );
}


/* =============================== */
/* FILE: ./app/parts/requests/[id]/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type Request = DB["public"]["Tables"]["part_requests"]["Row"];
type Item = DB["public"]["Tables"]["part_request_items"]["Row"] & {
  // schema is catching up
  work_order_line_id?: string | null;
  markup_pct?: number | null;
  qty?: number | null;
};
type Status = Request["status"];
type Part = DB["public"]["Tables"]["parts"]["Row"];

const DEFAULT_MARKUP = 30; // %

export default function PartsRequestDetail() {
  const { id } = useParams<{ id: string }>();
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const router = useRouter();

  const [req, setReq] = useState<Request | null>(null);
  const [items, setItems] = useState<Item[]>([]);
  const [loading, setLoading] = useState(true);
  const [parts, setParts] = useState<Part[]>([]);
  const [markupPct, setMarkupPct] = useState<Record<string, number>>({});
  const [savedRows, setSavedRows] = useState<Record<string, boolean>>({});
  // per-line manual part inputs
  const [manualParts, setManualParts] = useState<
    Record<string, { name: string; sku: string }>
  >({});

  async function load() {
    setLoading(true);

    // header
    const { data: r, error: rErr } = await supabase
      .from("part_requests")
      .select("*")
      .eq("id", id)
      .maybeSingle();
    if (rErr) toast.error(rErr.message);
    setReq(r ?? null);

    // items
    const { data: its, error: itErr } = await supabase
      .from("part_request_items")
      .select("*")
      .eq("request_id", id);
    if (itErr) toast.error(itErr.message);
    const itemsList = (its ?? []) as Item[];
    setItems(itemsList);

    // inventory
    if (r?.shop_id) {
      const { data: ps } = await supabase
        .from("parts")
        .select("*")
        .eq("shop_id", r.shop_id)
        .order("name")
        .limit(500);
      setParts(ps ?? []);
    } else {
      setParts([]);
    }

    // markup init
    const m: Record<string, number> = {};
    for (const it of itemsList) {
      m[it.id] =
        typeof it.markup_pct === "number" && !Number.isNaN(it.markup_pct)
          ? it.markup_pct
          : DEFAULT_MARKUP;
    }
    setMarkupPct(m);

    // clear saved flags on fresh load
    setSavedRows({});

    setLoading(false);
  }

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id]);

  function getLineIdFromItems(list: Item[]): string | null {
    for (const it of list) {
      if (it.work_order_line_id) return it.work_order_line_id;
    }
    return null;
  }

  async function setStatus(s: Status) {
    const { error } = await supabase.rpc("set_part_request_status", {
      p_request: id,
      p_status: s,
    });
    if (error) {
      toast.error(error.message);
      return;
    }

    if (s === "quoted") {
      const lineId = getLineIdFromItems(items);
      if (lineId) {
        // mark line quoted
        const { error: wolErr } = await supabase
          .from("work_order_lines")
          .update({
            status: "quoted",
          } as DB["public"]["Tables"]["work_order_lines"]["Update"])
          .eq("id", lineId);
        if (wolErr) {
          console.warn("could not set line to quoted:", wolErr.message);
        }

        // save to menu items
        try {
          const res = await fetch("/api/menu-items/save-from-line", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ workOrderLineId: lineId }),
          });
          const j = (await res.json().catch(() => null)) as {
            ok?: boolean;
            error?: string;
          } | null;
          if (!res.ok) {
            console.warn("menu save failed:", j?.error);
            toast.warning("Quoted, but couldn’t save to menu items.");
          } else {
            toast.success("Quoted and saved to menu items.");
          }
        } catch (e) {
          console.warn("menu save error:", e);
          toast.warning("Quoted, but couldn’t save to menu items.");
        }
      } else {
        toast.success("Parts request marked as quoted.");
      }
    } else {
      toast.success(`Parts request marked as ${s}.`);
    }

    await load();
  }

  async function saveLine(it: Item) {
    const qty =
      typeof it.qty === "number" && !Number.isNaN(it.qty) ? it.qty : null;
    if (!qty || qty <= 0) {
      toast.error("Enter a quantity greater than 0 before saving.");
      return;
    }

    const cost =
      typeof it.quoted_price === "number" && !Number.isNaN(it.quoted_price)
        ? it.quoted_price
        : 0;
    const m = markupPct[it.id] ?? DEFAULT_MARKUP;

    const { error } = await supabase
      .from("part_request_items")
      .update({
        vendor: it.vendor ?? null,
        quoted_price: cost,
        qty,
        markup_pct: m,
      })
      .eq("id", it.id);

    if (error) {
      toast.error(error.message);
      return;
    }

    setSavedRows((prev) => ({ ...prev, [it.id]: true }));
    toast.success("Line saved");
  }

  async function attachPartToItem(itemId: string, partId: string) {
    const p = parts.find((x) => x.id === partId);
    const desc = p?.name ?? "Part";

    const { error } = await supabase
      .from("part_request_items")
      .update({
        part_id: partId,
        description: desc,
      })
      .eq("id", itemId);

    if (error) {
      console.warn("attachPartToItem failed:", error.message);
      toast.error("Cannot attach part — check RLS.");
    } else {
      // change → unsave
      setSavedRows((prev) => ({ ...prev, [itemId]: false }));
      await load();
    }
  }

  // manual: create part in inventory, then attach
  async function createManualPartAndAttach(
    itemId: string,
    name: string,
    sku: string
  ) {
    const item = items.find((x) => x.id === itemId);
    if (!item) return;
    if (!req?.shop_id) {
      toast.error("Cannot create part — missing shop.");
      return;
    }
    if (!name.trim()) {
      toast.error("Enter a name for the part.");
      return;
    }

    // create part in inventory
    const { data: inserted, error } = await supabase
      .from("parts")
      .insert({
        shop_id: req.shop_id,
        name: name.trim(),
        sku: sku.trim() || null,
      })
      .select("*")
      .maybeSingle<Part>();

    if (error) {
      toast.error(error.message);
      return;
    }

    if (!inserted) {
      toast.error("Unable to create part.");
      return;
    }

    // attach to item
    const { error: attachErr } = await supabase
      .from("part_request_items")
      .update({
        part_id: inserted.id,
        description: inserted.name ?? name.trim(),
      })
      .eq("id", itemId);

    if (attachErr) {
      toast.error(attachErr.message);
      return;
    }

    toast.success("Part created and attached.");
    // clear manual fields for that line
    setManualParts((prev) => {
      const copy = { ...prev };
      delete copy[itemId];
      return copy;
    });

    // reload so the new part shows up in the select too
    await load();
  }

  const grandTotals = (() => {
    let sum = 0;
    for (const it of items) {
      const cost =
        typeof it.quoted_price === "number" && !Number.isNaN(it.quoted_price)
          ? it.quoted_price
          : 0;
      const m = markupPct[it.id] ?? DEFAULT_MARKUP;
      const unitSell = cost * (1 + m / 100);
      const qty =
        typeof it.qty === "number" && it.qty > 0 ? Number(it.qty) : 0;
      sum += unitSell * qty;
    }
    return sum;
  })();

  return (
    <div className="p-6 text-white space-y-4">
      <button
        className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
        onClick={() => router.back()}
      >
        ← Back
      </button>

      {loading || !req ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-neutral-400">
          Loading…
        </div>
      ) : (
        <>
          {/* header */}
          <div className="rounded border border-neutral-800 bg-neutral-900 p-4">
            <div className="flex flex-wrap items-center justify-between gap-2">
              <div>
                <div className="text-xl font-semibold">
                  Request #{req.id.slice(0, 8)}
                </div>
                <div className="text-sm text-neutral-400">
                  WO: {req.work_order_id ?? "—"} ·{" "}
                  {req.created_at
                    ? new Date(req.created_at).toLocaleString()
                    : "—"}
                </div>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-sm text-neutral-300 capitalize">
                  Status: {req.status}
                </span>
                {req.status !== "approved" && (
                  <button
                    className="rounded border border-blue-600 text-blue-300 px-3 py-1.5 text-sm hover:bg-blue-900/20"
                    onClick={() => void setStatus("approved")}
                  >
                    Mark Approved
                  </button>
                )}
                {req.status !== "quoted" && (
                  <button
                    className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10"
                    onClick={() => void setStatus("quoted")}
                  >
                    Mark Quoted
                  </button>
                )}
              </div>
            </div>
          </div>

          {/* table */}
          <div className="rounded border border-neutral-800 overflow-hidden">
            <table className="w-full text-sm">
              <thead className="bg-neutral-900 text-neutral-400">
                <tr>
                  <th className="p-2 text-left">Inventory</th>
                  <th className="p-2 text-left">Description</th>
                  <th className="p-2 text-right">Qty</th>
                  <th className="p-2 text-left">Vendor</th>
                  <th className="p-2 text-right">Cost (unit)</th>
                  <th className="p-2 text-right">Markup %</th>
                  <th className="p-2 text-right">Sell (unit)</th>
                  <th className="p-2 text-right">Line total</th>
                  <th className="p-2 w-28"></th>
                </tr>
              </thead>
              <tbody>
                {items.map((it) => {
                  const cost =
                    typeof it.quoted_price === "number" &&
                    !Number.isNaN(it.quoted_price)
                      ? it.quoted_price
                      : 0;
                  const m = markupPct[it.id] ?? DEFAULT_MARKUP;
                  const qty =
                    typeof it.qty === "number" && it.qty > 0 ? it.qty : null;
                  const unitSell = cost * (1 + m / 100);
                  const lineTotal = unitSell * (qty ?? 0);
                  const isSaved = savedRows[it.id] === true;

                  const manual = manualParts[it.id] || { name: "", sku: "" };

                  return (
                    <tr
                      key={it.id}
                      className={`border-t border-neutral-800 ${
                        isSaved ? "bg-neutral-900/50 text-neutral-400" : ""
                      }`}
                    >
                      <td className="p-2 align-top">
                        <div className="flex flex-col gap-1">
                          <select
                            className="w-40 rounded border border-neutral-700 bg-neutral-900 p-1 text-xs disabled:opacity-50"
                            value={it.part_id ?? ""}
                            onChange={(e) => {
                              setSavedRows((prev) => ({
                                ...prev,
                                [it.id]: false,
                              }));
                              void attachPartToItem(it.id, e.target.value);
                            }}
                            disabled={isSaved}
                          >
                            <option value="">— select —</option>
                            {parts.map((p) => (
                              <option key={p.id} value={p.id as string}>
                                {p.sku ? `${p.sku} — ${p.name}` : p.name}
                              </option>
                            ))}
                          </select>

                          {/* manual entry */}
                          <div className="flex gap-1">
                            <input
                              className="flex-1 rounded border border-neutral-700 bg-neutral-900 p-1 text-xs disabled:opacity-50"
                              placeholder="Manual part name"
                              value={manual.name}
                              onChange={(e) =>
                                setManualParts((prev) => ({
                                  ...prev,
                                  [it.id]: {
                                    name: e.target.value,
                                    sku: prev[it.id]?.sku ?? "",
                                  },
                                }))
                              }
                              disabled={isSaved}
                            />
                            <input
                              className="w-20 rounded border border-neutral-700 bg-neutral-900 p-1 text-xs disabled:opacity-50"
                              placeholder="SKU"
                              value={manual.sku}
                              onChange={(e) =>
                                setManualParts((prev) => ({
                                  ...prev,
                                  [it.id]: {
                                    name: prev[it.id]?.name ?? "",
                                    sku: e.target.value,
                                  },
                                }))
                              }
                              disabled={isSaved}
                            />
                          </div>
                          <button
                            className="rounded border border-neutral-700 bg-neutral-900 px-2 py-0.5 text-xs hover:bg-neutral-800 disabled:opacity-50"
                            onClick={() =>
                              void createManualPartAndAttach(
                                it.id,
                                manual.name,
                                manual.sku
                              )
                            }
                            disabled={isSaved}
                          >
                            Add & attach
                          </button>
                        </div>
                      </td>
                      <td className="p-2 align-top">{it.description}</td>
                      <td className="p-2 text-right align-top">
                        <input
                          type="number"
                          min={1}
                          step={1}
                          className="w-16 rounded border border-neutral-700 bg-neutral-900 p-1 text-right disabled:opacity-50"
                          value={qty ?? ""} // allow empty
                          onChange={(e) => {
                            const raw = e.target.value;
                            setItems((prev) => {
                              return prev.map((x) => {
                                if (x.id !== it.id) return x;
                                return {
                                  ...x,
                                  qty: raw === "" ? null : Number(raw),
                                } as Item;
                              });
                            });
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 align-top">
                        <input
                          className="w-32 rounded border border-neutral-700 bg-neutral-900 p-1 disabled:opacity-50"
                          value={it.vendor ?? ""}
                          onChange={(e) => {
                            const v = e.target.value;
                            setItems((prev) =>
                              prev.map((x) =>
                                x.id === it.id ? { ...x, vendor: v } : x
                              )
                            );
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 text-right align-top">
                        <input
                          type="number"
                          step={0.01}
                          className="w-24 rounded border border-neutral-700 bg-neutral-900 p-1 text-right disabled:opacity-50"
                          value={cost === 0 ? "" : cost}
                          onChange={(e) => {
                            const raw = e.target.value;
                            const v = raw === "" ? null : Number(raw);
                            setItems((prev) =>
                              prev.map((x) =>
                                x.id === it.id ? { ...x, quoted_price: v } : x
                              )
                            );
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 text-right align-top">
                        <input
                          type="number"
                          step={1}
                          className="w-20 rounded border border-neutral-700 bg-neutral-900 p-1 text-right disabled:opacity-50"
                          value={m}
                          onChange={(e) => {
                            setMarkupPct((prev) => ({
                              ...prev,
                              [it.id]: Math.max(
                                0,
                                Number(e.target.value || DEFAULT_MARKUP)
                              ),
                            }));
                            setSavedRows((prev) => ({
                              ...prev,
                              [it.id]: false,
                            }));
                          }}
                          disabled={isSaved}
                        />
                      </td>
                      <td className="p-2 text-right tabular-nums align-top">
                        {unitSell.toFixed(2)}
                      </td>
                      <td className="p-2 text-right tabular-nums align-top">
                        {lineTotal.toFixed(2)}
                      </td>
                      <td className="p-2 text-right align-top">
                        <button
                          className={`rounded border px-2 py-1 text-xs ${
                            isSaved
                              ? "border-neutral-700 bg-neutral-800/60 text-neutral-300 cursor-default"
                              : "border-neutral-700 hover:bg-neutral-800"
                          }`}
                          onClick={() => !isSaved && void saveLine(it)}
                          disabled={isSaved}
                        >
                          {isSaved ? "Saved" : "Save"}
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
              <tfoot>
                <tr className="bg-neutral-900/50">
                  <td className="p-2 text-right" colSpan={7}>
                    <span className="text-sm text-neutral-300">
                      Total (with markup)
                    </span>
                  </td>
                  <td className="p-2 text-right tabular-nums font-semibold">
                    {grandTotals.toFixed(2)}
                  </td>
                  <td />
                </tr>
              </tfoot>
            </table>
          </div>
        </>
      )}
    </div>
  );
}


/* =============================== */
/* FILE: ./app/parts/requests/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type Request = DB["public"]["Tables"]["part_requests"]["Row"];
type Item = DB["public"]["Tables"]["part_request_items"]["Row"];

const STATUSES: Request["status"][] = [
  "requested",
  "quoted",
  "approved",
  "fulfilled",
  "rejected",
  "cancelled",
];

export default function PartsRequestsPage() {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [byStatus, setByStatus] = useState<
    Record<Request["status"], (Request & { items: Item[] })[]>
  >({
    requested: [],
    quoted: [],
    approved: [],
    fulfilled: [],
    rejected: [],
    cancelled: [],
  });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    void (async () => {
      setLoading(true);

      // 1) fetch all requests
      const { data: reqs, error } = await supabase
        .from("part_requests")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) {
        console.error("load part_requests failed:", error.message);
        setLoading(false);
        return;
      }

      const requestList = reqs ?? [];
      const ids = requestList.map((r) => r.id);

      // 2) fetch all items for these requests
      const itemsMap: Record<string, Item[]> = {};
      if (ids.length) {
        const { data: items } = await supabase
          .from("part_request_items")
          .select("*")
          .in("request_id", ids);

        for (const it of items ?? []) {
          (itemsMap[it.request_id] ||= []).push(it);
        }
      }

      // 3) group by status
      const grouped: Record<Request["status"], (Request & { items: Item[] })[]> = {
        requested: [],
        quoted: [],
        approved: [],
        fulfilled: [],
        rejected: [],
        cancelled: [],
      };

      for (const r of requestList) {
  const status = (r.status ?? "requested") as Request["status"];
  const bucket = grouped[status];
  bucket.push({ ...r, items: itemsMap[r.id] ?? [] });
}

      setByStatus(grouped);
      setLoading(false);
    })();
  }, [supabase]);

  return (
    <div className="p-6 text-white space-y-4">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Parts Requests</h1>
        <Link
          href="/parts"
          className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
        >
          Parts Catalog
        </Link>
      </div>

      {loading ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-neutral-400">
          Loading…
        </div>
      ) : (
        <div className="grid gap-4 lg:grid-cols-3 xl:grid-cols-4">
          {STATUSES.map((status) => {
            const list = byStatus[status] ?? [];
            return (
              <div
                key={status}
                className="rounded border border-neutral-800 bg-neutral-900 flex flex-col"
              >
                <div className="border-b border-neutral-800 px-3 py-2 text-neutral-300 capitalize">
                  {status}
                </div>
                <div className="flex-1 space-y-3 p-3">
                  {list.length === 0 ? (
                    <div className="text-sm text-neutral-500">No requests</div>
                  ) : (
                    list.map((r) => (
                      <Link
                        key={r.id}
                        href={`/parts/requests/${r.id}`}
                        className="block rounded border border-neutral-800 p-3 hover:border-orange-500"
                      >
                        <div className="text-sm font-semibold">
                          WO: {r.work_order_id ?? "—"}
                        </div>
                        <div className="text-xs text-neutral-400">
                          {r.created_at
                            ? new Date(r.created_at).toLocaleString()
                            : "—"}
                        </div>
                        <ul className="mt-2 list-disc space-y-1 pl-5 text-sm">
                          {(r.items ?? []).slice(0, 4).map((it) => (
                            <li key={it.id}>
                              {it.description} × {Number(it.qty)}
                            </li>
                          ))}
                          {(r.items ?? []).length > 4 && (
                            <li>
                              + {(r.items ?? []).length - 4} more…
                            </li>
                          )}
                        </ul>
                      </Link>
                    ))
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}


/* =============================== */
/* FILE: ./app/parts/vendors/page.tsx */
/* =============================== */

"use client";
import { useState } from "react";

export default function VendorKeysPage() {
  const [vendor, setVendor] = useState("partstech");
  const [apiKey, setApiKey] = useState("");

  const save = async () => {
    // TODO: call /api/vendors/save to encrypt & store per shop
    alert(`Would save key for ${vendor}: ${apiKey.slice(0,4)}…`);
  };

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-2xl font-bold">Vendor Integrations</h1>
      <div className="rounded border border-neutral-800 bg-neutral-900 p-4 max-w-lg space-y-2">
        <label className="text-sm">Vendor</label>
        <select className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
          value={vendor} onChange={e=>setVendor(e.target.value)}>
          <option value="partstech">PartsTech</option>
          <option value="generic-email">Generic Email PO</option>
        </select>
        <label className="text-sm mt-2">API Key / Credential</label>
        <input className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
          placeholder="paste key…" value={apiKey} onChange={e=>setApiKey(e.target.value)} />
        <div className="pt-2">
          <button className="rounded bg-orange-500 px-3 py-2 text-black" onClick={save}>Save</button>
        </div>
      </div>
      <p className="text-xs text-neutral-500">Keys are stored per shop (encrypted at rest).</p>
    </div>
  );
}



/* =============================== */
/* FILE: ./app/parts/warranties/page.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { v4 as uuidv4 } from "uuid";
import { format, addMonths, isBefore, differenceInDays } from "date-fns";
import { toast } from "sonner";

/* ----------------------------- Local Types ----------------------------- */
type UUID = string;

type Warranty = {
  id: UUID;
  shop_id: UUID;
  part_id: UUID;
  work_order_id: UUID | null;
  work_order_line_id: UUID | null;
  customer_id: UUID | null;
  vehicle_id: UUID | null;
  supplier_id: UUID | null;
  installed_at: string;
  warranty_months: number;
  expires_at: string;
  notes: string | null;
  created_at?: string | null;
};

type WarrantyClaimStatus = "open" | "approved" | "denied" | "replaced" | "closed";

type WarrantyClaim = {
  id: UUID;
  warranty_id: UUID;
  opened_at: string;
  status: WarrantyClaimStatus;
  supplier_rma: string | null;
  notes: string | null;
  created_at?: string | null;
};

type Lookups = {
  parts: Record<string, { name: string | null; sku: string | null }>;
  suppliers: Record<string, { name: string | null }>;
  customers: Record<string, { first_name: string | null; last_name: string | null }>;
  vehicles: Record<string, { year: number | null; make: string | null; model: string | null }>;
  work_orders: Record<string, { custom_id: string | null }>;
};

/* Minimal Part type for the picker (matches your parts table) */
type PartLite = {
  id: UUID;
  shop_id: UUID | null;
  name: string | null;
  sku: string | null;
  category: string | null;
};

/* ----------------------------- UI Helpers ----------------------------- */
const outlineBtn =
  "font-header rounded border px-3 py-2 text-sm transition-colors";
const outlineNeutral = `${outlineBtn} border-neutral-700 text-neutral-200 hover:bg-neutral-800`;
const outlineInfo = `${outlineBtn} border-blue-600 text-blue-300 hover:bg-blue-900/20`;

type Tab = "active" | "expiring" | "expired" | "all";

/* ===================================================================== */
/*                        Part Picker (inline dialog)                     */
/* ===================================================================== */
function PartPickerDialog({
  open,
  onClose,
  shopId,
  onPick,
}: {
  open: boolean;
  onClose: () => void;
  shopId: string;
  onPick: (p: PartLite) => void;
}): JSX.Element | null {
  const supabase = useMemo(() => createClientComponentClient(), []);
  const [q, setQ] = useState<string>("");
  const [rows, setRows] = useState<PartLite[]>([]);
  const [loading, setLoading] = useState<boolean>(false);

  useEffect(() => {
    if (!open || !shopId) return;
    let cancelled = false;
    const run = async () => {
      setLoading(true);
      try {
        // Base query
        let query = supabase
          .from("parts")
          .select("id, shop_id, name, sku, category")
          .eq("shop_id", shopId)
          .order("name", { ascending: true })
          .limit(50);

        const term = q.trim();
        if (term) {
          query = query.or(
            `name.ilike.%${term}%,sku.ilike.%${term}%,category.ilike.%${term}%`
          );
        }

        const { data, error } = await query;
        if (!cancelled) {
          if (error) {
            toast.error(error.message);
            setRows([]);
          } else {
            setRows((data ?? []) as PartLite[]);
          }
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    };
    void run();
    return () => {
      cancelled = true;
    };
  }, [open, q, shopId, supabase]);

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-[340] flex items-center justify-center">
      <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" onClick={onClose} />
      <div
        className="relative z-[350] w-full max-w-2xl rounded border border-orange-400 bg-neutral-950 p-4 text-white"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="mb-3 flex items-center justify-between">
          <div className="text-lg font-semibold">Pick a Part</div>
          <button
            className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
            onClick={onClose}
          >
            ✕
          </button>
        </div>

        <div className="mb-3">
          <input
            value={q}
            onChange={(e) => setQ(e.target.value)}
            placeholder="Search name / SKU / category…"
            className="w-full rounded border border-neutral-700 bg-neutral-900 px-3 py-2"
          />
        </div>

        <div className="rounded border border-neutral-800 max-h-80 overflow-auto">
          {loading ? (
            <div className="p-3 text-neutral-300 text-sm">Searching…</div>
          ) : rows.length === 0 ? (
            <div className="p-3 text-neutral-400 text-sm">No parts found.</div>
          ) : (
            <ul className="divide-y divide-neutral-800">
              {rows.map((p) => (
                <li key={p.id}>
                  <button
                    className="block w-full px-3 py-2 text-left hover:bg-neutral-900/60"
                    onClick={() => {
                      onPick(p);
                      onClose();
                    }}
                  >
                    <div className="font-medium truncate">{p.name ?? "Part"}</div>
                    <div className="text-xs text-neutral-400">
                      {p.sku ?? "—"} • {p.category ?? "Uncategorized"}
                    </div>
                  </button>
                </li>
              ))}
            </ul>
          )}
        </div>

        <div className="mt-3 flex justify-end">
          <button className={outlineNeutral} onClick={onClose}>
            Close
          </button>
        </div>
      </div>
    </div>
  );
}

/* ===================================================================== */
/*                               PAGE                                    */
/* ===================================================================== */
export default function WarrantiesPage(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient(), []);

  const [shopId, setShopId] = useState<string>("");
  const [ready, setReady] = useState(false);

  const [rows, setRows] = useState<Warranty[]>([]);
  const [claimsByWarranty, setClaimsByWarranty] = useState<Record<string, WarrantyClaim[]>>({});
  const [lookups, setLookups] = useState<Lookups>({
    parts: {},
    suppliers: {},
    customers: {},
    vehicles: {},
    work_orders: {},
  });

  const [tab, setTab] = useState<Tab>("active");
  const [q, setQ] = useState("");

  // Modal state
  const [openReg, setOpenReg] = useState(false);
  const [openClaim, setOpenClaim] = useState<null | { warranty: Warranty }>(null);
  const [openPartPicker, setOpenPartPicker] = useState(false);

  // Register form
  const [partId, setPartId] = useState("");
  const [months, setMonths] = useState<number>(12);
  const [installedAt, setInstalledAt] = useState<string>(() => new Date().toISOString().slice(0, 10));
  const [supplierId, setSupplierId] = useState<string>("");
  const [woId, setWoId] = useState<string>("");
  const [woLineId, setWoLineId] = useState<string>("");
  const [vehicleId, setVehicleId] = useState<string>("");
  const [customerId, setCustomerId] = useState<string>("");
  const [notes, setNotes] = useState("");

  // Claim form
  const [claimStatus, setClaimStatus] = useState<WarrantyClaimStatus>("open");
  const [claimRma, setClaimRma] = useState("");
  const [claimNotes, setClaimNotes] = useState("");

  // Feature-detection
  const [hasTables, setHasTables] = useState<{ warranties: boolean; claims: boolean }>({
    warranties: true,
    claims: true,
  });

  useEffect(() => {
    (async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
          setReady(true);
          return;
        }
        const { data: prof } = await supabase
          .from("profiles")
          .select("shop_id")
          .eq("user_id", user.id)
          .maybeSingle();
        const sid = String(prof?.shop_id ?? "");
        setShopId(sid);

        const w = await supabase.from("warranties").select("id").limit(1);
        const c = await supabase.from("warranty_claims").select("id").limit(1);
        setHasTables({ warranties: !w.error, claims: !c.error });

        if (!sid || w.error) {
          setReady(true);
          return;
        }

        await loadAll(sid);
      } finally {
        setReady(true);
      }
    })();
  }, [supabase]);

  const loadAll = async (sid: string) => {
    const { data, error } = await supabase
      .from("warranties")
      .select("*")
      .eq("shop_id", sid)
      .order("created_at", { ascending: false });
    if (error) {
      toast.error(error.message);
      return;
    }
    const ws = (data ?? []) as Warranty[];
    setRows(ws);

    if (ws.length && hasTables.claims) {
      const ids = ws.map((w) => w.id);
      const { data: cs } = await supabase
        .from("warranty_claims")
        .select("*")
        .in("warranty_id", ids)
        .order("created_at", { ascending: false });
      const byW: Record<string, WarrantyClaim[]> = {};
      (cs ?? []).forEach((cRow) => {
        const wId = (cRow as WarrantyClaim).warranty_id;
        if (!byW[wId]) byW[wId] = [];
        byW[wId].push(cRow as WarrantyClaim);
      });
      setClaimsByWarranty(byW);
    } else {
      setClaimsByWarranty({});
    }

    await loadLookups(ws);
  };

  const loadLookups = async (ws: Warranty[]) => {
    const partsIds = Array.from(new Set(ws.map((w) => w.part_id).filter(Boolean)));
    const suppIds = Array.from(new Set(ws.map((w) => w.supplier_id).filter(Boolean) as string[]));
    const custIds = Array.from(new Set(ws.map((w) => w.customer_id).filter(Boolean) as string[]));
    const vehIds = Array.from(new Set(ws.map((w) => w.vehicle_id).filter(Boolean) as string[]));
    const woIds = Array.from(new Set(ws.map((w) => w.work_order_id).filter(Boolean) as string[]));

    const [pRes, sRes, cRes, vRes, woRes] = await Promise.all([
      partsIds.length
        ? supabase.from("parts").select("id,name,sku").in("id", partsIds)
        : Promise.resolve({ data: [] }),
      suppIds.length
        ? supabase.from("suppliers").select("id,name").in("id", suppIds)
        : Promise.resolve({ data: [] }),
      custIds.length
        ? supabase.from("customers").select("id,first_name,last_name").in("id", custIds)
        : Promise.resolve({ data: [] }),
      vehIds.length
        ? supabase.from("vehicles").select("id,year,make,model").in("id", vehIds)
        : Promise.resolve({ data: [] }),
      woIds.length
        ? supabase.from("work_orders").select("id,custom_id").in("id", woIds)
        : Promise.resolve({ data: [] }),
    ]);

    const lk: Lookups = {
      parts: Object.fromEntries((pRes.data ?? []).map((r) => [String(r.id), { name: r.name ?? null, sku: r.sku ?? null }])),
      suppliers: Object.fromEntries((sRes.data ?? []).map((r) => [String(r.id), { name: r.name ?? null }])),
      customers: Object.fromEntries((cRes.data ?? []).map((r) => [String(r.id), { first_name: r.first_name ?? null, last_name: r.last_name ?? null }])),
      vehicles: Object.fromEntries((vRes.data ?? []).map((r) => [String(r.id), { year: r.year ?? null, make: r.make ?? null, model: r.model ?? null }])),
      work_orders: Object.fromEntries((woRes.data ?? []).map((r) => [String(r.id), { custom_id: r.custom_id ?? null }])),
    };
    setLookups(lk);
  };

  const now = new Date();
  const filtered = rows.filter((w) => {
    const exp = new Date(w.expires_at);
    const isExpired = isBefore(exp, now);
    const days = differenceInDays(exp, now);
    const expSoon = days >= 0 && days <= 30;

    const keep =
      tab === "all" ||
      (tab === "expired" && isExpired) ||
      (tab === "expiring" && expSoon) ||
      (tab === "active" && !isExpired && !expSoon);

    if (!keep) return false;

    const p = lookups.parts[w.part_id];
    const supplier = w.supplier_id ? lookups.suppliers[w.supplier_id] : undefined;
    const hay = [
      p?.name ?? "",
      p?.sku ?? "",
      supplier?.name ?? "",
      w.notes ?? "",
      lookups.work_orders[w.work_order_id ?? ""]?.custom_id ?? "",
    ]
      .join(" ")
      .toLowerCase();
    return hay.includes(q.toLowerCase());
  });

  const registerWarranty = async () => {
    if (!shopId || !partId || !months || months <= 0) {
      toast.error("Part, months, and shop are required");
      return;
    }
    const installedIso = new Date(installedAt).toISOString();
    const expiresIso = addMonths(new Date(installedIso), months).toISOString();

    const payload: Warranty = {
      id: uuidv4(),
      shop_id: shopId,
      part_id: partId,
      supplier_id: supplierId || null,
      work_order_id: woId || null,
      work_order_line_id: woLineId || null,
      customer_id: customerId || null,
      vehicle_id: vehicleId || null,
      installed_at: installedIso,
      warranty_months: months,
      expires_at: expiresIso,
      notes: notes.trim() || null,
    };

    const { error } = await supabase.from("warranties").insert(payload);
    if (error) {
      toast.error(error.message);
      return;
    }

    toast.success("Warranty registered");
    setOpenReg(false);
    setPartId("");
    setSupplierId("");
    setWoId("");
    setWoLineId("");
    setCustomerId("");
    setVehicleId("");
    setMonths(12);
    setInstalledAt(new Date().toISOString().slice(0, 10));
    setNotes("");

    await loadAll(shopId);
  };

  const openClaimFor = (w: Warranty) => {
    setOpenClaim({ warranty: w });
    setClaimStatus("open");
    setClaimRma("");
    setClaimNotes("");
  };

  const createClaim = async () => {
    if (!openClaim) return;
    const payload: WarrantyClaim = {
      id: uuidv4(),
      warranty_id: openClaim.warranty.id,
      opened_at: new Date().toISOString(),
      status: claimStatus,
      supplier_rma: claimRma.trim() || null,
      notes: claimNotes.trim() || null,
    };
    const { error } = await supabase.from("warranty_claims").insert(payload);
    if (error) {
      toast.error(error.message);
      return;
    }
    toast.success("Claim created");
    setOpenClaim(null);
    await loadAll(shopId);
  };

  const updateClaimStatus = async (claimId: string, next: WarrantyClaimStatus) => {
    const { error } = await supabase.from("warranty_claims").update({ status: next }).eq("id", claimId);
    if (error) {
      toast.error(error.message);
      return;
    }
    await loadAll(shopId);
  };

  if (!ready) {
    return <div className="p-6 text-white">Loading…</div>;
  }

  if (!hasTables.warranties) {
    return (
      <div className="p-6 text-white">
        <h1 className="text-2xl font-semibold">Warranties</h1>
        <div className="mt-3 rounded border border-amber-600 bg-amber-900/20 p-4 text-amber-200">
          <div className="font-semibold mb-1">Setup required</div>
          <p className="text-sm">
            The <code>warranties</code> (and optionally <code>warranty_claims</code>) tables don’t exist yet.
            Create them to enable this page.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="p-6 text-white">
      <div className="mb-3 flex flex-wrap items-center justify-between gap-3">
        <h1 className="text-2xl font-semibold">Warranties</h1>
        <div className="flex items-center gap-2">
          <input
            value={q}
            onChange={(e) => setQ(e.target.value)}
            placeholder="Search parts / WO / notes…"
            className="rounded border border-neutral-700 bg-neutral-900 px-3 py-1.5 text-sm"
          />
          <button className={outlineInfo} onClick={() => setOpenReg(true)}>Register Warranty</button>
        </div>
      </div>

      <div className="mb-4 flex flex-wrap gap-2">
        {(["active", "expiring", "expired", "all"] as Tab[]).map((t) => (
          <button
            key={t}
            className={`rounded px-2 py-1 text-sm border ${
              tab === t ? "border-orange-500 text-orange-300" : "border-neutral-700 text-neutral-300"
            }`}
            onClick={() => setTab(t)}
          >
            {t[0].toUpperCase() + t.slice(1)}
          </button>
        ))}
      </div>

      {filtered.length === 0 ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-neutral-300">
          No warranties found.
        </div>
      ) : (
        <div className="overflow-x-auto rounded border border-neutral-800">
          <table className="min-w-[900px] w-full text-sm">
            <thead className="bg-neutral-950 text-neutral-400">
              <tr>
                <th className="px-3 py-2 text-left">Part</th>
                <th className="px-3 py-2 text-left">Supplier</th>
                <th className="px-3 py-2 text-left">Installed</th>
                <th className="px-3 py-2 text-left">Months</th>
                <th className="px-3 py-2 text-left">Expires</th>
                <th className="px-3 py-2 text-left">Status</th>
                <th className="px-3 py-2 text-left">WO</th>
                <th className="px-3 py-2 text-left">Vehicle</th>
                <th className="px-3 py-2 text-left">Customer</th>
                <th className="px-3 py-2 text-left">Claims</th>
                <th className="px-3 py-2 text-left">Actions</th>
              </tr>
            </thead>
            <tbody>
              {filtered.map((w) => {
                const p = lookups.parts[w.part_id];
                const s = w.supplier_id ? lookups.suppliers[w.supplier_id] : undefined;
                const wo = w.work_order_id ? lookups.work_orders[w.work_order_id] : undefined;
                const v = w.vehicle_id ? lookups.vehicles[w.vehicle_id] : undefined;
                const c = w.customer_id ? lookups.customers[w.customer_id] : undefined;

                const expDate = new Date(w.expires_at);
                const expired = isBefore(expDate, now);
                const days = differenceInDays(expDate, now);
                const expSoon = days >= 0 && days <= 30;

                const claims = claimsByWarranty[w.id] ?? [];
                const statusChip =
                  expired
                    ? "bg-red-900/30 border-red-600 text-red-300"
                    : expSoon
                    ? "bg-amber-900/20 border-amber-600 text-amber-300"
                    : "bg-green-900/20 border-green-600 text-green-300";

                return (
                  <tr key={w.id} className="border-t border-neutral-800">
                    <td className="px-3 py-2">
                      <div className="font-medium">{p?.name ?? "Part"}</div>
                      <div className="text-xs text-neutral-400">{p?.sku ?? "—"}</div>
                    </td>
                    <td className="px-3 py-2">{s?.name ?? "—"}</td>
                    <td className="px-3 py-2">{format(new Date(w.installed_at), "PP")}</td>
                    <td className="px-3 py-2">{w.warranty_months}</td>
                    <td className="px-3 py-2">{format(expDate, "PP")}</td>
                    <td className="px-3 py-2">
                      <span className={`inline-block rounded border px-2 py-0.5 text-xs ${statusChip}`}>
                        {expired ? "Expired" : expSoon ? `Expiring (${days}d)` : "Active"}
                      </span>
                    </td>
                    <td className="px-3 py-2">
                      {w.work_order_id ? (
                        <Link
                          className="text-orange-400 hover:underline"
                          href={`/work-orders/${w.work_order_id}`}
                          title="Open work order"
                        >
                          {wo?.custom_id ?? w.work_order_id.slice(0, 8)}
                        </Link>
                      ) : (
                        "—"
                      )}
                    </td>
                    <td className="px-3 py-2">
                      {v ? <span>{[v.year, v.make, v.model].filter(Boolean).join(" ")}</span> : "—"}
                    </td>
                    <td className="px-3 py-2">
                      {c ? <span>{[c.first_name, c.last_name].filter(Boolean).join(" ")}</span> : "—"}
                    </td>
                    <td className="px-3 py-2">
                      {claims.length === 0 ? (
                        <span className="text-neutral-400">—</span>
                      ) : (
                        <div className="flex flex-col gap-1">
                          {claims.map((cl) => (
                            <div key={cl.id} className="flex items-center justify-between gap-2">
                              <span className="text-xs">
                                {format(new Date(cl.opened_at), "PP")} • {cl.status}
                                {cl.supplier_rma ? ` • RMA ${cl.supplier_rma}` : ""}
                              </span>
                              <div className="flex items-center gap-1">
                                {(["open", "approved", "replaced", "closed", "denied"] as WarrantyClaimStatus[]).map(
                                  (st) => (
                                    <button
                                      key={st}
                                      className="rounded border border-neutral-700 px-1.5 py-0.5 text-[11px] hover:bg-neutral-800"
                                      onClick={() => updateClaimStatus(cl.id, st)}
                                      title={`Set ${st}`}
                                    >
                                      {st}
                                    </button>
                                  ),
                                )}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                    </td>
                    <td className="px-3 py-2">
                      <div className="flex items-center gap-2">
                        <button className={outlineInfo} onClick={() => openClaimFor(w)}>
                          Open Claim
                        </button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      )}

      {/* Register modal */}
      {openReg && (
        <div className="fixed inset-0 z-[300] flex items-center justify-center">
          <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" onClick={() => setOpenReg(false)} />
          <div
            className="relative z-[310] w-full max-w-xl rounded border border-orange-400 bg-neutral-950 p-4 text-white"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="mb-2 flex items-center justify-between">
              <div className="text-lg font-semibold">Register Warranty</div>
              <button
                className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
                onClick={() => setOpenReg(false)}
              >
                ✕
              </button>
            </div>

            <div className="grid gap-3 sm:grid-cols-2">
              {/* Part field with picker */}
              <div className="sm:col-span-2">
                <label className="mb-1 block text-sm text-neutral-300">Part</label>
                <div className="flex items-center gap-2">
                  <input
                    value={partId}
                    onChange={(e) => setPartId(e.target.value)}
                    placeholder="Part UUID (or use picker)"
                    className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                  />
                  <button
                    type="button"
                    className={outlineInfo}
                    onClick={() => setOpenPartPicker(true)}
                    disabled={!shopId}
                    title={shopId ? "Search parts" : "No shop selected"}
                  >
                    Pick
                  </button>
                </div>
                {partId && lookups.parts[partId] ? (
                  <div className="mt-1 text-xs text-neutral-400">
                    {lookups.parts[partId]?.name} ({lookups.parts[partId]?.sku})
                  </div>
                ) : null}
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">Supplier (optional)</label>
                <input
                  value={supplierId}
                  onChange={(e) => setSupplierId(e.target.value)}
                  placeholder="Supplier UUID"
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                />
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">Installed Date</label>
                <input
                  type="date"
                  value={installedAt}
                  onChange={(e) => setInstalledAt(e.target.value)}
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                />
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">Warranty Months</label>
                <input
                  type="number"
                  min={1}
                  value={months}
                  onChange={(e) => setMonths(Math.max(1, Number(e.target.value || 1)))}
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                />
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">Work Order (optional)</label>
                <input
                  value={woId}
                  onChange={(e) => setWoId(e.target.value)}
                  placeholder="Work order UUID"
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                />
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">WO Line (optional)</label>
                <input
                  value={woLineId}
                  onChange={(e) => setWoLineId(e.target.value)}
                  placeholder="Work order line UUID"
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                />
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">Vehicle (optional)</label>
                <input
                  value={vehicleId}
                  onChange={(e) => setVehicleId(e.target.value)}
                  placeholder="Vehicle UUID"
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                />
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">Customer (optional)</label>
                <input
                  value={customerId}
                  onChange={(e) => setCustomerId(e.target.value)}
                  placeholder="Customer UUID"
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                />
              </div>

              <div className="sm:col-span-2">
                <label className="mb-1 block text-sm text-neutral-300">Notes</label>
                <textarea
                  rows={3}
                  value={notes}
                  onChange={(e) => setNotes(e.target.value)}
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                  placeholder="Terms, conditions, etc."
                />
              </div>
            </div>

            <div className="mt-4 flex justify-end gap-2">
              <button className={outlineNeutral} onClick={() => setOpenReg(false)}>
                Cancel
              </button>
              <button className={outlineInfo} onClick={registerWarranty}>
                Save
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Claim modal */}
      {openClaim && (
        <div className="fixed inset-0 z-[300] flex items-center justify-center">
          <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" onClick={() => setOpenClaim(null)} />
          <div
            className="relative z-[310] w/full max-w-lg rounded border border-orange-400 bg-neutral-950 p-4 text-white"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="mb-2 flex items-center justify-between">
              <div className="text-lg font-semibold">Open Warranty Claim</div>
              <button
                className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
                onClick={() => setOpenClaim(null)}
              >
                ✕
              </button>
            </div>

            <div className="grid gap-3">
              <div>
                <div className="text-sm text-neutral-400">For warranty</div>
                <div className="text-sm">
                  {lookups.parts[openClaim.warranty.part_id]?.name ?? "Part"} •{" "}
                  {format(new Date(openClaim.warranty.installed_at), "PP")} →{" "}
                  {format(new Date(openClaim.warranty.expires_at), "PP")}
                </div>
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">Status</label>
                <select
                  value={claimStatus}
                  onChange={(e) => setClaimStatus(e.target.value as WarrantyClaimStatus)}
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                >
                  {(["open", "approved", "replaced", "closed", "denied"] as WarrantyClaimStatus[]).map((s) => (
                    <option key={s} value={s}>
                      {s}
                    </option>
                  ))}
                </select>
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">Supplier RMA (optional)</label>
                <input
                  value={claimRma}
                  onChange={(e) => setClaimRma(e.target.value)}
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                  placeholder="RMA #"
                />
              </div>

              <div>
                <label className="mb-1 block text-sm text-neutral-300">Notes</label>
                <textarea
                  rows={3}
                  value={claimNotes}
                  onChange={(e) => setClaimNotes(e.target.value)}
                  className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
                  placeholder="Describe failure, diagnostics, photos link, etc."
                />
              </div>
            </div>

            <div className="mt-4 flex justify-end gap-2">
              <button className={outlineNeutral} onClick={() => setOpenClaim(null)}>
                Cancel
              </button>
              <button className={outlineInfo} onClick={createClaim}>
                Create Claim
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Part search picker */}
      <PartPickerDialog
        open={openPartPicker}
        onClose={() => setOpenPartPicker(false)}
        shopId={shopId}
        onPick={(p) => {
          setPartId(p.id);
          // light lookup hydrate so the “selected” caption shows instantly
          setLookups((prev) => ({
            ...prev,
            parts: {
              ...prev.parts,
              [p.id]: { name: p.name, sku: p.sku },
            },
          }));
        }}
      />
    </div>
  );
}


/* =============================== */
/* FILE: ./features/parts/actions.ts */
/* =============================== */

"use server";

import { revalidatePath } from "next/cache";
import { cookies } from "next/headers";
import { createServerActionClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;

/** Keep this in sync with your Postgres enum stock_move_reason */
export type StockMoveReason =
  | "receive"
  | "adjust"
  | "consume"
  | "sale"
  | "waste"
  | "return_in"
  | "return_out";

export async function createPart(input: {
  shop_id: string;
  sku?: string;
  name: string;
  description?: string;
  default_cost?: number;
  default_price?: number;
  category?: string;
  subcategory?: string;
  low_stock_threshold?: number;
}) {
  const supabase = createServerActionClient<DB>({ cookies });
  const { data, error } = await supabase
    .from("parts")
    .insert(input)
    .select("id")
    .single();
  if (error) throw error;

  revalidatePath("/parts");
  return data.id as string;
}

/** RPC payload for apply_stock_move */
type ApplyStockMoveArgs = {
  p_part: string;
  p_loc: string;
  p_qty: number;
  p_reason: StockMoveReason | string; // Supabase RPC arg is `string`
  p_ref_kind: string;                 // must be string, not undefined/null
  p_ref_id: string;                   // must be string, not undefined/null
};

/**
 * Adjust on-hand stock for a part at a location.
 * Matches SQL: apply_stock_move(p_part, p_loc, p_qty, p_reason, p_ref_kind, p_ref_id) RETURNS uuid
 */
export async function adjustStock(input: {
  part_id: string;
  location_id: string;
  qty_change: number;
  reason: StockMoveReason;
  reference_kind?: string | null;
  reference_id?: string | null;
}) {
  const supabase = createServerActionClient<DB>({ cookies });

  const rpcArgs: ApplyStockMoveArgs = {
    p_part: input.part_id,
    p_loc: input.location_id,
    p_qty: input.qty_change,
    // The generated type for RPC often expects `string`; our union is compatible.
    p_reason: input.reason,
    // IMPORTANT: RPC arg types are `string`, so pass "" when omitted.
    p_ref_kind: input.reference_kind ?? "",
    p_ref_id: input.reference_id ?? "",
  };

  const { data, error } = await supabase.rpc("apply_stock_move", rpcArgs);
  if (error) throw error;

  // Supabase returns the function result directly; for RETURNS uuid it's a string.
  const moveId =
    typeof data === "string"
      ? data
      : (data as unknown as string); // retain type safety without `any`

  revalidatePath(`/parts/${input.part_id}`);
  return moveId;
}


/* =============================== */
/* FILE: ./features/parts/app/parts/[id]/page.tsx */
/* =============================== */

import { getPart } from "@/features/parts/lib/parts.queries";
import { AdjustStockForm } from "@/features/parts/components/AdjustStockForm";

export default async function PartDetail({ params }: { params: { id: string } }) {
  const part = await getPart(params.id);

  return (
    <div className="p-6 space-y-6">
      <div>
        <h1 className="text-2xl font-bold">{part.name}</h1>
        <p className="text-neutral-600">{part.sku ?? ""}</p>
      </div>

      <div className="grid md:grid-cols-2 gap-4">
        <div className="border rounded-xl p-4">
          <div className="font-semibold mb-2">Stock</div>
          {(part.v_part_stock ?? []).length ? (
            part.v_part_stock.map((s: any) => (
              <div key={s.location_id} className="flex justify-between py-1">
                <span>Loc {String(s.location_id).slice(0, 6)}…</span>
                <span>
                  {s.qty_available} avail (on hand {s.qty_on_hand})
                </span>
              </div>
            ))
          ) : (
            <div className="text-neutral-500">No stock yet</div>
          )}
        </div>

        <div className="border rounded-xl p-4">
          <div className="font-semibold mb-2">Quick Adjust</div>
          <AdjustStockForm partId={part.id} />
        </div>
      </div>
    </div>
  );
}



/* =============================== */
/* FILE: ./features/parts/app/parts/locations/page.tsx */
/* =============================== */

import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { listLocations, ensureMainLocation } from "@/features/parts/lib/locations";
import { LocationForm } from "@/features/parts/components/LocationForm";
type DB = Database;

async function getShopId(): Promise<string> {
  const supabase = createServerComponentClient<DB>({ cookies });
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return "";
  const { data } = await supabase.from("profiles").select("shop_id").eq("user_id", user.id).single();
  return data?.shop_id ?? "";
}

export default async function LocationsPage() {
  const shopId = await getShopId();
  if (!shopId) {
    return <div className="p-6 text-sm text-neutral-500">No shop selected.</div>;
  }

  await ensureMainLocation(shopId);
  const locs = await listLocations(shopId);

  return (
    <div className="p-6 space-y-6">
      <div>
        <h1 className="text-2xl font-bold">Stock Locations</h1>
        <p className="text-neutral-600 text-sm">Manage bins/shelves for parts.</p>
      </div>

      <div className="border rounded-xl p-4">
        <div className="font-semibold mb-2">Add Location</div>
        <LocationForm shopId={shopId} />
      </div>

      <div className="border rounded-xl p-4">
        <div className="font-semibold mb-2">Existing</div>
        <div className="grid gap-2">
          {locs.map(l => (
            <div key={l.id} className="flex justify-between border rounded p-2">
              <span className="font-medium">{l.code}</span>
              <span className="text-neutral-600">{l.name}</span>
            </div>
          ))}
          {locs.length === 0 && <div className="text-sm text-neutral-500">No locations yet.</div>}
        </div>
      </div>
    </div>
  );
}



/* =============================== */
/* FILE: ./features/parts/app/parts/new/page.tsx */
/* =============================== */

import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { PartForm } from "@parts/components/PartForm";

type DB = Database;

async function getShopId(): Promise<string> {
  const supabase = createServerComponentClient<DB>({ cookies });

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return "";

  const { data } = await supabase
    .from("profiles")
    .select("shop_id")
    .eq("user_id", user.id)
    .single();

  return data?.shop_id ?? "";
}

export default async function NewPartPage() {
  const shopId = await getShopId();

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-2xl font-bold">New Part</h1>

      {!shopId ? (
        <div className="text-sm text-neutral-500">
          No shop selected. Make sure your profile has a <code>shop_id</code>.
        </div>
      ) : (
        <PartForm shopId={shopId} />
      )}
    </div>
  );
}



/* =============================== */
/* FILE: ./features/parts/app/parts/page.tsx */
/* =============================== */

import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { listParts } from "@/features/parts/lib/parts.queries";

type DB = Database;

async function getShopId(): Promise<string> {
  const supabase = createServerComponentClient<DB>({ cookies });

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return "";

  const { data: profile } = await supabase
    .from("profiles")
    .select("shop_id")
    .eq("user_id", user.id)
    .single();

  return profile?.shop_id ?? "";
}

export default async function PartsPage() {
  const shopId = await getShopId();
  const parts = shopId ? await listParts(shopId) : [];

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-2xl font-bold">Parts</h1>

      <a
        href="/parts/new"
        className="px-3 py-2 rounded-xl bg-neutral-900 text-white"
      >
        New Part
      </a>

      {!shopId ? (
        <div className="text-sm text-neutral-500">
          No shop selected. Make sure your profile has a <code>shop_id</code>.
        </div>
      ) : (
        <div className="grid grid-cols-1 gap-2">
          {parts.map((p) => (
            <a
              key={p.id}
              href={`/parts/${p.id}`}
              className="border rounded-xl p-3 hover:bg-neutral-50"
            >
              <div className="font-medium">{p.name}</div>
              <div className="text-sm text-neutral-500">
                {p.sku ?? "—"} • {p.category ?? "Uncategorized"}
              </div>
            </a>
          ))}
          {parts.length === 0 && (
            <div className="text-sm text-neutral-500">No parts yet.</div>
          )}
        </div>
      )}
    </div>
  );
}



/* =============================== */
/* FILE: ./features/parts/app/parts/suppliers/page.tsx */
/* =============================== */

import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { listSuppliers } from "@/features/parts/lib/suppliers";
import { SupplierForm } from "@/features/parts/components/SupplierForm";
type DB = Database;

async function getShopId(): Promise<string> {
  const supabase = createServerComponentClient<DB>({ cookies });
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return "";
  const { data } = await supabase.from("profiles").select("shop_id").eq("user_id", user.id).single();
  return data?.shop_id ?? "";
}

export default async function SuppliersPage() {
  const shopId = await getShopId();
  if (!shopId) {
    return <div className="p-6 text-sm text-neutral-500">No shop selected.</div>;
  }

  const suppliers = await listSuppliers(shopId);

  return (
    <div className="p-6 space-y-6">
      <div>
        <h1 className="text-2xl font-bold">Suppliers</h1>
        <p className="text-neutral-600 text-sm">Create and manage parts vendors.</p>
      </div>

      <div className="border rounded-xl p-4">
        <div className="font-semibold mb-2">Add Supplier</div>
        <SupplierForm shopId={shopId} />
      </div>

      <div className="border rounded-xl p-4">
        <div className="font-semibold mb-2">Existing</div>
        <div className="grid gap-2">
          {suppliers.map(s => (
            <div key={s.id} className="flex justify-between border rounded p-2">
              <span className="font-medium">{s.name}</span>
              <span className="text-neutral-600 text-sm">{s.email ?? ""} {s.phone ? `• ${s.phone}` : ""}</span>
            </div>
          ))}
          {suppliers.length === 0 && <div className="text-sm text-neutral-500">No suppliers yet.</div>}
        </div>
      </div>
    </div>
  );
}



/* =============================== */
/* FILE: ./features/parts/components/AdjustStockForm.tsx */
/* =============================== */

"use client";
import { useState, useTransition } from "react";
import { adjustStock } from "@/features/parts/actions";

export function AdjustStockForm({ partId }: { partId: string }) {
  const [locationId, setLocationId] = useState("");
  const [qty, setQty] = useState<number>(0);
  const [pending, start] = useTransition();

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        start(async () => {
          await adjustStock({
            part_id: partId,
            location_id: locationId,
            qty_change: qty,
            reason: qty >= 0 ? "receive" : "adjust",
          });
        });
      }}
      className="space-y-2"
    >
      <input
        className="border rounded px-3 py-2 w-full"
        placeholder="Location ID"
        value={locationId}
        onChange={(e) => setLocationId(e.target.value)}
      />
      <input
        className="border rounded px-3 py-2 w-full"
        placeholder="Qty (+/-)"
        type="number"
        step="0.01"
        value={qty}
        onChange={(e) =>
          setQty(parseFloat(e.target.value || "0"))
        }
      />
      <button
        disabled={pending}
        className="px-3 py-2 rounded-xl bg-neutral-900 text-white"
      >
        {pending ? "Saving…" : "Apply"}
      </button>
    </form>
  );
}



/* =============================== */
/* FILE: ./features/parts/components/LocationForm.tsx */
/* =============================== */

"use client";
import { useState, useTransition } from "react";
import { createLocation } from "@/features/parts/lib/locations";

export function LocationForm({ shopId }: { shopId: string }) {
  const [code, setCode] = useState("MAIN");
  const [name, setName] = useState("Main Stock");
  const [pending, start] = useTransition();
  const [err, setErr] = useState<string | null>(null);

  return (
    <form
      className="space-y-3"
      onSubmit={(e) => {
        e.preventDefault();
        setErr(null);
        start(async () => {
          try {
            await createLocation({ shop_id: shopId, code: code.trim(), name: name.trim() });
            window.location.reload();
          } catch (e: any) {
            setErr(e?.message ?? "Failed");
          }
        });
      }}
    >
      {err && <div className="text-sm text-red-600">{err}</div>}
      <div className="grid grid-cols-2 gap-3">
        <label className="block">
          <div className="text-sm font-medium mb-1">Code</div>
          <input className="border rounded w-full px-3 py-2" value={code} onChange={(e) => setCode(e.target.value)} />
        </label>
        <label className="block">
          <div className="text-sm font-medium mb-1">Name</div>
          <input className="border rounded w-full px-3 py-2" value={name} onChange={(e) => setName(e.target.value)} />
        </label>
      </div>
      <button disabled={pending} className="px-3 py-2 rounded-xl bg-neutral-900 text-white">
        {pending ? "Saving…" : "Create Location"}
      </button>
    </form>
  );
}



/* =============================== */
/* FILE: ./features/parts/components/PartForm.tsx */
/* =============================== */

"use client";
import { useState, useTransition } from "react";
import { createPart } from "@/features/parts/actions";

export function PartForm({ shopId }: { shopId: string }) {
  const [form, setForm] = useState({
    sku: "",
    name: "",
    description: "",
    unit: "ea",
    category: "",
    subcategory: "",
    default_cost: 0,
    default_price: 0,
    low_stock_threshold: 0,
    taxable: true,
  });
  const [pending, start] = useTransition();
  const [error, setError] = useState<string | null>(null);

  function set<K extends keyof typeof form>(key: K, value: (typeof form)[K]) {
    setForm((f) => ({ ...f, [key]: value }));
  }

  return (
    <form
      className="space-y-4"
      onSubmit={(e) => {
        e.preventDefault();
        setError(null);
        start(async () => {
          try {
            const id = await createPart({
              shop_id: shopId,
              sku: form.sku || undefined,
              name: form.name,
              description: form.description || undefined,
              default_cost: Number(form.default_cost) || 0,
              default_price: Number(form.default_price) || 0,
              category: form.category || undefined,
              subcategory: form.subcategory || undefined,
              low_stock_threshold: Number(form.low_stock_threshold) || 0,
            });
            window.location.href = `/parts/${id}`;
          } catch (err: any) {
            setError(err?.message ?? "Failed to create part");
          }
        });
      }}
    >
      {error && <div className="text-sm text-red-600">{error}</div>}

      <div className="grid md:grid-cols-2 gap-4">
        <label className="block">
          <div className="text-sm font-medium mb-1">Name</div>
          <input
            className="border rounded w-full px-3 py-2"
            value={form.name}
            onChange={(e) => set("name", e.target.value)}
            required
          />
        </label>

        <label className="block">
          <div className="text-sm font-medium mb-1">SKU</div>
          <input
            className="border rounded w-full px-3 py-2"
            value={form.sku}
            onChange={(e) => set("sku", e.target.value)}
            placeholder="optional"
          />
        </label>

        <label className="block md:col-span-2">
          <div className="text-sm font-medium mb-1">Description</div>
          <textarea
            className="border rounded w-full px-3 py-2"
            rows={3}
            value={form.description}
            onChange={(e) => set("description", e.target.value)}
            placeholder="optional"
          />
        </label>

        <label className="block">
          <div className="text-sm font-medium mb-1">Category</div>
          <input
            className="border rounded w-full px-3 py-2"
            value={form.category}
            onChange={(e) => set("category", e.target.value)}
            placeholder="e.g., filters"
          />
        </label>

        <label className="block">
          <div className="text-sm font-medium mb-1">Subcategory</div>
          <input
            className="border rounded w-full px-3 py-2"
            value={form.subcategory}
            onChange={(e) => set("subcategory", e.target.value)}
            placeholder="e.g., oil filter"
          />
        </label>

        <label className="block">
          <div className="text-sm font-medium mb-1">Unit</div>
          <input
            className="border rounded w-full px-3 py-2"
            value={form.unit}
            onChange={(e) => set("unit", e.target.value)}
            placeholder="ea, box, set"
          />
        </label>

        <div className="grid grid-cols-2 gap-4">
          <label className="block">
            <div className="text-sm font-medium mb-1">Default Cost</div>
            <input
              type="number"
              step="0.01"
              className="border rounded w-full px-3 py-2"
              value={form.default_cost}
              onChange={(e) => set("default_cost", Number(e.target.value))}
            />
          </label>
          <label className="block">
            <div className="text-sm font-medium mb-1">Default Price</div>
            <input
              type="number"
              step="0.01"
              className="border rounded w-full px-3 py-2"
              value={form.default_price}
              onChange={(e) => set("default_price", Number(e.target.value))}
            />
          </label>
        </div>

        <label className="block">
          <div className="text-sm font-medium mb-1">Low Stock Threshold</div>
          <input
            type="number"
            className="border rounded w-full px-3 py-2"
            value={form.low_stock_threshold}
            onChange={(e) => set("low_stock_threshold", Number(e.target.value))}
          />
        </label>
      </div>

      <button
        type="submit"
        disabled={pending || !form.name}
        className="px-4 py-2 rounded-xl bg-neutral-900 text-white"
      >
        {pending ? "Saving…" : "Create Part"}
      </button>
    </form>
  );
}



/* =============================== */
/* FILE: ./features/parts/components/PartPicker.tsx */
/* =============================== */

"use client";

import { useEffect, useMemo, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { useAiPartSuggestions, AiPartSuggestion } from "@/features/parts/hooks/useAiPartSuggestions";

type DB = Database;
type UUID = string;

type PartRow = DB["public"]["Tables"]["parts"]["Row"];
type StockLoc = DB["public"]["Tables"]["stock_locations"]["Row"];

type VStock = {
  part_id: UUID;
  location_id: UUID;
  qty_available: number;
  qty_on_hand: number;
  qty_reserved: number;
};

export type PickedPart = { part_id: UUID; location_id?: UUID; qty: number };

type Props = {
  open: boolean;
  channel?: string;
  initialSearch?: string;
  workOrderId?: string;
  workOrderLineId?: string | null;
  vehicleSummary?: { year?: number | string | null; make?: string | null; model?: string | null } | null;
  jobDescription?: string | null;
  jobNotes?: string | null;
  onClose?: () => void;
  onPick?: (sel: PickedPart) => void;
};

export function PartPicker({
  open,
  channel = "partpicker",
  initialSearch = "",
  workOrderId,
  workOrderLineId,
  vehicleSummary,
  jobDescription,
  jobNotes,
  onClose,
  onPick,
}: Props) {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [shopId, setShopId] = useState<UUID>("");
  const [search, setSearch] = useState(initialSearch);
  const [parts, setParts] = useState<PartRow[]>([]);
  const [stock, setStock] = useState<Record<UUID, VStock[]>>({});
  const [locs, setLocs] = useState<StockLoc[]>([]);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  const [selectedPartId, setSelectedPartId] = useState<UUID | null>(null);
  const [selectedLocId, setSelectedLocId] = useState<UUID | null>(null);
  const [qty, setQty] = useState<number>(1);

  const { loading: aiLoading, items: aiItems, error: aiErr, suggest } = useAiPartSuggestions();

  const mainLocId = useMemo(() => {
    const m = locs.find((l) => (l.code ?? "").toUpperCase() === "MAIN");
    return (m?.id as UUID | undefined) ?? null;
  }, [locs]);

  useEffect(() => {
    if (!open) return;
    (async () => {
      setErr(null);
      const { data: auth } = await supabase.auth.getUser();
      const userId = auth.user?.id;
      if (!userId) return;

      const { data: prof, error: pe } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("user_id", userId)
        .single();
      if (pe) {
        setErr(pe.message);
        return;
      }
      const sid = (prof?.shop_id as UUID | null) ?? "";
      setShopId(sid);
      if (!sid) return;

      const { data: locsData, error: le } = await supabase
        .from("stock_locations")
        .select("id, code, name, shop_id")
        .eq("shop_id", sid)
        .order("code");
      if (le) {
        setErr(le.message);
        return;
      }
      setLocs(locsData ?? []);
    })();
  }, [open, supabase]);

  useEffect(() => {
    if (!open || !workOrderId) return;
    void suggest({
      workOrderId,
      workOrderLineId: workOrderLineId ?? null,
      vehicle: vehicleSummary ?? null,
      description: jobDescription ?? null,
      notes: jobNotes ?? null,
      topK: 5,
    });
  }, [open, workOrderId, workOrderLineId, vehicleSummary, jobDescription, jobNotes, suggest]);

  useEffect(() => {
    if (!open || !shopId) return;
    let cancelled = false;
    (async () => {
      setLoading(true);
      setErr(null);
      try {
        let q = supabase
          .from("parts")
          .select("*")
          .eq("shop_id", shopId)
          .order("name")
          .limit(50);

        const term = search.trim();
        if (term) {
          q = q.or(`name.ilike.%${term}%,sku.ilike.%${term}%,category.ilike.%${term}%`);
        }

        const { data: rows, error } = await q;
        if (error) throw error;
        if (cancelled) return;

        const rowsSafe = (rows ?? []) as PartRow[];
        setParts(rowsSafe);

        const ids = rowsSafe.map((r) => r.id as UUID);
        if (ids.length) {
          const { data: vs, error: ve } = await supabase
            .from("v_part_stock")
            .select("part_id, location_id, qty_available, qty_on_hand, qty_reserved")
            .in("part_id", ids);
          if (ve) throw ve;

          const grouped: Record<UUID, VStock[]> = {};
          (vs ?? []).forEach((s) => {
            const key = s.part_id as UUID;
            if (!grouped[key]) grouped[key] = [];
            grouped[key].push({
              part_id: s.part_id as UUID,
              location_id: s.location_id as UUID,
              qty_available: Number(s.qty_available),
              qty_on_hand: Number(s.qty_on_hand),
              qty_reserved: Number(s.qty_reserved),
            });
          });
          if (!cancelled) setStock(grouped);
        } else {
          setStock({});
        }
      } catch (e: unknown) {
        if (!cancelled) setErr(e instanceof Error ? e.message : "Search failed");
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [open, shopId, search, supabase]);

  useEffect(() => {
    if (!open) return;
    setSelectedPartId(null);
    setSelectedLocId(null);
    setQty(1);
    setSearch(initialSearch);
  }, [open, initialSearch]);

  const selectedStocks = selectedPartId ? stock[selectedPartId] ?? [] : [];
  const locMap = new Map<UUID, StockLoc>(locs.map((l) => [l.id as UUID, l]));
  const defaultLocId: UUID | null =
    selectedLocId ?? mainLocId ?? (selectedStocks[0]?.location_id ?? null);

  const emit = (name: "close" | "pick", detail?: unknown) => {
    const ev = new CustomEvent(`${channel}:${name}`, { detail });
    window.dispatchEvent(ev);
  };

  const close = () => {
    onClose?.();
    emit("close");
  };

  const confirmPick = () => {
    if (!selectedPartId || qty <= 0) return;
    const payload: PickedPart = {
      part_id: selectedPartId,
      location_id: selectedLocId ?? undefined,
      qty,
    };
    onPick?.(payload);
    emit("pick", payload);
    close();
  };

  async function resolveSuggestionToPartId(s: AiPartSuggestion): Promise<string | null> {
    if (!shopId) return null;
    if (s.sku) {
      const { data } = await supabase
        .from("parts")
        .select("id")
        .eq("shop_id", shopId)
        .eq("sku", s.sku)
        .maybeSingle();
      if (data?.id) return data.id as string;
    }
    if (s.name) {
      const { data } = await supabase
        .from("parts")
        .select("id")
        .eq("shop_id", shopId)
        .ilike("name", s.name)
        .maybeSingle();
      if (data?.id) return data.id as string;
    }
    return null;
  }

  if (!open) return null;

  return (
    <div
      className="fixed inset-0 z-[500] flex items-center justify-center"
      onClick={(e) => {
        // kill bubbling to job card
        e.stopPropagation();
      }}
    >
      {/* Backdrop */}
      <div
        className="fixed inset-0 bg-black/70 backdrop-blur-sm"
        aria-hidden="true"
        onClick={() => {
          close();
        }}
      />

      {/* Panel */}
      <div
        className="relative z-[510] w-full max-w-3xl rounded-lg border border-orange-400 bg-neutral-950 p-4 text-white shadow-xl"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="mb-3 flex items-center justify-between">
          <div>
            <div className="text-xs text-neutral-400">Select a part</div>
            <h3 className="text-lg font-semibold font-header">Part Picker</h3>
          </div>
          <button
            onClick={close}
            className="rounded border border-neutral-700 px-2 py-1 text-sm text-neutral-200 hover:bg-neutral-800"
          >
            Close
          </button>
        </div>

        {/* AI */}
        <div className="mb-3 rounded border border-neutral-800">
          <div className="flex items-center justify-between border-b border-neutral-800 px-3 py-2">
            <div className="text-sm font-semibold">AI suggestions</div>
            {aiLoading && <div className="text-xs text-neutral-400">Thinking…</div>}
          </div>
          <div className="p-2">
            {aiErr ? (
              <div className="text-xs text-red-400">{aiErr}</div>
            ) : aiItems.length === 0 ? (
              <div className="text-xs text-neutral-500">No suggestions.</div>
            ) : (
              <div className="flex flex-wrap gap-2">
                {aiItems.map((s, i) => (
                  <button
                    key={i}
                    className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-900"
                    title={s.rationale || ""}
                    onClick={async () => {
                      const pid = await resolveSuggestionToPartId(s);
                      if (pid) {
                        setSelectedPartId(pid as UUID);
                        setQty(Math.max(1, Number(s.qty ?? 1)));
                      } else {
                        setSearch(s.sku || s.name || "");
                      }
                    }}
                  >
                    {(s.sku ? `${s.sku} • ` : "") + s.name} {s.qty ? `×${s.qty}` : ""}
                  </button>
                ))}
              </div>
            )}
          </div>
        </div>

        {/* Search */}
        <div className="mb-3">
          <input
            className="w-full rounded border border-neutral-700 bg-neutral-900 px-3 py-2 text-white placeholder:text-neutral-400"
            placeholder="Search name, SKU, category…"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
        </div>

        {err && <div className="mb-2 text-sm text-red-400">{err}</div>}

        {loading ? (
          <div className="text-sm text-neutral-400">Searching…</div>
        ) : (
          <div className="grid gap-3 md:grid-cols-2">
            {/* left */}
            <div className="rounded-xl border border-neutral-800">
              <div className="border-b border-neutral-800 p-2 text-sm font-semibold">Results</div>
              <div className="max-h-72 overflow-auto">
                {parts.length === 0 ? (
                  <div className="p-3 text-sm text-neutral-400">No parts found.</div>
                ) : (
                  parts.map((p) => (
                    <button
                      key={p.id as UUID}
                      onClick={() => setSelectedPartId(p.id as UUID)}
                      className={`block w-full border-b border-neutral-800 px-3 py-2 text-left hover:bg-neutral-900 ${
                        selectedPartId === (p.id as UUID) ? "bg-neutral-900" : ""
                      }`}
                    >
                      <div className="truncate font-medium">{p.name}</div>
                      <div className="truncate text-xs text-neutral-500">
                        {p.sku ?? "—"} • {p.category ?? "Uncategorized"}
                      </div>
                    </button>
                  ))
                )}
              </div>
            </div>

            {/* right */}
            <div className="rounded-xl border border-neutral-800 p-3">
              <div className="mb-2 text-sm font-semibold">Stock by location</div>
              {!selectedPartId ? (
                <div className="text-sm text-neutral-400">Select a part to view stock.</div>
              ) : selectedStocks.length === 0 ? (
                <div className="text-sm text-neutral-400">No stock entries yet (you can still use/consume).</div>
              ) : (
                <div className="grid gap-2">
                  {selectedStocks
                    .slice()
                    .sort((a, b) => Number(b.qty_available) - Number(a.qty_available))
                    .map((s) => {
                      const l = locMap.get(s.location_id as UUID);
                      const checked = (selectedLocId ?? defaultLocId) === s.location_id;
                      return (
                        <label
                          key={s.location_id}
                          className="flex items-center justify-between rounded border border-neutral-800 p-2"
                        >
                          <div className="min-w-0">
                            <div className="font-medium">{l?.code ?? "LOC"}</div>
                            <div className="truncate text-xs text-neutral-500">
                              {l?.name ?? String(s.location_id).slice(0, 6) + "…"}
                            </div>
                          </div>
                          <div className="tabular-nums text-sm font-semibold">
                            {Number(s.qty_available)} avail
                          </div>
                          <input
                            type="radio"
                            name="loc"
                            className="ml-2"
                            checked={!!checked}
                            onChange={() => setSelectedLocId(s.location_id as UUID)}
                          />
                        </label>
                      );
                    })}
                </div>
              )}

              <div className="mt-3 grid grid-cols-2 gap-3">
                <div>
                  <div className="mb-1 text-xs text-neutral-500">Quantity</div>
                  <input
                    type="number"
                    min={0}
                    step="0.01"
                    value={qty}
                    onChange={(e) => setQty(Math.max(0, Number(e.target.value || 0)))}
                    className="w-full rounded border border-neutral-700 bg-neutral-900 px-3 py-2"
                  />
                </div>
                <div>
                  <div className="mb-1 text-xs text-neutral-500">Location</div>
                  <select
                    value={defaultLocId ?? ""}
                    onChange={(e) => setSelectedLocId((e.target.value || null) as UUID | null)}
                    className="w-full rounded border border-neutral-700 bg-neutral-900 px-3 py-2"
                  >
                    <option value="">Auto</option>
                    {locs.map((l) => (
                      <option key={l.id as UUID} value={l.id as UUID}>
                        {l.code} — {l.name}
                      </option>
                    ))}
                  </select>
                </div>
              </div>

              <div className="mt-4 flex justify-end">
                <button
                  disabled={!selectedPartId || qty <= 0}
                  onClick={confirmPick}
                  className="rounded border border-orange-500 px-3 py-2 font-header text-sm text-white hover:bg-orange-500/10 disabled:opacity-60"
                >
                  Use Part
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default PartPicker;


/* =============================== */
/* FILE: ./features/parts/components/PartsDrawer.tsx */
/* =============================== */

"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import PartPicker, { PickedPart } from "@/features/parts/components/PartPicker";
import PartsRequestModal from "@/features/work-orders/components/workorders/PartsRequestModal";
import { toast } from "sonner";

type DB = Database;

type SerializableVehicle = {
  year?: number | string | null;
  make?: string | null;
  model?: string | null;
} | null;

type Props = {
  open: boolean;
  workOrderId: string;
  workOrderLineId: string;
  vehicleSummary?: SerializableVehicle;
  jobDescription?: string | null;
  jobNotes?: string | null;
  closeEventName?: string;
};

export default function PartsDrawer({
  open,
  workOrderId,
  workOrderLineId,
  vehicleSummary: _vehicleSummary = null,
  jobDescription: _jobDescription = null,
  jobNotes: _jobNotes = null,
  closeEventName = "parts-drawer:closed",
}: Props) {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [tab, setTab] = useState<"use" | "request">("use");

  const emitClose = useCallback(() => {
    window.dispatchEvent(new CustomEvent(closeEventName));
  }, [closeEventName]);

  const handleUsePart = useCallback(
    async ({ part_id, location_id, qty }: PickedPart) => {
      try {
        let locId = location_id ?? null;

        if (!locId) {
          const { data: locs } = await supabase
            .from("stock_locations")
            .select("id, code")
            .order("code")
            .limit(50);

          const main = (locs ?? []).find(
            (l) => (l.code ?? "").toUpperCase() === "MAIN"
          );
          if (main?.id) locId = main.id as string;
        }

        const { error } = await supabase.from("work_order_part_allocations").insert({
          work_order_line_id: workOrderLineId,
          work_order_id: workOrderId,
          part_id,
          location_id: locId,
          qty,
        });

        if (error) throw error;
        toast.success("Part allocated to job.");
        window.dispatchEvent(new CustomEvent("wo:parts-used"));
        emitClose();
      } catch (e: any) {
        toast.error(e?.message ?? "Failed to allocate part.");
      }
    },
    [emitClose, supabase, workOrderId, workOrderLineId]
  );

  useEffect(() => {
    if (!open) return;

    const onCloseReq = () => emitClose();
    const onSubmitted = () => {
      toast.success("Parts request submitted");
      emitClose();
    };

    window.addEventListener("parts-request:close", onCloseReq);
    window.addEventListener("parts-request:submitted", onSubmitted);
    return () => {
      window.removeEventListener("parts-request:close", onCloseReq);
      window.removeEventListener("parts-request:submitted", onSubmitted);
    };
  }, [open, emitClose]);

  if (!open) return null;

  return (
    <div
      className="fixed inset-0 z-[510]"
      onClick={(e) => {
        // keep clicks inside here, don't trigger parent rows
        e.stopPropagation();
      }}
    >
      <div
        className="absolute inset-0 bg-black/70 backdrop-blur-sm"
        onClick={emitClose}
      />
      <div
        className="absolute inset-x-0 bottom-0 z-[520] w-full rounded-t-xl border border-orange-400 bg-neutral-950 p-0 text-white shadow-xl md:inset-auto md:top-1/2 md:left-1/2 md:h-[85vh] md:w-[960px] md:-translate-x-1/2 md:-translate-y-1/2 md:rounded-xl"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex items-center justify-between border-b border-neutral-800 p-3">
          <div className="flex items-center gap-2">
            <button
              className={`rounded px-3 py-1.5 text-sm ${
                tab === "use"
                  ? "border border-orange-500 text-orange-300"
                  : "border border-transparent text-neutral-300 hover:text-white"
              }`}
              onClick={() => setTab("use")}
            >
              Use from Inventory
            </button>
            <button
              className={`rounded px-3 py-1.5 text-sm ${
                tab === "request"
                  ? "border border-orange-500 text-orange-300"
                  : "border border-transparent text-neutral-300 hover:text-white"
              }`}
              onClick={() => setTab("request")}
            >
              Request to Purchase
            </button>
          </div>
          <button
            onClick={emitClose}
            className="rounded border border-neutral-700 px-2 py-1 text-sm text-neutral-200 hover:bg-neutral-800"
          >
            Close
          </button>
        </div>

        <div className="p-3">
          {tab === "use" ? (
            <PartPicker
              open={true}
              onClose={emitClose}
              onPick={handleUsePart}
              initialSearch=""
              workOrderId={workOrderId}
              workOrderLineId={workOrderLineId}
              jobDescription={_jobDescription}
              jobNotes={_jobNotes}
              vehicleSummary={_vehicleSummary}
            />
          ) : (
            <div className="relative">
              <PartsRequestModal
                isOpen={true}
                workOrderId={workOrderId}
                jobId={workOrderLineId}
                closeEventName="parts-request:close"
                submittedEventName="parts-request:submitted"
              />
            </div>
          )}
        </div>
      </div>
    </div>
  );
}


/* =============================== */
/* FILE: ./features/parts/components/PartsRequestChat.tsx */
/* =============================== */

// features/parts/components/PartsRequestChat.tsx
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { v4 as uuidv4 } from "uuid";
import { toast } from "sonner";

type Message = Database["public"]["Tables"]["parts_request_messages"]["Row"];

interface Props {
  // allow null/undefined from parents safely
  requestId: string | null | undefined;
  senderId: string;
}

export default function PartsRequestChat({ requestId, senderId }: Props) {
  const supabase = useMemo(() => createClientComponentClient<Database>(), []);

  const [messages, setMessages] = useState<Message[]>([]);
  const [newMsg, setNewMsg] = useState("");
  const bottomRef = useRef<HTMLDivElement | null>(null);

  // Fetch messages (guard if requestId isn't ready)
  useEffect(() => {
    if (!requestId) return;

    let cancelled = false;
    (async () => {
      const { data, error } = await supabase
        .from("parts_request_messages")
        .select("*")
        .eq("request_id", requestId)
        .order("created_at", { ascending: true });

      if (error) {
        console.error("Failed to load parts request messages:", error);
        return;
      }
      if (!cancelled && data) setMessages(data);
    })();

    return () => {
      cancelled = true;
    };
  }, [requestId, supabase]);

  // Realtime inserts (guard if requestId isn't ready)
  useEffect(() => {
    if (!requestId) return;

    const channel = supabase
      .channel(`req-messages-${requestId}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "parts_request_messages",
          filter: `request_id=eq.${requestId}`,
        },
        (payload) => {
          const newMessage = payload.new as Message;
          setMessages((prev) => [...prev, newMessage]);
          if (newMessage.sender_id !== senderId) {
            toast.info("New message on request");
          }
        },
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [requestId, senderId, supabase]);

  // Auto-scroll on new messages
  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSend = async () => {
    const content = newMsg.trim();
    if (!requestId || !content) return;

    const { error } = await supabase.from("parts_request_messages").insert({
      id: uuidv4(),
      request_id: requestId,
      sender_id: senderId,
      message: content,
    });

    if (error) {
      console.error("Failed to send parts request message:", error);
      toast.error("Failed to send message");
    } else {
      setNewMsg("");
    }
  };

  // If we don't have a valid request, render nothing (or a placeholder)
  if (!requestId) {
    return null;
  }

  return (
    <div className="border-t border-gray-700 mt-3 pt-2">
      <div className="max-h-40 overflow-y-auto space-y-2 text-sm">
        {messages.map((msg) => {
          const ts = msg.created_at ? new Date(msg.created_at) : null;
          return (
            <div
              key={msg.id}
              className={`p-2 rounded ${
                msg.sender_id === senderId
                  ? "bg-orange-600 text-white ml-auto text-right"
                  : "bg-gray-700 text-white mr-auto"
              }`}
            >
              <p>{msg.message}</p>
              <p className="text-xs text-gray-400">
                {ts ? ts.toLocaleTimeString() : ""}
              </p>
            </div>
          );
        })}
        <div ref={bottomRef} />
      </div>

      <div className="mt-2 flex items-center gap-2">
        <input
          value={newMsg}
          onChange={(e) => setNewMsg(e.target.value)}
          onKeyDown={(e) => e.key === "Enter" && handleSend()}
          placeholder="Type a message..."
          className="flex-1 rounded bg-neutral-800 border border-neutral-600 px-3 py-2 text-white"
        />
        <button
          onClick={handleSend}
          className="bg-orange-500 hover:bg-orange-600 px-3 py-1 rounded text-white"
          disabled={!requestId || !newMsg.trim()}
        >
          Send
        </button>
      </div>
    </div>
  );
}


/* =============================== */
/* FILE: ./features/parts/components/SupplierForm.tsx */
/* =============================== */

"use client";
import { useState, useTransition } from "react";
import { createSupplier } from "@/features/parts/lib/suppliers";

export function SupplierForm({ shopId }: { shopId: string }) {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [phone, setPhone] = useState("");
  const [pending, start] = useTransition();
  const [err, setErr] = useState<string | null>(null);

  return (
    <form
      className="space-y-3"
      onSubmit={(e) => {
        e.preventDefault();
        setErr(null);
        start(async () => {
          try {
            await createSupplier({ shop_id: shopId, name: name.trim(), email: email || undefined, phone: phone || undefined });
            window.location.reload();
          } catch (e: any) {
            setErr(e?.message ?? "Failed");
          }
        });
      }}
    >
      {err && <div className="text-sm text-red-600">{err}</div>}
      <div className="grid md:grid-cols-3 gap-3">
        <label className="block md:col-span-1">
          <div className="text-sm font-medium mb-1">Name</div>
          <input className="border rounded w-full px-3 py-2" value={name} onChange={(e) => setName(e.target.value)} required />
        </label>
        <label className="block">
          <div className="text-sm font-medium mb-1">Email</div>
          <input className="border rounded w-full px-3 py-2" type="email" value={email} onChange={(e) => setEmail(e.target.value)} />
        </label>
        <label className="block">
          <div className="text-sm font-medium mb-1">Phone</div>
          <input className="border rounded w-full px-3 py-2" value={phone} onChange={(e) => setPhone(e.target.value)} />
        </label>
      </div>
      <button disabled={pending} className="px-3 py-2 rounded-xl bg-neutral-900 text-white">
        {pending ? "Saving…" : "Create Supplier"}
      </button>
    </form>
  );
}



/* =============================== */
/* FILE: ./features/parts/components/VehiclePhotoGallery.tsx */
/* =============================== */

"use client";

import { useEffect, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

import Image from "next/image";
import { Dialog } from "@headlessui/react";
import { PencilIcon, TrashIcon, XMarkIcon } from "@heroicons/react/24/outline";
import type { Database } from "@shared/types/types/supabase";

type VehiclePhoto = Database["public"]["Tables"]["vehicle_photos"]["Row"];

interface Props {
  vehicleId: string;
  currentUserId: string;
}

export default function VehiclePhotoGallery({
  vehicleId,
  currentUserId,
}: Props) {
    const supabase = createClientComponentClient<Database>();

  const [photos, setPhotos] = useState<VehiclePhoto[]>([]);
  const [editingCaptionId, setEditingCaptionId] = useState<string | null>(null);
  const [editedCaption, setEditedCaption] = useState("");
  const [fullscreenPhoto, setFullscreenPhoto] = useState<VehiclePhoto | null>(
    null,
  );

  useEffect(() => {
    const fetchPhotos = async () => {
      const { data } = await supabase
        .from("vehicle_photos")
        .select("*")
        .eq("vehicle_id", vehicleId)
        .order("created_at", { ascending: false });
      if (data) setPhotos(data);
    };

    fetchPhotos();
  }, [vehicleId]);

  const handleDelete = async (id: string) => {
    await supabase.from("vehicle_photos").delete().eq("id", id);
    setPhotos((prev) => prev.filter((p) => p.id !== id));
  };

  const handleCaptionSave = async (id: string) => {
    await supabase
      .from("vehicle_photos")
      .update({ caption: editedCaption })
      .eq("id", id);
    setPhotos((prev) =>
      prev.map((p) => (p.id === id ? { ...p, caption: editedCaption } : p)),
    );
    setEditingCaptionId(null);
    setEditedCaption("");
  };

  return (
    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mt-4">
      {photos.map((photo) => (
        <div key={photo.id} className="relative group">
          <Image
            src={photo.url}
            alt="Vehicle Photo"
            width={300}
            height={200}
            className="rounded shadow cursor-pointer"
            onClick={() => setFullscreenPhoto(photo)}
          />

          <div className="absolute top-1 right-1 flex gap-1 opacity-0 group-hover:opacity-100 transition">
            {photo.uploaded_by === currentUserId && (
              <>
                <button
                  onClick={() => {
                    setEditingCaptionId(photo.id);
                    setEditedCaption(photo.caption || "");
                  }}
                >
                  <PencilIcon className="w-5 h-5 text-orange-400 hover:text-orange-600" />
                </button>
                <button onClick={() => handleDelete(photo.id)}>
                  <TrashIcon className="w-5 h-5 text-red-400 hover:text-red-600" />
                </button>
              </>
            )}
          </div>

          <div className="mt-1 text-sm text-gray-300">
            {editingCaptionId === photo.id ? (
              <div className="flex gap-2 items-center">
                <input
                  value={editedCaption}
                  onChange={(e) => setEditedCaption(e.target.value)}
                  className="bg-gray-800 border border-gray-600 rounded px-2 py-1 text-white text-sm w-full"
                />
                <button
                  onClick={() => handleCaptionSave(photo.id)}
                  className="text-green-500 text-sm"
                >
                  Save
                </button>
              </div>
            ) : (
              photo.caption
            )}
          </div>
        </div>
      ))}

      <Dialog
        open={!!fullscreenPhoto}
        onClose={() => setFullscreenPhoto(null)}
        className="relative z-50"
      >
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4">
          <Dialog.Panel className="relative">
            <Image
              src={fullscreenPhoto?.url || ""}
              alt="Full Size Vehicle"
              width={1000}
              height={700}
              className="rounded shadow-lg max-h-[90vh] object-contain"
            />
            {fullscreenPhoto?.caption && (
              <p className="text-white text-center mt-4">
                {fullscreenPhoto.caption}
              </p>
            )}
            <button
              className="absolute top-4 right-4 text-white hover:text-red-400"
              onClick={() => setFullscreenPhoto(null)}
            >
              <XMarkIcon className="w-6 h-6" />
            </button>
          </Dialog.Panel>
        </div>
      </Dialog>
    </div>
  );
}



/* =============================== */
/* FILE: ./features/parts/components/VehiclePhotoUploader.tsx */
/* =============================== */

"use client";

import { useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

import type { Database } from "@shared/types/types/supabase";
import { v4 as uuidv4 } from "uuid";
import { toast } from "sonner";

type VehiclePhoto = Database["public"]["Tables"]["vehicle_photos"]["Row"];

interface Props {
  vehicleId: string;
  onUpload?: (photo: VehiclePhoto) => void;
}

export default function VehiclePhotoUploader({ vehicleId, onUpload }: Props) {
    const supabase = createClientComponentClient<Database>();

  const [file, setFile] = useState<File | null>(null);
  const [caption, setCaption] = useState("");
  const [uploading, setUploading] = useState(false);

  const handleUpload = async () => {
    if (!file) return;
    setUploading(true);

    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser();

    if (userError || !user) {
      toast.error("User not authenticated");
      setUploading(false);
      return;
    }

    const fileExt = file.name.split(".").pop();
    const fileName = `${uuidv4()}.${fileExt}`;
    const filePath = `${vehicleId}/${fileName}`;

    const { error: uploadError } = await supabase.storage
      .from("vehicle-photos")
      .upload(filePath, file);

    if (uploadError) {
      toast.error("Upload failed");
      setUploading(false);
      return;
    }

    const { data: urlData } = supabase.storage
      .from("vehicle-photos")
      .getPublicUrl(filePath);

    const publicUrl = urlData?.publicUrl;

    if (!publicUrl) {
      toast.error("Could not get image URL");
      setUploading(false);
      return;
    }

    const { data: inserted, error: insertError } = await supabase
      .from("vehicle_photos")
      .insert({
        vehicle_id: vehicleId,
        uploaded_by: user.id,
        url: publicUrl,
        caption,
      })
      .select()
      .single();

    if (insertError || !inserted) {
      toast.error("Failed to save photo info");
      setUploading(false);
      return;
    }

    toast.success("Photo uploaded");
    if (onUpload) onUpload(inserted);
    setFile(null);
    setCaption("");
    setUploading(false);
  };

  return (
    <div className="bg-neutral-800 p-4 rounded-lg border border-neutral-700 space-y-4">
      <h3 className="text-white font-semibold text-lg">Upload Vehicle Photo</h3>

      <input
        type="file"
        accept="image/*"
        onChange={(e) => setFile(e.target.files?.[0] || null)}
        className="text-white"
      />

      <input
        type="text"
        placeholder="Enter caption (optional)"
        value={caption}
        onChange={(e) => setCaption(e.target.value)}
        className="w-full p-2 rounded bg-neutral-700 border border-neutral-600 text-white"
      />

      <button
        onClick={handleUpload}
        disabled={uploading || !file}
        className="bg-orange-600 hover:bg-orange-700 text-white px-4 py-2 rounded font-medium disabled:opacity-50"
      >
        {uploading ? "Uploading..." : "Upload Photo"}
      </button>
    </div>
  );
}



/* =============================== */
/* FILE: ./features/parts/hooks/useAiPartSuggestions.ts */
/* =============================== */

"use client";

import { useCallback, useState } from "react";

/** A single AI-suggested part candidate. */
export type AiPartSuggestion = {
  name: string;
  sku?: string | null;
  qty?: number | null;
  confidence?: number | null; // 0..1
  rationale?: string | null;  // short reason the model suggested it
};

/** Hook to request AI part suggestions for a WO / WO line. */
export function useAiPartSuggestions() {
  const [loading, setLoading] = useState(false);
  const [items, setItems] = useState<AiPartSuggestion[]>([]);
  const [error, setError] = useState<string | null>(null);

  const suggest = useCallback(
    async (input: {
      workOrderId: string;
      workOrderLineId?: string | null;
      vehicle?: { year?: number | string | null; make?: string | null; model?: string | null } | null;
      description?: string | null;  // complaint / job description
      notes?: string | null;        // any extra text you want to include
      topK?: number;
    }) => {
      setLoading(true);
      setError(null);
      try {
        const res = await fetch("/api/ai/parts/suggest", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(input),
        });
        const j = await res.json().catch(() => ({}));
        if (!res.ok) throw new Error(j?.error || "Suggestion failed");
        const arr = Array.isArray(j?.items) ? j.items : [];
        setItems(arr as AiPartSuggestion[]);
      } catch (e: unknown) {
        const msg = e instanceof Error ? e.message : "Suggestion failed";
        setError(msg);
        setItems([]);
      } finally {
        setLoading(false);
      }
    },
    [],
  );

  return { loading, items, error, suggest, setItems };
}


/* =============================== */
/* FILE: ./features/parts/lib/locations.ts */
/* =============================== */

"use server";
import { cookies } from "next/headers";
import { createServerComponentClient, createServerActionClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
type DB = Database;

export async function ensureMainLocation(shopId: string) {
  const supabase = createServerActionClient<DB>({ cookies });
  const { data, error } = await supabase
    .from("stock_locations")
    .select("id, code, name")
    .eq("shop_id", shopId)
    .eq("code", "MAIN")
    .maybeSingle();
  if (error) throw error;
  if (data) return data;
  const { data: created, error: cerr } = await supabase
    .from("stock_locations")
    .insert({ shop_id: shopId, code: "MAIN", name: "Main Stock" })
    .select("id, code, name")
    .single();
  if (cerr) throw cerr;
  return created;
}

export async function listLocations(shopId: string) {
  const supabase = createServerComponentClient<DB>({ cookies });
  const { data, error } = await supabase
    .from("stock_locations")
    .select("id, code, name")
    .eq("shop_id", shopId)
    .order("code");
  if (error) throw error;
  return data ?? [];
}

export async function createLocation(input: { shop_id: string; code: string; name: string }) {
  const supabase = createServerActionClient<DB>({ cookies });
  const { data, error } = await supabase
    .from("stock_locations")
    .insert(input)
    .select("id")
    .single();
  if (error) throw error;
  return data.id as string;
}



/* =============================== */
/* FILE: ./features/parts/lib/parts.queries.ts */
/* =============================== */

"use server";
import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
type DB = Database;

export async function listParts(shopId: string) {
  const supabase = createServerComponentClient<DB>({ cookies });
  const { data, error } = await supabase
    .from("parts")
    .select("id, sku, name, category, default_price, low_stock_threshold")
    .eq("shop_id", shopId)
    .order("name");
  if (error) throw error;
  return data ?? [];
}

export async function getPart(id: string) {
  const supabase = createServerComponentClient<DB>({ cookies });
  const { data, error } = await supabase
    .from("parts")
    .select("*, part_suppliers(*), v_part_stock(*)")
    .eq("id", id)
    .single();
  if (error) throw error;
  return data;
}



/* =============================== */
/* FILE: ./features/parts/lib/parts/searchParts.ts */
/* =============================== */

// lib/parts/searchParts.ts

import { createClient } from "@supabase/supabase-js";
import type { Database } from "@shared/types/types/supabase";

const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
);

/**
 * Search parts by keyword (fuzzy match on name, description, sku, or supplier).
 */
export async function searchPartsByKeyword(keyword: string): Promise<string[]> {
  if (!keyword || keyword.length < 2) return [];

  const { data, error } = await supabase
    .from("parts")
    .select("name")
    .or(
      `name.ilike.%${keyword}%,description.ilike.%${keyword}%,sku.ilike.%${keyword}%,supplier.ilike.%${keyword}%`,
    )
    .limit(10);

  if (error) {
    console.error("Part search error:", error.message);
    return [];
  }

  return data?.map((part) => part.name) ?? [];
}



/* =============================== */
/* FILE: ./features/parts/lib/po.ts */
/* =============================== */

/** Stubs for PO logic; wire to Supabase tables and email/pdf later. */
export type PoDraft = {
  supplier_id: string | null;
  notes?: string | null;
  lines: Array<{ part_id?: string|null; sku?: string|null; description?: string|null; qty: number; unit_cost?: number|null; location_id?: string|null }>;
};

export async function suggestReorder(): Promise<PoDraft[]> {
  // TODO: compute from low_stock + recent usage
  return [];
}

export async function createPoDraft(_draft: PoDraft): Promise<string> {
  // TODO: insert into purchase_orders + purchase_order_lines and return id
  return "TODO-PO-ID";
}



/* =============================== */
/* FILE: ./features/parts/lib/suppliers.ts */
/* =============================== */

"use server";
import { cookies } from "next/headers";
import { createServerComponentClient, createServerActionClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
type DB = Database;

export async function listSuppliers(shopId: string) {
  const supabase = createServerComponentClient<DB>({ cookies });
  const { data, error } = await supabase
    .from("suppliers")
    .select("id, name, email, phone, is_active")
    .eq("shop_id", shopId)
    .order("name");
  if (error) throw error;
  return data ?? [];
}

export async function createSupplier(input: { shop_id: string; name: string; email?: string; phone?: string }) {
  const supabase = createServerActionClient<DB>({ cookies });
  const { data, error } = await supabase
    .from("suppliers")
    .insert(input)
    .select("id")
    .single();
  if (error) throw error;
  return data.id as string;
}



/* =============================== */
/* FILE: ./features/parts/server/poActions.ts */
/* =============================== */

"use server";

import { cookies } from "next/headers";
import { revalidatePath } from "next/cache";
import { createServerActionClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
type DB = Database;

export async function createPurchaseOrder(input: {
  shop_id: string;
  supplier_id?: string | null;
  notes?: string | null;
}) {
  const supabase = createServerActionClient<DB>({ cookies });
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Unauthenticated");

  const { data, error } = await supabase
    .from("purchase_orders")
    .insert({
      shop_id: input.shop_id,
      supplier_id: input.supplier_id ?? null,
      notes: input.notes ?? null,
      created_by: user.id,
      status: "draft",
    })
    .select("id")
    .single();
  if (error) throw error;
  revalidatePath("/parts/po");
  return data.id as string;
}

export async function addPoLine(input: {
  po_id: string;
  part_id?: string | null;
  sku?: string | null;
  description?: string | null;
  qty: number;
  unit_cost?: number | null;
  location_id?: string | null;
}) {
  const supabase = createServerActionClient<DB>({ cookies });
  if (input.qty <= 0) throw new Error("Quantity must be > 0");

  const { error } = await supabase.from("purchase_order_lines").insert({
    po_id: input.po_id,
    part_id: input.part_id ?? null,
    sku: input.sku ?? null,
    description: input.description ?? null,
    qty: input.qty,
    unit_cost: input.unit_cost ?? null,
    location_id: input.location_id ?? null,
  });
  if (error) throw error;
  revalidatePath("/parts/po");
}

export async function markPoSent(po_id: string) {
  const supabase = createServerActionClient<DB>({ cookies });
  const { error } = await supabase
    .from("purchase_orders")
    .update({ status: "sent" })
    .eq("id", po_id);
  if (error) throw error;
  revalidatePath("/parts/po");
}

/** Receive all remaining qty for lines (simple MVP).
 *  For a granular UI, create a separate receivePoLine().
 */
export async function receivePo(po_id: string) {
  const supabase = createServerActionClient<DB>({ cookies });

  // Load PO + lines
  const { data: lines, error: le } = await supabase
    .from("purchase_order_lines")
    .select("id, part_id, qty, received_qty, location_id, purchase_orders!inner(shop_id)")
    .eq("po_id", po_id);
  if (le) throw le;

  // Apply stock moves (receive delta)
  for (const ln of lines ?? []) {
    const delta = Number(ln.qty) - Number(ln.received_qty || 0);
    if (delta > 0) {
      // location required: if missing, you can default to MAIN in your UI
      const loc = ln.location_id;
      if (!loc) continue;

      const { error: se } = await supabase.rpc("apply_stock_move", {
        p_part: ln.part_id,           // can be null if only SKU/desc; you may want to require part_id
        p_loc: loc,
        p_qty: delta,
        p_reason: "receive",
        p_ref_kind: "purchase_order",
        p_ref_id: po_id,
      });
      if (se) throw se;

      // Update received tally
      const { error: ue } = await supabase
        .from("purchase_order_lines")
        .update({ received_qty: Number(ln.received_qty || 0) + delta })
        .eq("id", ln.id);
      if (ue) throw ue;
    }
  }

  // Mark PO received
  const { error: pe } = await supabase
    .from("purchase_orders")
    .update({ status: "received" })
    .eq("id", po_id);
  if (pe) throw pe;

  revalidatePath("/parts/po");
}


/* =============================== */
/* FILE: ./features/parts/server/scanActions.ts */
/* =============================== */

"use server";

import { cookies } from "next/headers";
import { createServerActionClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
type DB = Database;

/**
 * Resolve a scanned code (barcode or SKU) to a part_id.
 * Strategy (in order):
 *  1) parts_barcodes(code, supplier_id?) -> part_id
 *  2) parts.sku == code (case-insensitive)
 *  3) parts.upc == code  (if you have this column)
 */
export async function resolveScannedCode(input: {
  code: string;
  supplier_id?: string | null;
}): Promise<{ part_id: string | null }> {
  const supabase = createServerActionClient<DB>({ cookies });
  const code = (input.code || "").trim();
  if (!code) return { part_id: null };

  // 1) explicit barcode mappings (recommended table)
  const { data: map } = await supabase
    .from("parts_barcodes")
    .select("part_id")
    .eq("code", code)
    .maybeSingle();

  if (map?.part_id) return { part_id: map.part_id };

  // If supplier-specific mappings exist, try them too
  if (input.supplier_id) {
    const { data: map2 } = await supabase
      .from("parts_barcodes")
      .select("part_id")
      .eq("code", code)
      .eq("supplier_id", input.supplier_id)
      .maybeSingle();
    if (map2?.part_id) return { part_id: map2.part_id };
  }

  // 2) fallback: SKU match
  const { data: bySku } = await supabase
    .from("parts")
    .select("id")
    .ilike("sku", code)
    .maybeSingle();
  if (bySku?.id) return { part_id: bySku.id };

  // 3) optional UPC column fallback (if present in your schema)
  // Comment out if you don't have this column.
  try {
    const { data: byUpc } = await supabase
      .from("parts")
      .select("id")
      .eq("upc", code as any)
      .maybeSingle();
    if (byUpc?.id) return { part_id: byUpc.id };
  } catch {
    /* column may not exist */
  }

  return { part_id: null };
}


/* =============================== */
/* FILE: ./features/parts/server/transcribe.md */
/* =============================== */

If you want voice receiving, add:
- /api/transcribe (POST audio blob) -> Whisper/OpenAI -> text
- Parse "receive 3 brake pads to main" -> {qty:3, part:"brake pads", loc:"MAIN"}



/* =============================== */
/* FILE: ./features/work-orders/lib/parts/consumePart.ts */
/* =============================== */

"use server";

import { cookies } from "next/headers";
import { revalidatePath } from "next/cache";
import { createServerActionClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { ensureMainLocation } from "@parts/lib/locations";

type DB = Database;

export async function consumePart(input: {
  work_order_line_id: string;
  part_id: string;
  qty: number;                 // positive number means "consume qty"
  location_id?: string;        // optional; defaults to MAIN for the WO's shop
}) {
  const supabase = createServerActionClient<DB>({ cookies });

  // 1) Look up WO + shop_id from the line
  const { data: woLine, error: wlErr } = await supabase
    .from("work_order_lines")
    .select("id, work_order_id, work_orders!inner(id, shop_id)")
    .eq("id", input.work_order_line_id)
    .single();
  if (wlErr) throw wlErr;

  const workOrderId = woLine.work_order_id;
  const shopId = (woLine as any).work_orders.shop_id as string;

  // 2) Determine location_id
  let locationId = input.location_id;
  if (!locationId) {
    const loc = await ensureMainLocation(shopId);
    locationId = loc.id;
  }

  // 3) (Optional) get a unit cost from part default for audit
  const { data: part, error: partErr } = await supabase
    .from("parts")
    .select("default_cost")
    .eq("id", input.part_id)
    .single();
  if (partErr) throw partErr;
  const unit_cost = Number(part?.default_cost ?? 0);

  // 4) Create allocation row (without stock_move_id yet)
  const { data: alloc, error: aErr } = await supabase
    .from("work_order_part_allocations")
    .insert({
      work_order_line_id: input.work_order_line_id,
      part_id: input.part_id,
      location_id: locationId!,
      qty: Math.abs(input.qty),
      unit_cost,
    })
    .select("id")
    .single();
  if (aErr) throw aErr;

  // 5) Create stock move (consume = negative)
  const { data: moveId, error: mErr } = await supabase.rpc("apply_stock_move", {
    p_part: input.part_id,
    p_loc: locationId!,
    p_qty: -Math.abs(input.qty),
    p_reason: "consume",
    p_ref_kind: "WO",
    p_ref_id: workOrderId,
  });
  if (mErr) throw mErr;

  // 6) Link stock move back to allocation
  const { error: linkErr } = await supabase
    .from("work_order_part_allocations")
    .update({ stock_move_id: moveId as string })
    .eq("id", alloc.id);
  if (linkErr) throw linkErr;

  // 7) Revalidate WO page if your route matches /work-orders/[id]
  revalidatePath(`/work-orders/${workOrderId}`);

  return { allocationId: alloc.id as string, moveId: moveId as string };
}



===== FILE: ./unified_inspection_dump.txt =====
=============== Inspection Header ===============
"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";

type Props = {
  session: InspectionSession;
};

export default function InspectionHeader({ session }: Props) {
  return (
    <div className="flex flex-col gap-1 rounded-xl border border-white/10 bg-black/40 p-3 text-xs text-neutral-200">
      <div className="text-sm font-semibold text-orange-400">
        {session.templateName || "Inspection"}
      </div>
      <div>
        Vehicle:{" "}
        {session.vehicle?.year} {session.vehicle?.make}{" "}
        {session.vehicle?.model}
      </div>
      <div>Customer: {session.customer?.first_name} {session.customer?.last_name}</div>
      <div>Status: {session.status}</div>
    </div>
  );
}

=============== Inspection Action Bar ===============
"use client";



type Props = {
  onSave?: () => void;
  onFinish?: () => void;
  onStartVoice?: () => void;
  onStopVoice?: () => void;
  isListening?: boolean;
};

export default function InspectionActionBar({
  onSave,
  onFinish,
  onStartVoice,
  onStopVoice,
  isListening,
}: Props) {
  return (
    <div className="flex flex-wrap items-center justify-between gap-2 rounded-xl border border-white/10 bg-black/40 p-3 text-xs">
      <div className="font-semibold text-neutral-200">Inspection actions</div>
      <div className="flex gap-2">
        <button
          type="button"
          onClick={onSave}
          className="rounded bg-neutral-800 px-3 py-1 text-xs text-white"
        >
          Save
        </button>
        <button
          type="button"
          onClick={onFinish}
          className="rounded bg-orange-600 px-3 py-1 text-xs text-white"
        >
          Finish
        </button>
        {isListening ? (
          <button
            type="button"
            onClick={onStopVoice}
            className="rounded bg-red-600 px-3 py-1 text-xs text-white"
          >
            Stop voice
          </button>
        ) : (
          <button
            type="button"
            onClick={onStartVoice}
            className="rounded bg-green-600 px-3 py-1 text-xs text-white"
          >
            Start voice
          </button>
        )}
      </div>
    </div>
  );
}

=============== Inspection Summary ===============
"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";

type Props = {
  session: InspectionSession;
};

export default function InspectionSummary({ session }: Props) {
  const sections = session.sections ?? [];
  const totalItems = sections.reduce(
    (sum, s) => sum + (s.items?.length ?? 0),
    0,
  );

  return (
    <div className="rounded-xl border border-white/10 bg-black/40 p-3 text-xs text-neutral-200">
      <div className="mb-1 text-sm font-semibold text-orange-400">
        Quick summary
      </div>
      <div>Sections: {sections.length}</div>
      <div>Items: {totalItems}</div>
      <div>Status: {session.status}</div>
    </div>
  );
}

=============== Section Renderer ===============
"use client";


import type {
  InspectionSection,
  InspectionItem,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/unified/ui/CornerGrid";
import AxleGrid from "@inspections/unified/ui/AxleGrid";
import SectionDisplay from "@inspections/unified/ui/SectionDisplay";

type Props = {
  sections: InspectionSection[];
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
};

// Steer / Drive / Trailer Left|Right ...
const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
// LF / RF / LR / RR ...
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
// Left Front / Right Rear ...
const HYD_FULL_RE =
  /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

function detectLayout(items: InspectionItem[]): "air" | "hyd" | "plain" {
  let airMatches = 0;
  let hydMatches = 0;

  for (const it of items) {
    const label = it.item ?? it.name ?? "";
    if (!label) continue;

    if (AIR_RE.test(label)) airMatches += 1;
    if (HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label)) hydMatches += 1;
  }

  if (airMatches > 0) return "air";
  if (hydMatches > 0) return "hyd";
  return "plain";
}

export default function SectionRenderer({ sections, onUpdateItem }: Props) {
  return (
    <div className="flex flex-col gap-4">
      {sections.map((section, sectionIndex) => {
        const items = section.items ?? [];
        const layout = detectLayout(items);

        // HYDRAULIC CORNER GRID (LF/RF/LR/RR + metrics)
        if (layout === "hyd") {
          return (
            <CornerGrid
              key={`${sectionIndex}-${section.title || "hyd"}`}
              sectionIndex={sectionIndex}
              items={items}
              unitMode="imperial"
              showKpaHint={true}
              onUpdateItem={onUpdateItem}
            />
          );
        }

        // AIR / AXLE GRID (Steer / Drive / Trailer Left/Right + metrics)
        if (layout === "air") {
          return (
            <AxleGrid
              key={`${sectionIndex}-${section.title || "air"}`}
              sectionIndex={sectionIndex}
              items={items}
              unitMode="imperial"
              showKpaHint={true}
              onUpdateItem={onUpdateItem}
            />
          );
        }

        // GENERIC “CARD” SECTION – unified theme, no legacy imports
        return (
          <SectionDisplay
            key={`${sectionIndex}-${section.title || "plain"}`}
            title={section.title ?? `Section ${sectionIndex + 1}`}
            section={section}
            sectionIndex={sectionIndex}
            showNotes
            showPhotos
            onUpdateStatus={(
              secIdx: number,
              itemIdx: number,
              status: InspectionItemStatus,
            ) => onUpdateItem(secIdx, itemIdx, { status })}
            onUpdateNote={(
              secIdx: number,
              itemIdx: number,
              note: string,
            ) => onUpdateItem(secIdx, itemIdx, { notes: note })}
            onUpload={(
              photoUrl: string,
              secIdx: number,
              itemIdx: number,
            ) => {
              const item = sections[secIdx]?.items?.[itemIdx];
              const existing = (item?.photoUrls ?? []) as string[];
              onUpdateItem(secIdx, itemIdx, {
                photoUrls: [...existing, photoUrl],
              });
            }}
          />
        );
      })}
    </div>
  );
}

=============== Section Display ===============
//features/inspections/unified/ui/SectionDisplay.tsx
"use client";

import { useMemo, useState } from "react";
import type {
  InspectionSection,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";
import { Button } from "@shared/components/ui/Button";

type SectionDisplayProps = {
  title: string;
  section: InspectionSection;
  sectionIndex: number;
  showNotes: boolean;
  showPhotos: boolean;
  onUpdateStatus: (
    sectionIndex: number,
    itemIndex: number,
    status: InspectionItemStatus,
  ) => void;
  onUpdateNote: (
    sectionIndex: number,
    itemIndex: number,
    note: string,
  ) => void;
  onUpload: (
    photoUrl: string,
    sectionIndex: number,
    itemIndex: number,
  ) => void;
};

export default function SectionDisplay({
  title,
  section,
  sectionIndex,
  showNotes,
  showPhotos,
  onUpdateStatus,
  onUpdateNote,
  onUpload,
}: SectionDisplayProps) {
  const [open, setOpen] = useState<boolean>(true);

  const stats = useMemo(() => {
    const total = section.items.length;
    const counts: Record<
      "ok" | "fail" | "na" | "recommend" | "unset",
      number
    > = { ok: 0, fail: 0, na: 0, recommend: 0, unset: 0 };

    for (const it of section.items) {
      const status = (it.status ?? "unset") as keyof typeof counts;
      if (status in counts) counts[status] += 1;
      else counts.unset += 1;
    }

    return { total, ...counts };
  }, [section.items]);

  const markAll = (status: InspectionItemStatus) => {
    section.items.forEach((_item, itemIndex) =>
      onUpdateStatus(sectionIndex, itemIndex, status),
    );
  };

  return (
    <div className="mb-6 rounded-2xl border border-white/8 bg-black/30 px-4 py-3 shadow-card backdrop-blur-md md:px-5 md:py-4">
      {/* Header */}
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-white/5 pb-3">
        <button
          type="button"
          onClick={() => setOpen((v) => !v)}
          className="text-left text-lg font-semibold tracking-wide text-orange-400"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
          aria-expanded={open}
        >
          {title}
        </button>

        <div className="flex flex-wrap items-center gap-2">
          <span
            className="hidden text-[11px] uppercase tracking-wide text-neutral-400 md:inline"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {stats.ok} OK · {stats.fail} FAIL · {stats.na} NA ·{" "}
            {stats.recommend} REC · {stats.unset} —
          </span>

          <div className="flex flex-wrap items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("ok")}
            >
              All OK
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("fail")}
            >
              All FAIL
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("na")}
            >
              All NA
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("recommend")}
            >
              All REC
            </Button>

            <Button
              variant="ghost"
              size="sm"
              className="ml-1 h-7 px-2 text-[11px]"
              type="button"
              onClick={() => setOpen((v) => !v)}
              aria-expanded={open}
              title={open ? "Collapse section" : "Expand section"}
            >
              {open ? "Collapse" : "Expand"}
            </Button>
          </div>
        </div>
      </div>

      {/* Body */}
      {open && (
        <div className="space-y-3 pt-3">
          {section.items.map((item, itemIndex) => {
            const keyBase =
              item.item ?? item.name ?? `item-${sectionIndex}-${itemIndex}`;

            const status = (item.status ?? "").toString().toLowerCase();
            const note = (item.notes ?? "").toString();
            const photoUrls = (item.photoUrls ?? []) as string[];

            return (
              <div
                key={`${keyBase}-${itemIndex}`}
                className="rounded-xl border border-white/5 bg-black/40 p-3 md:p-3.5"
              >
                {/* Top row: label + status buttons */}
                <div className="flex flex-wrap items-center justify-between gap-2">
                  <div className="min-w-0 flex-1 text-sm font-medium text-white">
                    {item.item ?? item.name ?? "Item"}
                  </div>

                  <div className="flex flex-wrap items-center gap-1">
                    {(["ok", "fail", "na", "recommend"] as const).map(
                      (s) => (
                        <Button
                          key={s}
                          type="button"
                          size="sm"
                          variant={
                            (status as InspectionItemStatus) === s
                              ? "orange"
                              : "outline"
                          }
                          className="h-7 px-2 text-[11px]"
                          onClick={() =>
                            onUpdateStatus(
                              sectionIndex,
                              itemIndex,
                              s as InspectionItemStatus,
                            )
                          }
                        >
                          {s.toUpperCase()}
                        </Button>
                      ),
                    )}
                  </div>
                </div>

                {/* Measurement + notes/photos */}
                <div className="mt-2 space-y-2 text-xs text-neutral-200">
                  <div className="flex flex-wrap items-center gap-2">
                    <span className="text-neutral-400">Value:</span>
                    <span>
                      {item.value ?? "—"}
                      {item.unit ? ` ${item.unit}` : ""}
                    </span>
                  </div>

                  {showNotes && (
                    <div className="space-y-1">
                      <div className="text-neutral-400">Notes</div>
                      <textarea
                        className="min-h-[60px] w-full rounded-md border border-white/10 bg-black/40 px-2 py-1 text-xs text-white outline-none focus:border-orange-400 focus:ring-1 focus:ring-orange-400"
                        value={note}
                        onChange={(e) =>
                          onUpdateNote(
                            sectionIndex,
                            itemIndex,
                            e.currentTarget.value,
                          )
                        }
                      />
                    </div>
                  )}

                  {showPhotos && (
                    <div className="space-y-1">
                      <div className="flex items-center justify-between text-neutral-400">
                        <span>Photos ({photoUrls.length})</span>
                        {/* hook up to actual uploader later */}
                        <Button
                          type="button"
                          size="xs"
                          variant="outline"
                          className="h-6 px-2 text-[10px]"
                          onClick={() => {
                            const dummyUrl = window.prompt(
                              "Photo URL (stub for now)",
                            );
                            if (!dummyUrl) return;
                            onUpload(dummyUrl, sectionIndex, itemIndex);
                          }}
                        >
                          + Add
                        </Button>
                      </div>

                      {photoUrls.length > 0 && (
                        <div className="flex flex-wrap gap-2">
                          {photoUrls.map((url) => (
                            <div
                              key={url}
                              className="h-12 w-12 overflow-hidden rounded border border-white/10 bg-neutral-900"
                            >
                              {/* eslint-disable-next-line @next/next/no-img-element */}
                              <img
                                src={url}
                                alt="Inspection"
                                className="h-full w-full object-cover"
                              />
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}
=============== Axle Grid ===============
"use client";


import type { InspectionItem } from "@inspections/lib/inspection/types";

type GridUnitMode = "metric" | "imperial";
type Side = "left" | "right";
type Variant = "main" | "inner" | "outer";

interface AxleGridProps {
  title?: string;
  sectionIndex: number;
  items: InspectionItem[];
  unitMode: GridUnitMode;
  showKpaHint: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
  onAddAxle?: () => void;
}

interface AxleCell {
  itemIndex: number;
  item: InspectionItem;
}

interface AxleSideInputs {
  main?: AxleCell;
  inner?: AxleCell;
  outer?: AxleCell;
}

interface AxleMetricRow {
  metricKey: string;
  metricLabel: string;
  left: AxleSideInputs;
  right: AxleSideInputs;
}

interface AxleBlock {
  axleName: string;
  rows: AxleMetricRow[];
}

interface ParsedAirLabel {
  axle: string;
  side: Side;
  variant: Variant;
  metric: string;
  metricBase: string;
}

function normaliseMetric(metric: string): string {
  return metric
    .replace(/\(\s*(inner|outer)\s*\)/gi, "")
    .replace(/\b(inner|outer)\b/gi, "")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/**
 * Supported label shapes:
 *  - "Steer Left Tire Pressure"
 *  - "Drive 1 Right Inner Tire Tread"
 *  - "Drive 2 LRI Pushrod Travel"
 *  - "Trailer 1 RRO Drum / Rotor Thickness"
 */
function parseAirLabel(labelRaw: string): ParsedAirLabel | null {
  const label = labelRaw.trim();
  if (!label) return null;

  // Abbreviation: "<axle> <code> <metric>"
  const abbrMatch = label.match(
    /^(?<axle>.+?)\s+(?<code>LRI|LRO|RRI|RRO|LF|RF|LR|RR)\s+(?<metric>.+)$/i,
  );
  if (abbrMatch && abbrMatch.groups) {
    const axle = abbrMatch.groups.axle.trim();
    const code = abbrMatch.groups.code.toUpperCase();
    const metric = abbrMatch.groups.metric.trim();
    if (!axle || !metric) return null;

    const side: Side = code.startsWith("L") ? "left" : "right";
    let variant: Variant = "main";
    if (code.endsWith("I")) variant = "inner";
    if (code.endsWith("O")) variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      axle,
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  // Text form: "<axle> Left [Inner|Outer] Metric..."
  const textMatch = label.match(
    /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?:(?<io>Inner|Outer)\s+)?(?<metric>.+)$/i,
  );
  if (textMatch && textMatch.groups) {
    const axle = textMatch.groups.axle.trim();
    const side: Side =
      textMatch.groups.side.toLowerCase() === "left" ? "left" : "right";
    const ioRaw = (textMatch.groups.io ?? "").toLowerCase();
    const metric = textMatch.groups.metric.trim();
    if (!axle || !metric) return null;

    let variant: Variant = "main";
    if (ioRaw === "inner") variant = "inner";
    if (ioRaw === "outer") variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      axle,
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  return null;
}

function buildAxles(items: InspectionItem[]): {
  axles: AxleBlock[];
  loose: Array<{ itemIndex: number; item: InspectionItem }>;
} {
  const perAxle = new Map<string, Map<string, AxleMetricRow>>();
  const loose: Array<{ itemIndex: number; item: InspectionItem }> = [];

  items.forEach((item, idx) => {
    const label = item.item ?? item.name ?? "";
    const parsed = parseAirLabel(label);
    if (!parsed) {
      loose.push({ itemIndex: idx, item });
      return;
    }

    const axleMap =
      perAxle.get(parsed.axle) ?? new Map<string, AxleMetricRow>();

    const existingRow =
      axleMap.get(parsed.metricBase) ??
      ({
        metricKey: parsed.metricBase,
        metricLabel: parsed.metricBase,
        left: {},
        right: {},
      } as AxleMetricRow);

    const cell: AxleCell = { itemIndex: idx, item };

    if (parsed.side === "left") {
      existingRow.left[parsed.variant] = cell;
    } else {
      existingRow.right[parsed.variant] = cell;
    }

    axleMap.set(parsed.metricBase, existingRow);
    perAxle.set(parsed.axle, axleMap);
  });

  const axles: AxleBlock[] = Array.from(perAxle.entries()).map(
    ([axleName, rowsMap]) => ({
      axleName,
      rows: Array.from(rowsMap.values()),
    }),
  );

  return { axles, loose };
}

function getUnitLabel(metricLabel: string, unitMode: GridUnitMode): string {
  const lower = metricLabel.toLowerCase();

  // Air pressure always psi, regardless of unit toggle.
  if (lower.includes("pressure")) return "psi";

  // Pushrod travel / drum / rotor / shoe thickness etc.
  if (
    lower.includes("tread") ||
    lower.includes("pad") ||
    lower.includes("shoe") ||
    lower.includes("drum") ||
    lower.includes("rotor") ||
    lower.includes("thickness") ||
    lower.includes("pushrod") ||
    lower.includes("push-rod") ||
    lower.includes("push rod")
  ) {
    return unitMode === "metric" ? "mm" : "in";
  }

  return unitMode === "metric" ? "mm" : "in";
}

interface ValueInputProps {
  value: string | number | null | undefined;
  unit: string;
  showKpaHint?: boolean;
  isPressure?: boolean;
  onChange: (next: string) => void;
}

const ValueInput: React.FC<ValueInputProps> = ({
  value,
  unit,
  showKpaHint,
  isPressure,
  onChange,
}) => {
  const display = value ?? "";

  return (
    <div className="flex items-center gap-2 rounded-xl border border-[color:var(--metal-border-soft)] bg-black/70 px-3 py-1.5 text-xs shadow-[0_10px_25px_rgba(0,0,0,0.9)] backdrop-blur-md">
      <input
        type="number"
        inputMode="decimal"
        className="w-full bg-transparent text-sm text-white placeholder:text-neutral-500 focus:outline-none"
        placeholder="Value"
        value={display}
        onChange={(e) => onChange(e.target.value)}
      />
      <div className="flex flex-col items-end text-[10px] leading-tight text-neutral-400">
        <span>{unit}</span>
        {isPressure && showKpaHint && (
          <span className="text-[9px] text-neutral-500">kPa hint</span>
        )}
      </div>
    </div>
  );
};

interface SideStackProps {
  sideLabel: string; // "Left" / "Right"
  side: AxleSideInputs;
  sectionIndex: number;
  unit: string;
  isPressure: boolean;
  showKpaHint: boolean;
  alignRight?: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

const SideStack: React.FC<SideStackProps> = ({
  sideLabel,
  side,
  sectionIndex,
  unit,
  isPressure,
  showKpaHint,
  alignRight = false,
  onUpdateItem,
}) => {
  const pieces: Array<{ key: string; caption: string; cell: AxleCell }> = [];

  if (side.main) {
    pieces.push({ key: "main", caption: sideLabel, cell: side.main });
  }
  if (side.outer) {
    pieces.push({
      key: "outer",
      caption: `${sideLabel} Outer`,
      cell: side.outer,
    });
  }
  if (side.inner) {
    pieces.push({
      key: "inner",
      caption: `${sideLabel} Inner`,
      cell: side.inner,
    });
  }

  if (!pieces.length) return null;

  return (
    <div className="space-y-1 sm:max-w-[40%]">
      {pieces.map(({ key, caption, cell }) => (
        <div key={key} className="space-y-1">
          <div
            className={`text-[11px] font-medium uppercase tracking-[0.18em] text-neutral-400 ${
              alignRight ? "text-right" : ""
            }`}
          >
            {caption}
          </div>
          <ValueInput
            value={cell.item.value}
            unit={unit}
            isPressure={isPressure}
            showKpaHint={isPressure && showKpaHint}
            onChange={(next) =>
              onUpdateItem(sectionIndex, cell.itemIndex, { value: next })
            }
          />
        </div>
      ))}
    </div>
  );
};

const AxleGrid: React.FC<AxleGridProps> = ({
  title,
  sectionIndex,
  items,
  unitMode,
  showKpaHint,
  onUpdateItem,
  onAddAxle,
}) => {
  const { axles, loose } = buildAxles(items);

  if (axles.length === 0 && loose.length === 0) return null;

  return (
    <section className="space-y-4">
      <div className="flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title ?? "Axle Measurements (Air Brake)"}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Steer, drive, and trailer axles – tire pressure, tread depth,
            push-rod travel, drum/rotor, pads/shoes. Values only.
          </p>
        </div>
        {onAddAxle && (
          <button
            type="button"
            onClick={onAddAxle}
            className="rounded-full bg-[color:var(--accent-copper)] px-3 py-1.5 text-[11px] font-semibold text-black shadow-[0_0_20px_rgba(193,102,59,0.75)] hover:bg-[color:var(--accent-copper-soft)]"
          >
            + Add axle
          </button>
        )}
      </div>

      <div className="space-y-4">
        {axles.map((axle) => (
          <div
            key={axle.axleName}
            className="metal-card rounded-2xl p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)]"
          >
            <div className="mb-3 flex items-center justify-between gap-2">
              <div className="text-xs font-semibold uppercase tracking-[0.18em] text-neutral-400">
                {axle.axleName}
              </div>
            </div>

            {/* Desktop header */}
            <div className="hidden text-[11px] text-neutral-400 sm:grid sm:grid-cols-[minmax(0,1fr)_minmax(0,2fr)_minmax(0,1fr)] sm:gap-2 sm:border-t sm:border-white/10 sm:pt-2">
              <div className="px-2 py-1">Left</div>
              <div className="px-2 py-1 text-center">Item</div>
              <div className="px-2 py-1 text-right">Right</div>
            </div>

            <div className="space-y-3 pt-1">
              {axle.rows.map((row) => {
                const unit = getUnitLabel(row.metricLabel, unitMode);
                const isPressure =
                  row.metricLabel.toLowerCase().includes("pressure");

                return (
                  <div
                    key={row.metricKey}
                    className="rounded-xl border border-white/10 bg-black/65 p-3 backdrop-blur-md"
                  >
                    <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
                      <SideStack
                        sideLabel="Left"
                        side={row.left}
                        sectionIndex={sectionIndex}
                        unit={unit}
                        isPressure={isPressure}
                        showKpaHint={showKpaHint}
                        onUpdateItem={onUpdateItem}
                      />

                      <div className="flex-1 text-center text-sm font-medium text-neutral-100">
                        {row.metricLabel}
                      </div>

                      <SideStack
                        sideLabel="Right"
                        side={row.right}
                        sectionIndex={sectionIndex}
                        unit={unit}
                        isPressure={isPressure}
                        showKpaHint={showKpaHint}
                        alignRight
                        onUpdateItem={onUpdateItem}
                      />
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ))}
      </div>

      {loose.length > 0 && (
        <div className="rounded-xl border border-amber-500/30 bg-amber-950/30 p-3 text-[11px] text-amber-100">
          <div className="mb-1 font-semibold tracking-wide">
            Other axle measurements
          </div>
          <div className="space-y-2">
            {loose.map(({ item, itemIndex }) => {
              const label = item.item ?? item.name ?? "Item";
              const unit = getUnitLabel(label, unitMode);
              const isPressure = label.toLowerCase().includes("pressure");

              return (
                <div key={itemIndex} className="space-y-1">
                  <div className="text-[11px] text-amber-100/80">
                    {label}
                  </div>
                  <ValueInput
                    value={item.value}
                    unit={unit}
                    isPressure={isPressure}
                    showKpaHint={showKpaHint}
                    onChange={(next) =>
                      onUpdateItem(sectionIndex, itemIndex, { value: next })
                    }
                  />
                </div>
              );
            })}
          </div>
        </div>
      )}
    </section>
  );
};

export default AxleGrid;
=============== Battery Grid ===============
"use client";



export interface BatteryMeasurement {
  label: string;
  factoryCca: number | null;
  testedCca: number | null;
  notes?: string;
}

interface BatteryGridProps {
  title?: string;
  batteries: BatteryMeasurement[];
  onChange: (index: number, patch: Partial<BatteryMeasurement>) => void;
  onAddBattery: () => void;
  onRemoveBattery?: (index: number) => void;
}

const BatteryGrid: React.FC<BatteryGridProps> = ({
  title = "Battery Measurements",
  batteries,
  onChange,
  onAddBattery,
  onRemoveBattery,
}) => {
  return (
    <section className="metal-card rounded-2xl p-4 sm:p-5">
      <div className="mb-3 flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Capture factory and tested CCA for each battery. Values only – any
            FAIL / RECOMMEND status is handled in the main inspection sections.
          </p>
        </div>
        <button
          type="button"
          onClick={onAddBattery}
          className="rounded-full bg-[color:var(--accent-copper)] px-3 py-1.5 text-[11px] font-semibold text-black shadow-[0_0_20px_rgba(193,102,59,0.75)] hover:bg-[color:var(--accent-copper-soft)]"
        >
          + Add battery
        </button>
      </div>

      {batteries.length === 0 ? (
        <p className="text-xs text-neutral-400">
          No batteries added yet. Use “Add battery” to start.
        </p>
      ) : (
        <div className="space-y-3">
          {batteries.map((batt, idx) => (
            <div
              key={idx}
              className="rounded-xl border border-white/10 bg-black/65 p-3 shadow-[0_12px_30px_rgba(0,0,0,0.9)] backdrop-blur-md"
            >
              <div className="mb-2 flex items-center justify-between gap-2">
                <div className="flex flex-col">
                  <span className="text-[11px] font-semibold uppercase tracking-[0.18em] text-neutral-400">
                    Battery {idx + 1}
                  </span>
                  <input
                    type="text"
                    className="mt-1 w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="Location / label (Start, Aux, LH, RH...)"
                    value={batt.label}
                    onChange={(e) =>
                      onChange(idx, { label: e.target.value })
                    }
                  />
                </div>

                {onRemoveBattery && batteries.length > 1 && (
                  <button
                    type="button"
                    onClick={() => onRemoveBattery(idx)}
                    className="rounded-full border border-red-500/70 px-2 py-1 text-[10px] font-medium text-red-100 hover:bg-red-500/10"
                  >
                    Remove
                  </button>
                )}
              </div>

              <div className="grid gap-3 text-xs sm:grid-cols-3">
                <div className="space-y-1">
                  <div className="text-[11px] text-neutral-400">
                    Factory CCA
                  </div>
                  <input
                    type="number"
                    inputMode="numeric"
                    className="w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="e.g. 750"
                    value={batt.factoryCca ?? ""}
                    onChange={(e) =>
                      onChange(idx, {
                        factoryCca:
                          e.target.value === ""
                            ? null
                            : Number(e.target.value),
                      })
                    }
                  />
                </div>

                <div className="space-y-1">
                  <div className="text-[11px] text-neutral-400">
                    Tested CCA
                  </div>
                  <input
                    type="number"
                    inputMode="numeric"
                    className="w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="e.g. 680"
                    value={batt.testedCca ?? ""}
                    onChange={(e) =>
                      onChange(idx, {
                        testedCca:
                          e.target.value === ""
                            ? null
                            : Number(e.target.value),
                      })
                    }
                  />
                </div>

                <div className="space-y-1 sm:col-span-1">
                  <div className="text-[11px] text-neutral-400">Notes</div>
                  <textarea
                    rows={2}
                    className="w-full resize-none rounded border border-white/15 bg-black/40 px-2 py-1 text-xs text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="Additional info (age, location, condition...)"
                    value={batt.notes ?? ""}
                    onChange={(e) =>
                      onChange(idx, { notes: e.target.value })
                    }
                  />
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </section>
  );
};

export default BatteryGrid;
=============== Corner Grid ===============
"use client";


import type { InspectionItem } from "@inspections/lib/inspection/types";

type GridUnitMode = "metric" | "imperial";
type Side = "left" | "right";
type Variant = "main" | "inner" | "outer";

interface CornerGridProps {
  title?: string;
  sectionIndex: number;
  items: InspectionItem[];
  unitMode: GridUnitMode;
  showKpaHint: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

interface CornerCell {
  itemIndex: number;
  item: InspectionItem;
}

interface CornerSideInputs {
  main?: CornerCell; // LF / RF / LR / RR
  inner?: CornerCell; // LRI / RRI
  outer?: CornerCell; // LRO / RRO
}

interface CornerRow {
  metricKey: string;
  metricLabel: string;
  left: CornerSideInputs;
  right: CornerSideInputs;
}

interface ParsedHydLocation {
  side: Side;
  variant: Variant;
  metric: string;
  metricBase: string;
}

/**
 * Remove "Inner" / "Outer" markup from a metric to group rows,
 * e.g. "Tire Tread (Outer)" + "Tire Tread (Inner)" → "Tire Tread".
 */
function normaliseMetric(metric: string): string {
  return metric
    .replace(/\(\s*(inner|outer)\s*\)/gi, "")
    .replace(/\b(inner|outer)\b/gi, "")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/**
 * Support:
 *  - "LF Tire Pressure"
 *  - "RRI Brake Pad Thickness"
 *  - "Left Front Tire Tread"
 *  - "Right Rear Inner Tire Tread (Outer)"
 */
function parseHydLabel(labelRaw: string): ParsedHydLocation | null {
  const label = labelRaw.trim();
  if (!label) return null;

  // Abbreviated location codes
  const abbrMatch = label.match(
    /^(LF|RF|LR|RR|LRI|LRO|RRI|RRO)\s+(.+)$/i,
  );
  if (abbrMatch) {
    const code = abbrMatch[1].toUpperCase();
    const metric = abbrMatch[2].trim();
    if (!metric) return null;

    const side: Side = code.startsWith("L") ? "left" : "right";
    let variant: Variant = "main";

    if (code.endsWith("I")) variant = "inner";
    if (code.endsWith("O")) variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  // Full text – e.g. "Left Rear Inner Tire Tread"
  const fullMatch = label.match(
    /^(Left|Right)\s+(Front|Rear)(?:\s+(Inner|Outer))?\s+(.+)$/i,
  );
  if (fullMatch) {
    const side: Side = fullMatch[1].toLowerCase() === "left" ? "left" : "right";
    const innerOuter = (fullMatch[3] ?? "").toLowerCase();
    const metric = fullMatch[4].trim();
    if (!metric) return null;

    let variant: Variant = "main";
    if (innerOuter === "inner") variant = "inner";
    if (innerOuter === "outer") variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  return null;
}

function buildRows(items: InspectionItem[]): {
  rows: CornerRow[];
  loose: Array<{ itemIndex: number; item: InspectionItem }>;
} {
  const rowsMap = new Map<string, CornerRow>();
  const loose: Array<{ itemIndex: number; item: InspectionItem }> = [];

  items.forEach((item, idx) => {
    const label = item.item ?? item.name ?? "";
    const parsed = parseHydLabel(label);
    if (!parsed) {
      loose.push({ itemIndex: idx, item });
      return;
    }

    const existing =
      rowsMap.get(parsed.metricBase) ??
      ({
        metricKey: parsed.metricBase,
        metricLabel: parsed.metricBase,
        left: {},
        right: {},
      } as CornerRow);

    const cell: CornerCell = { itemIndex: idx, item };

    if (parsed.side === "left") {
      existing.left[parsed.variant] = cell;
    } else {
      existing.right[parsed.variant] = cell;
    }

    rowsMap.set(parsed.metricBase, existing);
  });

  return { rows: Array.from(rowsMap.values()), loose };
}

function getUnitLabel(metricLabel: string, unitMode: GridUnitMode): string {
  const lower = metricLabel.toLowerCase();

  // Pressure is always psi – unit toggle does not affect this.
  if (lower.includes("pressure")) return "psi";

  // Everything else here is a length/thickness-style measurement.
  if (
    lower.includes("tread") ||
    lower.includes("pad") ||
    lower.includes("rotor") ||
    lower.includes("thickness")
  ) {
    return unitMode === "metric" ? "mm" : "in";
  }

  return unitMode === "metric" ? "mm" : "in";
}

interface ValueInputProps {
  value: string | number | null | undefined;
  unit: string;
  showKpaHint?: boolean;
  isPressure?: boolean;
  placeholder?: string;
  onChange: (next: string) => void;
}

const ValueInput: React.FC<ValueInputProps> = ({
  value,
  unit,
  showKpaHint,
  isPressure,
  placeholder = "Value",
  onChange,
}) => {
  const display = value ?? "";

  return (
    <div className="flex items-center gap-2 rounded-xl border border-[color:var(--metal-border-soft)] bg-black/70 px-3 py-1.5 text-xs shadow-[0_10px_25px_rgba(0,0,0,0.9)] backdrop-blur-md">
      <input
        type="number"
        inputMode="decimal"
        className="w-full bg-transparent text-sm text-white placeholder:text-neutral-500 focus:outline-none"
        placeholder={placeholder}
        value={display}
        onChange={(e) => onChange(e.target.value)}
      />
      <div className="flex flex-col items-end text-[10px] leading-tight text-neutral-400">
        <span>{unit}</span>
        {isPressure && showKpaHint && (
          <span className="text-[9px] text-neutral-500">kPa hint</span>
        )}
      </div>
    </div>
  );
};

interface SideStackProps {
  label: string;
  side: CornerSideInputs;
  sectionIndex: number;
  unit: string;
  isPressure: boolean;
  showKpaHint: boolean;
  alignRight?: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

const SideStack: React.FC<SideStackProps> = ({
  label,
  side,
  sectionIndex,
  unit,
  isPressure,
  showKpaHint,
  alignRight = false,
  onUpdateItem,
}) => {
  const pieces: Array<{ key: string; caption: string; cell: CornerCell }> = [];

  if (side.main) {
    pieces.push({ key: "main", caption: label, cell: side.main });
  }
  if (side.outer) {
    pieces.push({ key: "outer", caption: `${label} Outer`, cell: side.outer });
  }
  if (side.inner) {
    pieces.push({ key: "inner", caption: `${label} Inner`, cell: side.inner });
  }

  if (!pieces.length) return null;

  return (
    <div className="space-y-1 sm:max-w-[40%]">
      {pieces.map(({ key, caption, cell }) => (
        <div key={key} className="space-y-1">
          <div
            className={`text-[11px] font-medium uppercase tracking-[0.18em] text-neutral-400 ${
              alignRight ? "text-right" : ""
            }`}
          >
            {caption}
          </div>
          <ValueInput
            value={cell.item.value}
            unit={unit}
            isPressure={isPressure}
            showKpaHint={isPressure && showKpaHint}
            onChange={(next) =>
              onUpdateItem(sectionIndex, cell.itemIndex, { value: next })
            }
          />
        </div>
      ))}
    </div>
  );
};

const CornerGrid: React.FC<CornerGridProps> = ({
  title,
  sectionIndex,
  items,
  unitMode,
  showKpaHint,
  onUpdateItem,
}) => {
  const { rows, loose } = buildRows(items);

  if (rows.length === 0 && loose.length === 0) return null;

  return (
    <section className="metal-card rounded-2xl p-4 sm:p-5">
      <div className="mb-3 flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title ?? "Measurements (Hydraulic)"}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Corner-based measurements: tire pressure, tread depth, pad / rotor
            thickness. Values only – statuses live in other sections.
          </p>
        </div>
      </div>

      {/* Desktop header */}
      <div className="hidden text-[11px] text-neutral-400 sm:grid sm:grid-cols-[minmax(0,1fr)_minmax(0,2fr)_minmax(0,1fr)] sm:gap-2 sm:border-t sm:border-white/10 sm:pt-3">
        <div className="px-2 py-1">Left</div>
        <div className="px-2 py-1 text-center">Item</div>
        <div className="px-2 py-1 text-right">Right</div>
      </div>

      <div className="space-y-3 pt-1">
        {rows.map((row) => {
          const unit = getUnitLabel(row.metricLabel, unitMode);
          const isPressure = row.metricLabel.toLowerCase().includes("pressure");

          return (
            <div
              key={row.metricKey}
              className="rounded-xl border border-white/10 bg-black/60 p-3 shadow-[0_12px_30px_rgba(0,0,0,0.9)] backdrop-blur-md"
            >
              <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
                <SideStack
                  label="Left"
                  side={row.left}
                  sectionIndex={sectionIndex}
                  unit={unit}
                  isPressure={isPressure}
                  showKpaHint={showKpaHint}
                  onUpdateItem={onUpdateItem}
                />

                <div className="flex-1 text-center text-sm font-medium text-neutral-100">
                  {row.metricLabel}
                </div>

                <SideStack
                  label="Right"
                  side={row.right}
                  sectionIndex={sectionIndex}
                  unit={unit}
                  isPressure={isPressure}
                  showKpaHint={showKpaHint}
                  alignRight
                  onUpdateItem={onUpdateItem}
                />
              </div>
            </div>
          );
        })}
      </div>

      {loose.length > 0 && (
        <div className="mt-4 rounded-xl border border-amber-500/30 bg-amber-950/30 p-3 text-[11px] text-amber-100">
          <div className="mb-1 font-semibold tracking-wide">
            Other measurements
          </div>
          <div className="space-y-2">
            {loose.map(({ item, itemIndex }) => {
              const label = item.item ?? item.name ?? "Item";
              const unit = getUnitLabel(label, unitMode);
              const isPressure = label.toLowerCase().includes("pressure");

              return (
                <div key={itemIndex} className="space-y-1">
                  <div className="text-[11px] text-amber-100/80">
                    {label}
                  </div>
                  <ValueInput
                    value={item.value}
                    unit={unit}
                    isPressure={isPressure}
                    showKpaHint={showKpaHint}
                    onChange={(next) =>
                      onUpdateItem(sectionIndex, itemIndex, { value: next })
                    }
                  />
                </div>
              );
            })}
          </div>
        </div>
      )}
    </section>
  );
};

export default CornerGrid;
=============== Unified Screen (current) ===============
// features/inspections/unified/ui/InspectionUnifiedScreen.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { v4 as uuidv4 } from "uuid";
import { toast } from "sonner";

import type {
  InspectionSession,
  InspectionSection,
  InspectionItemStatus,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import SectionRenderer from "./SectionRenderer";
import VoiceInspectionController from "../voice/VoiceInspectionController";

// Simple helpers for progress + filtering
function countItems(sections: InspectionSection[]): {
  total: number;
  completed: number;
} {
  let total = 0;
  let completed = 0;
  for (const s of sections) {
    for (const it of s.items ?? []) {
      total += 1;
      const status = String(it.status ?? "").toLowerCase();
      if (status === "ok" || status === "fail" || status === "na" || status === "recommend") {
        completed += 1;
      }
    }
  }
  return { total, completed };
}

type Props = {
  session: InspectionSession;
  onUpdateSession: (patch: Partial<InspectionSession>) => void;
};

export default function InspectionUnifiedScreen({
  session,
  onUpdateSession,
}: Props) {
  const [unitMode, setUnitMode] = useState<"metric" | "imperial">("metric");
  const [buildingQuote, setBuildingQuote] = useState(false);

  // Track in-flight AI requests by "secIdx:itemIdx"
  const inflightRef = useRef<Set<string>>(new Set());

  const { total, completed } = useMemo(
    () => countItems(session.sections ?? []),
    [session.sections],
  );

  const workOrderId = session.workOrderId ?? undefined;

  // --- low-level helpers ----------------------------------------------------

  const updateSections = (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionSection["items"][number]>,
  ) => {
    const currentSections = session.sections ?? [];
    if (!currentSections[sectionIndex]) return;

    const nextSections = [...currentSections];
    const items = [...(nextSections[sectionIndex].items ?? [])];
    if (!items[itemIndex]) return;

    items[itemIndex] = { ...items[itemIndex], ...patch };
    nextSections[sectionIndex] = {
      ...nextSections[sectionIndex],
      items,
    };

    onUpdateSession({ sections: nextSections });
  };

  const updateQuoteLine = (id: string, patch: Partial<QuoteLineItem>) => {
    const existing = (session.quote ?? []) as QuoteLineItem[];
    const next = existing.map((line) =>
      line.id === id ? { ...line, ...patch } : line,
    );
    onUpdateSession({ quote: next });
  };

  const pushQuoteLine = (line: QuoteLineItem) => {
    const existing = (session.quote ?? []) as QuoteLineItem[];
    onUpdateSession({ quote: [...existing, line] });
  };

  // --- AI quote + work-order + parts request -------------------------------

  const buildQuoteForItem = async (
    sectionIndex: number,
    itemIndex: number,
  ): Promise<void> => {
    const key = `${sectionIndex}:${itemIndex}`;
    if (inflightRef.current.has(key)) return;

    const section = session.sections?.[sectionIndex];
    const it = section?.items?.[itemIndex];
    if (!section || !it) return;

    const status = String(it.status ?? "").toLowerCase() as InspectionItemStatus;
    const note = (it.notes ?? "").trim();
    if (!(status === "fail" || status === "recommend")) return;
    if (!note) {
      toast.error("Add a note before submitting this item for estimate.");
      return;
    }

    inflightRef.current.add(key);

    const description =
      it.item ?? it.name ?? section.title ?? "Inspection item";

    const id = uuidv4();
    const placeholder: QuoteLineItem = {
      id,
      description,
      item: description,
      name: description,
      inspectionItem: description,
      status,
      notes: it.notes ?? "",
      price: 0,
      laborHours: 0.5,
      laborRate: 0,
      editable: true,
      source: "inspection",
      value: it.value ?? null,
      photoUrls: it.photoUrls ?? [],
      aiState: "loading",
    };

    pushQuoteLine(placeholder);

    try {
      const tId = toast.loading("Getting AI estimate…");

      const suggestion = await requestQuoteSuggestion({
        item: description,
        notes: it.notes ?? "",
        section: section.title,
        status,
        value: it.value != null ? String(it.value) : undefined,
        unit: it.unit ?? undefined,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available.", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborHours = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborHours);

      updateQuoteLine(id, {
        price,
        laborHours,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      let jobId: string | undefined;

      // Create a work-order line if we know the work order id
      if (workOrderId) {
        const res = await addWorkOrderLineFromSuggestion({
          workOrderId,
          description,
          section: section.title,
          status,
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });

        jobId = res.id;
      }

      // Also send a parts request if we have both work order + job id
      if (workOrderId && jobId && suggestion.parts?.length) {
        try {
          const items = suggestion.parts.map((p) => ({
            description: p.name || "Part",
            qty: p.qty && p.qty > 0 ? p.qty : 1,
          }));

          const res = await fetch("/api/parts/requests/create", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              workOrderId,
              jobId,
              notes: suggestion.summary || undefined,
              items,
            }),
          });

          const raw = await res.text();
          let json: { requestId?: string; error?: string } | null = null;
          try {
            json = raw ? (JSON.parse(raw) as any) : null;
          } catch {
            /* ignore parse error; fall through */
          }

          if (!res.ok || !json?.requestId) {
            const msg = json?.error || raw || `status ${res.status}`;
            console.warn("Parts request failed:", msg);
          }
        } catch (err) {
          console.warn("Parts request error:", err);
        }
      }

      toast.success("Estimate generated.", { id: tId });
    } catch (err) {
      console.error("AI quote error:", err);
      updateQuoteLine(id, { aiState: "error" });
      toast.error("Couldn't generate estimate.");
    } finally {
      inflightRef.current.delete(key);
    }
  };

  const buildQuotesForAll = async () => {
    if (!session.sections?.length) return;
    if (buildingQuote) return;

    setBuildingQuote(true);

    try {
      for (let sIdx = 0; sIdx < session.sections.length; sIdx += 1) {
        const sec = session.sections[sIdx];
        for (let iIdx = 0; iIdx < (sec.items?.length ?? 0); iIdx += 1) {
          const it = sec.items[iIdx];
          const status = String(it.status ?? "").toLowerCase();
          if (
            (status === "fail" || status === "recommend") &&
            (it.notes ?? "").trim().length > 0
          ) {
            // eslint-disable-next-line no-await-in-loop
            await buildQuoteForItem(sIdx, iIdx);
          }
        }
      }
    } finally {
      setBuildingQuote(false);
    }
  };

  // --------------------------------------------------------------------------

  const hasSections = (session.sections?.length ?? 0) > 0;

  return (
    <div className="flex flex-col gap-4">
      {/* Header */}
      <div className="flex flex-col gap-1 border-b border-white/10 pb-3">
        <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
          Unified Inspection
        </div>
        <div className="flex flex-wrap items-baseline justify-between gap-2">
          <h1 className="text-xl font-blackops text-white">
            {session.templateName || session.templateitem || "Inspection"}
          </h1>
          {hasSections && (
            <div className="text-xs text-neutral-400">
              {completed}/{total} items marked
            </div>
          )}
        </div>
        <div className="flex flex-wrap items-center gap-2 text-[11px] text-neutral-500">
          <span>
            Work order:{" "}
            <span className="font-mono text-neutral-300">
              {session.workOrderId || "—"}
            </span>
          </span>
          <span className="mx-1 text-neutral-600">•</span>
          <button
            type="button"
            className="rounded-full border border-white/15 bg-black/60 px-2 py-0.5 text-[10px] uppercase tracking-[0.16em] text-neutral-200 hover:border-orange-400 hover:text-orange-300"
            onClick={() =>
              setUnitMode((m) => (m === "metric" ? "imperial" : "metric"))
            }
          >
            Units:{" "}
            {unitMode === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
          </button>
        </div>
      </div>

      {/* Voice controller (new unified stack) */}
      <VoiceInspectionController
        session={session}
        onUpdateSession={onUpdateSession}
      />

      {/* Main sections */}
      <SectionRenderer
        sections={session.sections ?? []}
        // minimal contract: SectionRenderer owns layout (corner grids, batteries, etc)
        onUpdateItem={updateSections}
      />

      {/* Footer actions */}
      <div className="mt-4 flex flex-col gap-3 border-t border-white/10 pt-3 text-xs text-neutral-400 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-2">
          <button
            type="button"
            disabled={buildingQuote}
            onClick={buildQuotesForAll}
            className="inline-flex items-center gap-1 rounded-full border border-orange-500/70 bg-orange-500/10 px-3 py-1.5 text-[11px] font-semibold uppercase tracking-[0.18em] text-orange-200 hover:bg-orange-500/20 disabled:opacity-50"
          >
            {buildingQuote ? "Building estimates…" : "Build estimates for FAIL / REC"}
          </button>
          {!workOrderId && (
            <span className="text-[11px] text-red-300">
              Work order id missing – new jobs & parts requests will not be created.
            </span>
          )}
        </div>

        <div className="text-[11px] text-neutral-500 md:text-right">
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable &nbsp;•&nbsp;
          REC = Recommend
        </div>
      </div>
    </div>
  );
}
=============== Voice Inspection Controller ===============
"use client";

import { useCallback, useEffect, useRef, useState } from "react";
import type { InspectionSession } from "@inspections/lib/inspection/types";

import { interpretTranscript } from "./interpretTranscript";
import { applyVoiceCommands } from "./commandMapper";

type Props = {
  session: InspectionSession;
  onUpdateSession: (patch: Partial<InspectionSession>) => void;
};

/**
 * Simple browser SpeechRecognition fallback for now.
 * You already use OpenAI Realtime elsewhere – once you paste me that file,
 * I will replace this stub with the full Hey-Techy Realtime pipeline.
 */
export default function VoiceInspectionController({
  session,
  onUpdateSession,
}: Props) {
  // UI state only — must be "used"
  const [isListening, setIsListening] = useState<boolean>(false);

  const recognitionRef = useRef<SpeechRecognition | null>(null);

  /** Create SpeechRecognition instance */
  const initRecognition = useCallback(() => {
    if (typeof window === "undefined") return null;

    const SpeechRecognition =
      (window as any).SpeechRecognition ||
      (window as any).webkitSpeechRecognition;

    if (!SpeechRecognition) {
      console.warn("Browser speech recognition unsupported");
      return null;
    }

    const recog = new SpeechRecognition();
    recog.lang = "en-US";
    recog.interimResults = true;
    recog.continuous = false;

    return recog;
  }, []);

  /** Start listening */
  const startListening = useCallback(() => {
    const recog = recognitionRef.current ?? initRecognition();
    if (!recog) return;

    recognitionRef.current = recog;
    setIsListening(true);

    recog.onresult = async (event: SpeechRecognitionEvent) => {
      let finalText = "";

      for (let i = 0; i < event.results.length; i++) {
        const res = event.results[i];
        if (res.isFinal) finalText += res[0].transcript;
      }

      // Only send final text into command mapper
      if (finalText.trim().length > 0) {
        const cmds = await interpretTranscript(finalText.trim());
        applyVoiceCommands(cmds, session, onUpdateSession);
      }
    };

    recog.onerror = () => {
      setIsListening(false);
    };

    recog.onend = () => {
      setIsListening(false);
    };

    recog.start();
  }, [initRecognition, onUpdateSession, session]);

  /** Stop listening */
  const stopListening = useCallback(() => {
    const recog = recognitionRef.current;
    if (recog) recog.stop();
    setIsListening(false);
  }, []);

  /** “Hey Techy” wake-word keyword */
  useEffect(() => {
    if (typeof window === "undefined") return;

    let wakeActive = true;
    const wakePhrase = "hey techy"; // lower-case match

    const handleWake = (e: SpeechRecognitionEvent) => {
      let text = "";
      for (let i = 0; i < e.results.length; i++) {
        const r = e.results[i];
        if (r.isFinal) text += r[0].transcript.toLowerCase();
      }
      if (text.includes(wakePhrase)) {
        startListening();
      }
    };

    const SpeechRecognition =
      (window as any).SpeechRecognition ||
      (window as any).webkitSpeechRecognition;

    if (!SpeechRecognition) return;

    const wake = new SpeechRecognition();
    wake.lang = "en-US";
    wake.interimResults = false;
    wake.continuous = true;

    wake.onresult = handleWake;
    wake.onerror = () => {};
    wake.onend = () => {
      if (wakeActive) wake.start();
    };

    wake.start();

    return () => {
      wakeActive = false;
      wake.stop();
    };
  }, [startListening]);

  return (
    <div className="mt-2 flex items-center gap-2 text-xs text-neutral-300">
      <button
        type="button"
        onClick={isListening ? stopListening : startListening}
        className="rounded bg-neutral-800 px-3 py-1 text-xs text-white"
      >
        {isListening ? "Stop listening" : "Start voice"}
      </button>

      <span className={isListening ? "text-green-400" : "text-neutral-500"}>
        {isListening ? "Listening…" : "Idle"}
      </span>
    </div>
  );
}
=============== Unified Inspection Hook (if exists) ===============
"use client";

import { useState } from "react";
import type { InspectionSession } from "@inspections/lib/inspection/types";

export default function useUnifiedInspection(initial: InspectionSession) {
  const [session, setSession] = useState<InspectionSession>(initial);

  const updateSession = (patch: Partial<InspectionSession>) =>
    setSession((prev) => ({ ...prev, ...patch }));

  return {
    session,
    updateSession,
  };
}

=============== Types ===============
/** ---------- Item / Section ---------- */
export type InspectionItemStatus = "ok" | "fail" | "na" | "recommend";
export type BrakeType = "air" | "hydraulic";

/** Duty class for inspections (light/medium/heavy) */
export type DutyClass = "light" | "medium" | "heavy";

export interface InspectionItem {
  /** Primary label. Some code uses `item`, some uses `name` — support both. */
  item?: string;
  name?: string;

  status?: InspectionItemStatus;
  notes?: string;
  /** Some AI/normalizers use singular `note`. */
  note?: string;

  value?: string | number | null;
  unit?: string | null;

  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionCategory {
  title: string;
  items: InspectionItem[];
}

/** Many places import `InspectionSection`; keep it as an alias. */
export type InspectionSection = InspectionCategory;

/** Template definition used by unified inspection builder / loader */
export interface InspectionTemplate {
  id: string;
  templateName: string;

  description?: string | null;
  tags?: string[] | null;
  vehicleType?: string | null;

  /** Whether this template is shared/public in the shop/library */
  isPublic?: boolean | null;

  /** Optional default labor hours for the template */
  laborHours?: number | null;

  /** Rendered sections (mirrors inspection_templates.sections JSON) */
  sections: InspectionSection[];

  /** Optional audit fields (mapped from DB created_at/updated_at) */
  createdAt?: string | null;
  updatedAt?: string | null;
}

/** ---------- Parsed voice/AI commands (support both shapes) ---------- */
/** Older, name-based command shape used by dispatchCommand/interpreter */
export type ParsedCommandNameBased =
  | { type: "status"; section: string; item: string; status: InspectionItemStatus }
  | { type: "add"; section: string; item: string; note: string }
  | { type: "recommend"; section: string; item: string; note: string }
  | {
      type: "measurement";
      section: string;
      item: string;
      value: number | string;
      unit?: string;
    };

/** Newer, index-based command shape used by convertParsedCommands.ts */
export type ParsedCommandIndexed = {
  command:
    | "update_status"
    | "update_value"
    | "add_note"
    | "recommend"
    | "complete_item"
    | "skip_item"
    | "pause_inspection"
    | "finish_inspection";
  sectionIndex?: number;
  itemIndex?: number;
  status?: InspectionItemStatus;
  value?: string | number;
  unit?: string;
  notes?: string;
  recommend?: string;
};

/** Unified ParsedCommand covering both shapes */
export type ParsedCommand = ParsedCommandNameBased | ParsedCommandIndexed;

/**
 * Commands consumed by dispatchCommand (older name-based shape),
 * plus a simple "pause" variant used in a few places.
 */
export type InspectionCommand =
  | ParsedCommandNameBased
  | { type: "pause"; section?: string; item?: string };

/** ---------- Runtime command objects (AI → actions) ---------- */
export type Command =
  | {
      type: "update_status";
      sectionIndex: number;
      itemIndex: number;
      status: InspectionItemStatus;
    }
  | {
      type: "update_value";
      sectionIndex: number;
      itemIndex: number;
      value: string | number;
      unit?: string;
    }
  | {
      type: "add_note";
      sectionIndex: number;
      itemIndex: number;
      notes: string;
    }
  | {
      type: "recommend";
      sectionIndex: number;
      itemIndex: number;
      recommendation: string;
    }
  | {
      type: "complete";
      sectionIndex: number;
      itemIndex: number;
    }
  | {
      type: "skip";
      sectionIndex: number;
      itemIndex: number;
    }
  | { type: "pause" }
  | { type: "finish" };

/** ---------- Quote shapes ---------- */
/** Rich source descriptor for where a line came from. */
export type QuoteSource = "inspection" | "manual" | string;

/**
 * Lightweight line produced by AI generators / costing flows.
 * Extended to include fields your costing + menu matching code writes.
 */
export interface QuoteLine {
  /** Core */
  description: string;

  /** IDs / provenance */
  id?: string;
  source?: QuoteSource;

  /** Names used across flows */
  item?: string;             // selected service/menu name
  name?: string;             // occasional alias
  inspectionItem?: string;   // originating inspection item text

  /** Status / notes */
  status?: InspectionItemStatus;
  notes?: string;

  /** Time & rates */
  hours?: number;
  rate?: number;
  total?: number;
  laborHours?: number | null;
  laborTime?: number;        // alias used on some screens
  laborRate?: number;

  /** Parts */
  parts?: Array<{ name?: string; number?: string; price?: number; type?: string }>;
  partNumber?: string | null;
  partName?: string;
  unitPrice?: number | null;

  /** Roll-up / pricing */
  qty?: number;
  price?: number;            // some code writes final line price here
  totalCost?: number;
}

/** Detailed line used by PDF/store. */
export interface QuoteLineItem {
  id: string;

  /** Some places map description into both `item` and `name`. */
  item?: string;
  name?: string;
  description: string;

  status: InspectionItemStatus;
  notes?: string;

  /** Unified commercial fields */
  price: number; // line price/total
  laborHours?: number;
  /** Additional variants used in some flows */
  laborTime?: number; // alias used on some pages
  laborRate?: number;

  /** Item-level measurement value (rare) */
  value?: string | number | null;

  /** Parts can be object or split fields */
  part?: { name: string; price: number };
  partName?: string;
  partPrice?: number | null;

  /** Old-style fields occasionally present */
  qty?: number;
  unitPrice?: number | null;

  /** Misc UI helpers */
  photoUrls?: string[];
  editable?: boolean;
  source?: QuoteSource;

  /** Collections used by some UIs */
  parts?: Array<{ name?: string; number?: string; price?: number }>;
  totalCost?: number;

  /** Optional back-reference to the inspection item */
  inspectionItem?: string;

  /** Optional AI suggestion metadata */
  ai?: {
    summary: string;
    confidence?: string;
    parts?: { name: string; qty?: number; cost?: number; notes?: string }[];
  };

  /** UI-only: track AI enrichment progress for this line */
  aiState?: "idle" | "loading" | "done" | "error";
}

/** ---------- Inspection Summary ---------- */
export interface SummaryItem {
  section: string;
  item: string;
  status: InspectionItemStatus;
  note?: string;
  value?: string | number | null;
  unit?: string | null;
  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionSummary {
  templateName?: string | null;
  date: string;
  items: SummaryItem[];
  summaryText: string;
}

/** ---------- Session (customer/vehicle) ---------- */
export interface SessionCustomer {
  first_name: string | null;
  last_name: string | null;
  phone: string | null;
  email: string | null;
  address: string | null;
  city: string | null;
  province: string | null;
  postal_code: string | null;
}

export interface SessionVehicle {
  year: string | null;
  make: string | null;
  model: string | null;
  vin: string | null;
  license_plate: string | null;
  mileage: string | null;
  color: string | null;
  /** Added for your form */
  unit_number?: string | null;
  engine_hours?: string | null;
}

/** ---------- Session status ---------- */
export type InspectionStatus = "not_started" | "in_progress" | "paused" | "completed";

/** ---------- Full session ---------- */
export interface InspectionSession {
  id?: string;

  /** Links to other records */
  customerId?: string | null;
  vehicleId?: string | null;
  workOrderId?: string | null;

  /** Template meta */
  templateId?: string | null;
  templateName?: string | null;
  /** Legacy alias still used by some pages */
  templateitem?: string | null;

  /** Selected brake system for rendering/units */
  brakeType?: BrakeType;

  /** Optional duty class for this inspection (light/medium/heavy) */
  dutyClass?: DutyClass | null;

  location?: string | null;

  /** Progress */
  currentSectionIndex: number;
  currentItemIndex: number;

  /** Voice */
  transcript?: string;
  isListening: boolean;

  /** Lifecycle */
  status: InspectionStatus;
  started: boolean;
  completed: boolean;
  isPaused: boolean;

  /** Audit */
  lastUpdated?: string;

  /** Entities */
  customer?: SessionCustomer | null;
  vehicle?: SessionVehicle | null;

  /** Content */
  sections: InspectionSection[];

  /** Quotes can be DB-sourced or UI-generated — accept both */
  quote?: Array<QuoteLine | QuoteLineItem>;

  /**
   * Optional runtime-only metadata.
   * Unified flows can stash arbitrary info here (e.g. source, duty class, debug flags).
   */
  meta?: {
    dutyClass?: DutyClass | null;
    source?: string;
    [key: string]: unknown;
  };
}

===== FILE: ./features/mobile/components/PunchInOutButton.tsx =====
"use client";


import { Button } from "@shared/components/ui/Button";

export interface JobLine {
  id: string;
  vehicle: string;
}

interface PunchInOutButtonProps {
  activeJob: JobLine | null;
  onPunchIn: () => void;
  onPunchOut: () => void;
  isLoading?: boolean;
}

const PunchInOutButton: React.FC<PunchInOutButtonProps> = ({
  activeJob,
  onPunchIn,
  onPunchOut,
  isLoading = false,
}) => {
  const isPunchedIn = !!activeJob;

  const handleClick = () => {
    if (isPunchedIn) onPunchOut();
    else onPunchIn();
  };

  const primaryLabel = isPunchedIn ? "Punch out" : "Punch in to job";
  const secondaryLabel = isPunchedIn
    ? activeJob?.vehicle ?? ""
    : "Start tracking time on this job";

  return (
    <div className="mt-4 w-full">
      <Button
        type="button"
        size="lg"
        variant={isPunchedIn ? "outline" : "orange"}
        onClick={handleClick}
        isLoading={isLoading}
        className={[
          "w-full justify-center rounded-2xl border px-4 py-3 text-sm shadow-card backdrop-blur-md",
          isPunchedIn
            ? "border-emerald-400/70 bg-emerald-500/5 text-emerald-100 hover:bg-emerald-500/10"
            : "border-[var(--accent-copper-soft)]/70 bg-[var(--glass-bg)] text-white hover:bg-[var(--accent-copper-soft)]/18",
        ].join(" ")}
      >
        <div className="flex flex-col items-center">
          <span className="text-[0.7rem] font-semibold uppercase tracking-[0.18em]">
            {primaryLabel}
          </span>
          {secondaryLabel && (
            <span className="mt-0.5 text-[0.7rem] text-neutral-200">
              {secondaryLabel}
            </span>
          )}
        </div>
      </Button>
    </div>
  );
};

export default PunchInOutButton;

===== FILE: ./features/auth/app/onboarding/OnboardingPage.tsx =====
"use client";

import { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type Role = "owner" | "admin" | "manager" | "advisor" | "mechanic";

const staffRedirect: Record<Role, string> = {
  owner: "/dashboard/owner",
  admin: "/dashboard/admin",
  manager: "/dashboard/manager",
  advisor: "/dashboard/advisor",
  mechanic: "/dashboard/tech",
};

const isStaffRole = (r: string | null | undefined): r is Role =>
  r === "owner" || r === "admin" || r === "manager" || r === "advisor" || r === "mechanic";

export default function OnboardingPage() {
  const supabase = createClientComponentClient<Database>();
  const router = useRouter();
  const searchParams = useSearchParams();

  const [sessionChecked, setSessionChecked] = useState(false);
  const [hasSession, setHasSession] = useState(false);

  const [fullName, setFullName] = useState("");
  const [phone, setPhone] = useState("");
  const [role, setRole] = useState<Role>("owner");
  const [userStreet, setUserStreet] = useState("");
  const [userCity, setUserCity] = useState("");
  const [userProvince, setUserProvince] = useState("");
  const [userPostal, setUserPostal] = useState("");

  const [businessName, setBusinessName] = useState("");
  const [shopName, setShopName] = useState("");
  const [shopStreet, setShopStreet] = useState("");
  const [shopCity, setShopCity] = useState("");
  const [shopProvince, setShopProvince] = useState("");
  const [shopPostal, setShopPostal] = useState("");
  const [ownerPin, setOwnerPin] = useState("");

  const [asOwner, setAsOwner] = useState(true);
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  // --- 1) Handle Supabase magic link exchange ---
  useEffect(() => {
    const code = searchParams.get("code");
    if (!code) return;
    (async () => {
      try {
        await supabase.auth.exchangeCodeForSession(code);
      } finally {
        const keepSid = searchParams.get("session_id");
        const clean = keepSid
          ? `/onboarding?session_id=${encodeURIComponent(keepSid)}`
          : "/onboarding";
        router.replace(clean);
        setTimeout(() => router.refresh(), 0);
      }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // --- 2) Check if user already belongs to a shop ---
  useEffect(() => {
    (async () => {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      const has = !!user;
      setHasSession(has);
      setSessionChecked(true);
      if (!has || !user) return;

      const sid = searchParams.get("session_id");
      if (sid) {
        try {
          await fetch("/api/stripe/link-user", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sessionId: sid, userId: user.id }),
          });
        } catch {
          /* ignore */
        }
      }

      const { data: prof } = await supabase
        .from("profiles")
        .select("role, full_name, phone, shop_id")
        .eq("id", user.id)
        .maybeSingle();

      const r = prof?.role ?? null;

      // ✅ NEW: Skip onboarding if user already linked to a shop
      if (prof?.shop_id) {
        if (isStaffRole(r)) {
          router.replace(staffRedirect[r]);
        } else {
          router.replace("/dashboard");
        }
        return;
      }

      // Legacy: otherwise check if their profile looks “complete”
      const complete =
        isStaffRole(r) &&
        !!prof?.full_name &&
        !!prof?.phone &&
        (r === "owner" ? true : !!prof?.shop_id);

      if (complete) {
        router.replace(staffRedirect[r]);
      }
    })();
  }, [router, searchParams, supabase]);

  useEffect(() => {
    setAsOwner(role === "owner");
  }, [role]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
      setError("User not found.");
      setLoading(false);
      return;
    }

    // Update profile
    const { error: updateErr } = await supabase
      .from("profiles")
      .update({
        full_name: fullName,
        phone,
        role: asOwner ? undefined : role,
        street: userStreet,
        city: userCity,
        province: userProvince,
        postal_code: userPostal,
        email: user.email ?? null,
      } as Database["public"]["Tables"]["profiles"]["Update"])
      .eq("id", user.id);

    if (updateErr) {
      setError("Failed to update profile.");
      setLoading(false);
      return;
    }

    // Owner bootstrap if needed
    if (asOwner) {
      if (!ownerPin || ownerPin.length < 4) {
        setError("Please provide an Owner PIN (min 4 characters).");
        setLoading(false);
        return;
      }
      if (!businessName || !shopStreet || !shopCity || !shopProvince || !shopPostal) {
        setError("Please fill all required shop fields.");
        setLoading(false);
        return;
      }

      const res = await fetch("/api/onboarding/bootstrap-owner", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          businessName,
          shopName: shopName || businessName,
          address: shopStreet,
          city: shopCity,
          province: shopProvince,
          postal_code: shopPostal,
          pin: ownerPin,
        }),
      });

      if (!res.ok) {
        const j = await res.json().catch(() => ({}));
        setError(j?.msg || "Failed to create shop. Please try again.");
        setLoading(false);
        return;
      }
    }

    const finalRole: Role = asOwner ? "owner" : role;
    router.replace(staffRedirect[finalRole] || "/dashboard");
    setLoading(false);
  };

  // --- Render ---
  if (!sessionChecked) {
    return (
      <div className="min-h-screen grid place-items-center bg-black text-white">
        <div className="rounded-lg border border-neutral-800 bg-neutral-950 px-4 py-3 text-xs text-neutral-300">
          Checking your session…
        </div>
      </div>
    );
  }

  if (!hasSession) {
    return (
      <div className="min-h-screen grid place-items-center bg-black text-white px-6">
        <div className="max-w-md space-y-4 rounded-xl border border-neutral-800 bg-neutral-950 px-6 py-5">
          <h1 className="text-2xl font-blackops text-orange-400">
            Confirm your email
          </h1>
          <p className="text-sm text-neutral-300">
            We sent a confirmation link to your email. Once you confirm, we&apos;ll bring you
            back here automatically to finish setting up your account.
          </p>
          <a
            href="/sign-in"
            className="inline-flex items-center justify-center rounded-md border border-orange-500 px-4 py-2 text-sm font-medium text-orange-100 hover:bg-orange-500/10"
          >
            Already confirmed? Sign in
          </a>
        </div>
      </div>
    );
  }

  // --- UI ---
  return (
    <div className="min-h-screen bg-black text-white">
      {/* Top bar */}
      <header className="border-b border-neutral-900 bg-neutral-950/70 px-4 py-4 sm:px-6">
        <div className="mx-auto flex max-w-6xl items-center justify-between gap-3">
          <div>
            <p className="text-xs uppercase tracking-[0.2em] text-neutral-500">
              ProFixIQ
            </p>
            <h1 className="text-xl font-blackops text-orange-400">
              Get your workspace ready
            </h1>
            <p className="text-xs text-neutral-400">
              Tell us about you {asOwner ? "and your shop" : ""} so we can route you to the
              right dashboard.
            </p>
          </div>
          <div className="hidden sm:flex flex-col items-end gap-1 text-[10px]">
            <span className="rounded-full border border-neutral-800 bg-neutral-900 px-2 py-1 text-neutral-300">
              Onboarding • Step 1 of 1
            </span>
            <span className="text-[10px] text-neutral-500">
              Takes about 1–2 minutes.
            </span>
          </div>
        </div>
      </header>

      <main className="mx-auto flex max-w-6xl flex-col gap-6 px-4 py-6 sm:px-6 lg:flex-row">
        {/* Left: form */}
        <div className="flex-1 space-y-6">
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Your info */}
            <section className="rounded-xl border border-neutral-800 bg-neutral-950 p-4 sm:p-5">
              <div className="mb-4 flex items-center justify-between gap-2">
                <div>
                  <h2 className="text-sm font-semibold text-neutral-100">
                    Your information
                  </h2>
                  <p className="text-[11px] text-neutral-500">
                    We use this for your profile and invoices.
                  </p>
                </div>
                <span className="rounded-full bg-neutral-900 px-2 py-0.5 text-[10px] text-neutral-400">
                  Required
                </span>
              </div>

              <div className="space-y-3">
                <div className="space-y-1">
                  <label className="text-xs text-neutral-300">Full name</label>
                  <input
                    type="text"
                    required
                    placeholder="e.g. Alex Smith"
                    value={fullName}
                    onChange={(e) => setFullName(e.target.value)}
                    className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                  />
                </div>

                <div className="space-y-1">
                  <label className="text-xs text-neutral-300">Phone</label>
                  <input
                    type="text"
                    required
                    placeholder="Mobile or shop phone"
                    value={phone}
                    onChange={(e) => setPhone(e.target.value)}
                    className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                  />
                </div>

                <div className="space-y-1">
                  <label className="text-xs text-neutral-300">Home / billing address</label>
                  <input
                    type="text"
                    required
                    placeholder="Street address"
                    value={userStreet}
                    onChange={(e) => setUserStreet(e.target.value)}
                    className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                  />
                  <div className="mt-2 grid grid-cols-1 gap-3 md:grid-cols-3">
                    <input
                      type="text"
                      required
                      placeholder="City"
                      value={userCity}
                      onChange={(e) => setUserCity(e.target.value)}
                      className="rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                    />
                    <input
                      type="text"
                      required
                      placeholder="Province / State"
                      value={userProvince}
                      onChange={(e) => setUserProvince(e.target.value)}
                      className="rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                    />
                    <input
                      type="text"
                      required
                      placeholder="Postal / ZIP"
                      value={userPostal}
                      onChange={(e) => setUserPostal(e.target.value)}
                      className="rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                    />
                  </div>
                </div>

                <div className="space-y-2">
                  <label className="text-xs text-neutral-300">Your role</label>
                  <select
                    required
                    value={role}
                    onChange={(e) => setRole(e.target.value as Role)}
                    className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white focus:border-orange-500 focus:outline-none"
                  >
                    <option value="owner">Owner</option>
                    <option value="admin">Admin</option>
                    <option value="manager">Manager</option>
                    <option value="advisor">Advisor</option>
                    <option value="mechanic">Mechanic</option>
                  </select>
                  <label className="mt-1 flex items-center gap-2 text-[11px] text-neutral-300">
                    <input
                      type="checkbox"
                      checked={asOwner}
                      onChange={(e) => setAsOwner(e.target.checked)}
                      className="h-4 w-4 rounded border-neutral-600 bg-neutral-900"
                    />
                    <span>
                      I&apos;m setting this up for my shop{" "}
                      <span className="text-neutral-400">(make me the owner)</span>
                    </span>
                  </label>
                </div>
              </div>
            </section>

            {/* Shop info */}
            <section className="rounded-xl border border-neutral-800 bg-neutral-950 p-4 sm:p-5">
              <div className="mb-4 flex items-center justify-between gap-2">
                <div>
                  <h2 className="text-sm font-semibold text-neutral-100">
                    Shop information
                  </h2>
                  <p className="text-[11px] text-neutral-500">
                    If you&apos;re staff, your owner can link you to a shop later.
                  </p>
                </div>
                {asOwner ? (
                  <span className="rounded-full bg-orange-500/10 px-2 py-0.5 text-[10px] text-orange-300">
                    Required for owners
                  </span>
                ) : (
                  <span className="rounded-full bg-neutral-900 px-2 py-0.5 text-[10px] text-neutral-400">
                    Optional for staff
                  </span>
                )}
              </div>

              <div className="space-y-3">
                <div className="space-y-1">
                  <label className="text-xs text-neutral-300">Business name</label>
                  <input
                    type="text"
                    placeholder="Legal business name"
                    value={businessName}
                    onChange={(e) => setBusinessName(e.target.value)}
                    className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                    required={asOwner}
                  />
                </div>

                <div className="space-y-1">
                  <label className="text-xs text-neutral-300">Shop name</label>
                  <input
                    type="text"
                    placeholder="Public-facing shop name (optional)"
                    value={shopName}
                    onChange={(e) => setShopName(e.target.value)}
                    className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                  />
                </div>

                <div className="space-y-1">
                  <label className="text-xs text-neutral-300">Shop address</label>
                  <input
                    type="text"
                    placeholder="Street address"
                    value={shopStreet}
                    onChange={(e) => setShopStreet(e.target.value)}
                    className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                    required={asOwner}
                  />
                  <div className="mt-2 grid grid-cols-1 gap-3 md:grid-cols-3">
                    <input
                      type="text"
                      placeholder="City"
                      value={shopCity}
                      onChange={(e) => setShopCity(e.target.value)}
                      className="rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                      required={asOwner}
                    />
                    <input
                      type="text"
                      placeholder="Province / State"
                      value={shopProvince}
                      onChange={(e) => setShopProvince(e.target.value)}
                      className="rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                      required={asOwner}
                    />
                    <input
                      type="text"
                      placeholder="Postal / ZIP"
                      value={shopPostal}
                      onChange={(e) => setShopPostal(e.target.value)}
                      className="rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                      required={asOwner}
                    />
                  </div>
                </div>

                {asOwner && (
                  <div className="space-y-1">
                    <label className="text-xs text-neutral-300">
                      Owner PIN <span className="text-neutral-400">(min 4 characters)</span>
                    </label>
                    <input
                      type="password"
                      placeholder="PIN you can share with trusted staff"
                      value={ownerPin}
                      onChange={(e) => setOwnerPin(e.target.value)}
                      className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none"
                      required
                    />
                    <p className="text-[11px] text-neutral-500">
                      Used to securely connect staff accounts to your shop.
                    </p>
                  </div>
                )}
              </div>
            </section>

            <div className="flex flex-wrap items-center gap-3">
              <button
                type="submit"
                disabled={loading}
                className="inline-flex items-center justify-center rounded-md bg-orange-500 px-4 py-2 text-sm font-semibold text-black shadow-sm transition hover:bg-orange-400 disabled:cursor-not-allowed disabled:opacity-60"
              >
                {loading ? "Saving…" : "Complete onboarding"}
              </button>
              {error && (
                <p className="text-xs text-red-400">
                  {error}
                </p>
              )}
            </div>
          </form>
        </div>

        {/* Right side: helper cards */}
        <aside className="w-full space-y-4 lg:w-72">
          <div className="rounded-xl border border-neutral-800 bg-neutral-950 p-4">
            <h3 className="mb-2 text-sm font-semibold text-neutral-100">
              What happens next
            </h3>
            <p className="text-xs text-neutral-400">
              When you hit <span className="text-orange-300">Complete onboarding</span>,
              we&apos;ll update your profile and, if you&apos;re the owner, create your shop
              record. Then we&apos;ll route you straight to the right dashboard view.
            </p>
          </div>

          <div className="rounded-xl border border-neutral-800 bg-neutral-950 p-4">
            <h3 className="mb-2 text-sm font-semibold text-neutral-100">
              Current mode
            </h3>
            <p className="text-xs text-neutral-400">
              {asOwner
                ? "Owner setup — you’re creating the shop and will have full access."
                : "Staff setup — your shop owner can link you to their shop later with your profile."}
            </p>
          </div>
        </aside>
      </main>
    </div>
  );
}

===== FILE: ./features/auth/app/reset-password/page.tsx =====
"use client";

import { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

export default function ResetPasswordPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClientComponentClient<Database>();

  const [password, setPassword] = useState("");
  const [confirm, setConfirm] = useState("");
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");

  useEffect(() => {
    const access_token = searchParams.get("access_token");
    const refresh_token = searchParams.get("refresh_token");

    if (access_token && refresh_token) {
      supabase.auth
        .setSession({ access_token, refresh_token })
        .then(({ error }) => {
          if (error) setError("Invalid or expired password reset link.");
          setLoading(false);
        });
    } else {
      setError("Missing access or refresh token.");
      setLoading(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams]); // supabase is stable from the factory; no need in deps

  const handleReset = async (e: React.FormEvent) => {
    e.preventDefault();

    if (password !== confirm) {
      setError("Passwords do not match.");
      return;
    }

    setLoading(true);
    setError("");
    setSuccess("");

    const { error } = await supabase.auth.updateUser({ password });

    if (error) {
      setError(error.message);
    } else {
      setSuccess("Password reset successfully.");
      setTimeout(() => router.push("/sign-in"), 1500);
    }

    setLoading(false);
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-black text-white px-4 font-blackops">
      <h1 className="text-3xl text-orange-500 mb-4">Reset Password</h1>

      {loading ? (
        <p>Loading...</p>
      ) : error ? (
        <p className="text-red-500">{error}</p>
      ) : (
        <form onSubmit={handleReset} className="w-full max-w-md space-y-4">
          {success && <p className="text-green-500">{success}</p>}

          <div>
            <label className="block text-sm mb-1">New Password</label>
            <input
              type="password"
              required
              className="w-full p-2 rounded bg-gray-900 text-white border border-orange-500"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </div>

          <div>
            <label className="block text-sm mb-1">Confirm Password</label>
            <input
              type="password"
              required
              className="w-full p-2 rounded bg-gray-900 text-white border border-orange-500"
              value={confirm}
              onChange={(e) => setConfirm(e.target.value)}
            />
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full bg-orange-500 hover:bg-orange-600 text-black font-bold py-2 px-4 rounded"
          >
            {loading ? "Resetting..." : "Reset Password"}
          </button>
        </form>
      )}

      <button
        className="mt-6 text-orange-400 underline"
        onClick={() => router.push("/sign-in")}
      >
        Back to Sign In
      </button>
    </div>
  );
}

===== FILE: ./features/auth/app/forgot-password/page.tsx =====
"use client";

import { useState } from "react";

export default function ForgotPasswordPage() {
  const [email, setEmail] = useState("");
  const [status, setStatus] = useState<"idle" | "sending" | "sent" | "error">(
    "idle",
  );
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setStatus("sending");
    setError("");

    const res = await fetch("/api/send-reset", {
      method: "POST",
      body: JSON.stringify({ email }),
      headers: { "Content-Type": "application/json" },
    });

    if (res.ok) {
      setStatus("sent");
    } else {
      const { error } = await res.json();
      setError(error || "Something went wrong.");
      setStatus("error");
    }
  };

  return (
    <div className="min-h-screen bg-black text-white flex flex-col items-center justify-center font-blackops p-4">
      <h1 className="text-3xl mb-4 text-orange-500">Forgot Password</h1>

      {status === "sent" ? (
        <p className="text-green-500">Password reset email sent!</p>
      ) : (
        <form onSubmit={handleSubmit} className="w-full max-w-md space-y-4">
          <input
            type="email"
            required
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="w-full p-2 bg-gray-900 text-white border border-orange-500 rounded"
            placeholder="Enter your email"
          />
          <button
            type="submit"
            disabled={status === "sending"}
            className="w-full bg-orange-500 hover:bg-orange-600 text-black font-bold py-2 px-4 rounded"
          >
            {status === "sending" ? "Sending..." : "Send Reset Link"}
          </button>
          {status === "error" && <p className="text-red-500">{error}</p>}
        </form>
      )}

      <button
        className="mt-6 text-orange-400 underline"
        onClick={() => (window.location.href = "/sign-in")}
      >
        Back to Sign In
      </button>
    </div>
  );
}


===== FILE: ./features/auth/app/signup/SignUpClient.tsx =====
// features/auth/components/SignUpClient.tsx
"use client";

import { useState, useEffect, useMemo } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

export default function SignUpClient() {
  const supabase = createClientComponentClient<Database>();
  const router = useRouter();
  const sp = useSearchParams();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [notice, setNotice] = useState("");
  const [loading, setLoading] = useState(false);

  // Compute origin for prod/preview/local
  const origin = useMemo(() => {
    if (typeof window !== "undefined") return window.location.origin;
    if (process.env.NEXT_PUBLIC_SITE_URL) return process.env.NEXT_PUBLIC_SITE_URL.replace(/\/$/, "");
    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
    return "http://localhost:3000";
  }, []);

  // ✅ Magic link / OAuth callback goes to /auth/callback and preserves ?redirect
  const emailRedirectTo = useMemo(() => {
    const redirect = sp.get("redirect");
    const tail = redirect ? `?redirect=${encodeURIComponent(redirect)}` : "";
    return `${origin}/auth/callback${tail}`;
  }, [origin, sp]);

  // Prefill from Stripe if present
  useEffect(() => {
    const sid = sp.get("session_id");
    if (!sid) return;
    (async () => {
      try {
        const res = await fetch(`/api/stripe/session?session_id=${sid}`);
        const data = await res.json();
        if (data?.email) setEmail(data.email);
      } catch {
        /* ignore */
      }
    })();
  }, [sp]);

  // Already signed in? send to redirect (if any) else dashboard
  useEffect(() => {
    (async () => {
      const { data } = await supabase.auth.getUser();
      if (data?.user) {
        const redirect = sp.get("redirect");
        router.replace(redirect || "/dashboard");
      }
    })();
  }, [router, sp, supabase]);

  // Ensure cookies sync to RSC/middleware before navigating
  const go = async (href: string) => {
    await supabase.auth.getSession(); // hydrate cookies
    router.refresh();
    router.replace(href);

    // Hard fallback for stubborn mobile caches
    setTimeout(() => {
      if (
        typeof window !== "undefined" &&
        window.location.pathname + window.location.search !== href
      ) {
        window.location.assign(href);
      }
    }, 60);
  };

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setNotice("");
    setLoading(true);

    const { data, error: signUpError } = await supabase.auth.signUp({
      email,
      password,
      options: { emailRedirectTo },
    });

    if (signUpError) {
      setError(signUpError.message || "Sign up failed.");
      setLoading(false);
      return;
    }

    // If email confirmation is required, there won't be a session yet
    if (!data.session) {
      setNotice(
        "Check your email to confirm your account. After confirming, we’ll take you to your dashboard."
      );
      setLoading(false);
      return;
    }

    // Session exists (e.g., confirm disabled) → go to redirect or dashboard
    const redirect = sp.get("redirect");
    await go(redirect || "/dashboard");
    setLoading(false);
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-black text-white px-4 font-blackops">
      <h1 className="text-3xl mb-6 text-orange-500">Create Account</h1>
      <form onSubmit={handleSignUp} className="w-full max-w-md space-y-4">
        <input
          type="email"
          placeholder="Email"
          required
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="w-full p-2 rounded bg-gray-900 border border-orange-500"
          autoComplete="email"
        />
        <input
          type="password"
          placeholder="Password"
          required
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="w-full p-2 rounded bg-gray-900 border border-orange-500"
          autoComplete="new-password"
          minLength={6}
        />
        <button
          type="submit"
          disabled={loading}
          className="w-full bg-orange-500 hover:bg-orange-600 text-black font-bold py-2 px-4 rounded"
        >
          {loading ? "Creating Account..." : "Sign Up"}
        </button>
        {error && <p className="text-red-500 text-sm">{error}</p>}
        {notice && <p className="text-green-400 text-sm">{notice}</p>}
      </form>
    </div>
  );
}

===== FILE: ./features/auth/components/SignIn.tsx =====
"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type Mode = "sign-in" | "sign-up";

const SHOP_USER_DOMAIN = "local.profix-internal";

export default function AuthPage() {
  const router = useRouter();
  const sp = useSearchParams();
  const supabase = createClientComponentClient<Database>();

  const [mode, setMode] = useState<Mode>("sign-in");
  const [identifier, setIdentifier] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string>("");
  const [notice, setNotice] = useState<string>("");
  const [loading, setLoading] = useState(false);

  // are we in "mobile companion" sign-in mode?
  const isMobileMode =
    (sp.get("mode") || "").toLowerCase() === "mobile" ||
    (sp.get("redirect") || "") === "/mobile";

  const origin = useMemo(() => {
    if (typeof window !== "undefined") return window.location.origin;
    if (process.env.NEXT_PUBLIC_SITE_URL)
      return process.env.NEXT_PUBLIC_SITE_URL.replace(/\/$/, "");
    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
    return "http://localhost:3000";
  }, []);

  const emailRedirectTo = useMemo(() => {
    const redirect = sp.get("redirect");
    const tail = redirect ? `?redirect=${encodeURIComponent(redirect)}` : "";
    return `${origin}/auth/callback${tail}`;
  }, [origin, sp]);

  // where to go *after* auth, based on profile + mode
  const routeAfterAuth = async (
    profile: { completed_onboarding?: boolean | null; shop_id?: string | null } | null,
  ) => {
    const redirectParam = sp.get("redirect");
    const hasShop = !!profile?.shop_id;
    const isOnboarded = !!profile?.completed_onboarding || hasShop;

    // special case: mobile mode always wins if user is allowed in
    if (isMobileMode && isOnboarded) {
      router.replace("/mobile");
      return;
    }

    if (redirectParam && isOnboarded) {
      router.replace(redirectParam);
      return;
    }

    if (isOnboarded) {
      router.replace("/dashboard");
    } else {
      router.replace("/onboarding");
    }
  };

  // already signed in → kick out of sign-in
  useEffect(() => {
    (async () => {
      const { data } = await supabase.auth.getSession();
      const session = data.session;
      if (!session?.user) return;

      const { data: profile } = await supabase
        .from("profiles")
        .select("completed_onboarding, shop_id")
        .eq("id", session.user.id)
        .maybeSingle();

      await routeAfterAuth(profile ?? null);
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const go = async (href: string) => {
    await supabase.auth.getSession();
    router.refresh();
    router.replace(href);
    setTimeout(() => {
      if (
        typeof window !== "undefined" &&
        window.location.pathname + window.location.search !== href
      ) {
        window.location.assign(href);
      }
    }, 60);
  };

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError("");
    setNotice("");

    const raw = identifier.trim();
    let emailToUse = raw;

    if (!raw.includes("@")) {
      emailToUse = `${raw.toLowerCase()}@${SHOP_USER_DOMAIN}`;
    }

    const { error: signInErr } = await supabase.auth.signInWithPassword({
      email: emailToUse,
      password,
    });

    if (signInErr) {
      setError(signInErr.message || "Sign in failed.");
      setLoading(false);
      return;
    }

    await supabase.auth.refreshSession();

    const { data: u } = await supabase.auth.getUser();
    if (!u.user) {
      setError("Signed in, but no session is visible yet. Try again.");
      setLoading(false);
      return;
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("completed_onboarding, shop_id")
      .eq("id", u.user.id)
      .maybeSingle();

    const hasShop = !!profile?.shop_id;
    const isOnboarded = !!profile?.completed_onboarding || hasShop;

    // explicit handling for mobile mode
    if (isMobileMode && isOnboarded) {
      await go("/mobile");
    } else if (isOnboarded) {
      const redirectParam = sp.get("redirect");
      await go(redirectParam || "/dashboard");
    } else {
      await go("/onboarding");
    }

    setLoading(false);
  };

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError("");
    setNotice("");

    const { data, error: signUpErr } = await supabase.auth.signUp({
      email: identifier,
      password,
      options: { emailRedirectTo },
    });

    if (signUpErr) {
      setError(signUpErr.message || "Sign up failed.");
      setLoading(false);
      return;
    }

    if (!data.session) {
      setNotice(
        "Check your inbox to confirm your email. We’ll continue after that.",
      );
      setLoading(false);
      return;
    }

    await go("/onboarding");
    setLoading(false);
  };

  const isSignIn = mode === "sign-in";

  return (
    <div
      className="
        min-h-screen px-4 text-foreground
        bg-background
        bg-[radial-gradient(circle_at_top,_rgba(248,113,22,0.16),transparent_55%),radial-gradient(circle_at_bottom,_rgba(15,23,42,0.96),#020617_78%)]
      "
    >
      <div className="mx-auto flex min-h-screen max-w-md flex-col items-center justify-center py-8">
        <div
          className="
            w-full rounded-3xl border
            border-[color:var(--metal-border-soft,#1f2937)]
            bg-[radial-gradient(circle_at_top,_rgba(248,113,22,0.2),transparent_60%),radial-gradient(circle_at_bottom,_rgba(15,23,42,0.98),#020617_82%)]
            shadow-[0_32px_80px_rgba(0,0,0,0.95)]
            px-6 py-7 sm:px-8 sm:py-9
          "
        >
          {/* Brand / title */}
          <div className="mb-6 space-y-2 text-center">
            <div
              className="
                inline-flex items-center gap-1 rounded-full border
                border-[color:var(--metal-border-soft,#1f2937)]
                bg-black/70
                px-3 py-1 text-[11px]
                uppercase tracking-[0.22em]
                text-neutral-300
              "
            >
              <span
                className="text-[10px] font-semibold text-[var(--accent-copper-light)]"
                style={{ fontFamily: "var(--font-blackops), system-ui" }}
              >
                ProFixIQ
              </span>
              <span className="h-1 w-1 rounded-full bg-[var(--accent-copper-light)]" />
              <span>Portal{isMobileMode ? " • Mobile" : ""}</span>
            </div>

            <h1
              className="mt-2 text-3xl sm:text-4xl font-semibold text-white"
              style={{ fontFamily: "var(--font-blackops), system-ui" }}
            >
              {isSignIn ? "Sign in" : "Create your account"}
            </h1>

            <p className="text-xs text-muted-foreground sm:text-sm">
              {isSignIn
                ? "Use your shop username or email to access your dashboard."
                : "Create an account with your email to get started."}
            </p>
          </div>

          {/* Mode switch */}
          <div className="mb-5 flex items-center justify-center">
            <div
              className="
                inline-flex rounded-full border
                border-[color:var(--metal-border-soft,#1f2937)]
                bg-black/70 p-1 text-xs
                shadow-[0_0_18px_rgba(15,23,42,0.8)]
              "
            >
              <button
                type="button"
                className={`px-3 py-1 rounded-full transition-all ${
                  isSignIn
                    ? "bg-[linear-gradient(to_right,var(--accent-copper-soft),var(--accent-copper))] text-black font-semibold shadow-[0_0_18px_rgba(212,118,49,0.7)]"
                    : "text-neutral-300 hover:text-white"
                }`}
                onClick={() => setMode("sign-in")}
                disabled={loading}
              >
                Sign in
              </button>
              <button
                type="button"
                className={`px-3 py-1 rounded-full transition-all ${
                  !isSignIn
                    ? "bg-[linear-gradient(to_right,var(--accent-copper-soft),var(--accent-copper))] text-black font-semibold shadow-[0_0_18px_rgba(212,118,49,0.7)]"
                    : "text-neutral-300 hover:text-white"
                }`}
                onClick={() => setMode("sign-up")}
                disabled={loading}
              >
                Sign up
              </button>
            </div>
          </div>

          {/* Error / notice */}
          {error && (
            <div className="mb-3 rounded-lg border border-red-500/60 bg-red-950/70 px-3 py-2 text-xs text-red-100 shadow-[0_0_18px_rgba(127,29,29,0.5)]">
              {error}
            </div>
          )}
          {notice && (
            <div className="mb-3 rounded-lg border border-emerald-500/60 bg-emerald-950/70 px-3 py-2 text-xs text-emerald-100 shadow-[0_0_18px_rgba(6,95,70,0.5)]">
              {notice}
            </div>
          )}

          {/* Form */}
          <form
            onSubmit={isSignIn ? handleSignIn : handleSignUp}
            className="space-y-4"
          >
            <div className="space-y-1 text-sm">
              <label className="block text-[0.7rem] font-semibold uppercase tracking-[0.18em] text-neutral-300">
                {isSignIn ? "Email or username" : "Email"}
              </label>
              <input
                type={isSignIn ? "text" : "email"}
                placeholder={
                  isSignIn ? "jane@shop.com or shop username" : "you@example.com"
                }
                autoComplete={isSignIn ? "username" : "email"}
                value={identifier}
                onChange={(e) => setIdentifier(e.target.value)}
                className="
                  w-full rounded-lg border
                  border-[color:var(--metal-border-soft,#1f2937)]
                  bg-black/70 px-3 py-2 text-sm text-white
                  placeholder:text-neutral-500
                  focus:outline-none focus:ring-2
                  focus:ring-[var(--accent-copper-soft)]
                  focus:border-[var(--accent-copper-soft)]
                "
                required
              />
              {isSignIn && (
                <p className="text-[11px] text-muted-foreground">
                  Shop accounts can sign in using the username provided by your
                  admin.
                </p>
              )}
            </div>

            <div className="space-y-1 text-sm">
              <label className="block text-[0.7rem] font-semibold uppercase tracking-[0.18em] text-neutral-300">
                Password
              </label>
              <input
                type="password"
                placeholder="••••••••"
                autoComplete={isSignIn ? "current-password" : "new-password"}
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="
                  w-full rounded-lg border
                  border-[color:var(--metal-border-soft,#1f2937)]
                  bg-black/70 px-3 py-2 text-sm text-white
                  placeholder:text-neutral-500
                  focus:outline-none focus:ring-2
                  focus:ring-[var(--accent-copper-soft)]
                  focus:border-[var(--accent-copper-soft)]
                "
                required
                minLength={6}
              />
            </div>

            <button
              type="submit"
              className="
                mt-3 w-full rounded-full
                bg-[linear-gradient(to_right,var(--accent-copper-soft),var(--accent-copper))]
                py-2.5 text-center text-sm
                font-semibold uppercase tracking-[0.22em] text-black
                shadow-[0_0_26px_rgba(212,118,49,0.9)]
                hover:brightness-110
                disabled:cursor-not-allowed disabled:opacity-60
              "
              style={{ fontFamily: "var(--font-blackops), system-ui" }}
              disabled={loading}
            >
              {loading
                ? isSignIn
                  ? "Signing in…"
                  : "Creating account…"
                : isSignIn
                ? "Sign in"
                : "Sign up"}
            </button>
          </form>

          {/* Mobile companion link – just sets mode=mobile */}
          {isSignIn && !isMobileMode && (
            <div className="mt-4 text-center">
              <button
                type="button"
                onClick={() => router.push("/sign-in?mode=mobile")}
                className="
                  text-[11px] font-medium
                  text-[var(--accent-copper-light)]
                  hover:text-[var(--accent-copper)]
                  hover:underline underline-offset-2
                "
                disabled={loading}
              >
                Sign in to mobile companion
              </button>
              <p className="mt-1 text-[10px] text-muted-foreground">
                Opens the tech-friendly mobile layout for phones and tablets.
              </p>
            </div>
          )}

          <div className="mt-6 text-center text-[11px] text-muted-foreground">
            <p>
              By continuing you agree to our{" "}
              <a
                href="/terms"
                className="font-medium text-[var(--accent-copper-light)] hover:text-[var(--accent-copper)] hover:underline"
              >
                Terms
              </a>{" "}
              and{" "}
              <a
                href="/privacy"
                className="font-medium text-[var(--accent-copper-light)] hover:text-[var(--accent-copper)] hover:underline"
              >
                Privacy Policy
              </a>
              .
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}

===== FILE: ./features/dashboard/app/dashboard/layout.tsx.bak =====
// features/dashboard/app/dashboard/layout.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import dynamic from "next/dynamic";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

import Calendar from "@shared/components/ui/Calendar";
import DynamicRoleSidebar from "@shared/components/DynamicRoleSidebar";

// Tabs (single source)
import { TabsProvider } from "@/features/shared/components/tabs/TabsProvider";
import TabsBar from "@/features/shared/components/tabs/TabsBar";
import ChatDock from "@/features/chat/components/ChatDock";

// Lazy to avoid SSR issues
const TechAssistant = dynamic(
  () => import("@/features/shared/components/TechAssistant"),
  { ssr: false }
);

// ---- Types ----
// Use a staff-only union here so <DynamicRoleSidebar role={...} /> is always correct.
type StaffRole = "owner" | "admin" | "manager" | "advisor" | "mechanic" | "parts";
type Role = StaffRole | null;

// Roles that can see calendar / staff tools
const CALENDAR_ROLES: readonly StaffRole[] = ["owner", "admin", "manager", "advisor"] as const;
const STAFF_ROLES: readonly StaffRole[] = ["owner", "admin", "manager", "advisor", "parts"] as const;

export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  const supabase = createClientComponentClient<Database>();

  // ---- Role state ----
  const [role, setRole] = useState<Role>(null);
  const [loadingRole, setLoadingRole] = useState(true);

  // ---- Calendar state ----
  const [month, setMonth] = useState<Date>(() => new Date());
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);

  // ---- Assistant drawer ----
  const [assistantOpen, setAssistantOpen] = useState(false);
  const [currentVehicle] = useState<{ year?: string; make?: string; model?: string } | null>(null);
  const [currentWorkOrderLineId] = useState<string | null>(null);

  // Fetch user role once (narrow to staff-only)
  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        setLoadingRole(true);
        const {
          data: { user },
        } = await supabase.auth.getUser();
        if (!user) {
          if (!cancelled) setRole(null);
          return;
        }

        const { data: profile } = await supabase
          .from("profiles")
          .select("role")
          .eq("id", user.id)
          .maybeSingle();

        const raw = profile?.role ?? null;
        const narrowed: Role =
          raw === "owner" ||
          raw === "admin" ||
          raw === "manager" ||
          raw === "advisor" ||
          raw === "mechanic" ||
          raw === "parts"
            ? raw
            : null;

        if (!cancelled) setRole(narrowed);
      } finally {
        if (!cancelled) setLoadingRole(false);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [supabase]);

  // ESC closes assistant
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      if (e.key === "Escape") setAssistantOpen(false);
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, []);

  const showCalendar = useMemo(
    () => !loadingRole && !!role && CALENDAR_ROLES.includes(role),
    [loadingRole, role],
  );

  const showStaffTools = useMemo(
    () => !loadingRole && !!role && STAFF_ROLES.includes(role),
    [loadingRole, role],
  );

  return (
    <TabsProvider>
      <div className="min-h-screen bg-black text-white font-blackops">
        {/* Top: Tabs bar only (no global navbar) */}
        <div className="border-b border-neutral-800 bg-neutral-900">
          <div className="mx-auto max-w-7xl px-3 py-2">
            <TabsBar />
          </div>
        </div>

        <div className="flex">
          {/* Sidebar with utilities / settings */}
          <aside className="hidden w-64 shrink-0 border-r border-neutral-800 bg-neutral-900 md:block">
            <div className="sticky top-0 h-[calc(100dvh-48px)] overflow-y-auto p-3">
              {/* Role-based sidebar (already trimmed to utilities per your role-nav files) */}
              <DynamicRoleSidebar role={role ?? undefined} />

              {showCalendar && (
                <div className="mt-4 rounded-xl border border-neutral-800 bg-neutral-950 p-3">
                  <h3 className="mb-2 text-sm font-semibold text-neutral-300">Calendar</h3>
                  <Calendar
                    className="shadow-inner"
                    month={month}
                    onMonthChange={setMonth}
                    value={selectedDate ?? undefined}
                    onChange={setSelectedDate}
                  />
                </div>
              )}

              {showStaffTools && (
                <>
                  <div className="mt-4">
                    <ChatDock />
                  </div>
                  <div className="mt-3">
                    <button
                      type="button"
                      onClick={() => setAssistantOpen(true)}
                      className="w-full rounded border border-white/15 px-3 py-2 text-sm hover:border-orange-500"
                    >
                      Tech Assistant
                    </button>
                  </div>
                </>
              )}
            </div>
          </aside>

          {/* Main content */}
          <main className="flex-1 p-6">
            {loadingRole ? (
              <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                {Array.from({ length: 6 }).map((_, i) => (
                  <div
                    key={i}
                    className="h-24 animate-pulse rounded-lg border border-neutral-800 bg-neutral-900"
                  />
                ))}
              </div>
            ) : (
              children
            )}
          </main>
        </div>
      </div>

      {/* Assistant Drawer */}
      {assistantOpen && (
        <div className="fixed inset-0 z-50">
          <button
            className="absolute inset-0 bg-black/60"
            aria-label="Close assistant"
            onClick={() => setAssistantOpen(false)}
          />
          <aside
            className="absolute right-0 top-0 h-full w-full max-w-3xl bg-neutral-900 text-white border-l border-neutral-800 p-4 overflow-y-auto"
            role="dialog"
            aria-modal="true"
          >
            <div className="mb-3 flex items-center justify-between">
              <h2 className="text-sm font-semibold text-neutral-300">Tech Assistant</h2>
              <button
                onClick={() => setAssistantOpen(false)}
                className="rounded border border-white/15 px-2 py-1 text-xs hover:border-orange-500"
              >
                Close
              </button>
            </div>
            <TechAssistant
              defaultVehicle={currentVehicle ?? undefined}
              workOrderLineId={currentWorkOrderLineId ?? undefined}
            />
          </aside>
        </div>
      )}
    </TabsProvider>
  );
}

===== FILE: ./features/dashboard/app/dashboard/admin/EmployeeDocsClient.tsx =====
"use client";

import { useEffect, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { uploadEmployeeDoc, type EmployeeDocType } from "@shared/lib/hr/uploadEmployeeDoc";

type DB = Database;
type EmpDocRow = DB["public"]["Tables"]["employee_documents"]["Row"];
type ProfileRow = DB["public"]["Tables"]["profiles"]["Row"];
type DocType = EmployeeDocType;

export default function EmployeeDocsClient() {
  const supabase = createClientComponentClient<DB>();
  const [docs, setDocs] = useState<EmpDocRow[]>([]);
  const [busy, setBusy] = useState(false);
  const [file, setFile] = useState<File | null>(null);
  const [docType, setDocType] = useState<DocType>("drivers_license");

  const load = async () => {
    const { data, error } = await supabase
      .from("employee_documents")
      .select("*")
      .order("uploaded_at", { ascending: false });
    if (!error && data) setDocs(data as EmpDocRow[]);
  };

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const onUpload = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!file) return;
    setBusy(true);
    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) throw new Error("Not signed in");

      const { data: prof, error } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("id", user.id)
        .maybeSingle<Pick<ProfileRow, "shop_id">>();
      if (error) throw error;

      const shopId = prof?.shop_id ?? null;
      if (!shopId) throw new Error("No shop_id on profile");

      // 👇 pass user.id as the 4th argument
      await uploadEmployeeDoc(file, docType, shopId, user.id);
      setFile(null);
      await load();
    } catch (err) {
      console.error(err);
      alert((err as Error).message);
    } finally {
      setBusy(false);
    }
  };

  // bucket name: employee_docs
  const publicUrlFor = (p: string) =>
    supabase.storage.from("employee_docs").getPublicUrl(p).data.publicUrl;

  return (
    <div className="p-6 text-white">
      <h1 className="text-2xl font-bold mb-4">Employee Documents</h1>

      <form onSubmit={onUpload} className="mb-6 flex gap-2 items-center">
        <select
          value={docType}
          onChange={(e) => setDocType(e.target.value as DocType)}
          className="border rounded px-2 py-1 bg-neutral-900"
        >
          <option value="drivers_license">Driver&apos;s License</option>
          <option value="certification">Certification</option>
          <option value="tax_form">Tax Form</option>
          <option value="other">Other</option>
        </select>

        <input
          type="file"
          onChange={(e) => setFile(e.target.files?.[0] ?? null)}
          className="border rounded px-2 py-1 bg-neutral-900"
        />

        <button
          type="submit"
          disabled={busy || !file}
          className="px-3 py-1 rounded bg-orange-600 text-white disabled:opacity-50"
        >
          {busy ? "Uploading…" : "Upload"}
        </button>
      </form>

      <div className="space-y-2">
        {docs.length === 0 ? (
          <p className="text-sm text-neutral-400">No documents uploaded yet.</p>
        ) : (
          docs.map((d) => (
            <div
              key={d.id}
              className="border rounded p-3 flex items-center justify-between bg-neutral-900/40"
            >
              <div>
                <div className="font-medium capitalize">{d.doc_type}</div>
                <div className="text-xs text-neutral-400">
                  {d.user_id} •{" "}
                  {d.uploaded_at ? new Date(d.uploaded_at).toLocaleString() : "—"}
                </div>
              </div>
              <a
                className="text-sm underline"
                href={publicUrlFor(d.file_path)}
                target="_blank"
                rel="noreferrer"
              >
                View
              </a>
            </div>
          ))
        )}
      </div>
    </div>
  );
}

===== FILE: ./features/dashboard/app/dashboard/settings/user/page.tsx =====
"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

import type { Database } from "@shared/types/types/supabase";
import { Input } from "@shared/components/ui/input";
import { Button } from "@shared/components/ui/Button";

type StatusKind = "success" | "error" | "info";

export default function SettingsPage() {
  const router = useRouter();
  const supabase = useMemo(() => createClientComponentClient<Database>(), []);

  const [email, setEmail] = useState("");
  const [emailVerified, setEmailVerified] = useState<boolean | null>(null);

  const [photoUrl, setPhotoUrl] = useState<string | null>(null);

  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [status, setStatus] = useState<string>("");
  const [statusType, setStatusType] = useState<StatusKind>("info");
  const [busy, setBusy] = useState(false);

  useEffect(() => {
    const loadUser = async () => {
      const {
        data: { user },
      } = await supabase.auth.getUser();

      if (!user) return;

      if (user.email) setEmail(user.email);
      setEmailVerified(Boolean(user.email_confirmed_at));

      // if you ever store avatar in user_metadata or profiles, hydrate it here
      if (typeof user.user_metadata?.avatar_url === "string") {
        setPhotoUrl(user.user_metadata.avatar_url);
      }
    };
    void loadUser();
  }, [supabase]);

  const showStatus = (msg: string, type: StatusKind = "info") => {
    setStatus(msg);
    setStatusType(type);
  };

  const handlePasswordUpdate = async () => {
    if (!newPassword || !confirmPassword) {
      showStatus("Enter and confirm your new password.", "error");
      return;
    }
    if (newPassword !== confirmPassword) {
      showStatus("Passwords do not match.", "error");
      return;
    }

    setBusy(true);
    const { error } = await supabase.auth.updateUser({ password: newPassword });
    setBusy(false);

    if (error) {
      showStatus(error.message, "error");
    } else {
      showStatus("Password updated successfully.", "success");
      setNewPassword("");
      setConfirmPassword("");
      router.refresh();
    }
  };

  const handleResendVerification = async () => {
    if (!email) {
      showStatus("No email address found for your account.", "error");
      return;
    }

    const origin =
      typeof window !== "undefined"
        ? window.location.origin
        : process.env.NEXT_PUBLIC_SITE_URL || "";

    setBusy(true);
    const { error } = await supabase.auth.resend({
      type: "signup",
      email,
      options: {
        emailRedirectTo: `${origin.replace(/\/$/, "")}/auth/callback`,
      },
    });
    setBusy(false);

    if (error) {
      showStatus(error.message, "error");
    } else {
      showStatus("Verification email resent.", "success");
      router.refresh();
    }
  };

  const handlePhotoUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const filePath = `avatars/${crypto.randomUUID()}-${file.name}`;
    setBusy(true);
    const { error } = await supabase.storage
      .from("profile-photos")
      .upload(filePath, file, { upsert: true });

    if (error) {
      setBusy(false);
      showStatus(error.message, "error");
      return;
    }

    const { data } = supabase.storage
      .from("profile-photos")
      .getPublicUrl(filePath);

    setPhotoUrl(data.publicUrl);
    setBusy(false);
    showStatus("Profile photo updated.", "success");
    router.refresh();
  };

  const statusClass =
    statusType === "success"
      ? "text-emerald-400"
      : statusType === "error"
      ? "text-red-400"
      : "text-neutral-300";

  return (
    <div className="mx-auto max-w-3xl px-4 py-8 text-foreground">
      {/* header */}
      <div className="mb-6 flex flex-wrap items-center justify-between gap-3">
        <div>
          <h1 className="text-2xl font-blackops text-orange-400">
            User Settings
          </h1>
          <p className="text-xs text-neutral-400">
            Manage your password, email verification, and profile photo.
          </p>
        </div>
        <Button variant="outline" onClick={() => router.back()} size="sm">
          Back
        </Button>
      </div>

      {/* content cards */}
      <div className="space-y-6">
        {/* Account info */}
        <section className="rounded-xl border border-border bg-card p-4">
          <h2 className="mb-2 text-sm font-semibold text-neutral-50">
            Account
          </h2>
          <p className="text-xs text-neutral-400">
            Signed in as{" "}
            <span className="font-mono text-orange-300">{email || "—"}</span>
          </p>
          {emailVerified != null && (
            <p className="mt-1 text-xs">
              Status:{" "}
              <span
                className={
                  emailVerified ? "text-emerald-400" : "text-yellow-300"
                }
              >
                {emailVerified ? "Email verified" : "Email not verified"}
              </span>
            </p>
          )}
        </section>

        {/* Password */}
        <section className="space-y-3 rounded-xl border border-border bg-card p-4">
          <h2 className="text-sm font-semibold text-neutral-50">
            Change password
          </h2>
          <div className="grid gap-2 md:grid-cols-2">
            <Input
              type="password"
              placeholder="New password"
              value={newPassword}
              onChange={(e) => setNewPassword(e.target.value)}
            />
            <Input
              type="password"
              placeholder="Confirm new password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
            />
          </div>
          <p className="text-[11px] text-neutral-500">
            Use at least 8 characters. Avoid reusing passwords from other
            services.
          </p>
          <Button
            onClick={handlePasswordUpdate}
            disabled={busy || !newPassword || !confirmPassword}
          >
            {busy ? "Updating…" : "Update password"}
          </Button>
        </section>

        {/* Email verification */}
        <section className="space-y-3 rounded-xl border border-border bg-card p-4">
          <h2 className="text-sm font-semibold text-neutral-50">
            Email verification
          </h2>
          <p className="text-xs text-neutral-400 mb-2">
            We use your email for security notices and portal invites.
          </p>
          <p className="text-sm mb-2">
            Current email:{" "}
            <span className="font-mono text-orange-300">
              {email || "Unknown"}
            </span>
          </p>
          <Button
            onClick={handleResendVerification}
            disabled={busy || !email}
            variant="outline"
          >
            {busy ? "Sending…" : "Resend verification email"}
          </Button>
        </section>

        {/* Profile photo */}
        <section className="space-y-3 rounded-xl border border-border bg-card p-4">
          <h2 className="text-sm font-semibold text-neutral-50">
            Profile photo
          </h2>
          <p className="text-xs text-neutral-400">
            This avatar appears in the app where your profile is shown.
          </p>
          <div className="mt-2 flex flex-wrap items-center gap-4">
            <div>
              <Input
                type="file"
                accept="image/*"
                onChange={handlePhotoUpload}
                disabled={busy}
              />
              <p className="mt-1 text-[11px] text-neutral-500">
                Recommended: square image, at least 256×256.
              </p>
            </div>
            {photoUrl && (
              <img
                src={photoUrl}
                alt="Profile"
                className="h-20 w-20 rounded-full border border-border object-cover"
              />
            )}
          </div>
        </section>

        {/* Status line */}
        {status && (
          <div className="rounded-lg border border-border bg-card px-4 py-2 text-sm">
            <span className={statusClass}>{status}</span>
          </div>
        )}
      </div>
    </div>
  );
}

===== FILE: ./features/dashboard/app/dashboard/owner/import-customers/page.tsx =====
"use client";

import { useEffect, useState } from "react";
import { Input } from "@shared/components/ui/input";
import { Button } from "@shared/components/ui/Button";
import Papa from "papaparse";
import { toast } from "sonner";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

import type { Database } from "@shared/types/types/supabase";

const supabase = createClientComponentClient<Database>();

const REQUIRED_FIELDS = [
  "customer_name",
  "customer_email",
  "customer_phone",
  "vehicle_vin",
  "vehicle_year",
  "vehicle_make",
  "vehicle_model",
  "vehicle_plate",
  "vehicle_mileage",
];

type ParsedRow = Record<string, string>;
type ColumnMapping = Record<string, string>;

export default function ImportCustomersPage() {
  const [shopId, setShopId] = useState<string | null>(null);
  const [csvFile, setCsvFile] = useState<File | null>(null);
  const [rawHeaders, setRawHeaders] = useState<string[]>([]);
  const [columnMapping, setColumnMapping] = useState<ColumnMapping>({});
  const [parsedData, setParsedData] = useState<ParsedRow[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchShop = async () => {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) return;

      const { data: profile } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("id", user.id)
        .single();

      setShopId(profile?.shop_id ?? null);
    };
    fetchShop();
  }, []);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) setCsvFile(file);
  };

  const parseCSV = () => {
    if (!csvFile) return;

    Papa.parse(csvFile, {
      header: true,
      skipEmptyLines: true,
      complete: async (results) => {
        const headers = results.meta.fields || [];
        setRawHeaders(headers);

        // Run AI mapping
        try {
          const res = await fetch("/api/ai/map-columns", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ headers }),
          });

          const json = await res.json();
          if (json.mapping) {
            setColumnMapping(json.mapping);
            setParsedData(results.data as ParsedRow[]);
            toast.success(`Mapped ${headers.length} columns with AI.`);
          } else {
            toast.error("AI mapping failed.");
          }
        } catch (err) {
          toast.error("AI mapping error.");
        }
      },
      error: () => {
        toast.error("Failed to parse CSV.");
      },
    });
  };

  const handleMappingChange = (original: string, mapped: string) => {
    setColumnMapping((prev) => ({ ...prev, [original]: mapped }));
  };

  const importData = async () => {
    if (!shopId) return toast.error("Shop ID not found");
    if (!parsedData.length) return toast.error("No data to import");

    setLoading(true);

    for (const row of parsedData) {
      const mapped = Object.entries(columnMapping).reduce(
        (acc, [original, mappedKey]) => {
          acc[mappedKey] = row[original];
          return acc;
        },
        {} as ParsedRow,
      );

      if (!REQUIRED_FIELDS.every((f) => mapped[f])) continue;

      // Insert customer
      const { data: existingCustomer } = await supabase
        .from("customers")
        .select("id")
        .eq("email", mapped.customer_email)
        .eq("shop_id", shopId)
        .single();

      let customerId = existingCustomer?.id;

      if (!customerId) {
        const { data: newCustomer, error: customerError } = await supabase
          .from("customers")
          .insert({
            full_name: mapped.customer_name,
            email: mapped.customer_email,
            phone_number: mapped.customer_phone,
            shop_id: shopId,
          })
          .select("id")
          .single();

        if (customerError || !newCustomer) {
          toast.error(`Failed to insert customer ${mapped.customer_email}`);
          continue;
        }

        customerId = newCustomer.id;
      }

      // Insert vehicle
      const { error: vehicleError } = await supabase.from("vehicles").insert({
        customer_id: customerId,
        shop_id: shopId,
        vin: mapped.vehicle_vin,
        year: parseInt(mapped.vehicle_year),
        make: mapped.vehicle_make,
        model: mapped.vehicle_model,
        plate: mapped.vehicle_plate,
        mileage: parseInt(mapped.vehicle_mileage),
      });

      if (vehicleError) {
        toast.error(`Failed to insert vehicle for ${mapped.vehicle_vin}`);
      }
    }

    toast.success("Import complete!");
    setLoading(false);
  };

  return (
    <div className="max-w-4xl mx-auto p-6 text-white">
      <h1 className="text-3xl font-bold text-orange-400 mb-6">
        Import Customers & Vehicles
      </h1>

      <div className="space-y-4">
        <Input type="file" accept=".csv" onChange={handleFileChange} />
        <Button onClick={parseCSV}>Parse CSV</Button>

        {rawHeaders.length > 0 && (
          <div className="mt-6">
            <h2 className="text-xl font-semibold mb-2">Column Mapping</h2>
            <table className="w-full text-sm">
              <thead>
                <tr className="text-orange-300">
                  <th className="text-left p-2">CSV Header</th>
                  <th className="text-left p-2">Mapped Field</th>
                </tr>
              </thead>
              <tbody>
                {rawHeaders.map((header) => (
                  <tr key={header}>
                    <td className="p-2">{header}</td>
                    <td className="p-2">
                      <Input
                        value={columnMapping[header] || ""}
                        onChange={(e) =>
                          handleMappingChange(header, e.target.value)
                        }
                        placeholder="Mapped field"
                      />
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}

        {parsedData.length > 0 && (
          <>
            <p className="text-sm text-green-400 mt-4">
              {parsedData.length} rows ready to import.
            </p>
            <Button onClick={importData} disabled={loading}>
              {loading ? "Importing..." : "Import to Database"}
            </Button>

            <div className="mt-6 max-h-64 overflow-auto border border-white rounded p-2 text-sm">
              <table className="w-full">
                <thead className="text-orange-300">
                  <tr>
                    {rawHeaders.map((h) => (
                      <th key={h}>{h}</th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {parsedData.map((row, i) => (
                    <tr key={i} className="border-t border-gray-700">
                      {rawHeaders.map((h) => (
                        <td key={h}>{row[h]}</td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </>
        )}
      </div>
    </div>
  );
}


===== FILE: ./features/dashboard/app/dashboard/owner/settings/page.tsx =====
"use client";

import { useEffect, useMemo, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { toast } from "sonner";

import type { Database } from "@shared/types/types/supabase";
import { Input } from "@shared/components/ui/input";
import { Button } from "@shared/components/ui/Button";
import OwnerPinModal from "@shared/components/OwnerPinModal";
import OwnerPinBadge from "@shared/components/OwnerPinBadge";
import ShopPublicProfileSection from "@/features/shops/components/ShopPublicProfileSection";
import ReviewsList from "@shared/components/reviews/ReviewsList";

type HourRow = {
  weekday: number;
  open_time: string;
  close_time: string;
  closed?: boolean;
};
type TimeOffRow = {
  id: string;
  starts_at: string;
  ends_at: string;
  reason: string | null;
};

const WEEKDAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

export default function OwnerSettingsPage() {
  const supabase = useMemo(
    () => createClientComponentClient<Database>(),
    [],
  );

  const [loading, setLoading] = useState(true);
  const [shopId, setShopId] = useState<string | null>(null);

  // PIN modal + timer
  const [pinModalOpen, setPinModalOpen] = useState(false);
  const [pinExpiresAt, setPinExpiresAt] = useState<string | undefined>();
  const [now, setNow] = useState<number>(() => Date.now());

  // Shop fields
  const [shopName, setShopName] = useState("");
  const [address, setAddress] = useState("");
  const [city, setCity] = useState("");
  const [province, setProvince] = useState("");
  const [postalCode, setPostalCode] = useState("");
  const [phone, setPhone] = useState("");
  const [email, setEmail] = useState("");
  const [logoUrl, setLogoUrl] = useState("");

  // Money / defaults
  const [laborRate, setLaborRate] = useState("");
  const [suppliesPercent, setSuppliesPercent] = useState("");
  const [diagnosticFee, setDiagnosticFee] = useState("");
  const [taxRate, setTaxRate] = useState("");

  // Workflow flags
  const [useAi, setUseAi] = useState(false);
  const [requireCauseCorrection, setRequireCauseCorrection] = useState(false);
  const [requireAuthorization, setRequireAuthorization] = useState(false);

  // Communication
  const [invoiceTerms, setInvoiceTerms] = useState("");
  const [invoiceFooter, setInvoiceFooter] = useState("");
  const [emailOnComplete, setEmailOnComplete] = useState(false);

  // Automation
  const [autoGeneratePdf, setAutoGeneratePdf] = useState(false);
  const [autoSendQuoteEmail, setAutoSendQuoteEmail] = useState(false);

  // Hours + time off
  const [hours, setHours] = useState<HourRow[]>(
    Array.from({ length: 7 }, (_, i) => ({
      weekday: i,
      open_time: "08:00",
      close_time: "17:00",
      closed: i === 0 || i === 6, // default: closed on weekend
    })),
  );
  const [timeOff, setTimeOff] = useState<TimeOffRow[]>([]);
  const [newOffStart, setNewOffStart] = useState("");
  const [newOffEnd, setNewOffEnd] = useState("");
  const [newOffReason, setNewOffReason] = useState("");

  // heartbeat to re-evaluate unlock
  useEffect(() => {
    const id = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(id);
  }, []);

  const isUnlocked = useMemo(() => {
    if (!pinExpiresAt) return false;
    return new Date(pinExpiresAt).getTime() > now;
  }, [pinExpiresAt, now]);

  // initial load
  useEffect(() => {
    const fetchSettings = async () => {
      const {
        data: { user },
      } = await supabase.auth.getUser();

      if (!user) {
        setLoading(false);
        return;
      }

      const { data: profile, error: profErr } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("id", user.id)
        .maybeSingle();

      if (profErr) {
        toast.error(profErr.message);
        setLoading(false);
        return;
      }

      if (!profile?.shop_id) {
        setLoading(false);
        return;
      }

      const sid = profile.shop_id;
      setShopId(sid);

      // core shop row
      const { data: shop, error } = await supabase
        .from("shops")
        .select("*")
        .eq("id", sid)
        .maybeSingle();

      if (error) toast.error(error.message);

      if (shop) {
        setShopName(shop.name || "");
        setAddress(shop.address || "");
        setCity(shop.city || "");
        setProvince(shop.province || "");
        setPostalCode(shop.postal_code || "");
        setPhone(shop.phone_number || "");
        setEmail(shop.email || "");
        setLogoUrl(shop.logo_url || "");

        setLaborRate(shop.labor_rate?.toString() || "");
        setSuppliesPercent(shop.supplies_percent?.toString() || "");
        setDiagnosticFee(shop.diagnostic_fee?.toString() || "");
        setTaxRate(shop.tax_rate?.toString() || "");

        setUseAi(!!shop.use_ai);
        setRequireCauseCorrection(!!shop.require_cause_correction);
        setRequireAuthorization(!!shop.require_authorization);

        setInvoiceTerms(shop.invoice_terms || "");
        setInvoiceFooter(shop.invoice_footer || "");
        setEmailOnComplete(!!shop.email_on_complete);

        setAutoGeneratePdf(!!shop.auto_generate_pdf);
        setAutoSendQuoteEmail(!!shop.auto_send_quote_email);
      }

      // hours (from shop_hours)
      try {
        const res = await fetch(`/api/settings/hours?shopId=${sid}`, {
          cache: "no-store",
        });
        if (res.ok) {
          const j = await res.json();
          if (Array.isArray(j?.hours)) {
            const byDay = new Map<number, HourRow>();
            (j.hours as HourRow[]).forEach((h) =>
              byDay.set(h.weekday, { ...h, closed: false }),
            );
            const normalized = Array.from({ length: 7 }, (_, i) => {
              const existing = byDay.get(i);
              if (existing) return existing;
              // no row in DB ⇒ treat as closed by default
              return {
                weekday: i,
                open_time: "08:00",
                close_time: "17:00",
                closed: true,
              };
            });
            setHours(normalized);
          }
        }
      } catch {
        // ignore
      }

      // time off
      try {
        const res = await fetch(`/api/settings/time-off?shopId=${sid}`, {
          cache: "no-store",
        });
        if (res.ok) {
          const j = await res.json();
          if (Array.isArray(j?.items)) setTimeOff(j.items);
        }
      } catch {
        // ignore
      }

      setLoading(false);
    };

    void fetchSettings();
  }, [supabase]);

  const guardUnlock = () => {
    if (!isUnlocked) {
      toast.warning("Unlock with Owner PIN first.");
      setPinModalOpen(true);
      return false;
    }
    return true;
  };

  // save core shop
  const handleSave = async () => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    const payload = {
      shopId,
      update: {
        name: shopName,
        address,
        city,
        province,
        postal_code: postalCode,
        phone_number: phone,
        email,
        logo_url: logoUrl,
        labor_rate: laborRate ? parseFloat(laborRate) : null,
        supplies_percent: suppliesPercent ? parseFloat(suppliesPercent) : null,
        diagnostic_fee: diagnosticFee ? parseFloat(diagnosticFee) : null,
        tax_rate: taxRate ? parseFloat(taxRate) : null,
        use_ai: useAi,
        require_cause_correction: requireCauseCorrection,
        require_authorization: requireAuthorization,
        invoice_terms: invoiceTerms,
        invoice_footer: invoiceFooter,
        email_on_complete: emailOnComplete,
        auto_generate_pdf: autoGeneratePdf,
        auto_send_quote_email: autoSendQuoteEmail,
      },
    };

    const res = await fetch("/api/settings/update", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!res.ok) {
      const j = await res.json().catch(() => ({}));
      toast.error(j?.error || "Failed to save settings");
      return;
    }

    toast.success("Settings saved.");
  };

  const handleLogoUpload = async (
    e: React.ChangeEvent<HTMLInputElement>,
  ) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const filePath = `logos/${crypto.randomUUID()}-${file.name}`;
    const { error } = await supabase.storage
      .from("logos")
      .upload(filePath, file, { upsert: true });

    if (error) {
      toast.error(error.message);
      return;
    }

    const { data } = supabase.storage.from("logos").getPublicUrl(filePath);
    setLogoUrl(data.publicUrl);
    toast.success("Logo uploaded.");
  };

  const handleGenerateLogo = () => {
    toast.info("AI Logo generation coming soon…");
  };

  // save hours → /api/settings/hours → shop_hours
  const saveHours = async () => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    // only send OPEN days to the API; closed days are omitted
    const openDays = hours.filter((h) => !h.closed);

    const res = await fetch("/api/settings/hours", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ shopId, hours: openDays }),
    });

    if (!res.ok) {
      const j = await res.json().catch(() => ({}));
      toast.error(j?.error || "Failed to save hours");
      return;
    }
    toast.success("Hours updated.");
  };

  // add time off
  const addTimeOff = async () => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    if (!newOffStart || !newOffEnd) {
      toast.warning("Select start and end time.");
      return;
    }

    const res = await fetch("/api/settings/time-off", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        shopId,
        range: {
          starts_at: newOffStart,
          ends_at: newOffEnd,
          reason: newOffReason || null,
        },
      }),
    });

    const j = await res.json().catch(() => ({}));
    if (!res.ok) {
      toast.error(j?.error || "Failed to add time off");
      return;
    }

    setNewOffStart("");
    setNewOffEnd("");
    setNewOffReason("");

    try {
      const r = await fetch(`/api/settings/time-off?shopId=${shopId}`, {
        cache: "no-store",
      });
      if (r.ok) {
        const jj = await r.json();
        setTimeOff(jj.items || []);
      }
    } catch {
      // ignore
    }

    toast.success("Time off added.");
  };

  const deleteTimeOff = async (id: string) => {
    if (!shopId) return;
    if (!guardUnlock()) return;

    const res = await fetch("/api/settings/time-off", {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ shopId, id }),
    });

    const j = await res.json().catch(() => ({}));
    if (!res.ok) {
      toast.error(j?.error || "Failed to remove time off");
      return;
    }

    setTimeOff((prev) => prev.filter((t) => t.id !== id));
    toast.success("Removed.");
  };

  if (loading) {
    return (
      <div className="p-6 text-muted-foreground">
        Loading shop settings…
      </div>
    );
  }

  return (
    <div className="mx-auto flex max-w-6xl flex-col gap-6 p-6 text-foreground">
      {/* top header */}
      <div className="flex flex-wrap items-center justify-between gap-3 rounded-xl border border-border bg-card px-4 py-3">
        <div>
          <h1 className="text-2xl font-blackops text-orange-400">
            Shop Settings
          </h1>
          <p className="text-xs text-neutral-400">
            Manage your shop profile, billing defaults, and scheduling.
          </p>
        </div>
        <div className="flex items-center gap-2">
          <OwnerPinBadge expiresAt={pinExpiresAt} />
          <Button size="sm" onClick={() => setPinModalOpen(true)}>
            {isUnlocked ? "Re-unlock" : "Unlock"}
          </Button>
          <Button size="sm" onClick={handleSave} disabled={!isUnlocked}>
            {isUnlocked ? "Save all" : "Unlock to save"}
          </Button>
        </div>
      </div>

      {/* main layout */}
      <div className="flex flex-col gap-6 lg:flex-row">
        {/* LEFT COLUMN */}
        <div className="flex-1 space-y-6">
          {/* Shop info */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Shop info
            </h2>
            <div className="space-y-2 text-sm">
              <Input
                value={shopName}
                onChange={(e) => setShopName(e.target.value)}
                placeholder="Shop name"
                disabled={!isUnlocked}
              />
              <Input
                value={address}
                onChange={(e) => setAddress(e.target.value)}
                placeholder="Street address"
                disabled={!isUnlocked}
              />
              <div className="grid gap-2 md:grid-cols-3">
                <Input
                  value={city}
                  onChange={(e) => setCity(e.target.value)}
                  placeholder="City"
                  disabled={!isUnlocked}
                />
                <Input
                  value={province}
                  onChange={(e) => setProvince(e.target.value)}
                  placeholder="Province / State"
                  disabled={!isUnlocked}
                />
                <Input
                  value={postalCode}
                  onChange={(e) => setPostalCode(e.target.value)}
                  placeholder="Postal code"
                  disabled={!isUnlocked}
                />
              </div>
              <div className="grid gap-2 md:grid-cols-2">
                <Input
                  value={phone}
                  onChange={(e) => setPhone(e.target.value)}
                  placeholder="Phone number"
                  disabled={!isUnlocked}
                />
                <Input
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="Email"
                  disabled={!isUnlocked}
                />
              </div>
              <div className="grid gap-2 md:grid-cols-2">
                <Input
                  value={logoUrl}
                  onChange={(e) => setLogoUrl(e.target.value)}
                  placeholder="Logo URL"
                  disabled={!isUnlocked}
                />
                <Input
                  type="file"
                  accept="image/*"
                  onChange={handleLogoUpload}
                  disabled={!isUnlocked}
                />
              </div>
              <Button
                onClick={handleGenerateLogo}
                variant="secondary"
                className="mt-1"
                disabled={!isUnlocked}
              >
                Generate logo with AI
              </Button>
              {logoUrl && (
                <img
                  src={logoUrl}
                  alt="Logo"
                  className="mt-2 h-20 w-32 rounded bg-white p-1 object-contain"
                />
              )}
            </div>
          </section>

          {/* Billing + workflow */}
          <div className="grid gap-6 md:grid-cols-2">
            <section className="space-y-3 rounded-xl border border-border bg-card p-4">
              <h2 className="text-sm font-semibold text-neutral-50">
                Billing defaults
              </h2>
              <div className="grid gap-2 md:grid-cols-2 text-sm">
                <Input
                  value={laborRate}
                  onChange={(e) => setLaborRate(e.target.value)}
                  placeholder="Labor rate ($/hr)"
                  disabled={!isUnlocked}
                />
                <Input
                  value={suppliesPercent}
                  onChange={(e) => setSuppliesPercent(e.target.value)}
                  placeholder="Shop supplies (%)"
                  disabled={!isUnlocked}
                />
                <Input
                  value={diagnosticFee}
                  onChange={(e) => setDiagnosticFee(e.target.value)}
                  placeholder="Diagnostic fee ($)"
                  disabled={!isUnlocked}
                />
                <Input
                  value={taxRate}
                  onChange={(e) => setTaxRate(e.target.value)}
                  placeholder="Tax rate (%)"
                  disabled={!isUnlocked}
                />
              </div>
            </section>

            <section className="space-y-3 rounded-xl border border-border bg-card p-4">
              <h2 className="text-sm font-semibold text-neutral-50">
                Workflow
              </h2>
              <label className="flex items-center gap-2 text-sm text-neutral-200">
                <input
                  type="checkbox"
                  checked={useAi}
                  onChange={(e) => setUseAi(e.target.checked)}
                  disabled={!isUnlocked}
                />
                Use AI features
              </label>
              <label className="flex items-center gap-2 text-sm text-neutral-200">
                <input
                  type="checkbox"
                  checked={requireCauseCorrection}
                  onChange={(e) =>
                    setRequireCauseCorrection(e.target.checked)
                  }
                  disabled={!isUnlocked}
                />
                Require cause / correction on lines
              </label>
              <label className="flex items-center gap-2 text-sm text-neutral-200">
                <input
                  type="checkbox"
                  checked={requireAuthorization}
                  onChange={(e) =>
                    setRequireAuthorization(e.target.checked)
                  }
                  disabled={!isUnlocked}
                />
                Require customer authorization
              </label>
            </section>
          </div>

          {/* Communication */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Communication & branding
            </h2>
            <Input
              value={invoiceTerms}
              onChange={(e) => setInvoiceTerms(e.target.value)}
              placeholder="Invoice terms"
              disabled={!isUnlocked}
            />
            <Input
              value={invoiceFooter}
              onChange={(e) => setInvoiceFooter(e.target.value)}
              placeholder="Invoice footer note"
              disabled={!isUnlocked}
            />
            <label className="flex items-center gap-2 text-sm text-neutral-200">
              <input
                type="checkbox"
                checked={emailOnComplete}
                onChange={(e) => setEmailOnComplete(e.target.checked)}
                disabled={!isUnlocked}
              />
              Email customer when job is complete
            </label>
          </section>

          {/* Automation */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Automation
            </h2>
            <label className="flex items-center gap-2 text-sm text-neutral-200">
              <input
                type="checkbox"
                checked={autoGeneratePdf}
                onChange={(e) => setAutoGeneratePdf(e.target.checked)}
                disabled={!isUnlocked}
              />
              Auto-generate quote PDF
            </label>
            <label className="flex items-center gap-2 text-sm text-neutral-200">
              <input
                type="checkbox"
                checked={autoSendQuoteEmail}
                onChange={(e) => setAutoSendQuoteEmail(e.target.checked)}
                disabled={!isUnlocked}
              />
              Auto-send quote email
            </label>
          </section>

          {/* Hours */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <div className="flex items-center justify-between gap-3">
              <h2 className="text-sm font-semibold text-neutral-50">
                Hours (controls public booking slots)
              </h2>
              <Button onClick={saveHours} disabled={!isUnlocked} size="sm">
                Save hours
              </Button>
            </div>

            <div className="grid gap-2 md:grid-cols-7">
              {hours.map((row, idx) => {
                const closed = !!row.closed;
                return (
                  <div
                    key={row.weekday}
                    className="rounded border border-neutral-800 bg-neutral-900 p-2 text-xs"
                  >
                    <div className="mb-1 flex items-center justify-between text-[11px] font-semibold text-orange-300">
                      <span>{WEEKDAYS[row.weekday]}</span>
                      <label className="flex items-center gap-1 text-[10px] text-neutral-300">
                        <input
                          type="checkbox"
                          checked={closed}
                          onChange={(e) => {
                            const isClosed = e.target.checked;
                            setHours((prev) => {
                              const copy = [...prev];
                              copy[idx] = { ...copy[idx], closed: isClosed };
                              return copy;
                            });
                          }}
                          disabled={!isUnlocked}
                        />
                        Closed
                      </label>
                    </div>
                    <label className="mb-1 block text-[10px] text-neutral-400">
                      Open
                    </label>
                    <input
                      type="time"
                      className="mb-2 w-full rounded bg-neutral-950 px-2 py-1 text-xs disabled:opacity-40"
                      value={row.open_time}
                      onChange={(e) => {
                        const v = e.target.value;
                        setHours((prev) => {
                          const copy = [...prev];
                          copy[idx] = { ...copy[idx], open_time: v };
                          return copy;
                        });
                      }}
                      disabled={!isUnlocked || closed}
                    />
                    <label className="mb-1 block text-[10px] text-neutral-400">
                      Close
                    </label>
                    <input
                      type="time"
                      className="w-full rounded bg-neutral-950 px-2 py-1 text-xs disabled:opacity-40"
                      value={row.close_time}
                      onChange={(e) => {
                        const v = e.target.value;
                        setHours((prev) => {
                          const copy = [...prev];
                          copy[idx] = { ...copy[idx], close_time: v };
                          return copy;
                        });
                      }}
                      disabled={!isUnlocked || closed}
                    />
                  </div>
                );
              })}
            </div>
          </section>

          {/* Time off */}
          <section className="space-y-3 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Time off / blackouts
            </h2>

            <div className="grid gap-2 md:grid-cols-4">
              <input
                type="datetime-local"
                className="rounded bg-neutral-900 px-3 py-2 text-sm"
                value={newOffStart}
                onChange={(e) => setNewOffStart(e.target.value)}
                disabled={!isUnlocked}
              />
              <input
                type="datetime-local"
                className="rounded bg-neutral-900 px-3 py-2 text-sm"
                value={newOffEnd}
                onChange={(e) => setNewOffEnd(e.target.value)}
                disabled={!isUnlocked}
              />
              <Input
                placeholder="Reason (optional)"
                value={newOffReason}
                onChange={(e) => setNewOffReason(e.target.value)}
                disabled={!isUnlocked}
              />
              <Button onClick={addTimeOff} disabled={!isUnlocked}>
                Add
              </Button>
            </div>

            {timeOff.length === 0 ? (
              <p className="text-xs text-neutral-500">
                No time-off entries.
              </p>
            ) : (
              <ul className="space-y-2">
                {timeOff.map((t) => {
                  const start = new Date(t.starts_at);
                  const end = new Date(t.ends_at);
                  return (
                    <li
                      key={t.id}
                      className="flex items-center justify-between rounded border border-neutral-800 bg-neutral-900 px-3 py-2 text-sm"
                    >
                      <div>
                        <div className="text-neutral-100">
                          {start.toLocaleString()} → {end.toLocaleString()}
                        </div>
                        {t.reason && (
                          <div className="text-xs text-neutral-400">
                            Reason: {t.reason}
                          </div>
                        )}
                      </div>
                      <Button
                        variant="secondary"
                        size="sm"
                        onClick={() => void deleteTimeOff(t.id)}
                        disabled={!isUnlocked}
                      >
                        Remove
                      </Button>
                    </li>
                  );
                })}
              </ul>
            )}
          </section>
        </div>

        {/* RIGHT COLUMN */}
        <div className="w-full space-y-6 lg:w-80">
          {shopId && (
            <ShopPublicProfileSection
              shopId={shopId}
              isUnlocked={isUnlocked}
            />
          )}

          {/* Invoice preview */}
          <section className="space-y-2 rounded-xl border border-border bg-card p-4">
            <h2 className="text-sm font-semibold text-neutral-50">
              Invoice preview
            </h2>
            <div className="space-y-2 rounded bg-white p-3 text-xs text-black shadow">
              {logoUrl && (
                <img
                  src={logoUrl}
                  alt="Logo"
                  className="h-12 object-contain"
                />
              )}
              <div className="font-semibold">
                {shopName || "Your shop name"}
              </div>
              <div>
                {address}
                {address && ","} {city} {province} {postalCode}
              </div>
              <div>
                {phone} {phone && email && "•"} {email}
              </div>
              <hr className="my-2" />
              <div className="font-semibold text-black">Invoice terms</div>
              <p>{invoiceTerms || "—"}</p>
              <div className="font-semibold text-black">Footer</div>
              <p>{invoiceFooter || "—"}</p>
            </div>
          </section>

          {shopId && (
            <section className="space-y-3 rounded-xl border border-border bg-card p-4">
              <h2 className="text-sm font-semibold text-neutral-50">
                Customer reviews
              </h2>
              <p className="text-[11px] text-neutral-400">
                Recent reviews for your shop. Owners/admins/managers can reply
                directly.
              </p>
              <ReviewsList shopId={shopId} />
            </section>
          )}
        </div>
      </div>

      <OwnerPinModal
        shopId={shopId}
        open={pinModalOpen}
        onClose={() => setPinModalOpen(false)}
        onVerified={(iso: string | undefined) => setPinExpiresAt(iso)}
      />
    </div>
  );
}

===== FILE: ./features/ai/components/chat/ChatWindow.tsx =====
// features/ai/components/chat/ChatWindow.tsx
"use client";

import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type Message = Database["public"]["Tables"]["messages"]["Row"];

type ChatWindowProps = {
  conversationId: string;
  userId: string;
  title?: string;
};

// Helper type for Realtime broadcast payloads coming from realtime.broadcast_changes
type BroadcastPayload<T> = {
  payload?: {
    record?: T;
    new?: T;
    old?: T | null;
    [key: string]: unknown;
  };
  record?: T;
  new?: T;
  old?: T | null;
  [key: string]: unknown;
};

function extractRecord<T>(payload: BroadcastPayload<T>): T | null {
  return (
    payload?.payload?.record ??
    payload?.payload?.new ??
    payload?.record ??
    payload?.new ??
    null
  ) as T | null;
}

export default function ChatWindow({
  conversationId,
  userId,
  title = "Conversation",
}: ChatWindowProps) {
  const supabase = useMemo(
    () => createClientComponentClient<Database>(),
    [],
  );
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState("");
  const [loading, setLoading] = useState(true);
  const [sending, setSending] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const bottomRef = useRef<HTMLDivElement | null>(null);
  const inputRef = useRef<HTMLTextAreaElement | null>(null);

  const fetchMessages = useCallback(async () => {
    if (!conversationId) return;
    setError(null);
    try {
      const res = await fetch("/api/chat/get-messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ conversationId }),
      });
      if (!res.ok) throw new Error(String(res.status));
      const data = (await res.json()) as Message[];
      setMessages((prev) =>
        prev.length > 0 && data.length === 0 ? prev : data,
      );
    } catch (err) {
      console.error("[ChatWindow] fetchMessages error:", err);
      setError("Couldn't load messages.");
    } finally {
      setLoading(false);
    }
  }, [conversationId]);

  // initial load
  useEffect(() => {
    if (!conversationId) return;
    setLoading(true);
    void fetchMessages();
  }, [conversationId, fetchMessages]);

  // 🔁 gentle polling safety net (no postgres_changes)
  useEffect(() => {
    if (!conversationId) return;
    const id = window.setInterval(() => {
      void fetchMessages();
    }, 4000); // every 4s
    return () => window.clearInterval(id);
  }, [conversationId, fetchMessages]);

  // 🛡️ Set auth token for Realtime
  useEffect(() => {
    let mounted = true;

    (async () => {
      const {
        data: { session },
      } = await supabase.auth.getSession();
      const token = session?.access_token;
      if (token && mounted) {
        try {
          await supabase.realtime.setAuth(token);
          console.log("[ChatWindow] realtime.setAuth OK");
        } catch (e) {
          console.warn("[ChatWindow] realtime.setAuth failed", e);
        }
      }
    })();

    return () => {
      mounted = false;
    };
  }, [supabase]);

  // 🔔 Realtime broadcast from `public.broadcast_chat_messages`
  useEffect(() => {
    if (!conversationId) return;

    const topic = `room:${conversationId}:messages`;

    const channel = supabase
      .channel(topic, {
        config: {
          broadcast: {
            self: true,
            ack: true,
          },
        },
      })
      .on(
        "broadcast",
        { event: "INSERT" },
        (payload: BroadcastPayload<Message>) => {
          console.log("[ChatWindow] broadcast INSERT", payload);
          const msg = extractRecord<Message>(payload);
          if (!msg) return;
          setMessages((prev) =>
            prev.some((m) => m.id === msg.id) ? prev : [...prev, msg],
          );
        },
      )
      .on(
        "broadcast",
        { event: "UPDATE" },
        (payload: BroadcastPayload<Message>) => {
          console.log("[ChatWindow] broadcast UPDATE", payload);
          const msg = extractRecord<Message>(payload);
          if (!msg) return;
          setMessages((prev) =>
            prev.map((m) => (m.id === msg.id ? msg : m)),
          );
        },
      )
      .on(
        "broadcast",
        { event: "DELETE" },
        (payload: BroadcastPayload<Message>) => {
          console.log("[ChatWindow] broadcast DELETE", payload);
          const msg =
            (payload?.payload?.old as Message | undefined) ??
            (payload.old as Message | undefined) ??
            null;
          if (!msg) return;
          setMessages((prev) => prev.filter((m) => m.id !== msg.id));
        },
      )
      .subscribe((status) => {
        console.log("[ChatWindow] broadcast subscribe status", status, topic);
      });

    return () => {
      supabase.removeChannel(channel);
    };
  }, [supabase, conversationId]);

  // scroll to bottom on new messages
  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  // focus once
  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  const sendMessage = useCallback(async () => {
    const content = newMessage.trim();
    if (!content || sending) return;

    const tempId = `temp-${Date.now()}`;
    const optimistic: Message = {
      id: tempId,
      conversation_id: conversationId,
      sender_id: userId,
      content,
      sent_at: new Date().toISOString(),
    } as Message;

    setMessages((prev) => [...prev, optimistic]);
    setNewMessage("");
    setSending(true);
    setError(null);

    try {
      const res = await fetch("/api/chat/send-message", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          conversationId,
          senderId: userId,
          content,
          recipients: [],
        }),
      });
      if (!res.ok) {
        console.error(
          "[ChatWindow] send-message failed:",
          await res.text(),
        );
        setError("Message failed to send.");
      }
    } catch (err) {
      console.error("[ChatWindow] sendMessage error:", err);
      setError("Message failed to send.");
    } finally {
      setSending(false);
    }
  }, [conversationId, newMessage, sending, userId]);

  const deleteMessage = useCallback(
    async (id: string) => {
      const prev = messages;
      setMessages((curr) => curr.filter((m) => m.id !== id));
      try {
        const res = await fetch("/api/chat/delete-message", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ id }),
        });
        if (!res.ok) {
          console.error(
            "[ChatWindow] delete-message failed:",
            await res.text(),
          );
          setMessages(prev);
        }
      } catch (err) {
        console.error("[ChatWindow] deleteMessage error:", err);
        setMessages(prev);
      }
    },
    [messages],
  );

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      void sendMessage();
    }
  };

  // group & render helpers
  const grouped = useMemo(() => {
    const byDay: Array<
      | { type: "day"; label: string }
      | { type: "msg"; msg: Message; isMine: boolean; showAvatar: boolean }
    > = [];

    let lastDay = "";
    let lastSender = "";

    messages.forEach((m) => {
      const day = m.sent_at ? new Date(m.sent_at).toDateString() : "Unknown";
      if (day !== lastDay) {
        byDay.push({ type: "day", label: day });
        lastDay = day;
        lastSender = "";
      }

      const isMine = m.sender_id === userId;
      const showAvatar = m.sender_id !== lastSender;
      byDay.push({ type: "msg", msg: m, isMine, showAvatar });

      lastSender = m.sender_id ?? "";
    });

    return byDay;
  }, [messages, userId]);

  return (
    <div className="flex h-full flex-col rounded border border-[var(--metal-border-soft)] bg-[var(--metal-surface)] text-neutral-50">
      {/* header */}
      <div className="border-b border-[var(--metal-border-soft)] px-4 py-3 flex items-center justify-between">
        <div className="text-sm font-medium text-neutral-100">{title}</div>
        {error ? (
          <div className="text-[10px] text-red-200/80">{error}</div>
        ) : null}
      </div>

      {/* messages */}
      <div className="flex-1 overflow-y-auto px-3 py-4 space-y-2">
        {loading ? (
          <div className="text-center text-neutral-400 text-sm py-6">
            Loading messages…
          </div>
        ) : grouped.length === 0 ? (
          <div className="text-center text-neutral-500 text-sm py-6">
            No messages yet. Say hi 👋
          </div>
        ) : (
          grouped.map((item, idx) => {
            if (item.type === "day") {
              return (
                <div key={`day-${idx}`} className="flex justify-center">
                  <span className="rounded-full bg-black/40 px-3 py-1 text-[11px] text-neutral-400">
                    {item.label}
                  </span>
                </div>
              );
            }

            const { msg, isMine, showAvatar } = item;
            const time =
              msg.sent_at &&
              new Date(msg.sent_at).toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit",
              });

            return (
              <div
                key={msg.id}
                className={`flex gap-2 ${
                  isMine ? "justify-end" : "justify-start"
                }`}
              >
                {!isMine && showAvatar ? (
                  <div className="mt-6 h-7 w-7 rounded-full bg-neutral-800 flex items-center justify-center text-[10px] text-neutral-100/80">
                    U
                  </div>
                ) : (
                  !isMine && <div className="w-7" />
                )}

                <div className="relative">
                  <div
                    className={[
                      "inline-flex",
                      "flex-col",
                      "min-w-[140px]",   // 👈 prevents super-narrow bubbles
                      "max-w-[80%]",     // 👈 lets them stretch nicely on wider screens
                      "rounded-2xl",
                      "px-3 py-2 text-sm",
                      "whitespace-pre-wrap break-words",
                      isMine
                        ? "bg-[var(--accent-copper-soft)] text-black"
                        : "bg-black/50 text-neutral-100",
                    ].join(" ")}
                  >
                    <p>{msg.content}</p>
                    {time ? (
                      <p
                        className={[
                          "mt-1 text-[10px]",
                          isMine ? "text-black/60" : "text-neutral-400",
                        ].join(" ")}
                      >
                        {time}
                      </p>
                    ) : null}
                  </div>

                  {isMine ? (
                    <button
                      type="button"
                      onClick={() => void deleteMessage(msg.id)}
                      className="absolute -top-2 -right-2 h-5 w-5 rounded-full bg-black/70 text-[10px] text-white/70 hover:bg-red-500 hover:text-white"
                      aria-label="Delete message"
                    >
                      ×
                    </button>
                  ) : null}
                </div>
              </div>
            );
          })
        )}

        <div ref={bottomRef} />
      </div>

      {/* composer */}
      <div className="border-t border-[var(--metal-border-soft)] bg-black/40 p-3 flex gap-2 items-end">
        <textarea
          ref={inputRef}
          value={newMessage}
          onChange={(e) => setNewMessage(e.target.value)}
          onKeyDown={handleKeyDown}
          rows={1}
          placeholder="Type a message… (Enter to send, Shift+Enter for new line)"
          className="flex-1 resize-none rounded bg-black/70 border border-[var(--metal-border-soft)] px-3 py-2 text-sm text-neutral-50 placeholder:text-neutral-500 focus:border-[var(--accent-copper-soft)] focus:outline-none"
        />
        <button
          onClick={() => void sendMessage()}
          disabled={sending || !newMessage.trim()}
          className="rounded-full border border-[var(--accent-copper-soft)] bg-black/70 px-4 py-2 text-sm font-semibold text-[var(--accent-copper-soft)] shadow-[0_10px_24px_rgba(0,0,0,0.85)] hover:bg-black/90 disabled:opacity-50"
        >
          {sending ? "Sending…" : "Send"}
        </button>
      </div>
    </div>
  );
}

===== FILE: ./features/inspections/lib/inspection/QuickJumpMenu.tsx =====
// src/components/inspection/QuickJumpMenu.tsx

import { InspectionSession } from "@inspections/lib/inspection/types";

interface QuickJumpMenuProps {
  session: InspectionSession;
  onJump: (sectionIndex: number, itemIndex: number) => void;
}

const QuickJumpMenu: React.FC<QuickJumpMenuProps> = ({ session, onJump }) => {
  return (
    <div className="flex flex-wrap gap-2 p-4 justify-center bg-gray-800 rounded-lg">
      {session.sections.map((section, sectionIndex) => (
        <div key={sectionIndex} className="text-sm">
          <div className="font-bold text-white mb-1">{section.title}</div>
          <div className="flex flex-wrap gap-1">
            {section.items.map((item, itemIndex) => (
              <button
                key={itemIndex}
                className="bg-gray-700 text-white px-2 py-1 rounded hover:bg-orange-600"
                onClick={() => onJump(sectionIndex, itemIndex)}
              >
                {item.item}
              </button>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
};

export default QuickJumpMenu;


===== FILE: ./features/inspections/lib/inspection/StatusButtons.tsx =====
"use client";

import type { InspectionItem, InspectionItemStatus } from "@inspections/lib/inspection/types";

type StatusButtonsProps = {
  item: InspectionItem;
  sectionIndex: number;
  itemIndex: number;
  updateItem: (
    sectionIndex: number,
    itemIndex: number,
    updates: Partial<InspectionItem>,
  ) => void;
  onStatusChange: (status: InspectionItemStatus) => void;
};

export default function StatusButtons(_props: any) {
  const {
    item,
    sectionIndex,
    itemIndex,
    updateItem,
    onStatusChange,
  } = _props as StatusButtonsProps;

  // Base: neutral until selected; strong focus ring for keyboard nav
  const base =
    "px-3 py-1 rounded text-xs font-bold mr-2 mb-2 transition-colors duration-150 " +
    "bg-zinc-700 text-zinc-200 hover:bg-zinc-600 focus:outline-none " +
    // focus ring that matches selected ring sizing/offset so it feels consistent
    "focus:ring-2 focus:ring-offset-2 focus:ring-offset-zinc-900";

  const selected = item.status;

  // Persistent ring + offset color per status
  const cls = (key: InspectionItemStatus) => {
    const isSel = selected === key;
    switch (key) {
      case "ok":
        return (
          base +
          (isSel
            ? " bg-green-600 text-white ring-2 ring-green-400 ring-offset-2 ring-offset-zinc-900"
            : " focus:ring-green-300")
        );
      case "fail":
        return (
          base +
          (isSel
            ? " bg-red-600 text-white ring-2 ring-red-400 ring-offset-2 ring-offset-zinc-900"
            : " focus:ring-red-300")
        );
      case "recommend":
        return (
          base +
          (isSel
            ? " bg-yellow-400 text-black ring-2 ring-yellow-300 ring-offset-2 ring-offset-zinc-900"
            : " focus:ring-yellow-300")
        );
      case "na":
      default:
        return (
          base +
          (isSel
            ? " bg-blue-600 text-white ring-2 ring-blue-400 ring-offset-2 ring-offset-zinc-900"
            : " focus:ring-blue-300")
        );
    }
  };

  const choose = (status: InspectionItemStatus) => {
    updateItem(sectionIndex, itemIndex, { status });
    onStatusChange(status);
  };

  const keyActivate = (
    status: InspectionItemStatus,
    e: React.KeyboardEvent<HTMLButtonElement>,
  ) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      choose(status);
    }
  };

  return (
    <div className="mt-2 flex flex-wrap">
      <button
        type="button"
        tabIndex={0}
        className={cls("ok")}
        onClick={() => choose("ok")}
        onKeyDown={(e) => keyActivate("ok", e)}
        aria-pressed={selected === "ok"}
        title="Mark OK"
      >
        OK
      </button>
      <button
        type="button"
        tabIndex={0}
        className={cls("fail")}
        onClick={() => choose("fail")}
        onKeyDown={(e) => keyActivate("fail", e)}
        aria-pressed={selected === "fail"}
        title="Mark FAIL"
      >
        FAIL
      </button>
      <button
        type="button"
        tabIndex={0}
        className={cls("recommend")}
        onClick={() => choose("recommend")}
        onKeyDown={(e) => keyActivate("recommend", e)}
        aria-pressed={selected === "recommend"}
        title="Mark Recommend"
      >
        Recommend
      </button>
      <button
        type="button"
        tabIndex={0}
        className={cls("na")}
        onClick={() => choose("na")}
        onKeyDown={(e) => keyActivate("na", e)}
        aria-pressed={selected === "na"}
        title="Mark N/A"
      >
        N/A
      </button>
    </div>
  );
}

===== FILE: ./features/inspections/lib/inspection/ui/CornerGrid.tsx =====
// shared/components/ui/CornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  unitHint?: (label: string) => string;
};

type CornerKey = "LF" | "RF" | "LR" | "RR";
type Side = "Left" | "Right";
type Region = "Front" | "Rear";

const cornerToRegion: Record<CornerKey, { side: Side; region: Region }> = {
  LF: { side: "Left", region: "Front" },
  RF: { side: "Right", region: "Front" },
  LR: { side: "Left", region: "Rear" },
  RR: { side: "Right", region: "Rear" },
};

const abbrevRE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const fullRE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

const metricOrder = [
  "Tire Pressure",
  "Tire Tread",
  "Brake Pad",
  "Rotor",
  "Rotor Condition",
  "Rotor Thickness",
  "Wheel Torque",
];
const orderIndex = (m: string) => {
  const i = metricOrder.findIndex((x) =>
    m.toLowerCase().includes(x.toLowerCase()),
  );
  return i === -1 ? Number.MAX_SAFE_INTEGER : i;
};

export default function CornerGrid({ sectionIndex, items, unitHint }: Props) {
  const { updateItem } = useInspectionForm();

  const parseCorner = (
    label: string,
  ): { corner: CornerKey | null; metric: string } => {
    let corner: CornerKey | null = null;
    let metric = "";

    const m1 = label.match(abbrevRE);
    if (m1?.groups) {
      corner = (m1.groups.corner.toUpperCase() as CornerKey) || null;
      metric = m1.groups.metric.trim();
      return { corner, metric };
    }

    const m2 = label.match(fullRE);
    if (m2?.groups) {
      const c = m2.groups.corner.toLowerCase();
      if (c === "left front") corner = "LF";
      if (c === "right front") corner = "RF";
      if (c === "left rear") corner = "LR";
      if (c === "right rear") corner = "RR";
      metric = m2.groups.metric.trim();
      return { corner, metric };
    }

    return { corner: null, metric: "" };
  };

  type MetricCell = {
    idx: number;
    metric: string;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };

  type RowTriplet = { metric: string; left?: MetricCell; right?: MetricCell };

  const groups = useMemo(() => {
    const byRegion = new Map<Region, Map<string, RowTriplet>>();
    const ensureRegion = (r: Region) =>
      byRegion.get(r) ?? byRegion.set(r, new Map()).get(r)!;

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const { corner, metric } = parseCorner(label);
      if (!corner) return;

      const { side, region } = cornerToRegion[corner];
      const reg = ensureRegion(region);

      const key = metric.toLowerCase();
      if (!reg.has(key)) reg.set(key, { metric });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: MetricCell = {
        idx,
        metric,
        unit,
        fullLabel: label,
        isPressure: /pressure/i.test(metric),
        initial: String(it.value ?? ""),
      };

      const row = reg.get(key)!;
      if (side === "Left") row.left = cell;
      else row.right = cell;
    });

    const sorted: Array<{ region: Region; rows: RowTriplet[] }> = [];
    (["Front", "Rear"] as Region[]).forEach((region) => {
      const reg = byRegion.get(region);
      if (!reg) return;
      const rows = Array.from(reg.values()).sort(
        (a, b) => orderIndex(a.metric) - orderIndex(b.metric),
      );
      sorted.push({ region, rows });
    });

    return sorted;
  }, [items, unitHint]);

  const [open, setOpen] = useState(true);
  const [showKpaHint, setShowKpaHint] = useState(true);

  const [, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });

  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    const has = value.trim().length > 0;
    setFilledMap((p) => (p[idx] === has ? p : { ...p, [idx]: has }));
  };

  const kpaFromPsi = (psiStr: string) => {
    const n = Number(psiStr);
    return isFinite(n) ? Math.round(n * 6.894757) : null;
  };

  const InputCell = ({
    idx,
    defaultValue,
    isPressure,
    unit,
  }: {
    idx: number;
    defaultValue: string;
    isPressure: boolean;
    unit: string;
  }) => {
    const kpaRef = useRef<HTMLSpanElement | null>(null);

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressure || !kpaRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpaHint) {
        kpaRef.current.textContent = "psi";
      } else if (k != null) {
        kpaRef.current.textContent = `psi (${k} kPa)`;
      } else {
        kpaRef.current.textContent = "psi (— kPa)";
      }
    };

    // seed text
    const seed = () => {
      if (!isPressure) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpaHint) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          name={`hyd-${idx}`}
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          autoCorrect="off"
          autoCapitalize="off"
          spellCheck={false}
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) => {
            if (e.key === "Enter") (e.currentTarget as HTMLInputElement).blur();
          }}
        />
        <span
          ref={kpaRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-[11px] text-neutral-400"
        >
          {seed()}
        </span>
      </div>
    );
  };

  const RegionCard = ({
    region,
    rows,
  }: {
    region: Region;
    rows: RowTriplet[];
  }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {region}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${region}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputCell
                    idx={row.left.idx}
                    defaultValue={row.left.initial}
                    isPressure={row.left.isPressure}
                    unit={row.left.unit}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputCell
                    idx={row.right.idx}
                    defaultValue={row.right.initial}
                    isPressure={row.right.isPressure}
                    unit={row.right.unit}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-end gap-3 px-1">
        <label className="flex items-center gap-2 select-none text-xs text-neutral-400">
          <input
            type="checkbox"
            className="h-3 w-3 accent-orange-500"
            checked={showKpaHint}
            onChange={(e) => setShowKpaHint(e.target.checked)}
            tabIndex={-1}
          />
          kPa hint
        </label>

        <button
          onClick={() => setOpen((v) => !v)}
          className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
          aria-expanded={open}
          title={open ? "Collapse" : "Expand"}
          tabIndex={-1}
        >
          {open ? "Collapse" : "Expand"}
        </button>
      </div>

      <div className="grid gap-4">
        {groups.map((g) => (
          <RegionCard key={g.region} region={g.region} rows={g.rows} />
        ))}
      </div>
    </div>
  );
}

===== FILE: ./features/inspections/lib/inspection/ui/AxlesCornerGrid.tsx =====
// shared/components/ui/AxlesCornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  /** Optional unit resolver when an item has no unit */
  unitHint?: (label: string) => string;
  /** Only shown (and used) for AIR mode */
  onAddAxle?: (axleLabel: string) => void;
};

/* ---------------------------- shared helpers ---------------------------- */

const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const HYD_FULL_RE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

type Side = "Left" | "Right";
type Region = "Front" | "Rear";
type CornerKey = "LF" | "RF" | "LR" | "RR";

const cornerToRegion: Record<CornerKey, { side: Side; region: Region }> = {
  LF: { side: "Left", region: "Front" },
  RF: { side: "Right", region: "Front" },
  LR: { side: "Left", region: "Rear" },
  RR: { side: "Right", region: "Rear" },
};

const normalizeCorner = (raw: string): CornerKey | null => {
  const s = raw.toLowerCase();
  if (s.startsWith("lf") || s === "left front") return "LF";
  if (s.startsWith("rf") || s === "right front") return "RF";
  if (s.startsWith("lr") || s === "left rear") return "LR";
  if (s.startsWith("rr") || s === "right rear") return "RR";
  return null;
};

const isPressureMetric = (label: string) => /pressure/i.test(label);
const kpaFromPsi = (psiStr: string) => {
  const n = Number(psiStr);
  return isFinite(n) ? Math.round(n * 6.894757) : null;
};

/* --------------------- strict ordering for AIR (matches steer) --------------------- */
const airPriority = (metric: string): [number, number] => {
  const m = metric.toLowerCase();

  if (/tire\s*pressure/i.test(m)) {
    const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
    return [0, second];
  }
  if (/(tire\s*)?tread\s*depth|tire\s*tread/i.test(m)) {
    const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
    return [1, second];
  }
  if (/(lining|shoe|pad)/i.test(m)) return [2, 0];
  if (/(drum|rotor)/i.test(m)) return [3, 0];
  if (/push\s*rod/i.test(m)) return [4, 0];
  if (/wheel\s*torque/i.test(m)) return [5, /inner/i.test(m) ? 1 : 0];
  return [99, 0];
};
const airCompare = (a: string, b: string) => {
  const [pa, sa] = airPriority(a);
  const [pb, sb] = airPriority(b);
  return pa !== pb ? pa - pb : sa - sb;
};

/* ---------------------- ordering for HYD (CornerGrid parity) ---------------------- */
const hydMetricOrder = [
  "Tire Pressure",
  "Tire Tread",
  "Brake Pad",
  "Rotor",
  "Rotor Condition",
  "Rotor Thickness",
  "Wheel Torque",
];
const hydCompare = (a: string, b: string) => {
  const ai = hydMetricOrder.findIndex((x) =>
    a.toLowerCase().includes(x.toLowerCase()),
  );
  const bi = hydMetricOrder.findIndex((x) =>
    b.toLowerCase().includes(x.toLowerCase()),
  );
  const A = ai === -1 ? Number.MAX_SAFE_INTEGER : ai;
  const B = bi === -1 ? Number.MAX_SAFE_INTEGER : bi;
  return A - B;
};

export default function AxlesCornerGrid({
  sectionIndex,
  items,
  unitHint,
  onAddAxle,
}: Props) {
  const { updateItem } = useInspectionForm();

  // Detect mode from the item labels
  const mode: "air" | "hyd" = useMemo(() => {
    for (const it of items) {
      const label = it.item ?? "";
      if (AIR_RE.test(label)) return "air";
      if (HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label)) return "hyd";
    }
    return "hyd"; // safe default
  }, [items]);

  /* ------------------------------------------------------------------ */
  /* HYDRAULIC (LF/RF/LR/RR) — matches CornerGrid layout                */
  /* ------------------------------------------------------------------ */

  type HydCell = {
    idx: number;
    metric: string;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type HydRow = { metric: string; left?: HydCell; right?: HydCell };

  const hydGroups = useMemo(() => {
    if (mode !== "hyd") return [] as Array<{ region: Region; rows: HydRow[] }>;

    const byRegion = new Map<Region, Map<string, HydRow>>();
    const ensureRegion = (r: Region) =>
      byRegion.get(r) ?? byRegion.set(r, new Map()).get(r)!;

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      let ck: CornerKey | null = null;
      let metric = "";

      const m1 = label.match(HYD_ABBR_RE);
      if (m1?.groups) {
        ck = normalizeCorner(m1.groups.corner);
        metric = m1.groups.metric.trim();
      } else {
        const m2 = label.match(HYD_FULL_RE);
        if (m2?.groups) {
          ck = normalizeCorner(m2.groups.corner);
          metric = m2.groups.metric.trim();
        }
      }
      if (!ck) return;

      const { side, region } = cornerToRegion[ck];
      const reg = ensureRegion(region);

      const key = metric.toLowerCase();
      if (!reg.has(key)) reg.set(key, { metric });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: HydCell = {
        idx,
        metric,
        unit,
        fullLabel: label,
        isPressure: isPressureMetric(metric),
        initial: String(it.value ?? ""),
      };

      const row = reg.get(key)!;
      if (side === "Left") row.left = cell;
      else row.right = cell;
    });

    const out: Array<{ region: Region; rows: HydRow[] }> = [];
    (["Front", "Rear"] as Region[]).forEach((region) => {
      const reg = byRegion.get(region);
      if (!reg) return;
      const rows = Array.from(reg.values()).sort((a, b) =>
        hydCompare(a.metric, b.metric),
      );
      out.push({ region, rows });
    });
    return out;
  }, [items, unitHint, mode]);

  /* ------------------------------------------------------------------ */
  /* AIR (Steer / Drive / Trailer … Left | Item | Right)                */
  /* ------------------------------------------------------------------ */

  type AirCell = {
    metric: string;
    idx: number;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type AirGroup = { axle: string; left: AirCell[]; right: AirCell[] };
  type AirRow = { metric: string; left?: AirCell; right?: AirCell };

  const isDualAxle = (axle: string) => {
    const a = axle.toLowerCase();
    if (a.startsWith("drive") || a.startsWith("trailer") || a.includes("rear"))
      return true;
    if (a.startsWith("tag") || a.startsWith("steer")) return false;
    return false;
  };

  const isDualizable = (metric: string) =>
    /tire\s*pressure/i.test(metric) ||
    /(tire\s*)?tread\s*depth|tire\s*tread/i.test(metric);
  const hasInnerOuter = (m: string) => /(inner|outer)/i.test(m);

  function expandDuals(axle: string, cells: AirCell[]): AirCell[] {
    if (!isDualAxle(axle)) return cells;
    const out: AirCell[] = [];
    for (const c of cells) {
      if (isDualizable(c.metric) && !hasInnerOuter(c.metric)) {
        const base = c.metric.replace(/\s*\((inner|outer)\)\s*/i, "").trim();
        out.push({ ...c, metric: `${base} (Outer)` });
        out.push({ ...c, metric: `${base} (Inner)` });
      } else {
        out.push(c);
      }
    }
    return out;
  }

  const airGroups = useMemo(() => {
    if (mode !== "air") return [] as AirGroup[];

    const byAxle = new Map<string, { Left: AirCell[]; Right: AirCell[] }>();

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const m = label.match(AIR_RE);
      if (!m?.groups) return;

      const axle = m.groups.axle.trim();
      const side = (m.groups.side as Side) || "Left";
      const metric = m.groups.metric.trim();

      if (!byAxle.has(axle)) byAxle.set(axle, { Left: [], Right: [] });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: AirCell = {
        metric,
        idx,
        unit,
        fullLabel: label,
        isPressure: isPressureMetric(metric),
        initial: String(it.value ?? ""),
      };

      byAxle.get(axle)![side].push(cell);
    });

    return Array.from(byAxle.entries()).map(([axle, sides]) => {
      const left = expandDuals(axle, sides.Left).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      const right = expandDuals(axle, sides.Right).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      return { axle, left, right };
    });
  }, [items, unitHint, mode]);

  // build rows for AIR like AirCornerGrid (merge left/right by metric)
  const airRowsPerAxle: Array<{ axle: string; rows: AirRow[] }> = useMemo(() => {
    if (mode !== "air") return [];
    const rows: Array<{ axle: string; rows: AirRow[] }> = [];

    for (const g of airGroups) {
      const map = new Map<string, AirRow>();
      const add = (c: AirCell, which: "left" | "right") => {
        const k = c.metric.toLowerCase();
        const existing = map.get(k) || { metric: c.metric };
        map.set(k, { ...existing, metric: c.metric, [which]: c } as AirRow);
      };
      g.left.forEach((c) => add(c, "left"));
      g.right.forEach((c) => add(c, "right"));
      const merged = Array.from(map.values()).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      rows.push({ axle: g.axle, rows: merged });
    }
    return rows;
  }, [airGroups, mode]);

  /* ---------------------------- UI state ---------------------------- */

  const [open, setOpen] = useState(true);
  const [showKpa, setShowKpa] = useState(true);
  const [filledMap, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });
  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    setFilledMap((p) =>
      p[idx] === !!value.trim() ? p : { ...p, [idx]: !!value.trim() },
    );
  };

  /* ------------------- shared input used by both modes ------------------ */

  const InputWithInlineUnit = ({
    idx,
    isPressureRow,
    unit,
    defaultValue,
  }: {
    idx: number;
    isPressureRow: boolean;
    unit: string;
    defaultValue: string;
  }) => {
    const spanRef = useRef<HTMLSpanElement | null>(null);

    const seedText = () => {
      if (!isPressureRow) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpa) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressureRow || !spanRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpa) {
        spanRef.current.textContent = "psi";
      } else if (k != null) {
        spanRef.current.textContent = `psi (${k} kPa)`;
      } else {
        spanRef.current.textContent = "psi (— kPa)";
      }
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) =>
            e.key === "Enter" &&
            (e.currentTarget as HTMLInputElement).blur()
          }
        />
        <span
          ref={spanRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 whitespace-nowrap text-[11px] text-neutral-400"
        >
          {seedText()}
        </span>
      </div>
    );
  };

  /* ---------------------------- HYD UI ---------------------------- */

  const HydRegionCard = ({ region, rows }: { region: Region; rows: HydRow[] }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {region}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${region}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputWithInlineUnit
                    idx={row.left.idx}
                    isPressureRow={row.left.isPressure}
                    unit={row.left.unit}
                    defaultValue={row.left.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputWithInlineUnit
                    idx={row.right.idx}
                    isPressureRow={row.right.isPressure}
                    unit={row.right.unit}
                    defaultValue={row.right.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  /* ----------------------------- AIR UI ----------------------------- */

  const AirAxleCard = ({ axle, rows }: { axle: string; rows: AirRow[] }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {axle}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${axle}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputWithInlineUnit
                    idx={row.left.idx}
                    isPressureRow={row.left.isPressure}
                    unit={row.left.unit}
                    defaultValue={row.left.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputWithInlineUnit
                    idx={row.right.idx}
                    isPressureRow={row.right.isPressure}
                    unit={row.right.unit}
                    defaultValue={row.right.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  const countFilled = (cells: Array<{ idx: number }>) =>
    cells.reduce((sum, c) => sum + (filledMap[c.idx] ? 1 : 0), 0);

  /* ------------------------------- render ------------------------------ */

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-between gap-3 px-1">
        {/* progress strip for AIR mode */}
        {mode === "air" ? (
          <div
            className="hidden text-xs text-neutral-400 md:block"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {airGroups.map((g, i) => {
              const filled = countFilled(g.left) + countFilled(g.right);
              const total = g.left.length + g.right.length;
              return (
                <span key={g.axle}>
                  {g.axle} {filled}/{total}
                  {i < airGroups.length - 1 ? "  |  " : ""}
                </span>
              );
            })}
          </div>
        ) : (
          <div />
        )}

        <div className="flex items-center gap-3">
          <label className="flex select-none items-center gap-2 text-xs text-neutral-300">
            <input
              type="checkbox"
              className="h-3 w-3 accent-orange-500"
              checked={showKpa}
              onChange={(e) => setShowKpa(e.target.checked)}
              tabIndex={-1}
            />
            kPa hint
          </label>

          <button
            onClick={() => setOpen((v) => !v)}
            className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
            title={open ? "Collapse" : "Expand"}
            tabIndex={-1}
          >
            {open ? "Collapse" : "Expand"}
          </button>
        </div>
      </div>

      {/* inline axle picker only for AIR and when provided */}
      {mode === "air" && onAddAxle && (
        <AddAxlePicker
          existingAxles={airGroups.map((g) => g.axle)}
          onAddAxle={onAddAxle}
        />
      )}

      {mode === "hyd" ? (
        <div className="grid gap-4">
          {hydGroups.map((g) => (
            <HydRegionCard key={g.region} region={g.region} rows={g.rows} />
          ))}
        </div>
      ) : (
        <>
          {airRowsPerAxle.map(({ axle, rows }) => (
            <AirAxleCard key={axle} axle={axle} rows={rows} />
          ))}
        </>
      )}
    </div>
  );
}

/* -------------------------- Add Axle (AIR only) -------------------------- */

function AddAxlePicker({
  existingAxles,
  onAddAxle,
}: {
  existingAxles: string[];
  onAddAxle: (axleLabel: string) => void;
}) {
  const [pending, setPending] = useState<string>("");

  const candidates = useMemo(() => {
    const wants: string[] = [];
    for (let i = 1; i <= 2; i++) wants.push(`Steer ${i}`);
    for (let i = 1; i <= 4; i++) wants.push(`Drive ${i}`);
    wants.push("Tag", "Trailer 1", "Trailer 2", "Trailer 3");
    return wants.filter((l) => !existingAxles.includes(l));
  }, [existingAxles]);

  return (
    <div className="flex items-center gap-2 px-1">
      <select
        className="rounded-lg border border-neutral-700 bg-neutral-900/80 px-2 py-1 text-sm text-white"
        value={pending}
        onChange={(e) => setPending(e.target.value)}
      >
        <option value="">Add axle…</option>
        {candidates.map((l) => (
          <option key={l} value={l}>
            {l}
          </option>
        ))}
      </select>
      <button
        className="rounded-lg bg-accent px-3 py-1 text-sm font-semibold text-black hover:bg-orange-500 disabled:opacity-40"
        onClick={() => pending && onAddAxle(pending)}
        disabled={!pending}
      >
        + Add
      </button>
    </div>
  );
}

===== FILE: ./features/inspections/lib/inspection/ui/AirCornerGrid.tsx =====
// shared/components/ui/AirCornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  unitHint?: (label: string) => string;
  onAddAxle?: (axleLabel: string) => void;
};

export default function AirCornerGrid({
  sectionIndex,
  items,
  unitHint,
  onAddAxle,
}: Props) {
  const { updateItem } = useInspectionForm();

  type Side = "Left" | "Right";
  const labelRe = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;

  type MetricCell = {
    metric: string;
    idx: number;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type AxleGroup = { axle: string; left: MetricCell[]; right: MetricCell[] };

  const airPriority = (metric: string): [number, number] => {
    const m = metric.toLowerCase();
    if (/tire\s*pressure/i.test(m)) {
      const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
      return [0, second];
    }
    if (/(tire\s*)?tread\s*depth|tire\s*tread/i.test(m)) {
      const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
      return [1, second];
    }
    if (/(lining|shoe|pad)/i.test(m)) return [2, 0];
    if (/(drum|rotor)/i.test(m)) return [3, 0];
    if (/push\s*rod/i.test(m)) return [4, 0];
    if (/wheel\s*torque/i.test(m)) return [5, /inner/i.test(m) ? 1 : 0];
    return [99, 0];
  };
  const orderCompare = (a: string, b: string) => {
    const [pa, sa] = airPriority(a);
    const [pb, sb] = airPriority(b);
    return pa !== pb ? pa - pb : sa - sb;
  };

  const isDualAxle = (axleLabel: string) => {
    const a = axleLabel.toLowerCase();
    if (a.startsWith("drive") || a.startsWith("trailer") || a.includes("rear"))
      return true;
    if (a.startsWith("tag") || a.startsWith("steer")) return false;
    return false;
  };

  const isDualizableMetric = (metric: string) =>
    /tire\s*pressure/i.test(metric) ||
    /(tire\s*)?tread\s*depth|tire\s*tread/i.test(metric);
  const hasInnerOuter = (metric: string) => /(inner|outer)/i.test(metric);

  function expandDuals(axle: string, cells: MetricCell[]): MetricCell[] {
    if (!isDualAxle(axle)) return cells;

    const out: MetricCell[] = [];
    for (const c of cells) {
      if (isDualizableMetric(c.metric) && !hasInnerOuter(c.metric)) {
        const base = c.metric.replace(/\s*\((inner|outer)\)\s*/i, "").trim();
        out.push({ ...c, metric: `${base} (Outer)` });
        out.push({ ...c, metric: `${base} (Inner)` });
      } else {
        out.push(c);
      }
    }
    return out;
  }

  const groups: AxleGroup[] = useMemo(() => {
    const byAxle = new Map<string, { Left: MetricCell[]; Right: MetricCell[] }>();

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const m = label.match(labelRe);
      if (!m?.groups) return;

      const axle = m.groups.axle.trim();
      const side = (m.groups.side as Side) || "Left";
      const metric = m.groups.metric.trim();

      if (!byAxle.has(axle)) byAxle.set(axle, { Left: [], Right: [] });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: MetricCell = {
        metric,
        idx,
        unit,
        fullLabel: label,
        isPressure: /pressure/i.test(metric),
        initial: String(it.value ?? ""),
      };

      byAxle.get(axle)![side].push(cell);
    });

    return Array.from(byAxle.entries()).map(([axle, sides]) => {
      const left = expandDuals(axle, sides.Left).sort((a, b) =>
        orderCompare(a.metric, b.metric),
      );
      const right = expandDuals(axle, sides.Right).sort((a, b) =>
        orderCompare(a.metric, b.metric),
      );
      return { axle, left, right };
    });
  }, [items, unitHint]);

  const [open, setOpen] = useState(true);
  const [showKpa, setShowKpa] = useState(true);

  const [filledMap, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });
  const count = (cells: MetricCell[]) =>
    cells.reduce((a, r) => a + (filledMap[r.idx] ? 1 : 0), 0);

  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    const has = value.trim().length > 0;
    setFilledMap((p) => (p[idx] === has ? p : { ...p, [idx]: has }));
  };

  const kpaFromPsi = (psiStr: string) => {
    const n = Number(psiStr);
    return isFinite(n) ? Math.round(n * 6.894757) : null;
  };

  type RowTriplet = { metric: string; left?: MetricCell; right?: MetricCell };

  const buildTriplets = (g: AxleGroup): RowTriplet[] => {
    const map = new Map<string, RowTriplet>();
    const add = (c: MetricCell, which: "left" | "right") => {
      const k = c.metric.toLowerCase();
      const existing = map.get(k) || { metric: c.metric };
      map.set(k, { ...existing, metric: c.metric, [which]: c });
    };
    g.left.forEach((c) => add(c, "left"));
    g.right.forEach((c) => add(c, "right"));
    return Array.from(map.values()).sort((a, b) =>
      orderCompare(a.metric, b.metric),
    );
  };

  const InputWithInlineUnit = ({
    idx,
    isPressure,
    unit,
    defaultValue,
    showKpaHint,
  }: {
    idx: number;
    isPressure: boolean;
    unit: string;
    defaultValue: string;
    showKpaHint: boolean;
  }) => {
    const spanRef = useRef<HTMLSpanElement | null>(null);

    const kSeed = () => {
      if (!isPressure) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpaHint) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressure || !spanRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpaHint) {
        spanRef.current.textContent = "psi";
      } else if (k != null) {
        spanRef.current.textContent = `psi (${k} kPa)`;
      } else {
        spanRef.current.textContent = "psi (— kPa)";
      }
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          name={`air-${idx}`}
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) =>
            e.key === "Enter" &&
            (e.currentTarget as HTMLInputElement).blur()
          }
        />
        <span
          ref={spanRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 whitespace-nowrap text-[11px] text-neutral-400"
        >
          {kSeed()}
        </span>
      </div>
    );
  };

  const AxleCard = ({ g }: { g: AxleGroup }) => {
    const rows = buildTriplets(g);
    return (
      <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
        <div
          className="mb-3 text-lg font-semibold text-accent"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
        >
          {g.axle}
        </div>

        <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
          <div>Left</div>
          <div className="text-center">Item</div>
          <div className="text-right">Right</div>
        </div>

        {open && (
          <div className="space-y-3">
            {rows.map((row, i) => {
              const leftUnit =
                row.left?.unit ??
                (unitHint ? unitHint(row.left?.fullLabel ?? "") : "") ??
                "";
              const rightUnit =
                row.right?.unit ??
                (unitHint ? unitHint(row.right?.fullLabel ?? "") : "") ??
                "";
              return (
                <div
                  key={`${row.metric}-${i}`}
                  className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
                >
                  <div>
                    {row.left ? (
                      <InputWithInlineUnit
                        idx={row.left.idx}
                        isPressure={row.left.isPressure}
                        unit={leftUnit}
                        defaultValue={row.left.initial}
                        showKpaHint={showKpa}
                      />
                    ) : (
                      <div className="h-[34px]" />
                    )}
                  </div>

                  <div
                    className="min-w-0 truncate text-center text-sm font-semibold text-white"
                    style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                    title={row.metric}
                  >
                    {row.metric}
                  </div>

                  <div className="justify-self-end">
                    {row.right ? (
                      <InputWithInlineUnit
                        idx={row.right.idx}
                        isPressure={row.right.isPressure}
                        unit={rightUnit}
                        defaultValue={row.right.initial}
                        showKpaHint={showKpa}
                      />
                    ) : (
                      <div className="h-[34px]" />
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-between gap-3 px-1">
        <div
          className="hidden text-xs text-neutral-400 md:block"
          style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
        >
          {groups.map((g, i) => {
            const filled = count(g.left) + count(g.right);
            const total = g.left.length + g.right.length;
            return (
              <span key={g.axle}>
                {g.axle} {filled}/{total}
                {i < groups.length - 1 ? "  |  " : ""}
              </span>
            );
          })}
        </div>

        <div className="flex items-center gap-3">
          <label className="flex select-none items-center gap-2 text-xs text-neutral-300">
            <input
              type="checkbox"
              className="h-3 w-3 accent-orange-500"
              checked={showKpa}
              onChange={(e) => setShowKpa(e.target.checked)}
              tabIndex={-1}
            />
            kPa hint
          </label>

          <button
            onClick={() => setOpen((v) => !v)}
            className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
            tabIndex={-1}
          >
            {open ? "Collapse" : "Expand"}
          </button>
        </div>
      </div>

      {onAddAxle && <AddAxlePicker groups={groups} onAddAxle={onAddAxle} />}

      {groups.map((g) => (
        <AxleCard key={g.axle} g={g} />
      ))}
    </div>
  );
}

/** Inline axle picker (same, but glassy) */
function AddAxlePicker({
  groups,
  onAddAxle,
}: {
  groups: { axle: string }[];
  onAddAxle: (axleLabel: string) => void;
}) {
  const existing = useMemo(() => groups.map((g) => g.axle), [groups]);
  const [pending, setPending] = useState<string>("");

  const candidates = useMemo(() => {
    const wants: string[] = [];
    for (let i = 1; i <= 2; i++) wants.push(`Steer ${i}`);
    for (let i = 1; i <= 4; i++) wants.push(`Drive ${i}`);
    wants.push("Tag", "Trailer 1", "Trailer 2", "Trailer 3");
    return wants.filter((l) => !existing.includes(l));
  }, [existing]);

  return (
    <div className="flex items-center gap-2 px-1">
      <select
        className="rounded-lg border border-neutral-700 bg-neutral-900/80 px-2 py-1 text-sm text-white"
        value={pending}
        onChange={(e) => setPending(e.target.value)}
      >
        <option value="">Add axle…</option>
        {candidates.map((l) => (
          <option key={l} value={l}>
            {l}
          </option>
        ))}
      </select>
      <button
        className="rounded-lg bg-accent px-3 py-1 text-sm font-semibold text-black hover:bg-orange-500 disabled:opacity-40"
        onClick={() => pending && onAddAxle(pending)}
        disabled={!pending}
      >
        + Add
      </button>
    </div>
  );
}

===== FILE: ./features/inspections/lib/inspection/ui/CustomerVehicleHeader.tsx =====
// features/inspections/lib/inspection/ui/CustomerVehicleHeader.tsx
"use client";



type Customer = {
  first_name?: string | null;
  last_name?: string | null;
  phone?: string | null;
  email?: string | null;
  address?: string | null;
  city?: string | null;
  province?: string | null;
  postal_code?: string | null;
};

type Vehicle = {
  year?: string | null;
  make?: string | null;
  model?: string | null;
  vin?: string | null;
  license_plate?: string | null;
  color?: string | null;
  mileage?: string | null;
  unit_number?: string | null;
  odometer?: string | null; // included since some pages pass this
};

type Props = {
  /** e.g. "Maintenance 50 (Hydraulic)" */
  templateName: string;
  customer?: Customer | null;
  vehicle?: Vehicle | null;
  /** Optional right-side content (buttons, etc.) */
  rightSlot?: React.ReactNode;
};

export default function CustomerVehicleHeader({
  templateName,
  customer,
  vehicle,
  rightSlot,
}: Props) {
  const fullName =
    [customer?.first_name, customer?.last_name].filter(Boolean).join(" ").trim() || "—";

  const addr =
    [customer?.address, customer?.city, customer?.province, customer?.postal_code]
      .filter(Boolean)
      .join(", ") || "";

  const vehicleLabel =
    [vehicle?.year, vehicle?.make, vehicle?.model].filter(Boolean).join(" ").trim() ||
    vehicle?.vin ||
    "—";

  const subBits = [
    vehicle?.license_plate ? `Plate: ${vehicle.license_plate}` : null,
    vehicle?.vin ? `VIN: ${vehicle.vin}` : null,
    vehicle?.unit_number ? `Unit: ${vehicle.unit_number}` : null,
    vehicle?.odometer ? `Odo: ${vehicle.odometer}` : null,
    vehicle?.mileage ? `Mileage: ${vehicle.mileage}` : null,
    vehicle?.color ? `Color: ${vehicle.color}` : null,
  ].filter(Boolean) as string[];

  return (
    <div className="mb-4 rounded-lg border border-zinc-800 bg-zinc-900 p-3">
      <div className="mb-2 flex items-start justify-between gap-3">
        <h1 className="text-xl font-bold text-orange-400">{templateName}</h1>
        {rightSlot ? <div className="shrink-0">{rightSlot}</div> : null}
      </div>

      <div className="grid gap-2 text-sm text-zinc-200 md:grid-cols-2">
        {/* Customer */}
        <div className="rounded border border-zinc-800 bg-zinc-950 p-2">
          <div className="text-zinc-400">Customer</div>
          <div className="font-medium">{fullName}</div>
          <div className="text-zinc-400">
            {[customer?.phone, customer?.email].filter(Boolean).join(" · ") || "—"}
          </div>
          {addr ? <div className="text-zinc-400">{addr}</div> : null}
        </div>

        {/* Vehicle */}
        <div className="rounded border border-zinc-800 bg-zinc-950 p-2">
          <div className="text-zinc-400">Vehicle</div>
          <div className="font-medium">{vehicleLabel}</div>
          <div className="text-zinc-400">{subBits.join(" · ") || "—"}</div>
        </div>
      </div>
    </div>
  );
}

===== FILE: ./features/inspections/lib/inspection/PhotoUploadButton.tsx =====
"use client";

import { useState } from "react";
import PhotoThumbnail from "@inspections/components/inspection/PhotoThumbnail";

// NOTE: Using `any` on the exported component props avoids Next's TS(71007)
// "Props must be serializable" check for function props starting with `on*`.
// We immediately cast inside for full type safety.
export default function PhotoUploadButton(props: any) {
  const { photoUrls, onChange } = props as {
    photoUrls: string[];
    onChange: (urls: string[]) => void;
  };

  const [urls, setUrls] = useState<string[]>(photoUrls ?? []);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files ?? []);
    if (!files.length) return;

    const newUrls = files.map((f) => URL.createObjectURL(f)); // swap with real upload later
    const updated = [...urls, ...newUrls];
    setUrls(updated);
    onChange(updated);
  };

  const handleRemove = (index: number) => {
    const updated = urls.filter((_, i) => i !== index);
    setUrls(updated);
    onChange(updated);
  };

  return (
    <div className="mt-2">
      <label className="text-xs text-white font-bold block mb-1">Upload Photos</label>

      <div className="flex flex-wrap">
        {urls.map((url, i) => (
          <PhotoThumbnail key={url + i} url={url} onRemove={() => handleRemove(i)} />
        ))}
      </div>

      <input
        type="file"
        multiple
        accept="image/*"
        onChange={handleFileChange}
        className="block mt-2 text-sm text-gray-300 file:rounded-full file:border-0
        file:text-sm file:font-semibold file:bg-orange-700 file:text-white
        hover:file:bg-orange-600"
      />
    </div>
  );
}

===== FILE: ./features/inspections/lib/inspection/InspectionItemCard.tsx =====
"use client";

import type React from "react";
import type {
  InspectionItem,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";
import StatusButtons from "./StatusButtons";
import PhotoUploadButton from "./PhotoUploadButton";
import PhotoThumbnail from "@inspections/components/inspection/PhotoThumbnail";

interface InspectionItemCardProps {
  item: InspectionItem;
  sectionIndex: number;
  itemIndex: number;
  showNotes: boolean;
  showPhotos: boolean;
  onUpdateNote: (sectionIndex: number, itemIndex: number, note: string) => void;
  onUpload: (photoUrl: string, sectionIndex: number, itemIndex: number) => void;
  onUpdateStatus: (
    sectionIndex: number,
    itemIndex: number,
    status: InspectionItemStatus,
  ) => void;
  onUpdateValue?: (
    sectionIndex: number,
    itemIndex: number,
    value: string,
  ) => void;
  onUpdateUnit?: (
    sectionIndex: number,
    itemIndex: number,
    unit: string,
  ) => void;
}

/**
 * NOTE: Accept `any` at the export boundary to avoid Next.js
 * “props must be serializable” warnings for Client Components that receive
 * function props. We cast to `InspectionItemCardProps` immediately for safety.
 */
export default function InspectionItemCard(_props: any) {
  const {
    item,
    sectionIndex,
    itemIndex,
    showNotes,
    showPhotos,
    onUpdateNote,
    onUpload,
    onUpdateStatus,
    onUpdateValue,
    onUpdateUnit,
  } = _props as InspectionItemCardProps;

  const name = item.item?.toLowerCase() || item.name?.toLowerCase() || "";
  const isMeasurementItem =
    name.includes("wheel torque") || name.includes("park lining");

  return (
    <div className="rounded-md border border-zinc-800 bg-zinc-950 p-3">
      {/* Compact two-column layout: left = title + controls, right = single bordered notes */}
      <div className="grid gap-3 md:grid-cols-2">
        <div className="min-w-0">
          <h3 className="truncate text-base font-semibold text-white">
            {item.item ?? item.name}
          </h3>

          {isMeasurementItem ? (
            <div className="mt-2 flex gap-2">
              <input
                type="number"
                value={item.value ?? ""}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                  onUpdateValue?.(sectionIndex, itemIndex, e.target.value)
                }
                placeholder="Value"
                className="w-24 rounded border border-zinc-700 bg-zinc-800 px-2 py-1 text-white"
              />
              <input
                type="text"
                value={item.unit ?? ""}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                  onUpdateUnit?.(sectionIndex, itemIndex, e.target.value)
                }
                placeholder="Unit"
                className="w-20 rounded border border-zinc-700 bg-zinc-800 px-2 py-1 text-white"
              />
            </div>
          ) : (
            <StatusButtons
              item={item}
              sectionIndex={sectionIndex}
              itemIndex={itemIndex}
              updateItem={(
                secIdx: number,
                itmIdx: number,
                updates: Partial<InspectionItem>,
              ) => {
                if (updates.status) {
                  onUpdateStatus(secIdx, itmIdx, updates.status);
                }
              }}
              onStatusChange={(status: InspectionItemStatus) =>
                onUpdateStatus(sectionIndex, itemIndex, status)
              }
            />
          )}
        </div>

        {showNotes && (
          <div className="min-w-0">
            <textarea
              className="h-[44px] w-full resize-y rounded border border-zinc-700 bg-black/60 px-2 py-2 text-white outline-none placeholder:text-zinc-400"
              placeholder="Enter notes..."
              value={item.notes || ""}
              onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
                onUpdateNote(sectionIndex, itemIndex, e.target.value)
              }
            />
          </div>
        )}
      </div>

      {showPhotos && (item.status === "fail" || item.status === "recommend") && (
        <div className="mt-2">
          <PhotoUploadButton
            photoUrls={item.photoUrls ?? []}
            onChange={(urls: string[]) => {
              const newUrl = urls[urls.length - 1];
              if (newUrl) onUpload(newUrl, sectionIndex, itemIndex);
            }}
          />
          {Array.isArray(item.photoUrls) && item.photoUrls.length > 0 && (
            <div className="mt-2 flex gap-2 overflow-x-auto">
              {item.photoUrls.map((url, i) => (
                <PhotoThumbnail key={url + i} url={url} />
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

===== FILE: ./features/inspections/screens/Maintenance50Screen.tsx =====
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/lib/inspection/ui/CornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* ---------- Props for screen usage (modal + page) ---------- */
type ScreenProps = {
  embed?: boolean;
  template?: string;
  params?: Record<string, string | number | boolean | null | undefined>;
};

/* ---------- Sections ---------- */
function buildHydraulicMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Hydraulic)",
    items: [
      { item: "LF Tire Pressure", unit: "psi", value: "" },
      { item: "RF Tire Pressure", unit: "psi", value: "" },
      { item: "LR Tire Pressure", unit: "psi", value: "" },
      { item: "RR Tire Pressure", unit: "psi", value: "" },
      { item: "LF Tire Tread", unit: "mm", value: "" },
      { item: "RF Tire Tread", unit: "mm", value: "" },
      { item: "LR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "LR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "LF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "LR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "Wheel Torque (after road test)", unit: "ft·lb", value: "" },
    ],
  };
}
function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}
function buildBrakesSection(): InspectionSection {
  return {
    title: "Brakes",
    items: [
      { item: "Front brake pads" },
      { item: "Rear brake pads" },
      { item: "Brake fluid level" },
      { item: "Brake lines and hoses" },
      { item: "ABS wiring / sensors" },
      { item: "Brake warning lights" },
    ],
  };
}
function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
    ],
  };
}
function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "CV shafts / joints" },
      { item: "Transmission leaks / mounts" },
      { item: "Transfer case leaks / mounts" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* ---------- Units helpers ---------- */
function unitForHydraulic(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tire tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad thickness")) return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}
function applyUnitsHydraulic(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    if ((s.title || "").toLowerCase().includes("measurements")) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForHydraulic(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }
    return s;
  });
}

/* ---------- Screen (component) ---------- */
export default function Maintenance50Screen(props: ScreenProps): JSX.Element {
  const searchParams = useSearchParams();
  const p = props.params ?? {};
  const rootRef = useRef<HTMLDivElement | null>(null);

  const get = (k: string): string => {
    const v = p[k];
    if (v !== undefined && v !== null) return String(v);
    return searchParams.get(k) ?? "";
  };

  // 🔸 only mobile companion gets voice
  const isMobileView =
    (get("view") || "").toLowerCase() === "mobile";

  const isEmbed =
    !!props.embed ||
    ["1", "true", "yes"].includes(
      (get("embed") || get("compact")).toLowerCase()
    );

  const workOrderLineId = get("workOrderLineId") || null;
  const workOrderId = get("workOrderId") || null;
  const inspectionId = useMemo<string>(
    () => get("inspectionId") || uuidv4(),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string = props.template || get("template") || "Maintenance 50";

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      sections: [],
    }),
    [inspectionId, templateName]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  // ---- AI submit guarding ----
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // ---- boot/restore ----
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // persist
  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        localStorage.setItem(key, JSON.stringify(session ?? initialSession));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // build sections once
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;
    const next: InspectionSection[] = [
      buildHydraulicMeasurementsSection(),
      buildLightsSection(),
      buildBrakesSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsHydraulic(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  // re-apply units
  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsHydraulic(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  // transcript → commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // speech
  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };
  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  /* 🧹 embed-safe scrubber (remove full-screen / overflow locks) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  /* 🔐 focus trap while embedded (keep Tab inside) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-sm text-neutral-300">Loading inspection…</div>;
  }

  const isMeasurements = (t?: string): boolean =>
    (t || "").toLowerCase().includes("measurements");

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const Body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Maintenance 50"}
          </div>
        </div>
      </div>

      {/* Controls */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              try {
                recognitionRef.current?.stop();
              } catch {}
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              recognitionRef.current = startVoiceRecognition(handleTranscript);
            }}
            recognitionInstance={
              recognitionRef.current as unknown as SpeechRecognition | null
            }
            onTranscript={handleTranscript}
            setRecognitionRef={(instance: SpeechRecognition | null): void => {
              (
                recognitionRef as React.MutableRefObject<SpeechRecognition | null>
              ).current = instance ?? null;
            }}
          />
        )}

        {/* Unit toggle on all views */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      {/* Sections */}
      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isMeasurements(section.title) && (
              <span className={hint}>
                {unit === "metric"
                  ? "Enter mm / kPa / N·m"
                  : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className="mt-4">
              {isMeasurements(section.title) ? (
                <CornerGrid sectionIndex={sectionIndex} items={section.items} />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes
                  showPhotos
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(
                    secIdx: number,
                    itemIdx: number,
                    note: string
                  ): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(
                    photoUrl: string,
                    secIdx: number,
                    itemIdx: number
                  ): void => {
                    const prev =
                      session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, {
                      photoUrls: [...prev, photoUrl],
                    });
                  }}
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) =>
                    void submitAIForItem(secIdx, itemIdx)
                  }
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      {/* Footer */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Maintenance 50"}
      description="Quick 50-point hydraulic brake maintenance inspection."
    >
      {Body}
    </PageShell>
  );
}

===== FILE: ./features/inspections/screens/Maintenance50AirScreen.tsx =====
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/lib/inspection/ui/CornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* ---------- Props for screen usage (modal + page) ---------- */
type ScreenProps = {
  embed?: boolean;
  template?: string;
  params?: Record<string, string | number | boolean | null | undefined>;
};

/* ---------- Sections ---------- */
function buildHydraulicMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Hydraulic)",
    items: [
      { item: "LF Tire Pressure", unit: "psi", value: "" },
      { item: "RF Tire Pressure", unit: "psi", value: "" },
      { item: "LR Tire Pressure", unit: "psi", value: "" },
      { item: "RR Tire Pressure", unit: "psi", value: "" },
      { item: "LF Tire Tread", unit: "mm", value: "" },
      { item: "RF Tire Tread", unit: "mm", value: "" },
      { item: "LR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "LR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "LF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "LR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "Wheel Torque (after road test)", unit: "ft·lb", value: "" },
    ],
  };
}
function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}
function buildBrakesSection(): InspectionSection {
  return {
    title: "Brakes",
    items: [
      { item: "Front brake pads" },
      { item: "Rear brake pads" },
      { item: "Brake fluid level" },
      { item: "Brake lines and hoses" },
      { item: "ABS wiring / sensors" },
      { item: "Brake warning lights" },
    ],
  };
}
function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
    ],
  };
}
function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "CV shafts / joints" },
      { item: "Transmission leaks / mounts" },
      { item: "Transfer case leaks / mounts" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* ---------- Units helpers ---------- */
function unitForHydraulic(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tire tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad thickness")) return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}
function applyUnitsHydraulic(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    if ((s.title || "").toLowerCase().includes("measurements")) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForHydraulic(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }
    return s;
  });
}

/* ---------- Screen (component) ---------- */
export default function Maintenance50Screen(props: ScreenProps): JSX.Element {
  const searchParams = useSearchParams();
  const p = props.params ?? {};
  const rootRef = useRef<HTMLDivElement | null>(null);

  const get = (k: string): string => {
    const v = p[k];
    if (v !== undefined && v !== null) return String(v);
    return searchParams.get(k) ?? "";
  };

  // 🔸 only mobile companion gets voice
  const isMobileView =
    (get("view") || "").toLowerCase() === "mobile";

  const isEmbed =
    !!props.embed ||
    ["1", "true", "yes"].includes(
      (get("embed") || get("compact")).toLowerCase()
    );

  const workOrderLineId = get("workOrderLineId") || null;
  const workOrderId = get("workOrderId") || null;
  const inspectionId = useMemo<string>(
    () => get("inspectionId") || uuidv4(),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string = props.template || get("template") || "Maintenance 50";

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      sections: [],
    }),
    [inspectionId, templateName]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  // ---- AI submit guarding ----
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // ---- boot/restore ----
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // persist
  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        localStorage.setItem(key, JSON.stringify(session ?? initialSession));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // build sections once
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;
    const next: InspectionSection[] = [
      buildHydraulicMeasurementsSection(),
      buildLightsSection(),
      buildBrakesSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsHydraulic(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  // re-apply units
  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsHydraulic(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  // transcript → commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // speech
  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };
  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  /* 🧹 embed-safe scrubber (remove full-screen / overflow locks) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  /* 🔐 focus trap while embedded (keep Tab inside) */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-sm text-neutral-300">Loading inspection…</div>;
  }

  const isMeasurements = (t?: string): boolean =>
    (t || "").toLowerCase().includes("measurements");

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const Body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Maintenance 50"}
          </div>
        </div>
      </div>

      {/* Controls */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              try {
                recognitionRef.current?.stop();
              } catch {}
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              recognitionRef.current = startVoiceRecognition(handleTranscript);
            }}
            recognitionInstance={
              recognitionRef.current as unknown as SpeechRecognition | null
            }
            onTranscript={handleTranscript}
            setRecognitionRef={(instance: SpeechRecognition | null): void => {
              (
                recognitionRef as React.MutableRefObject<SpeechRecognition | null>
              ).current = instance ?? null;
            }}
          />
        )}

        {/* Unit toggle on all views */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      {/* Sections */}
      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isMeasurements(section.title) && (
              <span className={hint}>
                {unit === "metric"
                  ? "Enter mm / kPa / N·m"
                  : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className="mt-4">
              {isMeasurements(section.title) ? (
                <CornerGrid sectionIndex={sectionIndex} items={section.items} />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes
                  showPhotos
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(
                    secIdx: number,
                    itemIdx: number,
                    note: string
                  ): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(
                    photoUrl: string,
                    secIdx: number,
                    itemIdx: number
                  ): void => {
                    const prev =
                      session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, {
                      photoUrls: [...prev, photoUrl],
                    });
                  }}
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) =>
                    void submitAIForItem(secIdx, itemIdx)
                  }
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      {/* Footer */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Maintenance 50"}
      description="Quick 50-point hydraulic brake maintenance inspection."
    >
      {Body}
    </PageShell>
  );
}

===== FILE: ./features/inspections/app/inspection/customer-vehicle/page.tsx =====
"use client";

import { useRouter, useSearchParams } from "next/navigation";
import { useState } from "react";

export default function CustomerVehicleFormPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const inspectionType = searchParams.get("inspectionType") || "maintenance50";

  const [customer, setCustomer] = useState({
    first_name: "",
    last_name: "",
    phone: "",
    email: "",
  });

  const [vehicle, setVehicle] = useState({
    year: "",
    make: "",
    model: "",
    vin: "",
    license_plate: "",
    mileage: "",
    color: "",
  });

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement>,
    type: "customer" | "vehicle",
  ) => {
    const { name, value } = e.target;
    if (type === "customer") {
      setCustomer((prev) => ({ ...prev, [name]: value }));
    } else {
      setVehicle((prev) => ({ ...prev, [name]: value }));
    }
  };

  const handleStart = async () => {
    if (
      !customer.first_name ||
      !customer.last_name ||
      !vehicle.make ||
      !vehicle.model
    ) {
      alert("Please fill in all required fields.");
      return;
    }

    try {
      const res = await fetch("/api/inspection/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          customer,
          vehicle,
        }),
      });

      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.error || "Save failed");
      }

      // Save locally for inspection usage
      localStorage.setItem("inspectionCustomer", JSON.stringify(customer));
      localStorage.setItem("inspectionVehicle", JSON.stringify(vehicle));

      // Navigate to inspection page with inspectionId
      alert("Customer and vehicle saved. Starting inspection...");
      router.push(`/inspection/${inspectionType}?id=${data.inspectionId}`);
    } catch (err) {
      console.error("Failed to start inspection:", err);
      alert("Something went wrong while starting the inspection.");
    }
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Enter Customer & Vehicle Info</h1>

      {/* Customer Info */}
      <div>
        <input
          type="text"
          name="first_name"
          placeholder="First Name"
          value={customer.first_name}
          onChange={(e) => handleChange(e, "customer")}
          className="input"
        />
        <input
          type="text"
          name="last_name"
          placeholder="Last Name"
          value={customer.last_name}
          onChange={(e) => handleChange(e, "customer")}
          className="input"
        />
        <input
          type="text"
          name="phone"
          placeholder="Phone"
          value={customer.phone}
          onChange={(e) => handleChange(e, "customer")}
          className="input"
        />
        <input
          type="email"
          name="email"
          placeholder="Email"
          value={customer.email}
          onChange={(e) => handleChange(e, "customer")}
          className="input"
        />
      </div>

      {/* Vehicle Info */}
      <div>
        <input
          type="text"
          name="year"
          placeholder="Year"
          value={vehicle.year}
          onChange={(e) => handleChange(e, "vehicle")}
          className="input"
        />
        <input
          type="text"
          name="make"
          placeholder="Make"
          value={vehicle.make}
          onChange={(e) => handleChange(e, "vehicle")}
          className="input"
        />
        <input
          type="text"
          name="model"
          placeholder="Model"
          value={vehicle.model}
          onChange={(e) => handleChange(e, "vehicle")}
          className="input"
        />
        <input
          type="text"
          name="vin"
          placeholder="VIN"
          value={vehicle.vin}
          onChange={(e) => handleChange(e, "vehicle")}
          className="input"
        />
        <input
          type="text"
          name="license_plate"
          placeholder="License Plate"
          value={vehicle.license_plate}
          onChange={(e) => handleChange(e, "vehicle")}
          className="input"
        />
        <input
          type="text"
          name="mileage"
          placeholder="Mileage"
          value={vehicle.mileage}
          onChange={(e) => handleChange(e, "vehicle")}
          className="input"
        />
        <input
          type="text"
          name="color"
          placeholder="Color"
          value={vehicle.color}
          onChange={(e) => handleChange(e, "vehicle")}
          className="input"
        />
      </div>

      <button
        type="button"
        onClick={handleStart}
        className="bg-orange-500 hover:bg-orange-600 text-white text-lg font-bold px-6 py-3 rounded w-full"
      >
        Start Inspection
      </button>
    </div>
  );
}


===== FILE: ./features/inspections/app/inspection/maintenance50/page.tsx =====
// features/inspections/app/inspection/maintenance50/page.tsx
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/lib/inspection/ui/CornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";

import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import toast from "react-hot-toast";

/* Header adapters */
type HeaderCustomer = {
  first_name: string;
  last_name: string;
  phone: string;
  email: string;
  address: string;
  city: string;
  province: string;
  postal_code: string;
};

type HeaderVehicle = {
  year: string;
  make: string;
  model: string;
  vin: string;
  license_plate: string;
  mileage: string;
  color: string;
  unit_number: string;
  engine_hours: string;
};

function toHeaderCustomer(c?: SessionCustomer | null): HeaderCustomer {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}

function toHeaderVehicle(v?: SessionVehicle | null): HeaderVehicle {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/* Sections */
function buildHydraulicMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Hydraulic)",
    items: [
      { item: "LF Tire Pressure", unit: "psi", value: "" },
      { item: "RF Tire Pressure", unit: "psi", value: "" },
      { item: "LR Tire Pressure", unit: "psi", value: "" },
      { item: "RR Tire Pressure", unit: "psi", value: "" },
      { item: "LF Tire Tread", unit: "mm", value: "" },
      { item: "RF Tire Tread", unit: "mm", value: "" },
      { item: "LR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "LR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Outer)", unit: "mm", value: "" },
      { item: "RR Tire Tread (Inner)", unit: "mm", value: "" },
      { item: "LF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RF Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "RR Brake Pad Thickness", unit: "mm", value: "" },
      { item: "LF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RF Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "LR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "RR Rotor Condition / Thickness", unit: "mm", value: "" },
      { item: "Wheel Torque (after road test)", unit: "ft·lb", value: "" },
    ],
  };
}
function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}
function buildBrakesSection(): InspectionSection {
  return {
    title: "Brakes",
    items: [
      { item: "Front brake pads" },
      { item: "Rear brake pads" },
      { item: "Brake fluid level" },
      { item: "Brake lines and hoses" },
      { item: "ABS wiring / sensors" },
      { item: "Brake warning lights" },
    ],
  };
}
function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
    ],
  };
}
function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "CV shafts / joints" },
      { item: "Transmission leaks / mounts" },
      { item: "Transfer case leaks / mounts" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* Units helpers */
function unitForHydraulic(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tire tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad thickness")) return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}
function applyUnitsHydraulic(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    if ((s.title || "").toLowerCase().includes("measurements")) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForHydraulic(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }
    return s;
  });
}

/* Page */
export default function Maintenance50HydraulicPage(): JSX.Element {
  const searchParams = useSearchParams();

  // embed mode in iframe
  const isEmbed = useMemo(
    () =>
      ["1", "true", "yes"].includes(
        (searchParams.get("embed") || searchParams.get("compact") || "").toLowerCase()
      ),
    [searchParams]
  );

  const workOrderLineId = searchParams.get("workOrderLineId") || null;
  const workOrderId = searchParams.get("workOrderId") || null;
  const inspectionId = useMemo<string>(
    () => searchParams.get("inspectionId") || uuidv4(),
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string =
    searchParams.get("template") || "Maintenance 50 (Hydraulic)";

  const customer: SessionCustomer = {
    first_name: searchParams.get("first_name") || "",
    last_name: searchParams.get("last_name") || "",
    phone: searchParams.get("phone") || "",
    email: searchParams.get("email") || "",
    address: searchParams.get("address") || "",
    city: searchParams.get("city") || "",
    province: searchParams.get("province") || "",
    postal_code: searchParams.get("postal_code") || "",
  };

  const vehicle: SessionVehicle = {
    year: searchParams.get("year") || "",
    make: searchParams.get("make") || "",
    model: searchParams.get("model") || "",
    vin: searchParams.get("vin") || "",
    license_plate: searchParams.get("license_plate") || "",
    mileage: searchParams.get("mileage") || "",
    color: searchParams.get("color") || "",
    unit_number: searchParams.get("unit_number") || "",
    engine_hours: searchParams.get("engine_hours") || "",
  };

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  // prevent duplicate AI submits
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      // 1) placeholder for local quote UI
      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      // 2) AI suggestion with vehicle context
      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      // 3) Persist to WO (awaiting approval)
      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // Boot / restore
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Persist session
  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  // Persist on unload/visibility
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // Build sections on first load
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;
    const next: InspectionSection[] = [
      buildHydraulicMeasurementsSection(),
      buildLightsSection(),
      buildBrakesSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsHydraulic(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  // Apply units when toggled
  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsHydraulic(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  // Header backfill via API when launched from FocusedJobModal
  useEffect(() => {
    (async () => {
      if (!session || !workOrderId) return;
      const haveName =
        (session.customer?.first_name || session.customer?.last_name || "").trim().length > 0;
      const haveVehicle =
        (session.vehicle?.make || session.vehicle?.model || "").trim().length > 0;
      if (haveName && haveVehicle) return;

      try {
        const res = await fetch(`/api/work-orders/header?id=${workOrderId}`);
        if (!res.ok) return;

        const j = (await res.json()) as {
          customer?: Partial<SessionCustomer>;
          vehicle?: Partial<SessionVehicle>;
        };

        const nextCust: Partial<SessionCustomer> = {
          ...(session.customer ?? {}),
          ...(j.customer ?? {}),
        };
        const nextVeh: Partial<SessionVehicle> = {
          ...(session.vehicle ?? {}),
          ...(j.vehicle ?? {}),
        };

        updateInspection({
          customer: nextCust,
          vehicle: nextVeh,
        } as Partial<InspectionSession>);
      } catch {
        // silent fail
      }
    })();
  }, [session, workOrderId, updateInspection]);

  // Transcript handler
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;

    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // Start listening
  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };

  // stop on unmount
  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-white">Loading inspection…</div>;
  }

  const isMeasurements = (t?: string): boolean =>
    (t || "").toLowerCase().includes("measurements");

  // ------- Bare embed: NO app chrome when isEmbed -------
  const shell = isEmbed ? "mx-auto max-w-[1100px] px-3 pb-8" : "px-4 pb-14";
  const controlsGap = "mb-4 grid grid-cols-3 gap-2";
  const card =
    "rounded-lg border border-zinc-800 bg-zinc-900 " +
    (isEmbed ? "p-3 mb-6" : "p-4 mb-8");
  const sectionTitle = "text-xl font-semibold text-orange-400 text-center";
  const hint = "text-xs text-zinc-400" + (isEmbed ? " mt-1 block text-center" : "");

  // ----- BODY -----
  const Body = (
    <div className={shell}>
      {/* Hide global chrome if embedded */}
      {isEmbed && (
        <>
          {/* Add marker classes + robust, persistent chrome hider */}
          <script
            dangerouslySetInnerHTML={{
              __html: `
                (function(){
                  var html = document.documentElement;
                  var body = document.body || document.getElementsByTagName('body')[0];
                  html && html.classList.add('inspection-embed');
                  body && body.classList.add('inspection-embed');

                  var CSS = \`
                    html.inspection-embed, body.inspection-embed { background:#000 !important; overflow:auto !important; }

                    /* Hide common app chrome */
                    .inspection-embed header,
                    .inspection-embed nav,
                    .inspection-embed aside,
                    .inspection-embed footer,
                    .inspection-embed [data-app-chrome],
                    .inspection-embed [data-app-header],
                    .inspection-embed [data-app-nav],
                    .inspection-embed [data-app-sidebar],
                    .inspection-embed [data-app-footer],
                    .inspection-embed .app-shell,
                    .inspection-embed .app-shell-nav,
                    .inspection-embed .app-shell-header,
                    .inspection-embed .app-shell-footer,
                    .inspection-embed .app-sidebar,
                    .inspection-embed .app-topbar,
                    .inspection-embed .nav-tabs,
                    .inspection-embed .tabs-bar,
                    .inspection-embed .dashboard-tabs,
                    .inspection-embed .global-nav,
                    .inspection-embed .global-header,
                    .inspection-embed .global-footer {
                      display: none !important;
                      visibility: hidden !important;
                    }

                    /* Let the page content expand edge-to-edge */
                    .inspection-embed main,
                    .inspection-embed [data-app-content],
                    .inspection-embed .app-content,
                    .inspection-embed #__next > *:not(main) {
                      margin: 0 !important;
                      padding: 0 !important;
                      width: 100% !important;
                      max-width: none !important;
                    }

                    /* Guard against fixed headers/footers */
                    .inspection-embed *[style*="position: fixed"],
                    .inspection-embed *[style*="position:sticky"] {
                      display: none !important;
                    }
                  \`;

                  var s = document.createElement('style');
                  s.setAttribute('data-inspection-embed-style','1');
                  s.type = 'text/css';
                  s.appendChild(document.createTextNode(CSS));
                  document.head.appendChild(s);

                  /* MutationObserver to re-hide chrome if layouts mount late */
                  var targets = [
                    document.body,
                    document.querySelector('#__next'),
                    document.documentElement
                  ].filter(Boolean);

                  var again = function() {
                    if (!document.querySelector('style[data-inspection-embed-style]')) {
                      var s2 = document.createElement('style');
                      s2.setAttribute('data-inspection-embed-style','1');
                      s2.type = 'text/css';
                      s2.appendChild(document.createTextNode(CSS));
                      document.head.appendChild(s2);
                    }
                  };

                  var mo = new MutationObserver(function() { again(); });
                  targets.forEach(function(t){
                    try { mo.observe(t, { childList: true, subtree: true, attributes: true }); } catch(e){}
                  });
                })();
              `,
            }}
          />
        </>
      )}

      <div className={card}>
        <div className="text-center text-lg font-semibold text-orange-400">
          {templateName}
        </div>
        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      <div className={controlsGap}>
        <StartListeningButton
          isListening={isListening}
          setIsListening={setIsListening}
          onStart={startListening}
        />
        <PauseResumeButton
          isPaused={isPaused}
          isListening={isListening}
          setIsListening={setIsListening}
          onPause={(): void => {
            setIsPaused(true);
            pauseSession();
            try {
              recognitionRef.current?.stop();
            } catch {}
          }}
          onResume={(): void => {
            setIsPaused(false);
            resumeSession();
            recognitionRef.current = startVoiceRecognition(handleTranscript);
          }}
          recognitionInstance={recognitionRef.current as unknown as SpeechRecognition | null}
          onTranscript={handleTranscript}
          setRecognitionRef={(instance: SpeechRecognition | null): void => {
            (recognitionRef as React.MutableRefObject<SpeechRecognition | null>).current =
              instance ?? null;
          }}
        />
        <button
          onClick={(): void => setUnit(unit === "metric" ? "imperial" : "metric")}
          className="w-full rounded bg-zinc-700 py-2 text-white hover:bg-zinc-600"
        >
          Unit: {unit === "metric" ? "Metric" : "Imperial"}
        </button>
      </div>

      <ProgressTracker
        currentItem={session.currentItemIndex}
        currentSection={session.currentSectionIndex}
        totalSections={session.sections.length}
        totalItems={session.sections[session.currentSectionIndex]?.items.length || 0}
      />

      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={card}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isMeasurements(section.title) && (
              <span className={hint}>
                {unit === "metric" ? "Enter mm / kPa / N·m" : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className={isEmbed ? "mt-3" : "mt-4"}>
              {isMeasurements(section.title) ? (
                <CornerGrid sectionIndex={sectionIndex} items={section.items} />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes={true}
                  showPhotos={true}
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    // Only update status here — AI flow moved to explicit Submit
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(secIdx: number, itemIdx: number, note: string): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(photoUrl: string, secIdx: number, itemIdx: number): void => {
                    const prev = session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, { photoUrls: [...prev, photoUrl] });
                  }}
                  /* require note + explicit submit to run AI */
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) => {
                    void submitAIForItem(secIdx, itemIdx);
                  }}
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      <div
        className={
          "flex items-center justify-between gap-4 " + (isEmbed ? "mt-6" : "mt-8")
        }
      >
        {/* Pass workOrderLineId down; disable when missing */}
        <div className="flex items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
        </div>

        {!workOrderLineId && (
          <div className="text-xs text-red-400">
            Missing <code>workOrderLineId</code> in URL — save/finish will be blocked.
          </div>
        )}

        <div className="ml-auto text-xs text-zinc-400">
          P = PASS, F = FAIL, NA = Not Applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;
  return Body;
}

===== FILE: ./features/inspections/app/inspection/maintenance50-air/page.tsx =====
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import AirCornerGrid from "@inspections/lib/inspection/ui/AirCornerGrid";
import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";

import { buildAirAxleItems } from "@inspections/lib/inspection/builders/addAxleHelpers";
import { startVoiceRecognition } from "@inspections/lib/inspection/voiceControl";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* ------------------------------ Header adapters ------------------------------ */
type HeaderCustomer = {
  first_name: string;
  last_name: string;
  phone: string;
  email: string;
  address: string;
  city: string;
  province: string;
  postal_code: string;
};

type HeaderVehicle = {
  year: string;
  make: string;
  model: string;
  vin: string;
  license_plate: string;
  mileage: string;
  color: string;
  unit_number: string;
  engine_hours: string;
};

function toHeaderCustomer(c?: SessionCustomer | null): HeaderCustomer {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}

function toHeaderVehicle(v?: SessionVehicle | null): HeaderVehicle {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/* ------------------------------ Section builders (AIR) ------------------------------ */
function buildAirCornerMeasurementsSection(): InspectionSection {
  return {
    title: "Measurements (Air – Corner Checks)",
    items: [
      { item: "Steer 1 Left Tire Pressure", unit: "psi", value: "" },
      { item: "Steer 1 Right Tire Pressure", unit: "psi", value: "" },

      { item: "Steer 1 Left Tread Depth", unit: "mm", value: "" },
      { item: "Steer 1 Right Tread Depth", unit: "mm", value: "" },

      { item: "Steer 1 Left Lining/Shoe Thickness", unit: "mm", value: "" },
      { item: "Steer 1 Right Lining/Shoe Thickness", unit: "mm", value: "" },

      { item: "Steer 1 Left Drum/Rotor Condition", unit: "", value: "" },
      { item: "Steer 1 Right Drum/Rotor Condition", unit: "", value: "" },

      { item: "Steer 1 Left Push Rod Travel", unit: "in", value: "" },
      { item: "Steer 1 Right Push Rod Travel", unit: "in", value: "" },
    ],
  };
}

function buildAirSystemMeasurementsSection(): InspectionSection {
  return {
    title: "Air System Measurements",
    items: [
      { item: "Air Build Time (90→120)", unit: "sec", value: "" },
      { item: "Gov Cut-In", unit: "psi", value: "" },
      { item: "Gov Cut-Out", unit: "psi", value: "" },
      { item: "Leak Rate @ Cut-Out", unit: "psi/min", value: "" },
      { item: "Low Air Warning Activates", unit: "psi", value: "" },
      { item: "Compressor Cut-Out Ref", unit: "psi", value: "" },
      { item: "Torque Reference", unit: "ft·lb", value: "" },
    ],
  };
}

function buildLightsSection(): InspectionSection {
  return {
    title: "Lighting & Reflectors",
    items: [
      { item: "Headlights (high/low beam)" },
      { item: "Turn signals / flashers" },
      { item: "Brake lights" },
      { item: "Tail lights" },
      { item: "Reverse lights" },
      { item: "License plate light" },
      { item: "Clearance / marker lights" },
      { item: "Reflective tape / reflectors" },
      { item: "Hazard switch function" },
    ],
  };
}

function buildSuspensionSection(): InspectionSection {
  return {
    title: "Suspension / Steering",
    items: [
      { item: "Front springs (coil/leaf)" },
      { item: "Rear springs (coil/leaf)" },
      { item: "Shocks / struts" },
      { item: "Control arms / ball joints" },
      { item: "Sway bar bushings / links" },
      { item: "Tie-rods / drag link / steering gear leaks" },
    ],
  };
}

function buildDrivelineSection(): InspectionSection {
  return {
    title: "Driveline / Axles",
    items: [
      { item: "Driveshaft / U-joints" },
      { item: "Center support bearing" },
      { item: "Slip yokes / seals" },
      { item: "Axle seals / leaks" },
      { item: "Differential leaks / play" },
    ],
  };
}

/* ------------------------------ Units helpers (AIR) ------------------------------ */
function unitForAir(label: string, mode: "metric" | "imperial"): string {
  const l = label.toLowerCase();
  if (l.includes("tire pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("lining") || l.includes("shoe")) return mode === "metric" ? "mm" : "in";
  if (l.includes("drum") || l.includes("rotor")) return mode === "metric" ? "mm" : "in";
  if (l.includes("push rod")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  return "";
}

function applyUnitsAir(
  sections: InspectionSection[],
  mode: "metric" | "imperial"
): InspectionSection[] {
  return sections.map((s) => {
    const isCorner = (s.title || "").toLowerCase().includes("corner");
    const isAirMeas = (s.title || "").toLowerCase().includes("air system");

    if (isCorner) {
      const items = s.items.map((it) => ({
        ...it,
        unit: unitForAir(it.item ?? "", mode) || it.unit || "",
      }));
      return { ...s, items };
    }

    if (isAirMeas) {
      const items = s.items.map((it) => {
        const label = (it.item ?? "").toLowerCase();
        if (label.includes("build time")) return { ...it, unit: "sec" };
        if (label.includes("leak"))
          return { ...it, unit: mode === "metric" ? "kPa/min" : "psi/min" };
        if (label.includes("gov") || label.includes("warning") || label.includes("compressor"))
          return { ...it, unit: mode === "metric" ? "kPa" : "psi" };
        if (label.includes("torque")) return { ...it, unit: mode === "metric" ? "N·m" : "ft·lb" };
        return it;
      });
      return { ...s, items };
    }

    return s;
  });
}

/* ------------------------------ Page (Screen) ------------------------------ */
export default function Maintenance50AirPage(): JSX.Element {
  const searchParams = useSearchParams();
  const rootRef = useRef<HTMLDivElement | null>(null);

  // 🔸 voice only on mobile companion
  const isMobileView =
    (searchParams.get("view") || "").toLowerCase() === "mobile";

  const isEmbed = useMemo(() => {
    const flag =
      ["1", "true", "yes"].includes(
        (searchParams.get("embed") || searchParams.get("compact") || "").toLowerCase()
      );
    const inIframe =
      typeof window !== "undefined" && window.self !== window.top;
    return flag || inIframe;
  }, [searchParams]);

  const workOrderLineId = searchParams.get("workOrderLineId") || null;
  const workOrderId = searchParams.get("workOrderId") || null;

  const inspectionId = useMemo<string>(
    () => searchParams.get("inspectionId") || uuidv4(),
    [searchParams]
  );

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState<boolean>(false);
  const [isPaused, setIsPaused] = useState<boolean>(false);
  const recognitionRef = useRef<SpeechRecognition | null>(null);

  const templateName: string =
    searchParams.get("template") || "Maintenance 50 (Air Brake CVIP)";

  const customer: SessionCustomer = {
    first_name: searchParams.get("first_name") || "",
    last_name: searchParams.get("last_name") || "",
    phone: searchParams.get("phone") || "",
    email: searchParams.get("email") || "",
    address: searchParams.get("address") || "",
    city: searchParams.get("city") || "",
    province: searchParams.get("province") || "",
    postal_code: searchParams.get("postal_code") || "",
  };

  const vehicle: SessionVehicle = {
    year: searchParams.get("year") || "",
    make: searchParams.get("make") || "",
    model: searchParams.get("model") || "",
    vin: searchParams.get("vin") || "",
    license_plate: searchParams.get("license_plate") || "",
    mileage: searchParams.get("mileage") || "",
    color: searchParams.get("color") || "",
    unit_number: searchParams.get("unit_number") || "",
    engine_hours: searchParams.get("engine_hours") || "",
  };

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(initialSession);

  /* ---------- AI submit flow ---------- */
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? it.name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  /* ---------- hydrate / persist ---------- */
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const saved = typeof window !== "undefined" ? localStorage.getItem(key) : null;
    if (saved) {
      try {
        const parsed = JSON.parse(saved) as InspectionSession;
        updateInspection(parsed);
      } catch {
        startSession(initialSession);
      }
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (session) {
      const key = `inspection-${inspectionId}`;
      localStorage.setItem(key, JSON.stringify(session));
    }
  }, [session, inspectionId]);

  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };

    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };

    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);

    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  /* ---------- sections + unit toggle ---------- */
  useEffect(() => {
    if (!session) return;
    if ((session.sections?.length ?? 0) > 0) return;

    const next: InspectionSection[] = [
      buildAirCornerMeasurementsSection(),
      buildAirSystemMeasurementsSection(),
      buildLightsSection(),
      buildSuspensionSection(),
      buildDrivelineSection(),
    ];
    updateInspection({
      sections: applyUnitsAir(next, unit) as typeof session.sections,
    });
  }, [session, updateInspection, unit]);

  useEffect(() => {
    if (!session?.sections?.length) return;
    updateInspection({
      sections: applyUnitsAir(session.sections, unit) as typeof session.sections,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unit]);

  /* ---------- speech → commands ---------- */
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess: InspectionSession | undefined = session ?? undefined;
    if (!sess) return;

    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  const startListening = (): void => {
    if (recognitionRef.current) {
      try {
        recognitionRef.current.stop();
      } catch {}
    }
    recognitionRef.current = startVoiceRecognition(async (text) => {
      await handleTranscript(text);
    });
    setIsListening(true);
  };

  useEffect(() => {
    return () => {
      try {
        recognitionRef.current?.stop();
      } catch {}
    };
  }, []);

  /* 🧹 embed-safe scrubber */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  /* 🔐 focus trap when embedded */
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return <div className="p-4 text-white">Loading inspection…</div>;
  }

  const isCorner = (t?: string): boolean =>
    (t || "").toLowerCase().includes("corner");

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const Body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Maintenance 50 – Air Brake CVIP"}
          </div>
        </div>
        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      {/* Controls */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              try {
                recognitionRef.current?.stop();
              } catch {}
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              recognitionRef.current = startVoiceRecognition(handleTranscript);
            }}
            recognitionInstance={
              recognitionRef.current as unknown as SpeechRecognition | null
            }
            onTranscript={handleTranscript}
            setRecognitionRef={(instance: SpeechRecognition | null): void => {
              (
                recognitionRef as React.MutableRefObject<SpeechRecognition | null>
              ).current = instance ?? null;
            }}
          />
        )}

        {/* Unit toggle always available */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      {/* Sections */}
      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => (
          <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
            <h2 className={sectionTitle}>{section.title}</h2>
            {isCorner(section.title) && (
              <span className={hint}>
                {unit === "metric"
                  ? "Enter mm / kPa / N·m"
                  : "Enter in / psi / ft·lb"}
              </span>
            )}

            <div className="mt-4">
              {isCorner(section.title) ? (
                <AirCornerGrid
                  sectionIndex={sectionIndex}
                  items={section.items}
                  unitHint={(label: string) => unitForAir(label, unit)}
                  onAddAxle={(axleLabel: string) => {
                    const extra = buildAirAxleItems(axleLabel);
                    updateSection(sectionIndex, {
                      items: [...section.items, ...extra],
                    });
                  }}
                />
              ) : (
                <SectionDisplay
                  title=""
                  section={section}
                  sectionIndex={sectionIndex}
                  showNotes
                  showPhotos
                  onUpdateStatus={(
                    secIdx: number,
                    itemIdx: number,
                    status: InspectionItemStatus
                  ): void => {
                    updateItem(secIdx, itemIdx, { status });
                  }}
                  onUpdateNote={(
                    secIdx: number,
                    itemIdx: number,
                    note: string
                  ): void => {
                    updateItem(secIdx, itemIdx, { notes: note });
                  }}
                  onUpload={(
                    photoUrl: string,
                    secIdx: number,
                    itemIdx: number
                  ): void => {
                    const prev =
                      session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                    updateItem(secIdx, itemIdx, {
                      photoUrls: [...prev, photoUrl],
                    });
                  }}
                  requireNoteForAI
                  onSubmitAI={(secIdx, itemIdx) => {
                    void submitAIForItem(secIdx, itemIdx);
                  }}
                  isSubmittingAI={isSubmittingAI}
                />
              )}
            </div>
          </div>
        ))}
      </InspectionFormCtx.Provider>

      {/* Footer */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          <FinishInspectionButton
            session={session}
            workOrderLineId={workOrderLineId ?? ""}
          />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return Body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Maintenance 50 – Air Brake CVIP"}
      description="Air-brake CVIP multi-axle inspection."
    >
      {Body}
    </PageShell>
  );
}

===== FILE: ./features/inspections/components/inspection/ SectionHeader.tsx =====
// features/inspections/components/inspection/SectionHeader.tsx
"use client";

import { useId } from "react";
import { ChevronUpIcon, ChevronDownIcon } from "@heroicons/react/24/outline";
import clsx from "clsx";

export interface SectionHeaderProps {
  title?: string;
  subtitle?: string | null;
  section?: number;
  isCollapsed: boolean;
  onToggle: () => void;
  count?: number;
  right?: React.ReactNode;
  sticky?: boolean;
  panelId?: string;
  className?: string;
}

// Exported as `any` so Next.js stops complaining about function props
export default function SectionHeader(props: any) {
  const {
    title,
    subtitle,
    section,
    isCollapsed,
    onToggle,
    count,
    right,
    sticky = true,
    panelId,
    className,
  } = props as SectionHeaderProps;

  const uid = useId();
  const controlsId = panelId ?? `inspection-panel-${uid}`;

  return (
    <div
      className={clsx(
        "flex items-center gap-3 px-3 py-2 border-b border-neutral-700/80 bg-black/70 backdrop-blur supports-[backdrop-filter]:bg-black/50",
        sticky && "sticky top-0 z-20",
        className
      )}
    >
      {typeof section === "number" && (
        <span className="text-xs uppercase tracking-wide text-neutral-400 shrink-0">
          Section {section + 1}
        </span>
      )}

      <div className="min-w-0 flex-1">
        {title && (
          <div className="flex items-center gap-2">
            <h2 className="text-sm sm:text-base font-semibold text-white truncate">
              {title}
            </h2>
            {typeof count === "number" && (
              <span className="inline-flex items-center justify-center text-[10px] px-1.5 py-0.5 rounded-full bg-orange-600/90 text-white">
                {count}
              </span>
            )}
          </div>
        )}
        {subtitle && (
          <p className="text-xs text-neutral-400 truncate">{subtitle}</p>
        )}
      </div>

      {right && <div className="hidden sm:flex items-center gap-2">{right}</div>}

      <button
        type="button"
        onClick={onToggle}
        className={clsx(
          "ml-1 inline-flex items-center justify-center rounded-md p-1.5",
          "text-neutral-300 hover:text-white hover:bg-white/10 focus:outline-none focus:ring-2 focus:ring-orange-500/60"
        )}
        aria-expanded={!isCollapsed}
        aria-controls={controlsId}
        aria-label={isCollapsed ? "Expand section" : "Collapse section"}
      >
        {isCollapsed ? (
          <ChevronDownIcon className="h-5 w-5" />
        ) : (
          <ChevronUpIcon className="h-5 w-5" />
        )}
      </button>
    </div>
  );
}

===== FILE: ./features/inspections/components/inspection/StatusLegend.tsx =====
// src/components/inspection/StatusLegend.tsx


const StatusLegend: React.FC = () => {
  return (
    <div className="flex justify-center gap-4 text-sm text-gray-300 mb-4">
      <div className="flex items-center gap-1">
        <span className="w-4 h-4 rounded-full bg-green-500 inline-block" /> OK
      </div>
      <div className="flex items-center gap-1">
        <span className="w-4 h-4 rounded-full bg-red-500 inline-block" /> FAIL
      </div>
      <div className="flex items-center gap-1">
        <span className="w-4 h-4 rounded-full bg-yellow-400 inline-block" />{" "}
        Recommend
      </div>
      <div className="flex items-center gap-1">
        <span className="w-4 h-4 rounded-full bg-gray-500 inline-block" /> N/A
      </div>
    </div>
  );
};

export default StatusLegend;


===== FILE: ./features/inspections/components/inspection/UndoVoiceActionButton.tsx =====
// components/inspection/UndoVoiceActionButton.tsx

import { useState } from "react";
import { ArrowUturnLeftIcon } from "@heroicons/react/24/outline";

interface UndoVoiceActionButtonProps {
  onUndo: () => void;
}

const UndoVoiceActionButton: React.FC<UndoVoiceActionButtonProps> = ({
  onUndo,
}) => {
  const [visible, setVisible] = useState(true);

  if (!visible) return null;

  return (
    <button
      className="fixed bottom-24 right-4 z-50 bg-orange-500 text-white p-2 rounded-full shadow-md hover:bg-orange-600"
      onClick={() => {
        onUndo();
        setVisible(false);
        setTimeout(() => setVisible(true), 2000); // prevent spam
      }}
      title="Undo Last Voice Action"
    >
      <ArrowUturnLeftIcon className="h-6 w-6" />
    </button>
  );
};

export default UndoVoiceActionButton;


===== FILE: ./features/inspections/components/inspection/PhotoThumbnail.tsx =====
"use client";



interface PhotoThumbnailProps {
  url: string;
  onRemove?: () => void;
}

const PhotoThumbnail: React.FC<PhotoThumbnailProps> = ({ url, onRemove }) => {
  return (
    <div className="relative w-24 h-24 m-1 rounded overflow-hidden border border-gray-600 shadow">
      <img
        src={url}
        alt="Inspection"
        className="object-cover w-full h-full rounded"
      />
      {onRemove && (
        <button
          onClick={onRemove}
          className="absolute top-0 right-0 bg-red-600 text-white rounded-bl px-1 text-xs hover:bg-red-700"
        >
          ✕
        </button>
      )}
    </div>
  );
};

export default PhotoThumbnail;


===== FILE: ./features/inspections/components/inspection/SectionWrapper.tsx =====
// components/inspection/SectionWrapper.tsx
import { useState } from "react";

interface SectionWrapperProps {
  title: string;
  children: React.ReactNode;
  defaultOpen?: boolean;
}

const SectionWrapper: React.FC<SectionWrapperProps> = ({
  title,
  children,
  defaultOpen = true,
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className="mb-4 rounded-lg bg-black/40 p-4 shadow-md">
      <button
        className="w-full text-left font-black text-lg text-orange-400 mb-2 flex justify-between items-center"
        onClick={() => setIsOpen(!isOpen)}
      >
        <span>{title}</span>
        <span>{isOpen ? "−" : "+"}</span>
      </button>
      {isOpen && <div className="space-y-2">{children}</div>}
    </div>
  );
};

export default SectionWrapper;


===== FILE: ./features/inspections/components/inspection/PhotoPreview.tsx =====
// components/inspection/PhotoPreview.tsx



interface PhotoPreviewProps {
  photoUrls?: string[];
}

const PhotoPreview: React.FC<PhotoPreviewProps> = ({ photoUrls }) => {
  if (!photoUrls || photoUrls.length === 0) return null;

  return (
    <div className="flex gap-2 flex-wrap mt-2">
      {photoUrls.map((url, index) => (
        <img
          key={index}
          src={url}
          alt={`Photo ${index + 1}`}
          className="w-16 h-16 object-cover rounded border border-gray-500"
        />
      ))}
    </div>
  );
};

export default PhotoPreview;


===== FILE: ./features/inspections/components/inspectionHost.tsx =====
"use client";

import { Suspense } from "react";
import dynamic from "next/dynamic";

/** Props our screens accept (now includes params for modal renders). */
type ScreenProps = {
  embed?: boolean;
  template?: string;
  params?: Record<string, string | number | boolean | null | undefined>;
};

/** Host props (modal passes these). */
type HostProps = {
  template: string;                 // "maintenance50", "maintenance50-air", "custom:abc"
  embed?: boolean;
  params?: Record<string, string | number | boolean | null | undefined>;
};

/* -------- Lazy screens -------- */
const Maintenance50 = dynamic<ScreenProps>(() => import("../screens/Maintenance50Screen"));
const Maintenance50Air = dynamic<ScreenProps>(() => import("../screens/Maintenance50AirScreen"));
const GenericInspectionScreen = dynamic<ScreenProps>(() => import("../screens/GenericInspectionScreen"));

/* -------- Registry (canonical keys) -------- */
const REGISTRY: Record<string, React.ComponentType<ScreenProps>> = {
  maintenance50: Maintenance50,
  "maintenance50-air": Maintenance50Air,
};

/* -------- Normalizer: accept a bunch of aliases safely -------- */
function normalizeTemplate(input: string): string {
  const raw = input.split("?")[0].split("#")[0];
  const t = raw.trim().toLowerCase().replace(/[_\s]+/g, "-");
  if (t === "maintenance50-hydraulic" || t === "maintenance-50" || t === "maintenance50-std")
    return "maintenance50";
  if (t === "maintenance50air" || t === "maintenance-50-air" || t === "maintenance50-air")
    return "maintenance50-air";
  return t;
}

/* -------- Host -------- */
export default function InspectionHost({ template, embed = false, params }: HostProps) {
  const key = normalizeTemplate(template);
  const isCustom = key.startsWith("custom:");
  const Renderer = (!isCustom && REGISTRY[key]) || GenericInspectionScreen;

  return (
    <Suspense fallback={<div className="p-4 text-neutral-400">Loading…</div>}>
      <Renderer embed={embed} template={key} params={params} />
    </Suspense>
  );
}

===== FILE: ./features/shared/chat/components/RecipientPickerModalWrapper.tsx =====
// features/shared/chat/components/RecipientPickerModalWrapper.tsx
"use client";

import RecipientPickerModal from "./RecipientPickerModal";

type Props = React.ComponentProps<typeof RecipientPickerModal>;
export default function RecipientPickerModalWrapper(props: Props) {
  return <RecipientPickerModal {...props} />;
}

===== FILE: ./features/shared/voice/VoiceProvider.tsx =====
"use client";

import {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { usePathname, useSearchParams } from "next/navigation";

type PlannerKind = "openai" | "simple";

export type VoiceAgentContext = {
  // high-level route hints
  route: string;
  query?: Record<string, string>;
  // page-specific hints (you set these from pages via <VoiceContextSetter/>)
  workOrderId?: string;
  vehicleId?: string;
  customerId?: string;
  shopId?: string;
  // user role hint (optional)
  role?: "owner" | "admin" | "manager" | "advisor" | "mechanic" | "parts";
  // anything else you want
  [k: string]: unknown;
};

type VoiceState = {
  isListening: boolean;
  transcript: string;
  lastRunId?: string | null;
  error?: string | null;
};

type VoiceAPI = {
  state: VoiceState;
  planner: PlannerKind;
  setPlanner: (p: PlannerKind) => void;

  // push contextual hints from a page
  setContext: (patch: Partial<VoiceAgentContext>) => void;
  clearContext: () => void;
  context: VoiceAgentContext;

  // voice controls
  startListening: () => void;
  stopListening: () => void;
  runTranscript: (overrideGoal?: string) => Promise<void>;
};

const VoiceCtx = createContext<VoiceAPI | null>(null);

export function VoiceProvider({ children }: { children: React.ReactNode }) {
  const pathname = usePathname() || "/";
  const sp = useSearchParams();
  const query = useMemo(() => {
    const q: Record<string, string> = {};
    sp?.forEach((v, k) => (q[k] = v));
    return q;
  }, [sp]);

  const [planner, setPlanner] = useState<PlannerKind>("openai");
  const [context, setContextState] = useState<VoiceAgentContext>({
    route: pathname,
    query,
  });
  const setContext = useCallback(
    (patch: Partial<VoiceAgentContext>) =>
      setContextState((c) => ({ ...c, ...patch })),
    [],
  );
  const clearContext = useCallback(
    () => setContextState({ route: pathname, query }),
    [pathname, query],
  );

  const [state, setState] = useState<VoiceState>({
    isListening: false,
    transcript: "",
    lastRunId: null,
    error: null,
  });

  const recRef = useRef<SpeechRecognition | null>(null);

  // Ensure native or webkit SpeechRecognition
  function ensureRecognizer(): SpeechRecognition | null {
    if (typeof window === "undefined") return null;
    const SR: any =
      (window as any).SpeechRecognition ||
      (window as any).webkitSpeechRecognition;
    if (!SR) return null;
    if (recRef.current) return recRef.current;
    const rec: SpeechRecognition = new SR();
    rec.lang = "en-US";
    rec.interimResults = true;
    rec.continuous = true;

    rec.onresult = (e: SpeechRecognitionEvent) => {
      let text = "";
      for (let i = e.resultIndex; i < e.results.length; i++) {
        text += e.results[i][0].transcript;
      }
      setState((s) => ({ ...s, transcript: text }));
    };

    rec.onerror = (e: any) => {
      setState((s) => ({
        ...s,
        error: String(e?.error || "speech error"),
        isListening: false,
      }));
    };

    rec.onend = () => {
      setState((s) => ({ ...s, isListening: false }));
    };

    recRef.current = rec;
    return rec;
  }

  const startListening = useCallback(() => {
    const rec = ensureRecognizer();
    if (!rec) {
      setState((s) => ({
        ...s,
        error: "Speech recognition not supported in this browser.",
      }));
      return;
    }
    setState((s) => ({
      ...s,
      isListening: true,
      transcript: "",
      error: null,
    }));
    rec.start();
  }, []);

  const stopListening = useCallback(() => {
    recRef.current?.stop();
  }, []);

  // Very small intent helper: enriches the raw transcript with the current page context
  function buildGoal(raw: string, c: VoiceAgentContext): string {
    const lower = raw.trim().toLowerCase();

    if (
      c.workOrderId &&
      (lower.startsWith("add line") || lower.startsWith("add a line"))
    ) {
      const desc = raw.replace(/^add (a )?line\s*/i, "");
      return `On work order ${c.workOrderId}, add a line: "${desc}".`;
    }

    if (lower.startsWith("create work order for")) {
      return raw;
    }

    if (c.workOrderId && lower.startsWith("finish line")) {
      return `On work order ${c.workOrderId}, finish the current line.`;
    }

    if (c.workOrderId && lower.includes("on hold")) {
      return `On work order ${c.workOrderId}, put the current line on hold.`;
    }

    // fallback – let the LLM infer using the context we pass
    return raw;
  }

  const runTranscript = useCallback(
    async (overrideGoal?: string) => {
      const goal = buildGoal(overrideGoal ?? state.transcript, context);
      if (!goal.trim()) return;

      try {
        const res = await fetch("/api/agent", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            goal,
            planner,
            context, // pass page+app context along
            idempotencyKey: crypto.randomUUID(),
          }),
        });

        const j = (await res.json().catch(() => ({}))) as {
          runId?: string;
          error?: string;
        };
        if (!res.ok) throw new Error(j?.error || `HTTP ${res.status}`);
        setState((s) => ({ ...s, lastRunId: j.runId ?? null }));
      } catch (e: any) {
        setState((s) => ({ ...s, error: e?.message || "Agent error" }));
      }
    },
    [state.transcript, context, planner],
  );

  const api: VoiceAPI = {
    state,
    planner,
    setPlanner,
    setContext,
    clearContext,
    context,
    startListening,
    stopListening,
    runTranscript,
  };

  // Keep route/query fresh in context automatically
  useEffect(() => {
    setContextState((c) => ({ ...c, route: pathname, query }));
  }, [pathname, query]);

  return <VoiceCtx.Provider value={api}>{children}</VoiceCtx.Provider>;
}

export function useVoice() {
  const v = useContext(VoiceCtx);
  if (!v) throw new Error("useVoice must be used within <VoiceProvider/>");
  return v;
}

===== FILE: ./features/shared/signaturePad/controller.tsx =====
// features/shared/signaturePad/controller.tsx
"use client";

import { useEffect, useLayoutEffect, useRef, useState } from "react";

type SigCanvasInstance = {
  clear: () => void;
  isEmpty: () => boolean;
  getCanvas: () => HTMLCanvasElement;
  getTrimmedCanvas: () => HTMLCanvasElement;
};

export type OpenOptions = { shopName?: string };

export function openSignaturePad(opts: OpenOptions = {}): Promise<string | null> {
  return new Promise((resolve) => {
    const detail = { shopName: opts.shopName ?? "", resolve };
    window.dispatchEvent(new CustomEvent("signaturepad:open", { detail }));
  });
}

export default function SignaturePad() {
  return <SignaturePadHost />;
}

function SignaturePadHost() {
  const [open, setOpen] = useState(false);
  const [shopName, setShopName] = useState<string>("");
  const [SigCanvasComp, setSigCanvasComp] = useState<React.ComponentType<any> | null>(null);

  const resolverRef = useRef<((v: string | null) => void) | null>(null);
  const sigRef = useRef<SigCanvasInstance | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null);

  const [saving, setSaving] = useState(false);
  const [size, setSize] = useState({ w: 480, h: 220 });

  // Load react-signature-canvas on client so ref is reliable
  useEffect(() => {
    let mounted = true;
    (async () => {
      const mod = await import("react-signature-canvas");
      if (mounted) setSigCanvasComp(() => mod.default);
    })();
    return () => {
      mounted = false;
    };
  }, []);

  // Open listener
  useEffect(() => {
    const handler = (e: Event) => {
      const { shopName, resolve } = (e as CustomEvent).detail as {
        shopName: string;
        resolve: (v: string | null) => void;
      };
      resolverRef.current = resolve;
      setShopName(shopName || "");
      setOpen(true);
      setSaving(false);

      // clear any previous ink and size up next paint
      requestAnimationFrame(() => {
        sigRef.current?.clear?.();
        const el = containerRef.current;
        const w = Math.max(320, Math.floor(el?.clientWidth || 0)) || 480;
        const h = Math.floor(w * 0.44);
        setSize({ w, h });
      });
    };
    window.addEventListener("signaturepad:open", handler as EventListener);
    return () => window.removeEventListener("signaturepad:open", handler as EventListener);
  }, []);

  // Responsive sizing
  useLayoutEffect(() => {
    if (!containerRef.current) return;
    const el = containerRef.current;
    const ro = new ResizeObserver(() => {
      const w = Math.max(320, Math.floor(el.clientWidth)) || 480;
      const h = Math.floor(w * 0.44);
      setSize({ w, h });
    });
    ro.observe(el);
    return () => ro.disconnect();
  }, []);

  // Retina crispness
  useEffect(() => {
    const canvas = sigRef.current?.getCanvas?.();
    if (!canvas) return;
    const ratio = Math.max(window.devicePixelRatio || 1, 1);
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const W = Math.floor(size.w * ratio);
    const H = Math.floor(size.h * ratio);
    if (canvas.width !== W || canvas.height !== H) {
      canvas.width = W;
      canvas.height = H;
      canvas.style.width = `${size.w}px`;
      canvas.style.height = `${size.h}px`;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    }
  }, [size]);

  // Prevent page scroll while signing (iOS)
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;
    const preventScroll = (e: TouchEvent) => {
      const t = e.target as HTMLElement | null;
      if (t?.tagName?.toLowerCase() === "canvas") e.preventDefault();
    };
    el.addEventListener("touchmove", preventScroll, { passive: false });
    return () => el.removeEventListener("touchmove", preventScroll);
  }, []);

  const closeWith = (v: string | null) => {
    resolverRef.current?.(v);
    resolverRef.current = null;
    setOpen(false);
  };

  const hasInk = () => !!sigRef.current && typeof sigRef.current.isEmpty === "function" && !sigRef.current.isEmpty();

  const handleClear = () => sigRef.current?.clear?.();

  const handleSave = () => {
    if (saving) return;

    if (!hasInk()) {
      alert("Please draw a signature before saving.");
      return;
    }

    setSaving(true);
    try {
      const inst = sigRef.current!;
      // Some Safari builds throw on getTrimmedCanvas; fall back to raw canvas
      let canvas: HTMLCanvasElement | null = null;

      try {
        canvas = inst.getTrimmedCanvas?.() ?? null;
      } catch {
        canvas = null;
      }
      if (!canvas) {
        try {
          canvas = inst.getCanvas?.() ?? null;
        } catch {
          canvas = null;
        }
      }

      if (!canvas) {
        throw new Error("Signature capture unavailable (canvas not ready).");
      }
      if (canvas.width === 0 || canvas.height === 0) {
        throw new Error("Signature area not ready. Please try again.");
      }

      const base64 = canvas.toDataURL("image/png");
      if (!base64 || base64.length < 50) {
        throw new Error("Could not read signature image.");
      }

      closeWith(base64);
    } catch (err: any) {
      alert(err?.message || "Failed to save signature.");
    } finally {
      setSaving(false);
    }
  };

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/60 p-4">
      <div
        className="w-full max-w-md rounded-lg border-2 border-orange-400 bg-neutral-900 p-6 shadow-xl"
        style={{ fontFamily: "Roboto, ui-sans-serif, system-ui" }}
        role="dialog"
        aria-modal="true"
        onClick={(e) => e.stopPropagation()}
      >
        <h2
          className="mb-1 text-center text-lg font-semibold text-white"
          style={{ fontFamily: "'Black Ops One', Roboto, ui-sans-serif, system-ui" }}
        >
          {shopName ? `${shopName} — Customer Approval` : "Customer Approval"}
        </h2>

        <p className="mb-4 text-center text-xs text-neutral-300">
          By signing, I approve the described work and acknowledge the estimate.
        </p>

        <div ref={containerRef} className="w-full">
          {SigCanvasComp ? (
            <SigCanvasComp
              ref={(inst: SigCanvasInstance | null) => {
                sigRef.current = inst;
              }}
              penColor="white"
              canvasProps={{
                width: size.w,
                height: size.h,
                className: "w-full rounded-md border border-neutral-700 bg-neutral-950",
                role: "img",
                "aria-label": "Signature input area",
              }}
            />
          ) : (
            <div className="h-[220px] w-full animate-pulse rounded-md border border-neutral-800 bg-neutral-950" />
          )}
        </div>

        <div className="mt-4 flex flex-wrap items-center justify-between gap-2">
          <button
            type="button"
            onClick={handleClear}
            disabled={saving}
            className="rounded px-4 py-2 text-neutral-900 hover:opacity-90 disabled:opacity-50"
            style={{ backgroundColor: "#e5e7eb", fontFamily: "'Black Ops One', Roboto, ui-sans-serif, system-ui" }}
          >
            Clear
          </button>
          <div className="flex gap-2">
            <button
              type="button"
              onClick={() => closeWith(null)}
              disabled={saving}
              className="rounded px-4 py-2 text-white disabled:opacity-50"
              style={{ backgroundColor: "#ef4444", fontFamily: "'Black Ops One', Roboto, ui-sans-serif, system-ui" }}
            >
              Cancel
            </button>
            <button
              type="button"
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                handleSave();
              }}
              className="rounded px-4 py-2 text-white"
              style={{ backgroundColor: "#16a34a", fontFamily: "'Black Ops One', Roboto, ui-sans-serif, system-ui" }}
            >
              {saving ? "Saving…" : "Save"}
            </button>
          </div>
        </div>

        <p className="mt-3 text-center text-[10px] leading-snug text-neutral-400">
          Signature is stored securely and associated to this work order.
        </p>
      </div>
    </div>
  );
}

===== FILE: ./features/shared/components/tabs/TabsBridge.tsx =====
// features/shared/components/tabs/TabsBridge.tsx
"use client";

import { useEffect, useMemo } from "react";
import { useSession } from "@supabase/auth-helpers-react";
import { usePathname } from "next/navigation";
import { TabsProvider } from "./TabsProvider";
import TabsBar from "./TabsBar";
import { metaFor } from "@/features/shared/lib/routeMeta";

/**
 * Build a stable, user-scoped storage prefix for the current route.
 * Example: tabs:u_123:/work-orders/abc → "tabs:u_123:_work_orders_abc"
 */
function useStoragePrefix(userId?: string | null) {
  const pathname = usePathname() || "/";
  const safePath = pathname.replace(/\W+/g, "_"); // "/work-orders/123" → "_work_orders_123"
  const userPart = userId ? `u_${userId}` : "anon";
  return `tabs:${userPart}:${safePath}`;
}

/**
 * Public helper in case a page wants to persist extra blobs manually.
 * Example: const key = useTabsScopedStorageKey("assistant:thread")
 */
export function useTabsScopedStorageKey(subkey: string) {
  const session = useSession();
  const prefix = useStoragePrefix(session?.user?.id);
  return `${prefix}:${subkey}`;
}

export default function TabsBridge({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = useSession();
  const userId = session?.user?.id ?? null;
  const pathname = usePathname() || "/";
  const prefix = useStoragePrefix(userId);

  const isMobileRoute =
    pathname === "/mobile" || pathname.startsWith("/mobile/");

  // Ask routeMeta what the persistence policy is (defaults: inputs+scroll true for all).
  const persist = useMemo(() => metaFor(pathname).persist, [pathname]);

  // ---------- INPUT PERSISTENCE (skip on mobile, opt-out per route in routeMeta) ----------
  useEffect(() => {
    if (isMobileRoute) return; // ✅ no input persistence on mobile companion
    if (!persist?.inputs) return;

    const STORAGE_KEY = `${prefix}:inputs`;

    // Try to restore once on mount/route-change
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const map = JSON.parse(raw) as Record<string, string>;
        // Match by name or id only (avoid type=password/file)
        for (const [k, v] of Object.entries(map)) {
          const el =
            (document.querySelector(
              `input[name="${k}"]`,
            ) as HTMLInputElement | null) ||
            (document.getElementById(k) as HTMLInputElement | null) ||
            (document.querySelector(
              `textarea[name="${k}"]`,
            ) as HTMLTextAreaElement | null) ||
            (document.querySelector(
              `select[name="${k}"]`,
            ) as HTMLSelectElement | null);
          if (!el) continue;
          const tag = el.tagName.toLowerCase();
          const type = (el as HTMLInputElement).type?.toLowerCase?.() || "";
          if (tag === "input" && (type === "password" || type === "file"))
            continue;

          if (tag === "input" || tag === "textarea") {
            (el as HTMLInputElement | HTMLTextAreaElement).value = v;
            el.dispatchEvent(new Event("input", { bubbles: true })); // keep React state in sync
          } else if (tag === "select") {
            (el as HTMLSelectElement).value = v;
            el.dispatchEvent(new Event("change", { bubbles: true }));
          }
        }
      }
    } catch {
      /* noop */
    }

    // Write-through on user edits (debounced)
    let t: ReturnType<typeof setTimeout> | null = null;
    const save = () => {
      if (t) clearTimeout(t);
      t = setTimeout(() => {
        try {
          const map: Record<string, string> = {};
          const fields = Array.from(
            document.querySelectorAll<
              HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
            >("input, textarea, select"),
          );
          fields.forEach((el, idx) => {
            const tag = el.tagName.toLowerCase();
            const type = (el as HTMLInputElement).type?.toLowerCase?.() || "";
            if (tag === "input" && (type === "password" || type === "file"))
              return;

            const key = el.getAttribute("name") || el.id || `__idx_${idx}`;
            // Only store if we have a stable key
            if (!key) return;

            // Coerce to string
            const val =
              tag === "select"
                ? (el as HTMLSelectElement).value ?? ""
                : (
                    el as HTMLInputElement | HTMLTextAreaElement
                  ).value ?? "";

            map[key] = val;
          });
          localStorage.setItem(STORAGE_KEY, JSON.stringify(map));
        } catch {
          /* noop */
        }
      }, 150);
    };

    const handler = (e: Event) => {
      const target = e.target as HTMLElement | null;
      if (!target) return;
      const tag = target.tagName?.toLowerCase();
      if (tag === "input" || tag === "textarea" || tag === "select") save();
    };

    document.addEventListener("input", handler, true);
    document.addEventListener("change", handler, true);
    window.addEventListener("beforeunload", save);

    return () => {
      document.removeEventListener("input", handler, true);
      document.removeEventListener("change", handler, true);
      window.removeEventListener("beforeunload", save);
      if (t) clearTimeout(t);
    };
  }, [persist?.inputs, prefix, isMobileRoute]);

  // ---------- SCROLL PERSISTENCE (skip on mobile, window scroll only, opt-out per route) ----------
  useEffect(() => {
    if (isMobileRoute) return; // ✅ no scroll persistence on mobile companion
    if (!persist?.scroll) return;

    const SCROLL_KEY = `${prefix}:scrollY`;

    // Restore immediately (next frame ensures layout is ready)
    const id = requestAnimationFrame(() => {
      try {
        const raw = sessionStorage.getItem(SCROLL_KEY);
        const y = raw ? parseInt(raw, 10) : 0;
        if (!Number.isNaN(y)) window.scrollTo({ top: y, behavior: "auto" });
      } catch {
        /* noop */
      }
    });

    let t: ReturnType<typeof setTimeout> | null = null;
    const onScroll = () => {
      if (t) clearTimeout(t);
      t = setTimeout(() => {
        try {
          sessionStorage.setItem(
            SCROLL_KEY,
            String(window.scrollY || 0),
          );
        } catch {
          /* noop */
        }
      }, 100);
    };

    window.addEventListener("scroll", onScroll, { passive: true });

    return () => {
      cancelAnimationFrame(id);
      window.removeEventListener("scroll", onScroll);
      if (t) clearTimeout(t);
    };
  }, [persist?.scroll, prefix, isMobileRoute]);

  // ---------- Tabs UI + children ----------
  return (
    <TabsProvider userId={userId ?? undefined}>
      {/* No tab bar on the mobile companion routes */}
      {!isMobileRoute && <TabsBar />}
      {children}
    </TabsProvider>
  );
}

===== FILE: ./features/shared/components/tabs/TabsProvider.tsx =====
"use client";

import { createContext, useContext, useEffect, useMemo, useRef, useState } from "react";
import { usePathname, useRouter } from "next/navigation";
import { metaFor } from "@/features/shared/lib/routeMeta";

type Tab = { href: string; title: string; icon?: string; pinned?: boolean };

type TabsContextValue = {
  tabs: Tab[];
  activeHref: string;
  openTab: (href: string) => void;
  activateTab: (href: string) => void;
  closeTab: (href: string) => void;
  closeOthers: (href: string) => void;
  closeAll: () => void;
};

const TabsCtx = createContext<TabsContextValue | null>(null);
export const useTabs = (): TabsContextValue => {
  const ctx = useContext(TabsCtx);
  if (!ctx) throw new Error("useTabs must be used inside <TabsProvider>");
  return ctx;
};

function storageKey(userId?: string) {
  return `dash-tabs:${userId ?? "anon"}`;
}

type PersistShape = { tabs: Tab[]; activeHref: string };

export function TabsProvider({
  children,
  userId,
}: {
  children: React.ReactNode;
  userId?: string;
}) {
  const router = useRouter();
  const pathname = usePathname() || "/";
  const [tabs, setTabs] = useState<Tab[]>([]);
  const [activeHref, setActiveHref] = useState<string>("");

  // Seed with pinned Dashboard on first paint
  useEffect(() => {
    setTabs((prev) => {
      if (prev.some((t) => t.href === "/dashboard")) return prev;
      return [{ href: "/dashboard", title: "Dashboard", pinned: true }];
    });
    if (!activeHref) setActiveHref("/dashboard");
  }, []); // once

  // Load persisted (but always ensure dashboard pinned)
  useEffect(() => {
    try {
      const raw = localStorage.getItem(storageKey(userId));
      if (!raw) return;
      const parsed = JSON.parse(raw) as Partial<PersistShape>;
      const loaded = Array.isArray(parsed.tabs) ? parsed.tabs : [];
      const withPinned = [
        { href: "/dashboard", title: "Dashboard", pinned: true },
        ...loaded.filter((t) => t.href !== "/dashboard"),
      ];
      setTabs(withPinned);
      if (typeof parsed.activeHref === "string") setActiveHref(parsed.activeHref || "/dashboard");
    } catch {}
  }, [userId]);

  // Persist
  useEffect(() => {
    try {
      localStorage.setItem(storageKey(userId), JSON.stringify({ tabs, activeHref }));
    } catch {}
  }, [tabs, activeHref, userId]);

  // Sync across tabs
  useEffect(() => {
    const onStorage = (e: StorageEvent) => {
      if (e.key !== storageKey(userId) || !e.newValue) return;
      try {
        const parsed = JSON.parse(e.newValue) as PersistShape;
        const loaded = parsed.tabs ?? [];
        const withPinned = [
          { href: "/dashboard", title: "Dashboard", pinned: true },
          ...loaded.filter((t) => t.href !== "/dashboard"),
        ];
        setTabs(withPinned);
        setActiveHref(parsed.activeHref || "/dashboard");
      } catch {}
    };
    window.addEventListener("storage", onStorage);
    return () => window.removeEventListener("storage", onStorage);
  }, [userId]);

  // Auto-open a tab if route wants to appear
  const lastPath = useRef<string>("");
  useEffect(() => {
    if (!pathname || pathname === lastPath.current) return;
    lastPath.current = pathname;

    const { title, icon, show } = metaFor(pathname);
    if (!show) {
      setActiveHref(pathname);
      return;
    }
    setTabs((prev) => (prev.some((t) => t.href === pathname) ? prev : [...prev, { href: pathname, title, icon }]));
    setActiveHref(pathname);
  }, [pathname]);

  const api = useMemo<TabsContextValue>(
    () => ({
      tabs,
      activeHref,

      openTab: (href) => {
        const { title, icon, show } = metaFor(href);
        if (!show) {
          setActiveHref(href);
          router.push(href);
          return;
        }
        setTabs((prev) => (prev.some((t) => t.href === href) ? prev : [...prev, { href, title, icon }]));
        setActiveHref(href);
        router.push(href);
      },

      activateTab: (href) => {
        setActiveHref(href);
        router.push(href);
      },

      closeTab: (href) => {
        // never close pinned
        if (href === "/dashboard") return;
        setTabs((prev) => prev.filter((t) => t.href !== href));
        if (activeHref === href) {
          const remaining = tabs.filter((t) => t.href !== href);
          const next = remaining.length ? remaining[remaining.length - 1].href : "/dashboard";
          setActiveHref(next);
          router.push(next);
        }
      },

      closeOthers: (href) => {
        setTabs((prev) => [{ href: "/dashboard", title: "Dashboard", pinned: true }, ...prev.filter((t) => t.href === href && href !== "/dashboard")]);
        setActiveHref(href);
        router.push(href);
      },

      closeAll: () => {
        setTabs([{ href: "/dashboard", title: "Dashboard", pinned: true }]);
        setActiveHref("/dashboard");
        router.push("/dashboard");
      },
    }),
    [tabs, activeHref, router]
  );

  return <TabsCtx.Provider value={api}>{children}</TabsCtx.Provider>;
}

===== FILE: ./features/shared/components/JobQueueCard.tsx =====
"use client";

import { memo, useMemo, useState } from "react";
import type { Database } from "@shared/types/types/supabase";

type JobLine = Database["public"]["Tables"]["work_order_lines"]["Row"];

type AssignProps = {
  techOptions?: { id: string; full_name: string | null }[];
  onAssignTech?: (jobId: string, techId: string) => void | Promise<void>;
  onView?: () => void;
};

type PunchProps = {
  onPunchIn?: (job: JobLine) => void | Promise<void>;
  onPunchOut?: (job: JobLine) => void | Promise<void>;
};

type JobQueueCardProps = {
  job: JobLine;
  isActive?: boolean;
} & AssignProps &
  PunchProps;

// Possible waiter flags that might exist on the line row
type JobWaiterFlags = {
  is_waiter?: boolean | null;
  waiter?: boolean | null;
  customer_waiting?: boolean | null;
};

const BADGE_BASE =
  "inline-flex items-center rounded-full px-2.5 py-0.5 text-[10px] font-medium";

const STATUS_STYLES: Record<string, string> = {
  in_progress: `${BADGE_BASE} bg-orange-500/10 text-orange-200 border border-orange-400/40`,
  on_hold: `${BADGE_BASE} bg-amber-500/10 text-amber-100 border border-amber-400/40`,
  queued: `${BADGE_BASE} bg-indigo-500/10 text-indigo-100 border border-indigo-400/40`,
  awaiting: `${BADGE_BASE} bg-slate-500/10 text-slate-100 border border-slate-400/40`,
  planned: `${BADGE_BASE} bg-purple-500/10 text-purple-100 border border-purple-400/40`,
  new: `${BADGE_BASE} bg-neutral-500/10 text-neutral-100 border border-neutral-400/40`,
  completed: `${BADGE_BASE} bg-green-500/10 text-green-100 border border-green-400/40`,
};

function getStatusBadge(
  status: string | null,
  holdReason: string | null,
): { text: string; className: string } {
  const key = (status ?? "awaiting").toLowerCase();
  if (key === "on_hold") {
    return {
      text: holdReason ? `On hold — ${holdReason}` : "On hold",
      className: STATUS_STYLES.on_hold ?? STATUS_STYLES.awaiting,
    };
  }
  const base = STATUS_STYLES[key] ?? STATUS_STYLES.awaiting;
  return {
    text: (status ?? "awaiting").replaceAll("_", " "),
    className: base,
  };
}

function JobQueueCard({
  job,
  techOptions = [],
  onAssignTech,
  onView,
  onPunchIn,
  onPunchOut,
  isActive,
}: JobQueueCardProps) {
  const {
    complaint,
    description,
    created_at,
    assigned_to,
    id,
    status,
    hold_reason,
  } = job;

  const [selectedTech, setSelectedTech] = useState<string | null>(
    assigned_to ?? null,
  );

  const assignedLabel = useMemo(() => {
    if (!selectedTech) return "Unassigned";
    const match = techOptions.find((t) => t.id === selectedTech);
    return match?.full_name || selectedTech;
  }, [selectedTech, techOptions]);

  const { text: badgeText, className: badgeClass } = getStatusBadge(
    status ?? null,
    hold_reason ?? null,
  );

  // 🔴 waiter flag per job line (supports multiple possible columns)
  const waiterSource = job as JobLine & JobWaiterFlags;
  const isWaiter =
    !!(
      waiterSource.is_waiter ||
      waiterSource.waiter ||
      waiterSource.customer_waiting
    );

  const handleAssign = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const techId = e.target.value || null;
    setSelectedTech(techId);
    if (techId && onAssignTech && id) {
      void onAssignTech(id, techId);
    }
  };

  return (
    <div
      className={`rounded-xl border bg-neutral-950/90 p-3 shadow-sm transition hover:border-orange-500/70 hover:shadow-md ${
        isActive
          ? "border-orange-400 ring-1 ring-orange-400/70"
          : "border-neutral-800"
      }`}
    >
      <div className="space-y-2">
        {/* Header */}
        <div className="flex items-start justify-between gap-3">
          <div className="min-w-0">
            <div className="truncate text-sm font-semibold text-white">
              {complaint || description || "No description"}
            </div>
            <div className="mt-0.5 text-[11px] text-neutral-400">
              Created:{" "}
              {created_at ? new Date(created_at).toLocaleString() : "—"}
            </div>
            <div className="mt-1 text-[11px] text-neutral-400">
              <span className="text-neutral-500">Assigned:</span>{" "}
              <span className="font-medium text-neutral-200">
                {assignedLabel}
              </span>
            </div>
          </div>

          <div className="flex flex-col items-end gap-1">
            {isWaiter && (
              <span
                className="
                  inline-flex items-center whitespace-nowrap
                  rounded-full border border-red-500
                  bg-red-500/10
                  px-3 py-1
                  text-[10px] font-semibold uppercase tracking-[0.16em]
                  text-red-200
                  shadow-[0_0_14px_rgba(248,113,113,0.9)]
                "
              >
                Waiter
              </span>
            )}
            <span className={badgeClass}>{badgeText}</span>
          </div>
        </div>

        {/* Tech assign + view */}
        {(techOptions.length > 0 || onView) && (
          <div className="flex flex-wrap items-center gap-2">
            {techOptions.length > 0 && onAssignTech && (
              <select
                value={selectedTech ?? ""}
                onChange={handleAssign}
                className="rounded border border-neutral-700 bg-neutral-900 px-2 py-1 text-xs text-neutral-100 focus:border-orange-500 focus:outline-none focus:ring-1 focus:ring-orange-500"
              >
                <option value="">Unassigned</option>
                {techOptions.map((t) => (
                  <option key={t.id} value={t.id}>
                    {t.full_name ?? t.id}
                  </option>
                ))}
              </select>
            )}

            {onView && (
              <button
                className="rounded border border-neutral-700 bg-neutral-900 px-2 py-1 text-xs text-neutral-100 hover:border-orange-400 hover:bg-neutral-800"
                onClick={onView}
              >
                View work order
              </button>
            )}
          </div>
        )}

        {/* Punch buttons */}
        {(onPunchIn || onPunchOut) && (
          <div className="flex flex-wrap gap-2 pt-1">
            {onPunchIn && !isActive && (
              <button
                className="rounded bg-blue-600 px-3 py-1 text-xs font-semibold text-white hover:bg-blue-500"
                onClick={() => void onPunchIn(job)}
              >
                Punch in
              </button>
            )}
            {onPunchOut && isActive && (
              <button
                className="rounded bg-neutral-700 px-3 py-1 text-xs font-semibold text-white hover:bg-neutral-600"
                onClick={() => void onPunchOut(job)}
              >
                Punch out
              </button>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

export default memo(JobQueueCard);

===== FILE: ./features/shared/components/DynamicRoleSidebar.tsx =====
// features/shared/components/DynamicRoleSidebar.tsx
"use client";

import { useEffect, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

import RoleNavAdmin from "@shared/components/RoleNavAdmin";
import RoleNavManager from "@shared/components/RoleNavManager";
import RoleNavTech from "@shared/components/RoleNavTech";
import RoleNavAdvisor from "@shared/components/RoleNavAdvisor";
import RoleNavOwner from "@shared/components/RoleNavOwner";
import RoleNavParts from "@shared/components/RoleNavParts";

type Db = Database;
type DbRole = Db["public"]["Enums"]["user_role_enum"] | null | undefined;
type Role = "owner" | "admin" | "manager" | "advisor" | "mechanic" | "parts";

/** Small, consistent AI Planner link shown under any role nav */
function AIAgentLink() {
  return (
    <div className="mt-3 pt-3 border-t border-neutral-800">
      <Link
        href="/agent/planner"
        className="group flex items-center gap-2 rounded-lg border border-orange-500/60 bg-neutral-950 px-3 py-2 hover:bg-neutral-900"
      >
        <span className="text-lg leading-none">🤖</span>
        <span className="font-black text-orange-400 group-hover:text-orange-300"
              style={{ fontFamily: "'Black Ops One', system-ui, sans-serif" }}>
          AI Planner
        </span>
      </Link>
      <p className="mt-1 text-xs text-neutral-500">
        Auto-create work orders, add lines, and email invoices.
      </p>
    </div>
  );
}

/** Wrap any role nav with the AI Planner link beneath */
function withAI(children: React.ReactNode) {
  return (
    <div className="flex flex-col">
      {children}
      <AIAgentLink />
    </div>
  );
}

export default function DynamicRoleSidebar({ role }: { role?: Role }): JSX.Element | null {
  const supabase = createClientComponentClient<Db>();
  const [detectedRole, setDetectedRole] = useState<Role | null>(null);

  useEffect(() => {
    if (role) return;

    let mounted = true;
    (async () => {
      const { data: { session } } = await supabase.auth.getSession();
      const uid = session?.user?.id;
      if (!uid || !mounted) return;

      const { data: profile } = await supabase
        .from("profiles")
        .select("role")
        .eq("id", uid)
        .maybeSingle();

      const r = profile?.role as DbRole;
      const narrowed: Role | null =
        r === "owner" || r === "admin" || r === "manager" || r === "advisor" || r === "mechanic" || r === "parts"
          ? (r as Role)
          : null;

      if (mounted) setDetectedRole(narrowed);
    })();

    return () => {
      mounted = false;
    };
  }, [role, supabase]);

  const effective = role ?? detectedRole;
  if (!effective) return null;

  switch (effective) {
    case "owner":
      return withAI(<RoleNavOwner />);
    case "admin":
      return withAI(<RoleNavAdmin />);
    case "manager":
      return withAI(<RoleNavManager />);
    case "advisor":
      return withAI(<RoleNavAdvisor />);
    case "mechanic":
      return withAI(<RoleNavTech />);
    case "parts":
      return withAI(<RoleNavParts />);
    default:
      return null;
  }
}

===== FILE: ./features/shared/components/PunchInOutButton.tsx =====
// features/shared/components/PunchInOutButton.tsx
"use client";


import { Button } from "@shared/components/ui/Button";

export interface JobLine {
  id: string;
  vehicle: string;
}

interface PunchInOutButtonProps {
  activeJob: JobLine | null;
  onPunchIn: () => void;
  onPunchOut: () => void;
  isLoading?: boolean;
}

const PunchInOutButton: React.FC<PunchInOutButtonProps> = ({
  activeJob,
  onPunchIn,
  onPunchOut,
  isLoading = false,
}) => {
  const isPunchedIn = !!activeJob;

  return (
    <div className="w-full mt-4">
      <Button
        type="button"
        size="lg"
        variant={isPunchedIn ? "outline" : "orange"}
        className="w-full text-sm justify-center"
        onClick={isPunchedIn ? onPunchOut : onPunchIn}
        isLoading={isLoading}
      >
        {isPunchedIn
          ? `Punch Out of ${activeJob?.vehicle}`
          : "Punch In to Job"}
      </Button>
    </div>
  );
};

export default PunchInOutButton;

===== FILE: ./features/shared/components/VehicleSelector.tsx =====
"use client";


import useVehicleInfo from "@shared/hooks/useVehicleInfo";

export default function VehicleSelector() {
  const { vehicleInfo, updateVehicle, clearVehicle } = useVehicleInfo();

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { value } = e.target;

    updateVehicle({
      year: vehicleInfo?.year || "",
      make: vehicleInfo?.make || "",
      model: vehicleInfo?.model || "",
      engine: vehicleInfo?.engine || "",
      plate: vehicleInfo?.plate || "",
      id: value,
    });
  };

  return (
    <div className="mb-6 space-y-4 text-left">
      <h3 className="font-header text-xl text-accent font-bold">
        Vehicle Info
      </h3>

      <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
        <input
          type="text"
          name="year"
          placeholder="Year"
          value={vehicleInfo?.year || ""}
          onChange={handleChange}
          className="w-full p-3 rounded-md bg-surface border border-neutral-700"
        />
        <input
          type="text"
          name="make"
          placeholder="Make"
          value={vehicleInfo?.make || ""}
          onChange={handleChange}
          className="w-full p-3 rounded-md bg-surface border border-neutral-700"
        />
        <input
          type="text"
          name="model"
          placeholder="Model"
          value={vehicleInfo?.model || ""}
          onChange={handleChange}
          className="w-full p-3 rounded-md bg-surface border border-neutral-700"
        />
        <input
          type="text"
          name="engine"
          placeholder="Engine"
          value={vehicleInfo?.engine || ""}
          onChange={handleChange}
          className="w-full p-3 rounded-md bg-surface border border-neutral-700"
        />
        <input
          type="text"
          name="plate"
          placeholder="Plate"
          value={vehicleInfo?.plate || ""}
          onChange={handleChange}
          className="w-full p-3 rounded-md bg-surface border border-neutral-700"
        />
      </div>

      {vehicleInfo && (
        <button
          onClick={clearVehicle}
          className="mt-2 text-sm text-blue-400 underline hover:text-blue-200"
        >
          Change Vehicle
        </button>
      )}
    </div>
  );
}


===== FILE: ./features/shared/components/ModalShell.tsx =====
// src/features/shared/components/ModalShell.tsx
"use client";

import { Dialog } from "@headlessui/react";


type ModalShellProps = {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  onSubmit?: () => void | Promise<void>;
  submitText?: string;
  footerLeft?: React.ReactNode;
  /** sm = 24rem, md = 32rem, lg = 48rem, xl = 64rem */
  size?: "sm" | "md" | "lg" | "xl";
  /** hide the footer completely (for interactive panels like AI) */
  hideFooter?: boolean;
  /** when false, body is NOT a scroll container (useful when a child manages its own scroll) */
  bodyScrollable?: boolean;
};

export default function ModalShell({
  isOpen,
  onClose,
  title,
  children,
  onSubmit,
  submitText = "Save",
  footerLeft,
  size = "md",
  hideFooter = false,
  bodyScrollable = true,
}: ModalShellProps) {
  const width =
    size === "sm"
      ? "max-w-sm"
      : size === "md"
      ? "max-w-lg"
      : size === "lg"
      ? "max-w-4xl"
      : "max-w-6xl"; // xl

  return (
    <Dialog
      open={isOpen}
      onClose={onClose}
      className="fixed inset-0 z-[500] flex items-center justify-center px-3 py-6 sm:px-4"
    >
      {/* Backdrop */}
      <div
        className="fixed inset-0 bg-black/80 backdrop-blur-md"
        aria-hidden="true"
      />

      {/* Panel wrapper */}
      <div className={`relative z-[510] w-full ${width}`}>
        <Dialog.Panel className="w-full overflow-hidden rounded-2xl border border-[var(--metal-border-soft)] bg-[radial-gradient(circle_at_top,_#050910,_#020308_60%,_#000)] text-neutral-100 shadow-[0_24px_80px_rgba(0,0,0,0.95)]">
          {/* Header */}
          <div className="flex items-center justify-between border-b border-[var(--metal-border-soft)] bg-black/40 px-4 py-3">
            {title ? (
              <Dialog.Title className="font-blackops text-[0.8rem] tracking-[0.22em] text-neutral-200">
                {title}
              </Dialog.Title>
            ) : (
              <div />
            )}
            <button
              type="button"
              onClick={onClose}
              className="inline-flex h-7 w-7 items-center justify-center rounded-full border border-white/20 bg-black/60 text-[0.75rem] text-neutral-200 hover:bg-black/80 hover:text-white active:scale-95"
              aria-label="Close"
              title="Close"
            >
              ✕
            </button>
          </div>

          {/* Body – optionally scrollable */}
          <div
            className={`px-4 py-4 sm:px-5 sm:py-5 ${
              bodyScrollable
                ? "max-h-[calc(100vh-8rem)] overflow-y-auto"
                : ""
            }`}
          >
            {children}
          </div>

          {/* Footer */}
          {!hideFooter && (onSubmit || footerLeft) && (
            <div className="flex items-center justify-between gap-3 border-t border-[var(--metal-border-soft)] bg-black/40 px-4 py-3 sm:px-5">
              <div className="flex items-center gap-2 text-[0.7rem] text-neutral-400">
                {footerLeft}
              </div>
              <div className="flex gap-2">
                <button
                  type="button"
                  onClick={onClose}
                  className="rounded-full border border-[var(--metal-border-soft)] bg-black/60 px-3 py-1.5 text-xs font-medium uppercase tracking-[0.18em] text-neutral-200 hover:bg-white/5"
                >
                  Cancel
                </button>
                {onSubmit && (
                  <button
                    type="button"
                    onClick={() => void onSubmit()}
                    className="rounded-full bg-[linear-gradient(to_right,var(--accent-copper-soft),var(--accent-copper))] px-4 py-1.5 text-xs font-semibold uppercase tracking-[0.22em] text-black shadow-[0_0_20px_rgba(212,118,49,0.7)] hover:brightness-110 disabled:opacity-60"
                  >
                    {submitText}
                  </button>
                )}
              </div>
            </div>
          )}
        </Dialog.Panel>
      </div>
    </Dialog>
  );
}

===== FILE: ./features/shared/components/JobActions.tsx =====
"use client";



import { Button } from "@shared/components/ui/Button";

type JobActionsProps = {
  status: string;
  onStart: () => void;
  onPause: () => void;
  onResume: () => void;
  onComplete: () => void;
  isOnHold: boolean;
  isCompleted: boolean;
};

export const JobActions: React.FC<JobActionsProps> = ({
  status,
  onStart,
  onPause,
  onResume,
  onComplete,
  isOnHold,
  isCompleted,
}) => {
  return (
    <div className="flex gap-2 mt-2">
      {status === "not_started" && (
        <Button onClick={onStart} className="bg-blue-600 text-white">
          Start Job
        </Button>
      )}

      {status === "in_progress" && (
        <>
          <Button onClick={onPause} className="bg-yellow-500 text-black">
            Pause
          </Button>
          <Button onClick={onComplete} className="bg-green-600 text-white">
            Complete
          </Button>
        </>
      )}

      {isOnHold && status === "on_hold" && (
        <Button onClick={onResume} className="bg-blue-500 text-white">
          Resume
        </Button>
      )}

      {isCompleted && (
        <span className="text-green-600 font-semibold">✅ Completed</span>
      )}
    </div>
  );
};


===== FILE: ./features/shared/components/ButtonLink.tsx =====
"use client";
import Link from "next/link";

type Props = {
  href: string;
  children: React.ReactNode;
  className?: string;
  prefetch?: boolean;
};

export default function ButtonLink({ href, children, className = "", prefetch = true }: Props) {
  return (
    <Link
      href={href}
      prefetch={prefetch}
      className={[
        "inline-flex items-center justify-center rounded-lg px-4 py-2",
        "bg-surface text-accent shadow-card hover:shadow-lg transition",
        "border border-neutral-800/20 dark:border-neutral-200/10",
        className,
      ].join(" ")}
    >
      {children}
    </Link>
  );
}


===== FILE: ./features/shared/components/ui/Card.tsx =====
// shared/components/Card.tsx
"use client";


import { cn } from "@shared/lib/utils";

interface CardProps {
  children: React.ReactNode;
  onClick?: () => void;
  className?: string;
}

export default function Card({ children, onClick, className }: CardProps) {
  return (
    <div
      onClick={onClick}
      className={cn(
        "rounded-2xl border border-white/8 bg-black/30",
        "backdrop-blur-md px-6 py-5 shadow-card transition",
        "hover:border-accent/70 hover:shadow-glow hover:-translate-y-[1px]",
        onClick ? "cursor-pointer" : "",
        className,
      )}
    >
      {children}
    </div>
  );
}

===== FILE: ./features/shared/components/ui/PreviousPageButton.tsx =====
// @shared/components/ui/PreviousPageButton.tsx
"use client";

import * as React from "react";
import { useRouter } from "next/navigation";
import { ChevronLeft } from "lucide-react";

type PreviousPageButtonProps = {
  /**
   * Optional explicit target.
   * If omitted, will try history.back(), with a safe fallback list route.
   */
  to?: string;
  label?: string;
  className?: string;
};

const baseClasses =
  "inline-flex items-center gap-1 rounded-full border border-neutral-700 bg-neutral-950/70 px-3 py-1.5 text-xs font-medium text-neutral-200 shadow-sm hover:border-neutral-500 hover:bg-neutral-900/80 transition-colors";

export default function PreviousPageButton({
  to,
  label = "Back",
  className = "",
}: PreviousPageButtonProps) {
  const router = useRouter();

  const handleClick = React.useCallback(() => {
    // If an explicit target is provided, respect it.
    if (to) {
      router.push(to);
      return;
    }

    // Otherwise, try to go back in history first.
    if (typeof window !== "undefined") {
      if (window.history.length > 1) {
        router.back();
        return;
      }

      // No history: choose a sensible fallback based on current path.
      const pathname = window.location.pathname || "";
      const fallback = pathname.startsWith("/mobile")
        ? "/mobile/work-orders"
        : "/work-orders";

      router.push(fallback);
    }
  }, [router, to]);

  return (
    <button
      type="button"
      onClick={handleClick}
      className={`${baseClasses} ${className}`.trim()}
    >
      <ChevronLeft className="h-4 w-4" />
      <span>{label}</span>
    </button>
  );
}

===== FILE: ./features/shared/components/ui/input.tsx =====
import * as React from "react";
import { cn } from "@shared/lib/utils";

type InputProps = React.InputHTMLAttributes<HTMLInputElement>;

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type = "text", ...props }, ref) => {
    return (
      <input
        type={type}
        ref={ref}
        className={cn(
          "w-full h-10 rounded-md px-3 py-2 text-sm text-white",
          "bg-zinc-900 border border-zinc-700",
          "placeholder:text-neutral-400",
          "focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-orange-500",
          "transition-all duration-200 ease-in-out",
          "disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        {...props}
      />
    );
  },
);

Input.displayName = "Input";

export { Input };


===== FILE: ./features/shared/components/ui/textarea.tsx =====
"use client";

import * as React from "react";
import { clsx } from "clsx";

type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>;

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className = "", ...props }, ref) => {
    return (
      <textarea
        ref={ref}
        className={clsx(
          "w-full min-h-[100px] rounded-md bg-zinc-900 border border-zinc-700 px-4 py-2 text-sm text-white placeholder-zinc-400 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed",
          className,
        )}
        {...props}
      />
    );
  },
);

Textarea.displayName = "Textarea";

export { Textarea };


===== FILE: ./features/shared/components/ui/Section.tsx =====
// shared/components/Section.tsx
"use client";


import { cn } from "@shared/lib/utils";

interface SectionProps {
  children: React.ReactNode;
  className?: string;
  id?: string;
  ariaLabel?: string;
}

export default function Section({
  children,
  className,
  id,
  ariaLabel,
}: SectionProps) {
  return (
    <section
      id={id}
      aria-label={ariaLabel || id || undefined}
      className={cn(
        "w-full py-10 md:py-14 lg:py-20 px-4 sm:px-6",
        "fade-in",
        "bg-transparent",
        className,
      )}
    >
      {children}
    </section>
  );
}

===== FILE: ./features/shared/components/ui/LinkButton.tsx =====
"use client";

import Link from "next/link";
import clsx from "clsx";


type Variant = "default" | "secondary" | "destructive" | "ghost" | "outline";
type Size = "sm" | "md" | "lg";

interface LinkButtonProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
  href: string;
  children: React.ReactNode;
  className?: string;
  variant?: Variant;
  size?: Size;
  icon?: React.ReactNode;
  iconRight?: React.ReactNode;
}

const variantClasses: Record<Variant, string> = {
  default: "bg-orange-600 hover:bg-orange-700 text-white",
  secondary: "bg-zinc-700 hover:bg-zinc-600 text-white",
  destructive: "bg-red-600 hover:bg-red-700 text-white",
  ghost: "bg-transparent hover:bg-zinc-800 text-white border border-zinc-600",
  outline:
    "bg-transparent border border-orange-500 text-orange-400 hover:bg-orange-500 hover:text-white",
};

const sizeClasses: Record<Size, string> = {
  sm: "text-sm px-3 py-1.5",
  md: "text-base px-4 py-2",
  lg: "text-lg px-5 py-3",
};

function LinkButton({
  href,
  children,
  className = "",
  variant = "default",
  size = "md",
  icon,
  iconRight,
  ...props
}: LinkButtonProps) {
  return (
    <Link
      href={href}
      className={clsx(
        "inline-flex items-center justify-center rounded font-semibold transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500",
        variantClasses[variant],
        sizeClasses[size],
        className,
      )}
      {...props}
    >
      {icon && <span className="mr-2">{icon}</span>}
      <span>{children}</span>
      {iconRight && <span className="ml-2">{iconRight}</span>}
    </Link>
  );
}

export default LinkButton;
export type { LinkButtonProps, Variant, Size };

===== FILE: ./features/shared/components/ui/badge.tsx =====
"use client";

import { cn } from "@shared/lib/utils";

export function Badge({
  children,
  className,
}: {
  children: React.ReactNode;
  className?: string;
}) {
  return (
    <span
      className={cn(
        "inline-flex items-center rounded-md border px-2 py-0.5 text-[10px] font-medium uppercase tracking-wide",
        className
      )}
    >
      {children}
    </span>
  );
}

===== FILE: ./features/shared/components/ui/dialog.tsx =====
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { cn } from "@shared/lib/utils";

export const Dialog = DialogPrimitive.Root;
export const DialogTrigger = DialogPrimitive.Trigger;

export const DialogPortal = ({
  children,
  ...props
}: DialogPrimitive.DialogPortalProps) => (
  <DialogPrimitive.Portal {...props}>{children}</DialogPrimitive.Portal>
);

export const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-40 bg-black/70 backdrop-blur-sm transition-opacity data-[state=open]:opacity-100 data-[state=closed]:opacity-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

export const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-1/2 top-1/2 z-50 w-[95%] max-w-lg -translate-x-1/2 -translate-y-1/2 rounded-xl border border-white/10 bg-black/80 p-6 shadow-xl backdrop-blur-xl",
        "data-[state=open]:animate-in data-[state=closed]:animate-out",
        "data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        "data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
        className
      )}
      {...props}
    >
      {children}
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

export const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col gap-1 border-b border-white/10 pb-3",
      className
    )}
    {...props}
  />
);

export const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-blackops uppercase tracking-[0.18em] text-neutral-300",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

export const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-neutral-400", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "mt-4 flex w-full items-center justify-end gap-2 border-t border-white/10 pt-3",
      className
    )}
    {...props}
  />
);

===== FILE: ./features/shared/components/ui/Container.tsx =====
// shared/components/Container.tsx
"use client";


import { cn } from "@shared/lib/utils";

interface ContainerProps {
  children: React.ReactNode;
  className?: string;
}

export default function Container({ children, className }: ContainerProps) {
  return (
    <div
      className={cn(
        "w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
        "py-6 md:py-8",
        className,
      )}
    >
      {children}
    </div>
  );
}

===== FILE: ./features/shared/components/ui/Button.tsx =====
// @shared/components/ui/Button.tsx
"use client";


import clsx from "clsx";

type Variant =
  | "default"
  | "secondary"
  | "destructive"
  | "ghost"
  | "outline"
  | "orange";
type Size = "xs" | "sm" | "md" | "lg";

interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  className?: string;
  variant?: Variant;
  size?: Size;
  isLoading?: boolean;
  icon?: React.ReactNode;
  iconRight?: React.ReactNode;
}

const base =
  "inline-flex items-center justify-center rounded font-semibold transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500 backdrop-blur-sm";

// glassy variants – all white text, orange-ish borders
const variantClasses: Record<Exclude<Variant, "orange">, string> = {
  default:
    "bg-black/30 border border-orange-400/80 text-white hover:bg-orange-500/10",
  secondary:
    "bg-black/20 border border-orange-400/60 text-white hover:bg-orange-500/10",
  destructive:
    "bg-red-700/80 border border-red-400 text-white hover:bg-red-600",
  ghost:
    "bg-transparent border border-orange-400/50 text-white hover:bg-orange-500/10",
  outline:
    "bg-transparent border border-orange-400 text-white hover:bg-orange-500/10",
};

// optional filled orange accent if you still want it elsewhere
const orangeClass =
  "bg-orange-500/90 hover:bg-orange-500 text-black border border-orange-400/80";

export function buttonClasses({
  variant = "default",
  size = "md",
  className = "",
  disabled = false,
  isLoading = false,
}: {
  variant?: Variant;
  size?: Size;
  className?: string;
  disabled?: boolean;
  isLoading?: boolean;
}) {
  const sizeClasses: Record<Size, string> = {
    xs: "text-xs px-2 py-1",
    sm: "text-sm px-3 py-1.5",
    md: "text-sm px-4 py-2",
    lg: "text-base px-5 py-3",
  };

  const applied =
    variant === "orange"
      ? orangeClass
      : variantClasses[variant as Exclude<Variant, "orange">];

  return clsx(
    base,
    applied,
    sizeClasses[size],
    disabled || isLoading ? "opacity-50 cursor-not-allowed" : "",
    className
  );
}

export const Button = ({
  children,
  className = "",
  variant = "default",
  size = "md",
  isLoading = false,
  icon,
  iconRight,
  disabled,
  ...props
}: ButtonProps) => {
  return (
    <button
      className={buttonClasses({
        variant,
        size,
        className,
        disabled,
        isLoading,
      })}
      disabled={disabled || isLoading}
      {...props}
    >
      {isLoading && (
        <svg
          className="mr-2 h-4 w-4 animate-spin text-white"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          />
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
          />
        </svg>
      )}
      {!isLoading && icon && <span className="mr-2">{icon}</span>}
      <span>{children}</span>
      {!isLoading && iconRight && <span className="ml-2">{iconRight}</span>}
    </button>
  );
};

===== FILE: ./features/shared/components/PhotoCapture.tsx =====
"use client";

import { useRef, useState } from "react";

type Props = {
  onImageSelect: (file: File) => void;
};

export default function PhotoCapture(rawProps: any) {
  // Cast internally so Next.js serializable-props check doesn’t run on the export type
  const { onImageSelect } = rawProps as Props;

  const captureInputRef = useRef<HTMLInputElement>(null);
  const uploadInputRef = useRef<HTMLInputElement>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setPreviewUrl(URL.createObjectURL(file));
    onImageSelect(file);
  };

  return (
    <div className="space-y-4">
      <div className="flex gap-4 justify-center">
        <button
          onClick={() => captureInputRef.current?.click()}
          className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold font-header rounded shadow-card"
        >
          📷 Capture Photo
        </button>
        <button
          onClick={() => uploadInputRef.current?.click()}
          className="px-4 py-2 bg-gray-700 hover:bg-gray-800 text-white font-bold font-header rounded shadow-card"
        >
          📁 Upload Photo
        </button>
      </div>

      {/* Hidden Inputs */}
      <input
        type="file"
        accept="image/*"
        capture="environment"
        ref={captureInputRef}
        onChange={handleFileChange}
        className="hidden"
      />
      <input
        type="file"
        accept="image/*"
        ref={uploadInputRef}
        onChange={handleFileChange}
        className="hidden"
      />

      {previewUrl && (
        <div className="mt-4 flex justify-center">
          <img
            src={previewUrl}
            alt="Preview"
            className="rounded border max-w-full shadow-card"
          />
        </div>
      )}
    </div>
  );
}

===== FILE: ./features/shared/components/AppShell.tsx =====
// features/shared/components/AppShell.tsx
"use client";

import Link from "next/link";
import { usePathname, useRouter } from "next/navigation";
import { useEffect, useRef, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { Toaster } from "sonner";

import RoleSidebar from "@/features/shared/components/RoleSidebar";
import ShiftTracker from "@shared/components/ShiftTracker";
import NewChatModal from "@/features/ai/components/chat/NewChatModal";
import AgentRequestModal from "@/features/agent/components/AgentRequestModal";
import { cn } from "@/features/shared/utils/cn";

const NON_APP_ROUTES = [
  "/",
  "/sign-in",
  "/sign-up",
  "/coming-soon",
  "/auth",
  "/mobile",
];

const ActionButton = ({
  onClick,
  children,
  title,
}: {
  onClick?: () => void;
  children: React.ReactNode;
  title?: string;
}) => (
  <button
    type="button"
    onClick={onClick}
    title={title}
    className="inline-flex items-center gap-1 rounded-md border border-white/10 bg-black/60 px-2.5 py-1.5 text-xs text-neutral-100 shadow-sm backdrop-blur-md transition hover:border-[color:var(--accent-copper-soft,#fdba74)] hover:text-white hover:bg-black/80"
  >
    {children}
  </button>
);

export default function AppShell({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();
  const router = useRouter();
  const supabase = createClientComponentClient<Database>();

  const [userId, setUserId] = useState<string | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);
  const [punchOpen, setPunchOpen] = useState(false);
  const [chatOpen, setChatOpen] = useState(false);
  const [agentDialogOpen, setAgentDialogOpen] = useState(false);
  const [incomingConvoId, setIncomingConvoId] = useState<string | null>(null);
  const [sidebarOpen, setSidebarOpen] = useState(true);

  const punchRef = useRef<HTMLDivElement | null>(null);

  const isAppRoute = !NON_APP_ROUTES.some(
    (p) => pathname === p || pathname.startsWith(p + "/"),
  );

  // load session user once, load role, & subscribe to messages
  useEffect(() => {
    (async () => {
      const {
        data: { session },
      } = await supabase.auth.getSession();
      const uid = session?.user?.id ?? null;
      setUserId(uid);

      if (!uid) return;

      // load user role for agent console gating
      try {
        const { data: profile } = await supabase
          .from("profiles")
          .select("role")
          .eq("id", uid)
          .single();

        if (profile?.role) {
          setUserRole(profile.role as string);
        }
      } catch (err) {
        console.error("Failed to load profile role for AppShell", err);
      }

      // realtime for incoming messages
      const channel = supabase
        .channel("app-shell-messages")
        .on(
          "postgres_changes",
          {
            event: "INSERT",
            schema: "public",
            table: "messages",
          },
          (payload) => {
            const msg =
              payload.new as Database["public"]["Tables"]["messages"]["Row"] &
                Partial<{ recipients: string[] }>;

            // ignore messages I sent
            if (msg.sender_id === uid) return;

            // if a recipients array exists, make sure i'm in it
            if (Array.isArray((msg as any).recipients)) {
              const recips = (msg as any).recipients as string[];
              if (!recips.includes(uid)) {
                return;
              }
            }

            // ok, this is for me – open modal on top
            setIncomingConvoId(msg.conversation_id);
            setChatOpen(true);
          },
        )
        .subscribe();

      return () => {
        supabase.removeChannel(channel);
      };
    })();
  }, [supabase]);

  // click-away for shift tracker
  useEffect(() => {
    if (!punchOpen) return;
    const onClick = (e: MouseEvent) => {
      if (!punchRef.current) return;
      if (!punchRef.current.contains(e.target as Node)) {
        setPunchOpen(false);
      }
    };
    document.addEventListener("mousedown", onClick);
    return () => document.removeEventListener("mousedown", onClick);
  }, [punchOpen]);

  const NavItem = ({ href, label }: { href: string; label: string }) => {
    const active = pathname.startsWith(href);
    return (
      <Link
        href={href}
        className={cn(
          "flex-1 py-2 text-center text-xs font-medium transition-colors",
          active
            ? "text-[color:var(--accent-copper,#f97316)] font-semibold"
            : "text-neutral-500 hover:text-neutral-100",
        )}
      >
        {label}
      </Link>
    );
  };

  // who can see the Agent Console button
  const canSeeAgentConsole =
    !!userRole &&
    ["owner", "manager", "admin", "advisor", "agent_admin"].includes(userRole);

  if (!isAppRoute) {
    return (
      <div className="min-h-screen bg-black text-foreground">
        {children}
        <Toaster
          closeButton
          richColors
          position="top-right"
          theme="dark"
        />
      </div>
    );
  }

  return (
    <>
      <div className="flex min-h-screen bg-transparent text-foreground">
        {/* Sidebar – collapsible on desktop */}
        <aside
          className={cn(
            "hidden md:flex md:flex-col border-r border-[color:var(--metal-border-soft,#1f2937)] bg-gradient-to-b from-black/90 via-slate-950/95 to-black/90 backdrop-blur-xl transition-all duration-300",
            sidebarOpen
              ? "md:w-64 translate-x-0"
              : "md:w-0 -translate-x-full pointer-events-none",
          )}
        >
          <div className="flex h-14 items-center justify-between border-b border-white/10 px-4">
            <Link
              href="/dashboard"
              className="text-lg font-semibold tracking-tight text-neutral-100 hover:text-[color:var(--accent-copper,#f97316)] transition-colors"
              style={{
                fontFamily: "Black Ops One, var(--font-blackops), system-ui",
              }}
            >
              ProFixIQ
            </Link>
          </div>

          <RoleSidebar />

          <div className="mt-auto h-12 border-t border-white/10" />
        </aside>

        {/* Main */}
        <div className="flex min-h-screen flex-1 flex-col">
          {/* Top bar */}
          <header className="fixed inset-x-0 top-0 z-40 hidden h-14 items-center justify-between border-b border-[color:var(--metal-border-soft,#1f2937)] bg-gradient-to-r from-black/90 via-slate-950/90 to-black/90 px-4 shadow-[0_18px_40px_rgba(0,0,0,0.95)] backdrop-blur-xl md:flex">
            <div className="flex items-center gap-3">
              {/* Sidebar toggle */}
              <button
                type="button"
                onClick={() => setSidebarOpen((v) => !v)}
                className="inline-flex h-9 w-9 items-center justify-center rounded-md border border-white/10 bg-black/60 text-neutral-300 shadow-sm transition hover:border-[color:var(--accent-copper-soft,#fdba74)] hover:text-white hover:bg-black/80"
              >
                <span className="sr-only">Toggle navigation</span>
                <div className="space-y-0.5">
                  <span className="block h-[2px] w-4 rounded-full bg-current" />
                  <span className="block h-[2px] w-4 rounded-full bg-current" />
                  <span className="block h-[2px] w-4 rounded-full bg-current" />
                </div>
              </button>

              <nav className="flex gap-4 text-sm text-neutral-400">
                <Link href="/dashboard" className="hover:text-neutral-100">
                  Dashboard
                </Link>
                <Link href="/work-orders" className="hover:text-neutral-100">
                  Work Orders
                </Link>
                <Link href="/inspections" className="hover:text-neutral-100">
                  Inspections
                </Link>
                <Link href="/parts" className="hover:text-neutral-100">
                  Parts
                </Link>
              </nav>
            </div>

            <div className="flex items-center gap-2">
              {userId ? (
                <ActionButton
                  onClick={() => setPunchOpen((p) => !p)}
                  title="Punch / shift tracker"
                >
                  <span className="inline-block h-2 w-2 rounded-full bg-emerald-400 shadow-[0_0_10px_rgba(16,185,129,0.9)]" />
                  Shift
                </ActionButton>
              ) : null}

              <ActionButton onClick={() => setChatOpen(true)} title="Messages">
                💬 <span className="hidden lg:inline">Messages</span>
              </ActionButton>

              {userId && (
                <ActionButton
                  onClick={() => setAgentDialogOpen(true)}
                  title="Submit a request to ProFixIQ Agent"
                >
                  🤖 <span className="hidden lg:inline">Agent Request</span>
                </ActionButton>
              )}

              <ActionButton
                onClick={() => router.push("/portal/appointments")}
                title="Planner / appointments"
              >
                📅 <span className="hidden lg:inline">Planner</span>
              </ActionButton>

              <ActionButton
                onClick={() => router.push("/agent/planner")}
                title="AI Planner"
              >
                ⚡ <span className="hidden lg:inline">AI Planner</span>
              </ActionButton>

              {userId && canSeeAgentConsole && (
                <ActionButton
                  onClick={() => router.push("/agent")}
                  title="ProFixIQ Agent Console"
                >
                  🧠 <span className="hidden lg:inline">Agent</span>
                </ActionButton>
              )}

              <ActionButton
                onClick={async () => {
                  await supabase.auth.signOut();
                  router.replace("/sign-in");
                }}
                title="Sign out"
              >
                Sign out
              </ActionButton>
            </div>
          </header>

          {/* floating shift panel */}
          {punchOpen && userId ? (
            <div
              ref={punchRef}
              className="fixed right-6 top-20 z-50 hidden w-72 rounded-xl border border-[color:var(--metal-border-soft,#1f2937)] bg-black/90 p-3 shadow-[0_18px_40px_rgba(0,0,0,0.95)] backdrop-blur-xl md:block"
            >
              <h2 className="mb-2 text-sm font-medium text-neutral-100">
                Shift Tracker
              </h2>
              <ShiftTracker userId={userId} />
            </div>
          ) : null}

          {/* content */}
          <main className="mx-auto flex w-full max-w-6xl flex-1 flex-col px-3 pb-14 pt-16 md:px-6 md:pb-6 md:pt-20">
            {children}
          </main>

          {/* mobile nav */}
          <nav className="fixed inset-x-0 bottom-0 z-40 border-t border-[color:var(--metal-border-soft,#1f2937)] bg-black/95 pb-[env(safe-area-inset-bottom)] backdrop-blur md:hidden">
            <div className="flex px-1">
              <NavItem href="/dashboard" label="Dashboard" />
              <NavItem href="/work-orders" label="Work Orders" />
              <NavItem href="/inspections" label="Inspections" />
              <NavItem href="/chat" label="Messages" />
              <NavItem href="/mobile/planner" label="Planner" />

              <button
                type="button"
                onClick={async () => {
                  await supabase.auth.signOut();
                  router.replace("/sign-in");
                }}
                className="flex-1 py-2 text-center text-xs font-medium text-neutral-500 transition-colors hover:text-neutral-100"
              >
                Sign Out
              </button>
            </div>
          </nav>
        </div>
      </div>

      {/* Global chat modal */}
      <NewChatModal
        isOpen={chatOpen}
        onClose={() => {
          setChatOpen(false);
          setIncomingConvoId(null);
        }}
        created_by={userId ?? undefined}
        context_type={null}
        context_id={null}
        activeConversationId={incomingConvoId}
      />

      {/* Global Agent Request modal */}
      {userId && (
        <AgentRequestModal
          open={agentDialogOpen}
          onOpenChange={setAgentDialogOpen}
        />
      )}

      {/* Global toaster for the entire app shell */}
      <Toaster closeButton richColors position="top-right" theme="dark" />
    </>
  );
}

===== FILE: ./features/work-orders/app/work-orders/create/page.tsx =====
"use client";

/**
 * Create Work Order (Front Desk)
 * ---------------------------------------------------------------------------
 * Integrated with VIN scanner + draft store.
 */

import { 
  useCallback,
  useEffect,
  useMemo,
  useState,
} from "react";
import dynamic from "next/dynamic";
import { useRouter, useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { useTabState } from "@/features/shared/hooks/useTabState";

import VinCaptureModal from "app/vehicle/VinCaptureModal";
import { useWorkOrderDraft } from "app/work-orders/state/useWorkOrderDraft";
import { useCustomerVehicleDraft } from "app/work-orders/state/useCustomerVehicleDraft";

// UI
import CustomerVehicleForm from "@/features/inspections/components/inspection/CustomerVehicleForm";
import { MenuQuickAdd } from "@work-orders/components/MenuQuickAdd";
import { NewWorkOrderLineForm } from "@work-orders/components/NewWorkOrderLineForm";
import { AiSuggestModal } from "@work-orders/components/AiSuggestModal";

// 🔢 shared custom-id generator
import { generateWorkOrderCustomId } from "@/features/work-orders/lib/generateCustomId";

// Session types
import type {
  SessionCustomer,
  SessionVehicle,
} from "@/features/inspections/lib/inspection/types";

// 👇 inspection modal, client-only
const InspectionModal = dynamic(
  () => import("@/features/inspections/components/InspectionModal"),
  { ssr: false },
);

/* =============================================================================
   Types & helpers
============================================================================= */
type DB = Database;
type WorkOrderRow = DB["public"]["Tables"]["work_orders"]["Row"];
type WorkOrderInsert = DB["public"]["Tables"]["work_orders"]["Insert"];
type LineRow = DB["public"]["Tables"]["work_order_lines"]["Row"];
type CustomerRow = DB["public"]["Tables"]["customers"]["Row"];
type VehicleRow = DB["public"]["Tables"]["vehicles"]["Row"];

type WOType = "inspection" | "maintenance" | "diagnosis";
type UploadSummary = { uploaded: number; failed: number };

// Extended line type so we can read template metadata safely
type WorkOrderLineWithInspectionMeta = LineRow & {
  inspection_template?: string | null;
  inspectionTemplate?: string | null;
  template?: string | null;
  inspection_template_id?: string | null;
  metadata?:
    | {
        inspection_template_id?: string | null;
        inspection_template?: string | null;
        template?: string | null;
        [key: string]: unknown;
      }
    | null;
};

const getStrField = (obj: unknown, key: string): string | null => {
  if (obj && typeof obj === "object") {
    const v = (obj as Record<string, unknown>)[key];
    if (typeof v === "string") return v.trim() || null;
    if (typeof v === "number") return String(v);
    if (v == null) return null;
  }
  return null;
};

const getMetaString = (meta: unknown, key: string): string | null => {
  if (!meta || typeof meta !== "object") return null;
  const v = (meta as Record<string, unknown>)[key];
  if (typeof v !== "string") return null;
  const t = v.trim();
  return t.length ? t : null;
};

const strOrNull = (v: string | null | undefined) => {
  const t = (v ?? "").trim();
  return t ? t : null;
};
const numOrNull = (v: string | number | null | undefined) => {
  if (v === null || v === undefined) return null;
  const s = String(v).trim();
  if (!s) return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
};

export default function CreateWorkOrderPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);

  useEffect(() => {
    (window as unknown as Record<string, unknown>)._sb = supabase;
  }, [supabase]);

  // Prefill ids from URL
  const [prefillVehicleId, setPrefillVehicleId] = useTabState<string | null>(
    "prefillVehicleId",
    null,
  );
  const [prefillCustomerId, setPrefillCustomerId] = useTabState<string | null>(
    "prefillCustomerId",
    null,
  );

  // Keep state (not shown in UI now)
  const [, setSourceFlags] = useTabState("__create_sources", {
    queryVehicle: false,
    queryCustomer: false,
    autoWO: false,
  } as {
    queryVehicle: boolean;
    queryCustomer: boolean;
    autoWO: boolean;
  });

  // Session-shaped state
  const defaultCustomer: SessionCustomer = {
    first_name: null,
    last_name: null,
    phone: null,
    email: null,
    address: null,
    city: null,
    province: null,
    postal_code: null,
  };
  const defaultVehicle: SessionVehicle = {
    year: null,
    make: null,
    model: null,
    vin: null,
    license_plate: null,
    mileage: null,
    color: null,
    unit_number: null,
    engine_hours: null,
  };

  const [customer, setCustomer] = useTabState<SessionCustomer>(
    "__cv_customer",
    defaultCustomer,
  );
  const [vehicle, setVehicle] = useTabState<SessionVehicle>(
    "__cv_vehicle",
    defaultVehicle,
  );

  // CV draft (session persisted)
  const cvDraft = useCustomerVehicleDraft();

  // Hydrate from CV draft on first load (only fill empty fields)
  useEffect(() => {
    const d = cvDraft;
    if (!d) return;

    const hasDraftCust = Object.values(d.customer || {}).some(Boolean);
    const hasDraftVeh = Object.values(d.vehicle || {}).some(Boolean);

    if (hasDraftCust) {
      setCustomer((prev) => ({
        ...prev,
        ...Object.fromEntries(
          Object.entries(d.customer).map(([k, v]) => [
            k as keyof SessionCustomer,
            (prev as any)[k] ?? v ?? null,
          ]),
        ),
      }));
    }
    if (hasDraftVeh) {
      setVehicle((prev) => ({
        ...prev,
        vin: d.vehicle.vin ?? prev.vin,
        year: d.vehicle.year ?? prev.year,
        make: d.vehicle.make ?? prev.make,
        model: d.vehicle.model ?? prev.model,
        license_plate:
          // support both new `license_plate` and legacy `plate` fields
          (d.vehicle as any).license_plate ??
          (d.vehicle as any).plate ??
          prev.license_plate,
      }));
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // once

  const onCustomerChange = (
    field: keyof SessionCustomer | "business_name",
    value: string | null,
  ) => {
    if (field === "business_name") {
      // store extra field alongside SessionCustomer shape
      setCustomer((c) => ({ ...(c as any), business_name: value } as any));
      cvDraft.setCustomerField(field as any, value);
    } else {
      setCustomer((c) => ({ ...c, [field]: value }));
      cvDraft.setCustomerField(field as any, value);
    }
  };

  const onVehicleChange = (
    field: keyof SessionVehicle,
    value: string | null,
  ) => {
    setVehicle((v) => ({ ...v, [field]: value }));
    cvDraft.setVehicleField(field as any, value);
  };

  // Captured ids
  const [customerId, setCustomerId] = useTabState<string | null>(
    "customerId",
    null,
  );
  const [vehicleId, setVehicleId] = useTabState<string | null>(
    "vehicleId",
    null,
  );

  // Work order + lines
  const [wo, setWo] = useTabState<WorkOrderRow | null>("__create_wo", null);
  const [lines, setLines] = useTabState<LineRow[]>("__create_lines", []);

  // ✅ inspection modal state
  const [inspectionOpen, setInspectionOpen] = useState(false);
  const [inspectionSrc, setInspectionSrc] = useState<string | null>(null);

  // ✅ AI suggest modal state
  const [aiSuggestOpen, setAiSuggestOpen] = useState(false);

  // Defaults / notes
  const [type, setType] = useTabState<WOType>("type", "maintenance");
  const [notes, setNotes] = useTabState("notes", "");
  // 👇 work order priority (1 urgent → 4 low). default 3 = normal
  const [priority, setPriority] = useTabState<number>("priority", 3);
  // 👇 waiter flag (customer waiting on-site)
  const [isWaiter, setIsWaiter] = useTabState<boolean>("is_waiter", false);

  // Uploads
  const [photoFiles, setPhotoFiles] = useState<File[]>([]);
  const [docFiles, setDocFiles] = useState<File[]>([]);
  const [uploadSummary, setUploadSummary] = useState<UploadSummary | null>(
    null,
  );

  // UI state
  const [loading, setLoading] = useTabState("loading", false);
  const [error, setError] = useTabState("error", "");
  const [inviteNotice, setInviteNotice] =
    useTabState<string>("inviteNotice", "");
  const [sendInvite, setSendInvite] = useTabState<boolean>("sendInvite", false);

  // Current user id (for VIN modal)
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  // read profile.shop_id early so autocomplete is scoped before WO exists
  const [currentShopId, setCurrentShopId] = useState<string | null>(null);
  useEffect(() => {
    (async () => {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user?.id) return;

      let shop: string | null = null;
      const byUserId = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("user_id", user.id)
        .maybeSingle();

      if (byUserId.data?.shop_id) {
        shop = byUserId.data.shop_id;
      } else {
        const byId = await supabase
          .from("profiles")
          .select("shop_id")
          .eq("id", user.id)
          .maybeSingle();
        shop = byId.data?.shop_id ?? null;
      }

      setCurrentShopId(shop);
    })();
  }, [supabase]);

  // VIN / OCR draft hydration
  const draft = useWorkOrderDraft();
  useEffect(() => {
    const hasVeh = Object.values(draft.vehicle || {}).some((v) => v);
    const hasCust = Object.values(draft.customer || {}).some((v) => v);

    if (hasVeh) {
      setVehicle((prev) => ({
        ...prev,
        vin: draft.vehicle.vin ?? prev.vin,
        year: draft.vehicle.year ?? prev.year,
        make: draft.vehicle.make ?? prev.make,
        model: draft.vehicle.model ?? prev.model,
        license_plate:
          (draft.vehicle as any).license_plate ??
          (draft.vehicle as any).plate ??
          prev.license_plate,
      }));
    }
    if (hasCust) {
      setCustomer((prev) => ({
        ...prev,
        first_name: draft.customer.first_name ?? prev.first_name,
        last_name: draft.customer.last_name ?? prev.last_name,
        phone: draft.customer.phone ?? prev.phone,
        email: draft.customer.email ?? prev.email,
      }));
    }

    if (hasVeh || hasCust) {
      setSourceFlags((s) => ({
        ...s,
        queryVehicle: s.queryVehicle || hasVeh,
        queryCustomer: s.queryCustomer || hasCust,
      }));
      draft.reset();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // keep waiter state in sync with an existing WO (editing case)
  useEffect(() => {
    if (!wo) return;
    const flag = (wo as any).is_waiter ?? false;
    setIsWaiter(Boolean(flag));
  }, [wo, setIsWaiter]);

  // get current user id (for VIN modal)
  useEffect((): void => {
    (async () => {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      setCurrentUserId(user?.id ?? null);
    })();
  }, [supabase]);

  async function getOrLinkShopId(userId: string): Promise<string | null> {
    // 1) try to read the profile we actually have (id = auth user id)
    const { data: profileById, error: profErr } = await supabase
      .from("profiles")
      .select("shop_id")
      .eq("id", userId)
      .maybeSingle();

    if (profErr) throw profErr;
    if (profileById?.shop_id) {
      return profileById.shop_id;
    }

    // 2) no shop on profile → see if this user owns a shop
    const { data: ownedShop, error: shopErr } = await supabase
      .from("shops")
      .select("id")
      .eq("owner_id", userId)
      .maybeSingle();

    if (shopErr) throw shopErr;
    if (!ownedShop?.id) {
      // nothing to link
      return null;
    }

    // 3) write it back to profile so future calls are fast
    const { error: updErr } = await supabase
      .from("profiles")
      .update({ shop_id: ownedShop.id })
      .eq("id", userId);

    if (updErr) throw updErr;

    return ownedShop.id;
  }

  const buildCustomerInsert = (c: SessionCustomer, shopId: string | null) => ({
    business_name: strOrNull((c as any).business_name ?? null),
    first_name: strOrNull(c.first_name),
    last_name: strOrNull(c.last_name),
    phone: strOrNull(c.phone),
    email: strOrNull(c.email),
    address: strOrNull(c.address),
    city: strOrNull(c.city),
    province: strOrNull(c.province),
    postal_code: strOrNull(c.postal_code),
    shop_id: shopId,
  });

  const buildVehicleInsert = (
    v: SessionVehicle,
    customerId: string,
    shopId: string | null,
  ) => ({
    customer_id: customerId,
    vin: strOrNull(v.vin),
    year: numOrNull(v.year),
    make: strOrNull(v.make),
    model: strOrNull(v.model),
    license_plate: strOrNull(v.license_plate),
    mileage: strOrNull(v.mileage),
    unit_number: strOrNull(v.unit_number),
    color: strOrNull(v.color),
    engine_hours: numOrNull(v.engine_hours),
    shop_id: shopId,
  });

  // helper to hydrate customer state from DB row (including business_name when present)
  const hydrateCustomerFromRow = (row: any): SessionCustomer => {
    const base: any = {
      first_name: row.first_name ?? null,
      last_name: row.last_name ?? null,
      phone: getStrField(row, "phone"),
      email: row.email ?? null,
      address: getStrField(row, "address"),
      city: getStrField(row, "city"),
      province: getStrField(row, "province"),
      postal_code: getStrField(row, "postal_code"),
    };
    if (row.business_name) {
      base.business_name = row.business_name;
    }
    return base as SessionCustomer;
  };

  // Read query params (prefill)
  useEffect(() => {
    const v = searchParams.get("vehicleId");
    const c = searchParams.get("customerId");
    if (v) {
      setPrefillVehicleId(v);
      setSourceFlags((s) => ({ ...s, queryVehicle: true }));
    }
    if (c) {
      setPrefillCustomerId(c);
      setSourceFlags((s) => ({ ...s, queryCustomer: true }));
    }
  }, [searchParams, setPrefillVehicleId, setPrefillCustomerId, setSourceFlags]);

  // Prefill from DB → session shapes
  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        if (prefillCustomerId) {
          const { data } = await supabase
            .from("customers")
            .select("*")
            .eq("id", prefillCustomerId)
            .single();
          if (!cancelled && data) {
            setCustomer(hydrateCustomerFromRow(data));
            setCustomerId(data.id);
          }
        }
        if (prefillVehicleId) {
          const { data } = await supabase
            .from("vehicles")
            .select(
              "id, vin, year, make, model, license_plate, mileage, unit_number, color, engine_hours, customer_id",
            )
            .eq("id", prefillVehicleId)
            .single();
          if (!cancelled && data) {
            setVehicle({
              vin: data.vin ?? null,
              year: data.year != null ? String(data.year) : null,
              make: data.make ?? null,
              model: data.model ?? null,
              license_plate: data.license_plate ?? null,
              mileage: getStrField(data, "mileage"),
              unit_number: getStrField(data, "unit_number"),
              color: getStrField(data, "color"),
              engine_hours:
                data.engine_hours != null ? String(data.engine_hours) : null,
            });
            setVehicleId(data.id);

            if (!customerId && data.customer_id) {
              const { data: cust } = await supabase
                .from("customers")
                .select("*")
                .eq("id", data.customer_id)
                .maybeSingle();
              if (cust) {
                setCustomer(hydrateCustomerFromRow(cust));
                setCustomerId(cust.id);
              }
            }
          }
        }
      } catch {
        // noop
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [
    prefillCustomerId,
    prefillVehicleId,
    supabase,
    setCustomer,
    setVehicle,
    setCustomerId,
    setVehicleId,
    customerId,
  ]);

  // Ensure / create: Customer & Vehicle
  async function ensureCustomer(shopId: string): Promise<CustomerRow> {
    if (customerId) {
      const { data } = await supabase
        .from("customers")
        .select("*")
        .eq("id", customerId)
        .single();
      if (data) return data;
    }

    let q = supabase.from("customers").select("*").eq("shop_id", shopId).limit(1);
    if (customer.phone) q = q.ilike("phone", customer.phone);
    else if (customer.email) q = q.ilike("email", customer.email);
    const { data: found } = await q;
    if (found?.length) {
      setCustomerId(found[0].id);
      return found[0];
    }

    const { data: inserted, error: insErr } = await supabase
      .from("customers")
      .insert(buildCustomerInsert(customer, shopId))
      .select("*")
      .single();
    if (insErr || !inserted)
      throw new Error(insErr?.message ?? "Failed to create customer");
    setCustomerId(inserted.id);
    return inserted;
  }

  async function ensureVehicleRow(
    cust: CustomerRow,
    shopId: string | null,
  ): Promise<VehicleRow> {
    if (vehicleId) {
      const { data } = await supabase
        .from("vehicles")
        .select("*")
        .eq("id", vehicleId)
        .single();
      if (data) return data;
    }
    const orParts = [
      vehicle.vin ? `vin.eq.${vehicle.vin}` : "",
      vehicle.license_plate ? `license_plate.eq.${vehicle.license_plate}` : "",
    ].filter(Boolean);
    if (orParts.length) {
      const { data: maybe } = await supabase
        .from("vehicles")
        .select("*")
        .eq("customer_id", cust.id)
        .or(orParts.join(","));
      if (maybe?.length) {
        setVehicleId(maybe[0].id);
        return maybe[0] as VehicleRow;
      }
    }

    const { data: inserted, error: insErr } = await supabase
      .from("vehicles")
      .insert(buildVehicleInsert(vehicle, cust.id, shopId))
      .select("*")
      .single();
    if (insErr || !inserted)
      throw new Error(insErr?.message ?? "Failed to create vehicle");
    setVehicleId(inserted.id);
    return inserted as VehicleRow;
  }

  // Save & Continue (creates/links WO right away)
  const [savingCv, setSavingCv] = useState(false);
  const fetchLines = useCallback(async () => {
    if (!wo?.id) return;
    const { data } = await supabase
      .from("work_order_lines")
      .select("*")
      .eq("work_order_id", wo.id)
      .order("created_at", { ascending: true });
    setLines(data ?? []);
  }, [supabase, wo?.id, setLines]);

  const handleSaveCustomerVehicle = useCallback(async () => {
    if (savingCv) return;
    setSavingCv(true);
    setError("");

    try {
      if (!customer.first_name && !customer.phone && !customer.email) {
        throw new Error(
          "Please enter at least a name, phone, or email for the customer.",
        );
      }

      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user?.id) throw new Error("Not signed in.");
      const shopId = await getOrLinkShopId(user.id);
      if (!shopId) throw new Error("Your profile isn’t linked to a shop yet.");

      const cust = await ensureCustomer(shopId);
      const veh = await ensureVehicleRow(cust, shopId);

      cvDraft.bulkSet({
        customer: {
          first_name: cust.first_name ?? null,
          last_name: cust.last_name ?? null,
          phone: customer.phone ?? null,
          email: cust.email ?? null,
          address: customer.address ?? null,
          city: customer.city ?? null,
          province: customer.province ?? null,
          postal_code: customer.postal_code ?? null,
          // business_name is optional, lives in draft as any if supported
          ...(cust as any).business_name
            ? { business_name: (cust as any).business_name }
            : {},
        } as any,
        vehicle: {
          vin: veh.vin ?? null,
          year: veh.year != null ? String(veh.year) : null,
          make: veh.make ?? null,
          model: veh.model ?? null,
          license_plate: veh.license_plate ?? null,
          mileage: (veh.mileage as string | null) ?? vehicle.mileage ?? null,
          unit_number: vehicle.unit_number ?? null,
          color: veh.color ?? null,
          engine_hours: vehicle.engine_hours ?? null,
        },
      });

      if (wo?.id) {
        if (wo.customer_id !== cust.id || wo.vehicle_id !== veh.id) {
          const { data: updated, error: updErr } = await supabase
            .from("work_orders")
            .update({
              customer_id: cust.id,
              vehicle_id: veh.id,
              // keep existing waiter flag when editing
              ...(typeof (wo as any).is_waiter !== "undefined"
                ? { is_waiter: (wo as any).is_waiter }
                : {}),
            } as any)
            .eq("id", wo.id)
            .select("*")
            .single();
          if (updErr) throw updErr;
          setWo(updated);
        }
        await fetchLines();
        return;
      }

      // 🔑 Only here do we create a new work order now
      const customId = await generateWorkOrderCustomId(supabase, cust.id);
      const newId = uuidv4();

      const insertPayload: WorkOrderInsert = {
        id: newId,
        custom_id: customId ?? null,
        vehicle_id: veh.id,
        customer_id: cust.id,
        notes: strOrNull(notes),
        user_id: user.id,
        shop_id: shopId,
        status: "awaiting_approval",
        priority: priority,
      };

      // waiter flag – stored on work_orders.is_waiter (typed via any)
      (insertPayload as any).is_waiter = isWaiter;

      const { data: inserted, error: insertWOError } = await supabase
        .from("work_orders")
        .insert(insertPayload as any)
        .select("*")
        .single();
      if (insertWOError || !inserted)
        throw new Error(insertWOError?.message || "Failed to create work order.");

      setWo(inserted);
      await fetchLines();
    } catch (e) {
      const msg =
        e instanceof Error ? e.message : "Failed to save customer/vehicle.";
      setError(msg);
    } finally {
      setSavingCv(false);
    }
  }, [
    savingCv,
    supabase,
    wo?.id,
    notes,
    customer,
    fetchLines,
    cvDraft,
    vehicle,
    priority,
    isWaiter,
    wo,
  ]);

  // Clear form
  const handleClearForm = useCallback(() => {
    setCustomer(defaultCustomer as any); // clears known fields; extra ones like business_name drop to undefined
    setVehicle(defaultVehicle);
    setCustomerId(null);
    setVehicleId(null);
    setPrefillCustomerId(null);
    setPrefillVehicleId(null);
    setPhotoFiles([]);
    setDocFiles([]);
    setUploadSummary(null);
    setInviteNotice("");
    setSendInvite(false);
    setIsWaiter(false);
    cvDraft.reset();
  }, [
    setCustomer,
    setVehicle,
    setCustomerId,
    setVehicleId,
    setPrefillCustomerId,
    setPrefillVehicleId,
    setPhotoFiles,
    setDocFiles,
    setUploadSummary,
    setInviteNotice,
    setSendInvite,
    setIsWaiter,
    cvDraft,
  ]);

  // Upload helpers
  async function uploadVehicleFiles(vId: string): Promise<UploadSummary> {
    let uploaded = 0,
      failed = 0;
    const {
      data: { user },
    } = await supabase.auth.getUser();
    const uploader = user?.id ?? null;
    const currentShopIdForMedia = wo?.shop_id ?? null;

    const upOne = async (
      bucket: "vehicle-photos" | "vehicle-docs",
      f: File,
      mediaType: "photo" | "document",
    ) => {
      const key = `veh_${vId}/${Date.now()}_${f.name}`;
      const up = await supabase.storage.from(bucket).upload(key, f, {
        upsert: false,
      });
      if (up.error) {
        failed += 1;
        return;
      }
      const { error: rowErr } = await supabase.from("vehicle_media").insert({
        vehicle_id: vId,
        type: mediaType,
        storage_path: key,
        uploaded_by: uploader,
        shop_id: currentShopIdForMedia,
      });
      if (rowErr) failed += 1;
      else uploaded += 1;
    };

    for (const f of photoFiles) await upOne("vehicle-photos", f, "photo");
    for (const f of docFiles) await upOne("vehicle-docs", f, "document");
    return { uploaded, failed };
  }

  const handleDeleteLine = useCallback(
    async (lineId: string) => {
      if (!wo?.id) return;

      const ok = confirm("Delete this line?");
      if (!ok) return;

      try {
        const q = supabase
          .from("work_order_lines")
          .delete()
          .eq("id", lineId)
          .eq("work_order_id", wo.id);

        if (wo.shop_id) (q as any).eq("shop_id", wo.shop_id);

        const { data: deleted, error } = await (q as any)
          .select("id")
          .maybeSingle();

        if (error) {
          alert(error.message || "Delete failed");
          return;
        }
        if (!deleted) {
          alert(
            "Could not delete the line (no matching row). Check permissions/policies.",
          );
          return;
        }

        setLines((prev) => prev.filter((l) => l.id !== lineId));
        await fetchLines();
      } catch (err) {
        const msg = err instanceof Error ? err.message : "Delete failed";
        alert(msg);
      }
    },
    [supabase, wo?.id, wo?.shop_id, fetchLines, setLines],
  );

  // ✅ open inspection for a given line – unified stack
  const openInspectionForLine = useCallback(
    (line: LineRow) => {
      if (!wo?.id || !line?.id) return;

      const ln = line as WorkOrderLineWithInspectionMeta;

      // Prefer FK → inspection_templates.id
      const templateId: string | null =
        ln.inspection_template_id ??
        getMetaString(ln.metadata, "inspection_template_id");

      // Optional human-readable slug / name (for legacy routes / context)
      const templateSlug: string | null =
        ln.inspection_template ??
        ln.inspectionTemplate ??
        ln.template ??
        getMetaString(ln.metadata, "inspection_template") ??
        getMetaString(ln.metadata, "template");

      if (!templateId && !templateSlug) {
        alert(
          "This job line doesn't have an inspection template attached yet. Build or attach a custom inspection first.",
        );
        return;
      }

      const params = new URLSearchParams({
        workOrderId: wo.id,
        workOrderLineId: line.id,
      });

      if (vehicleId) params.set("vehicleId", vehicleId);
      if (customerId) params.set("customerId", customerId);
      if (templateId) params.set("templateId", templateId);
      if (templateSlug) params.set("template", templateSlug);
      params.set("embed", "1");

      const url = `/inspections/unified/session/${encodeURIComponent(
        line.id,
      )}?${params.toString()}`;

      setInspectionSrc(url);
      setInspectionOpen(true);
    },
    [wo?.id, vehicleId, customerId],
  );

  // Submit → Review & Sign
  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    if (loading) return;
    setLoading(true);
    setError("");
    setInviteNotice("");
    setUploadSummary(null);

    try {
      // Make sure customer & vehicle (and WO) are persisted first
      await handleSaveCustomerVehicle();

      const woId = wo?.id;
      if (!woId) throw new Error("Could not create work order.");

      const { data: latest, error: latestErr } = await supabase
        .from("work_orders")
        .select("id, custom_id, customer_id, vehicle_id, is_waiter")
        .eq("id", woId)
        .maybeSingle();

      if (latestErr) throw latestErr;
      if (!latest?.customer_id || !latest?.vehicle_id) {
        throw new Error("Please link a customer and vehicle first.");
      }

      if (vehicleId && (photoFiles.length || docFiles.length)) {
        const summary = await uploadVehicleFiles(vehicleId);
        setUploadSummary(summary);
      }

      if (sendInvite && customer.email) {
        try {
          const origin =
            typeof window !== "undefined"
              ? window.location.origin
              : (process.env.NEXT_PUBLIC_SITE_URL || "").replace(/\/$/, "");
          const portalUrl = `${
            origin || "https://profixiq.com"
          }/portal/signup?email=${encodeURIComponent(customer.email)}`;
          const { error: fnErr } = await supabase.functions.invoke(
            "send-portal-invite",
            {
              body: {
                email: customer.email,
                customer_id: latest.customer_id,
                portal_url: portalUrl,
              },
            },
          );
          if (fnErr)
            setInviteNotice(
              "Work order created. Failed to send invite email (logged).",
            );
          else
            setInviteNotice(
              "Work order created. Invite email queued to the customer.",
            );
        } catch {
          setInviteNotice(
            "Work order created. Failed to send invite email (caught).",
          );
        }
      }

      router.push(`/work-orders/${latest.id}/approve`);
    } catch (ex) {
      const message =
        ex instanceof Error ? ex.message : "Failed to create work order.";
      setError(message);
    } finally {
      setLoading(false);
    }
  }

  // Realtime line refresh
  useEffect(() => {
    if (!wo?.id) return;
    void fetchLines();
    const ch = supabase
      .channel(`create-wo:${wo.id}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "work_order_lines",
          filter: `work_order_id=eq.${wo.id}`,
        },
        () => fetchLines(),
      )
      .subscribe();
    return () => {
      try {
        supabase.removeChannel(ch);
      } catch {
        /* noop */
      }
    };
  }, [supabase, wo?.id, fetchLines]);

  useEffect(() => {
    const h = () => {
      void fetchLines();
    };
    window.addEventListener("wo:line-added", h);
    return () => window.removeEventListener("wo:line-added", h);
  }, [fetchLines]);

  // Vehicle label for AI modal context
  const vehicleLabel =
    (vehicle.year || vehicle.make || vehicle.model)
      ? `${vehicle.year ?? ""} ${vehicle.make ?? ""} ${
          vehicle.model ?? ""
        }`.trim()
      : vehicle.license_plate
      ? `Plate ${vehicle.license_plate}`
      : null;

  /* UI */
  return (
    <div className="relative min-h-[calc(100vh-4rem)] px-4 py-6 text-white">
      {/* radial wash similar to Service Menu page */}
      <div
        aria-hidden
        className="pointer-events-none absolute inset-0 -z-10 bg-[radial-gradient(circle_at_top,_rgba(248,113,22,0.18),transparent_55%),radial-gradient(circle_at_bottom,_rgba(15,23,42,0.96),#020617_78%)]"
      />

      <div className="mx-auto max-w-6xl space-y-6">
        {/* Header card – matches Menu header vibe */}
        <section className="metal-card mb-2 flex items-center justify-between gap-4 rounded-2xl border border-[color:var(--metal-border-soft,#1f2937)] bg-gradient-to-r from-black/85 via-slate-950/95 to-black/85 px-5 py-4 shadow-[0_22px_45px_rgba(0,0,0,0.9)] backdrop-blur-xl">
          <div>
            <h1
              className="text-2xl font-semibold text-white"
              style={{ fontFamily: "var(--font-blackops), system-ui" }}
            >
              Create Work Order
            </h1>
            <p className="mt-1 text-sm text-neutral-400">
              Link a customer and vehicle, add jobs and inspections, then send
              to approval and signature.
            </p>
            {wo?.custom_id && (
              <p className="mt-1 text-xs text-neutral-500">
                Current WO:{" "}
                <span className="font-mono text-orange-300">
                  {wo.custom_id}
                </span>
              </p>
            )}
          </div>
          <button
            type="button"
            onClick={() => router.back()}
            className="rounded-full border border-[color:var(--metal-border-soft,#1f2937)] bg-black/70 px-4 py-1.5 text-xs font-semibold uppercase tracking-[0.18em] text-neutral-200 shadow-[0_10px_24px_rgba(0,0,0,0.85)] hover:bg-white/5"
          >
            Back to list
          </button>
        </section>

        {/* Main metal card with form */}
        <section className="metal-card rounded-2xl border border-[color:var(--metal-border-soft,#1f2937)] bg-black/65 px-4 py-5 shadow-[0_24px_80px_rgba(0,0,0,0.95)] backdrop-blur-xl sm:px-6 sm:py-6">
          {error && (
            <div className="mb-4 rounded-lg border border-red-500/60 bg-red-950/70 px-4 py-2 text-sm text-red-100">
              {error}
            </div>
          )}

          {uploadSummary && (
            <div className="mb-4 rounded-lg border border-neutral-700 bg-black/60 px-4 py-2 text-sm text-neutral-100">
              Uploaded {uploadSummary.uploaded} file(s)
              {uploadSummary.failed ? `, ${uploadSummary.failed} failed` : ""}.
            </div>
          )}
          {inviteNotice && (
            <div className="mb-4 rounded-lg border border-neutral-700 bg-black/60 px-4 py-2 text-sm text-neutral-100">
              {inviteNotice}
            </div>
          )}

          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Customer & Vehicle */}
            <section className="rounded-2xl border border-[var(--metal-border-soft)] bg-black/55 p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)] sm:p-5">
              <h2 className="mb-3 text-xs font-semibold uppercase tracking-[0.2em] text-neutral-400">
                Customer &amp; Vehicle
              </h2>

              <CustomerVehicleForm
                customer={customer}
                vehicle={vehicle}
                saving={savingCv}
                workOrderExists={!!wo?.id}
                shopId={wo?.shop_id ?? currentShopId}
                handlers={{
                  onCustomerChange,
                  onVehicleChange,
                  onCustomerSelected: (id: string) => setCustomerId(id),
                  onVehicleSelected: (id: string) => setVehicleId(id),
                }}
              />

              {/* Local buttons row */}
              <div className="mt-3 flex flex-wrap items-center gap-2">
                <button
                  type="button"
                  onClick={handleSaveCustomerVehicle}
                  disabled={savingCv || loading}
                  className="rounded-full border border-[var(--metal-border-soft)] bg-black/70 px-3 py-1.5 text-xs sm:text-sm font-medium uppercase tracking-[0.16em] text-neutral-100 hover:border-orange-500 hover:bg-black/80 disabled:opacity-60"
                >
                  {savingCv ? "Saving…" : "Save & Continue"}
                </button>

                <button
                  type="button"
                  onClick={handleClearForm}
                  className="rounded-full border border-red-600/70 bg-black/70 px-3 py-1.5 text-xs sm:text-sm font-medium uppercase tracking-[0.16em] text-red-200 hover:bg-red-900/30"
                >
                  Clear form
                </button>

                <VinCaptureModal
                  userId={currentUserId ?? "anon"}
                  action="/api/vin"
                  onDecoded={(d) => {
                    // 1) push into transient VIN draft store
                    draft.setVehicle({
                      vin: d.vin,
                      year: d.year ?? null,
                      make: d.make ?? null,
                      model: d.model ?? null,
                      engine: d.engine ?? null,
                      fuel_type: d.fuelType ?? null,
                      drivetrain: d.driveType ?? null,
                      transmission: d.transmission ?? null,
                    } as any);

                    // 2) hydrate the visible form state
                    setVehicle((prev) =>
                      ({
                        ...prev,
                        vin: d.vin || prev.vin,
                        year: d.year ?? prev.year,
                        make: d.make ?? prev.make,
                        model: d.model ?? prev.model,
                        engine:
                          d.engine ??
                          (prev as any).engine ??
                          null,
                        fuel_type:
                          d.fuelType ??
                          (prev as any).fuel_type ??
                          null,
                        drivetrain:
                          d.driveType ??
                          (prev as any).drivetrain ??
                          null,
                        transmission:
                          d.transmission ??
                          (prev as any).transmission ??
                          null,
                      } as any),
                    );

                    // 3) persist into CV draft
                    cvDraft.bulkSet({
                      vehicle: {
                        vin: d.vin ?? null,
                        year: d.year ?? null,
                        make: d.make ?? null,
                        model: d.model ?? null,
                        engine: d.engine ?? null,
                        fuel_type: d.fuelType ?? null,
                        drivetrain: d.driveType ?? null,
                        transmission: d.transmission ?? null,
                      } as any,
                    });
                  }}
                >
                  <span className="cursor-pointer rounded-full border border-orange-500/80 bg-black/70 px-3 py-1.5 text-xs text-orange-300 hover:bg-orange-500/10 sm:text-sm">
                    Add by VIN / Scan
                  </span>
                </VinCaptureModal>
              </div>

              <label className="mt-3 flex items-center gap-2 text-xs text-neutral-300">
                <input
                  id="send-invite"
                  type="checkbox"
                  checked={sendInvite}
                  onChange={(e) => setSendInvite(e.target.checked)}
                  className="h-4 w-4 rounded border-neutral-700 bg-neutral-900"
                  disabled={loading}
                />
                Email a customer portal sign-up link
              </label>
            </section>

            {/* Uploads */}
            <section className="rounded-2xl border border-[var(--metal-border-soft)] bg-black/55 p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)] sm:p-5">
              <h2 className="mb-3 text-sm font-semibold text-neutral-100">
                Uploads
              </h2>
              <div className="grid gap-3 md:grid-cols-2">
                <div>
                  <label className="mb-1 block text-xs uppercase tracking-wide text-neutral-400">
                    Vehicle Photos
                  </label>
                  <input
                    type="file"
                    accept="image/*"
                    multiple
                    onChange={(e) =>
                      setPhotoFiles(Array.from(e.target.files ?? []))
                    }
                    className="input"
                    disabled={loading}
                  />
                </div>
                <div>
                  <label className="mb-1 block text-xs uppercase tracking-wide text-neutral-400">
                    Documents (PDF/JPG/PNG)
                  </label>
                  <input
                    type="file"
                    accept="application/pdf,image/*"
                    multiple
                    onChange={(e) =>
                      setDocFiles(Array.from(e.target.files ?? []))
                    }
                    className="input"
                    disabled={loading}
                  />
                </div>
              </div>
            </section>

            {/* Quick add from menu */}
            {wo?.id && (
              <section className="rounded-2xl border border-[var(--metal-border-soft)] bg-black/55 p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)] sm:p-5">
                <h2 className="mb-3 text-sm font-semibold text-orange-300">
                  Quick add from menu
                </h2>
                <MenuQuickAdd workOrderId={wo.id} />
              </section>
            )}

            {/* Manual add line */}
            {wo?.id && (
              <section className="rounded-2xl border border-[var(--metal-border-soft)] bg-black/55 p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)] sm:p-5">
                <h2 className="mb-3 text-sm font-semibold text-neutral-100">
                  Add Job Line
                </h2>
                <NewWorkOrderLineForm
                  workOrderId={wo.id}
                  vehicleId={vehicleId}
                  defaultJobType={type}
                  shopId={wo.shop_id ?? null}
                  onCreated={fetchLines}
                />
              </section>
            )}

            {/* Current Lines */}
            <section className="rounded-2xl border border-[var(--metal-border-soft)] bg-black/55 p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)] sm:p-5">
              <div className="mb-3 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                <h2 className="text-sm font-semibold text-neutral-100">
                  Current lines
                </h2>
                {wo?.id && (
                  <button
                    type="button"
                    onClick={() => setAiSuggestOpen(true)}
                    className="inline-flex items-center rounded-full border border-blue-600 bg-black/70 px-3 py-1.5 text-xs sm:text-sm text-blue-300 hover:bg-blue-900/30"
                  >
                    AI: Suggest jobs
                  </button>
                )}
              </div>
              {!wo?.id || lines.length === 0 ? (
                <p className="text-sm text-neutral-400">No lines yet.</p>
              ) : (
                <div className="space-y-2">
                  {lines.map((ln) => (
                    <div
                      key={ln.id}
                      className="flex flex-col gap-3 rounded-xl border border-neutral-800 bg-neutral-950/80 p-3 sm:flex-row sm:items-start sm:justify-between"
                    >
                      <div className="min-w-0">
                        <div className="truncate font-medium">
                          {ln.description || ln.complaint || "Untitled job"}
                        </div>
                        <div className="text-xs text-neutral-400">
                          {String(ln.job_type ?? "job").replaceAll("_", " ")} •{" "}
                          {typeof ln.labor_time === "number"
                            ? `${ln.labor_time}h`
                            : "—"}{" "}
                          • {(ln.status ?? "awaiting").replaceAll("_", " ")}
                        </div>
                        {(ln.complaint || ln.cause || ln.correction) && (
                          <div className="mt-1 text-xs text-neutral-500">
                            {ln.complaint ? `Cmpl: ${ln.complaint}  ` : ""}
                            {ln.cause ? `| Cause: ${ln.cause}  ` : ""}
                            {ln.correction ? `| Corr: ${ln.correction}` : ""}
                          </div>
                        )}
                      </div>
                      <div className="flex gap-2">
                        {ln.job_type === "inspection" && (
                          <button
                            type="button"
                            onClick={() => openInspectionForLine(ln)}
                            className="rounded border border-orange-500 px-2 py-1 text-xs text-orange-200 hover:bg-orange-500/10"
                          >
                            Open inspection
                          </button>
                        )}
                        <button
                          type="button"
                          onClick={() => handleDeleteLine(ln.id)}
                          className="rounded border border-red-600 px-2 py-1 text-xs text-red-300 hover:bg-red-900/20"
                        >
                          Delete
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </section>

            {/* Work Order defaults / options */}
            <section className="rounded-2xl border border-[var(--metal-border-soft)] bg-black/55 p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)] sm:p-5">
              <h2 className="mb-3 text-sm font-semibold text-neutral-100">
                Work order options
              </h2>
              <div className="grid gap-3 md:grid-cols-3">
                <div>
                  <label className="mb-1 block text-xs uppercase tracking-wide text-neutral-400">
                    Default job type
                  </label>
                  <select
                    value={type}
                    onChange={(e) => setType(e.target.value as WOType)}
                    className="input"
                    disabled={loading}
                  >
                    <option value="maintenance">Maintenance</option>
                    <option value="diagnosis">Diagnosis</option>
                    <option value="inspection">Inspection</option>
                  </select>
                  <p className="mt-1 text-[11px] text-neutral-500">
                    Sets the default for new lines you add on this work order.
                  </p>
                </div>
                <div>
                  <label className="mb-1 block text-xs uppercase tracking-wide text-neutral-400">
                    Priority
                  </label>
                  <select
                    value={priority}
                    onChange={(e) => setPriority(Number(e.target.value))}
                    className="input"
                    disabled={loading}
                  >
                    <option value={1}>Urgent</option>
                    <option value={2}>High</option>
                    <option value={3}>Normal</option>
                    <option value={4}>Low</option>
                  </select>
                  <p className="mt-1 text-[11px] text-neutral-500">
                    Used to highlight urgent jobs in queues and dashboards.
                  </p>
                </div>
                <div>
                  <label className="mb-1 block text-xs uppercase tracking-wide text-neutral-400">
                    Customer waiting (waiter)
                  </label>
                  <select
                    value={isWaiter ? "waiter" : "dropoff"}
                    onChange={(e) => setIsWaiter(e.target.value === "waiter")}
                    className="input"
                    disabled={loading}
                  >
                    <option value="dropoff">Drop-off / not waiting</option>
                    <option value="waiter">Customer waiting (waiter)</option>
                  </select>
                  <p className="mt-1 text-[11px] text-neutral-500">
                    When set to waiter, the work order will show a{" "}
                    <span className="font-semibold">WAITING</span> status
                    badge.
                  </p>
                </div>
                <div className="md:col-span-3">
                  <label className="mb-1 block text-xs uppercase tracking-wide text-neutral-400">
                    Notes
                  </label>
                  <textarea
                    value={notes}
                    onChange={(e) => setNotes(e.target.value)}
                    className="input"
                    rows={3}
                    placeholder="Optional notes for technician"
                    disabled={loading}
                  />
                </div>
              </div>
            </section>

            {/* Submit */}
            <div className="flex flex-wrap items-center gap-3">
              <button
                type="submit"
                disabled={loading}
                className="rounded-full bg-[linear-gradient(to_right,var(--accent-copper-soft),var(--accent-copper))] px-5 py-2 text-sm font-semibold uppercase tracking-[0.2em] text-black shadow-[0_0_24px_rgba(212,118,49,0.7)] hover:brightness-110 disabled:opacity-60"
              >
                {loading ? "Creating..." : "Approve & Sign"}
              </button>
              <button
                type="button"
                onClick={() => router.push("/work-orders")}
                className="text-sm text-neutral-400 hover:text:white"
                disabled={loading}
              >
                Cancel
              </button>
            </div>
          </form>

          {/* 👇 inspection modal lives here */}
          {inspectionOpen && inspectionSrc && (
            <InspectionModal
              open={inspectionOpen}
              src={inspectionSrc}
              title="Inspection"
              onClose={() => setInspectionOpen(false)}
            />
          )}

          {/* 👇 AI Suggest modal lives here */}
          {wo?.id && (
            <AiSuggestModal
              open={aiSuggestOpen}
              onClose={() => setAiSuggestOpen(false)}
              workOrderId={wo.id}
              vehicleId={vehicleId}
              vehicleLabel={vehicleLabel}
              onAdded={() => {
                void fetchLines();
              }}
            />
          )}
        </section>
      </div>
    </div>
  );
}

===== FILE: ./unified_inspection_required_files.txt =====
===== FILE: ./features/inspections/lib/inspection/aiQuote.ts =====
// features/inspections/lib/inspection/aiQuote.ts
export type AISuggestion = {
  parts: { name: string; qty?: number; cost?: number; notes?: string }[];
  laborHours: number;
  laborRate?: number;
  summary: string;
  confidence?: "low" | "medium" | "high";
  price?: number;
  notes?: string;
  title?: string;
};

export async function requestQuoteSuggestion(args: {
  item: string;
  notes?: string;
  section: string;
  status: string;
  value?: string;
  unit?: string;
  vehicle?: Record<string, any>;
}): Promise<AISuggestion | null> {
  try {
    const res = await fetch("/api/ai/quote-suggest", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(args),
    });
    if (!res.ok) return null;
    const data = await res.json();
    return (data?.suggestion ?? null) as AISuggestion | null;
  } catch (e) {
    console.error("requestQuoteSuggestion error:", e);
    return null;
  }
}
===== FILE: ./features/inspections/lib/inspection/addWorkOrderLine.ts =====
export type AISuggestion = {
  parts: { name: string; qty?: number; cost?: number; notes?: string }[];
  laborHours: number;
  laborRate?: number;
  summary: string;
  confidence?: "low" | "medium" | "high";
  price?: number;
  notes?: string;
  title?: string;
};

type JobType = "diagnosis" | "inspection" | "maintenance" | "repair" | "tech-suggested";

export async function addWorkOrderLineFromSuggestion(args: {
  workOrderId: string;
  description: string;
  section?: string;
  status?: "recommend" | "fail";
  suggestion: AISuggestion;
  source?: "inspection";
  /** mark AI-added items clearly for UI rules like “not punchable until approved” */
  jobType?: JobType; // default will be set server-side if omitted
}) {
  const res = await fetch("/api/work-orders/add-line", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(args),
  });

  if (!res.ok) {
    const j = (await res.json().catch(() => null)) as { error?: string } | null;
    throw new Error(j?.error || "Failed to add work order line");
  }

  return (await res.json()) as { id: string };
}
===== FILE: ./features/inspections/lib/inspection/types.ts =====
/** ---------- Item / Section ---------- */
export type InspectionItemStatus = "ok" | "fail" | "na" | "recommend";
export type BrakeType = "air" | "hydraulic";

/** Duty class for inspections (light/medium/heavy) */
export type DutyClass = "light" | "medium" | "heavy";

export interface InspectionItem {
  /** Primary label. Some code uses `item`, some uses `name` — support both. */
  item?: string;
  name?: string;

  status?: InspectionItemStatus;
  notes?: string;
  /** Some AI/normalizers use singular `note`. */
  note?: string;

  value?: string | number | null;
  unit?: string | null;

  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionCategory {
  title: string;
  items: InspectionItem[];
}

/** Many places import `InspectionSection`; keep it as an alias. */
export type InspectionSection = InspectionCategory;

/** Template definition used by unified inspection builder / loader */
export interface InspectionTemplate {
  id: string;
  templateName: string;

  description?: string | null;
  tags?: string[] | null;
  vehicleType?: string | null;

  /** Whether this template is shared/public in the shop/library */
  isPublic?: boolean | null;

  /** Optional default labor hours for the template */
  laborHours?: number | null;

  /** Rendered sections (mirrors inspection_templates.sections JSON) */
  sections: InspectionSection[];

  /** Optional audit fields (mapped from DB created_at/updated_at) */
  createdAt?: string | null;
  updatedAt?: string | null;
}

/** ---------- Parsed voice/AI commands (support both shapes) ---------- */
/** Older, name-based command shape used by dispatchCommand/interpreter */
export type ParsedCommandNameBased =
  | { type: "status"; section: string; item: string; status: InspectionItemStatus }
  | { type: "add"; section: string; item: string; note: string }
  | { type: "recommend"; section: string; item: string; note: string }
  | {
      type: "measurement";
      section: string;
      item: string;
      value: number | string;
      unit?: string;
    };

/** Newer, index-based command shape used by convertParsedCommands.ts */
export type ParsedCommandIndexed = {
  command:
    | "update_status"
    | "update_value"
    | "add_note"
    | "recommend"
    | "complete_item"
    | "skip_item"
    | "pause_inspection"
    | "finish_inspection";
  sectionIndex?: number;
  itemIndex?: number;
  status?: InspectionItemStatus;
  value?: string | number;
  unit?: string;
  notes?: string;
  recommend?: string;
};

/** Unified ParsedCommand covering both shapes */
export type ParsedCommand = ParsedCommandNameBased | ParsedCommandIndexed;

/**
 * Commands consumed by dispatchCommand (older name-based shape),
 * plus a simple "pause" variant used in a few places.
 */
export type InspectionCommand =
  | ParsedCommandNameBased
  | { type: "pause"; section?: string; item?: string };

/** ---------- Runtime command objects (AI → actions) ---------- */
export type Command =
  | {
      type: "update_status";
      sectionIndex: number;
      itemIndex: number;
      status: InspectionItemStatus;
    }
  | {
      type: "update_value";
      sectionIndex: number;
      itemIndex: number;
      value: string | number;
      unit?: string;
    }
  | {
      type: "add_note";
      sectionIndex: number;
      itemIndex: number;
      notes: string;
    }
  | {
      type: "recommend";
      sectionIndex: number;
      itemIndex: number;
      recommendation: string;
    }
  | {
      type: "complete";
      sectionIndex: number;
      itemIndex: number;
    }
  | {
      type: "skip";
      sectionIndex: number;
      itemIndex: number;
    }
  | { type: "pause" }
  | { type: "finish" };

/** ---------- Quote shapes ---------- */
/** Rich source descriptor for where a line came from. */
export type QuoteSource = "inspection" | "manual" | string;

/**
 * Lightweight line produced by AI generators / costing flows.
 * Extended to include fields your costing + menu matching code writes.
 */
export interface QuoteLine {
  /** Core */
  description: string;

  /** IDs / provenance */
  id?: string;
  source?: QuoteSource;

  /** Names used across flows */
  item?: string;             // selected service/menu name
  name?: string;             // occasional alias
  inspectionItem?: string;   // originating inspection item text

  /** Status / notes */
  status?: InspectionItemStatus;
  notes?: string;

  /** Time & rates */
  hours?: number;
  rate?: number;
  total?: number;
  laborHours?: number | null;
  laborTime?: number;        // alias used on some screens
  laborRate?: number;

  /** Parts */
  parts?: Array<{ name?: string; number?: string; price?: number; type?: string }>;
  partNumber?: string | null;
  partName?: string;
  unitPrice?: number | null;

  /** Roll-up / pricing */
  qty?: number;
  price?: number;            // some code writes final line price here
  totalCost?: number;
}

/** Detailed line used by PDF/store. */
export interface QuoteLineItem {
  id: string;

  /** Some places map description into both `item` and `name`. */
  item?: string;
  name?: string;
  description: string;

  status: InspectionItemStatus;
  notes?: string;

  /** Unified commercial fields */
  price: number; // line price/total
  laborHours?: number;
  /** Additional variants used in some flows */
  laborTime?: number; // alias used on some pages
  laborRate?: number;

  /** Item-level measurement value (rare) */
  value?: string | number | null;

  /** Parts can be object or split fields */
  part?: { name: string; price: number };
  partName?: string;
  partPrice?: number | null;

  /** Old-style fields occasionally present */
  qty?: number;
  unitPrice?: number | null;

  /** Misc UI helpers */
  photoUrls?: string[];
  editable?: boolean;
  source?: QuoteSource;

  /** Collections used by some UIs */
  parts?: Array<{ name?: string; number?: string; price?: number }>;
  totalCost?: number;

  /** Optional back-reference to the inspection item */
  inspectionItem?: string;

  /** Optional AI suggestion metadata */
  ai?: {
    summary: string;
    confidence?: string;
    parts?: { name: string; qty?: number; cost?: number; notes?: string }[];
  };

  /** UI-only: track AI enrichment progress for this line */
  aiState?: "idle" | "loading" | "done" | "error";
}

/** ---------- Inspection Summary ---------- */
export interface SummaryItem {
  section: string;
  item: string;
  status: InspectionItemStatus;
  note?: string;
  value?: string | number | null;
  unit?: string | null;
  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionSummary {
  templateName?: string | null;
  date: string;
  items: SummaryItem[];
  summaryText: string;
}

/** ---------- Session (customer/vehicle) ---------- */
export interface SessionCustomer {
  first_name: string | null;
  last_name: string | null;
  phone: string | null;
  email: string | null;
  address: string | null;
  city: string | null;
  province: string | null;
  postal_code: string | null;
}

export interface SessionVehicle {
  year: string | null;
  make: string | null;
  model: string | null;
  vin: string | null;
  license_plate: string | null;
  mileage: string | null;
  color: string | null;
  /** Added for your form */
  unit_number?: string | null;
  engine_hours?: string | null;
}

/** ---------- Session status ---------- */
export type InspectionStatus = "not_started" | "in_progress" | "paused" | "completed";

/** ---------- Full session ---------- */
export interface InspectionSession {
  id?: string;

  /** Links to other records */
  customerId?: string | null;
  vehicleId?: string | null;
  workOrderId?: string | null;

  /** Template meta */
  templateId?: string | null;
  templateName?: string | null;
  /** Legacy alias still used by some pages */
  templateitem?: string | null;

  /** Selected brake system for rendering/units */
  brakeType?: BrakeType;

  /** Optional duty class for this inspection (light/medium/heavy) */
  dutyClass?: DutyClass | null;

  location?: string | null;

  /** Progress */
  currentSectionIndex: number;
  currentItemIndex: number;

  /** Voice */
  transcript?: string;
  isListening: boolean;

  /** Lifecycle */
  status: InspectionStatus;
  started: boolean;
  completed: boolean;
  isPaused: boolean;

  /** Audit */
  lastUpdated?: string;

  /** Entities */
  customer?: SessionCustomer | null;
  vehicle?: SessionVehicle | null;

  /** Content */
  sections: InspectionSection[];

  /** Quotes can be DB-sourced or UI-generated — accept both */
  quote?: Array<QuoteLine | QuoteLineItem>;

  /**
   * Optional runtime-only metadata.
   * Unified flows can stash arbitrary info here (e.g. source, duty class, debug flags).
   */
  meta?: {
    dutyClass?: DutyClass | null;
    source?: string;
    [key: string]: unknown;
  };
}
===== FILE: ./features/inspections/lib/inspection/SectionDisplay.tsx =====
"use client";

import { useState, useMemo } from "react";
import {
  InspectionSection,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";
import InspectionItemCard from "./InspectionItemCard";
import { Button } from "@shared/components/ui/Button";

interface SectionDisplayProps {
  title: string;
  section: InspectionSection;
  sectionIndex: number;
  showNotes: boolean;
  showPhotos: boolean;
  onUpdateStatus: (
    sectionIndex: number,
    itemIndex: number,
    status: InspectionItemStatus,
  ) => void;
  onUpdateNote: (
    sectionIndex: number,
    itemIndex: number,
    note: string,
  ) => void;
  onUpload: (
    photoUrl: string,
    sectionIndex: number,
    itemIndex: number,
  ) => void;

  /** require a note and show a Submit button for AI */
  requireNoteForAI?: boolean;
  /** handler to run AI + persist, invoked per item */
  onSubmitAI?: (sectionIndex: number, itemIndex: number) => void;
  /** let parent indicate a submit is in-flight for this item */
  isSubmittingAI?: (sectionIndex: number, itemIndex: number) => boolean;
}

export default function SectionDisplay(props: SectionDisplayProps) {
  const {
    title,
    section,
    sectionIndex,
    showNotes = false,
    showPhotos = true,
    onUpdateStatus,
    onUpdateNote,
    onUpload,
    requireNoteForAI,
    onSubmitAI,
    isSubmittingAI,
  } = props;

  const [open, setOpen] = useState(true);

  const stats = useMemo(() => {
    const total = section.items.length || 0;
    const counts = { ok: 0, fail: 0, na: 0, recommend: 0, unset: 0 };
    for (const it of section.items) {
      const s = (it.status ?? "unset") as keyof typeof counts;
      if (counts[s] !== undefined) counts[s] += 1;
      else counts.unset += 1;
    }
    return { total, ...counts };
  }, [section.items]);

  const markAll = (status: InspectionItemStatus) => {
    section.items.forEach((_item, idx) =>
      onUpdateStatus(sectionIndex, idx, status),
    );
  };

  return (
    <div className="mb-6 rounded-2xl border border-white/8 bg-black/30 px-4 py-3 shadow-card backdrop-blur-md md:px-5 md:py-4">
      {/* Header */}
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-white/5 pb-3">
        {/* Title still toggles open/closed */}
        <button
          onClick={() => setOpen((v) => !v)}
          className="text-left text-lg font-semibold tracking-wide text-orange-400"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
          aria-expanded={open}
        >
          {title}
        </button>

        <div className="flex flex-wrap items-center gap-2">
          <span
            className="hidden text-[11px] uppercase tracking-wide text-neutral-400 md:inline"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {stats.ok} OK · {stats.fail} FAIL · {stats.na} NA ·{" "}
            {stats.recommend} REC · {stats.unset} —
          </span>

          <div className="flex flex-wrap items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("ok")}
              title="Mark all OK"
              type="button"
            >
              All OK
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("fail")}
              title="Mark all FAIL"
              type="button"
            >
              All FAIL
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("na")}
              title="Mark all NA"
              type="button"
            >
              All NA
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("recommend")}
              title="Mark all Recommend"
              type="button"
            >
              All REC
            </Button>

            {/* explicit collapse/expand control */}
            <Button
              variant="ghost"
              size="sm"
              className="ml-1 h-7 px-2 text-[11px]"
              onClick={() => setOpen((v) => !v)}
              aria-expanded={open}
              title={open ? "Collapse section" : "Expand section"}
              type="button"
            >
              {open ? "Collapse" : "Expand"}
            </Button>
          </div>
        </div>
      </div>

      {/* Body */}
      {open && (
        <div className="space-y-3 pt-3">
          {section.items.map((item, itemIndex) => {
            const key =
              (item.item ?? item.name ?? `item-${sectionIndex}-${itemIndex}`) +
              `-${itemIndex}`;

            const status = String(item.status ?? "").toLowerCase();
            const isFailOrRec = status === "fail" || status === "recommend";
            const note = (item.notes ?? "").trim();
            const canShowSubmit =
              !!requireNoteForAI &&
              isFailOrRec &&
              note.length > 0 &&
              typeof onSubmitAI === "function";

            const submitting =
              isSubmittingAI?.(sectionIndex, itemIndex) ?? false;

            return (
              <div
                key={key}
                className="rounded-xl border border-white/5 bg-black/40 p-3 md:p-3.5"
              >
                <InspectionItemCard
                  item={item}
                  sectionIndex={sectionIndex}
                  itemIndex={itemIndex}
                  showNotes={showNotes}
                  showPhotos={showPhotos}
                  onUpdateStatus={onUpdateStatus}
                  onUpdateNote={onUpdateNote}
                  onUpload={onUpload}
                />

                {canShowSubmit && (
                  <div className="mt-3 flex items-center justify-end">
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      className="px-3"
                      disabled={submitting}
                      onClick={() => onSubmitAI!(sectionIndex, itemIndex)}
                    >
                      {submitting ? "Submitting…" : "Submit for estimate"}
                    </Button>
                  </div>
                )}
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}
===== FILE: ./features/inspections/lib/inspection/handleTranscript.ts =====
// features/inspections/lib/inspection/handleTranscript.ts

import {
  ParsedCommand,
  ParsedCommandNameBased,
  ParsedCommandIndexed,
  InspectionSession,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";

type UpdateInspectionFn = (updates: Partial<InspectionSession>) => void;
type UpdateItemFn = (
  sectionIndex: number,
  itemIndex: number,
  updates: Partial<InspectionSession["sections"][number]["items"][number]>,
) => void;
type UpdateSectionFn = (
  sectionIndex: number,
  updates: Partial<InspectionSession["sections"][number]>,
) => void;

interface HandleTranscriptArgs {
  command: ParsedCommand;
  session: InspectionSession;
  updateInspection: UpdateInspectionFn;
  updateItem: UpdateItemFn;
  updateSection: UpdateSectionFn;
  finishSession: () => void;
}

export async function handleTranscriptFn({
  command,
  session,
  updateItem,
}: HandleTranscriptArgs): Promise<void> {
  // Normalized fields
  let section: string | undefined;
  let item: string | undefined;
  let status: InspectionItemStatus | undefined;
  let note: string | undefined;
  let value: string | number | undefined;
  let unit: string | undefined;
  let mode: string; // which type of command

  if ("command" in command) {
    // Indexed shape
    const c = command as ParsedCommandIndexed;
    mode = c.command;
    status = c.status;
    note = c.notes;
    value = c.value;
    unit = c.unit;
  } else {
    // Name-based shape
    const c = command as ParsedCommandNameBased;
    mode = c.type;
    section = c.section;
    item = c.item;
    if ("status" in c) status = c.status;
    if ("note" in c) note = c.note;
    if ("value" in c) value = c.value;
    if ("unit" in c) unit = c.unit;
  }

  // Locate section & item by name (fallback)
  const sectionIndex = session.sections.findIndex((sec) =>
    section ? sec.title.toLowerCase().includes(section.toLowerCase()) : false,
  );
  const itemIndex =
    sectionIndex >= 0
      ? session.sections[sectionIndex].items.findIndex((it) =>
          item ? (it.name ?? it.item ?? "").toLowerCase().includes(item.toLowerCase()) : false,
        )
      : -1;

  if (sectionIndex === -1 || itemIndex === -1) {
    console.warn("Could not match section/item from transcript:", { section, item });
    return;
  }

  const itemUpdates: Partial<
    InspectionSession["sections"][number]["items"][number]
  > = {};

  switch (mode) {
    case "update_status":
    case "status":
      if (status) itemUpdates.status = status;
      break;

    case "update_value":
    case "measurement":
      if (value) itemUpdates.value = value;
      if (unit) itemUpdates.unit = unit;
      break;

    case "add_note":
    case "add":
      if (note) itemUpdates.notes = note;
      break;

    case "recommend":
      if (note) itemUpdates.recommend = [note];
      break;

    case "complete_item":
    case "skip_item":
      // no-op for now
      break;

    default:
      break;
  }

  if (Object.keys(itemUpdates).length > 0) {
    updateItem(sectionIndex, itemIndex, itemUpdates);
  }
}
===== FILE: ./features/inspections/lib/inspection/handleTranscript.js =====
[NO JS VERSION]

===== FILE: ./features/inspections/components/inspection/interpretCommand.ts =====
// src/lib/inspection/interpretCommand.ts

import { ParsedCommand } from "@inspections/lib/inspection/types";

export const interpretCommand = async (
  transcript: string,
): Promise<ParsedCommand[]> => {
  try {
    const response = await fetch("/api/ai/interpret", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ transcript }),
    });

    if (!response.ok) {
      console.error("Interpretation request failed");
      return [];
    }

    const data = await response.json();

    if (!Array.isArray(data)) {
      console.warn("Unexpected AI response format:", data);
      return [];
    }

    return data as ParsedCommand[];
  } catch (error) {
    console.error("Interpretation error:", error);
    return [];
  }
};

===== FILE: ./features/inspections/components/inspection/interpretCommand.js =====
[NO JS VERSION]

===== FILE: ./features/inspections/hooks/useInspectionSession.ts =====
"use client";

import { useState } from "react";
import {
  InspectionItem,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,      // ⬅️ use only QuoteLineItem here
  BrakeType,
} from "@inspections/lib/inspection/types";

type AxleLayoutConfig = { axleCount: number; brakeType: BrakeType };

function generateAxleSections({ axleCount, brakeType }: AxleLayoutConfig): InspectionSection[] {
  const sections: InspectionSection[] = [];

  for (let i = 1; i <= axleCount; i++) {
    const title = `Axle ${i}`;
    const items: InspectionItem[] = [
      { item: "Left Tread Depth",  name: "Left Tread Depth",  value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Right Tread Depth", name: "Right Tread Depth", value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Left Tire Pressure",  name: "Left Tire Pressure",  value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Right Tire Pressure", name: "Right Tire Pressure", value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Left Lining Thickness",  name: "Left Lining Thickness",  value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Right Lining Thickness", name: "Right Lining Thickness", value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Wheel Torque", name: "Wheel Torque", value: null, unit: "ft lbs", notes: "", photoUrls: [] },
    ];

    if (brakeType === "air") {
      items.push(
        { item: "Left Push Rod Travel",  name: "Left Push Rod Travel",  value: null, unit: "in", notes: "", photoUrls: [] },
        { item: "Right Push Rod Travel", name: "Right Push Rod Travel", value: null, unit: "in", notes: "", photoUrls: [] },
      );
    }

    sections.push({ title, items });
  }

  return sections;
}

export default function useInspectionSession(initialSession?: Partial<InspectionSession>) {
  const [session, setSession] = useState<InspectionSession>(() => ({
    id: "",
    vehicleId: "",
    customerId: "",
    workOrderId: "",
    templateId: "",
    templateName: "",
    location: "",
    currentSectionIndex: 0,
    currentItemIndex: 0,
    transcript: "",
    status: "not_started",
    started: false,
    completed: false,
    isListening: false,
    isPaused: false,
    quote: [],                                 // ⬅️ QuoteLineItem[]
    lastUpdated: new Date().toISOString(),
    customer: {
      first_name: "",
      last_name: "",
      phone: "",
      email: "",
      address: "",
      city: "",
      province: "",
      postal_code: "",
    },
    vehicle: {
      year: "",
      make: "",
      model: "",
      vin: "",
      license_plate: "",
      mileage: "",
      color: "",
    },
    sections: [],
    ...initialSession,
  }));

  const stamp = () => ({ lastUpdated: new Date().toISOString() });

  const updateInspection = (updates: Partial<InspectionSession>) =>
    setSession(prev => ({ ...prev, ...updates, ...stamp() }));

  const updateSection = (sectionIndex: number, updates: Partial<InspectionSection>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      sections[sectionIndex] = { ...sections[sectionIndex], ...updates };
      return { ...prev, sections, ...stamp() };
    });

  const updateItem = (sectionIndex: number, itemIndex: number, updates: Partial<InspectionItem>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      const items = [...sections[sectionIndex].items];
      items[itemIndex] = { ...items[itemIndex], ...updates };
      sections[sectionIndex] = { ...sections[sectionIndex], items };
      return { ...prev, sections, ...stamp() };
    });

  // ✅ strictly QuoteLineItem (the normalized/store+PDF shape)
  const addQuoteLine = (line: QuoteLineItem) =>
    setSession(prev => ({ ...prev, quote: [...(prev.quote ?? []), line], ...stamp() }));

  const updateQuoteLines = (lines: QuoteLineItem[]) =>
    setSession(prev => ({ ...prev, quote: lines, ...stamp() }));

  // ✅ targeted updater for enriching a single line (AI merge, edits, etc.)
  const updateQuoteLine = (id: string, patch: Partial<QuoteLineItem>) =>
    setSession(prev => ({
      ...prev,
      quote: (prev.quote ?? []).map((l) => (l.id === id ? { ...l, ...patch } : l)),
      ...stamp(),
    }));

  const startSession = (sessionData: Partial<InspectionSession> & { axleConfig?: AxleLayoutConfig }) => {
    const { axleConfig, ...rest } = sessionData;
    const newSections =
      axleConfig?.axleCount && axleConfig?.brakeType
        ? generateAxleSections(axleConfig)
        : sessionData.sections || session.sections;

    setSession(prev => ({
      ...prev,
      ...rest,
      sections: newSections,
      currentSectionIndex: 0,
      currentItemIndex: 0,
      transcript: "",
      started: true,
      completed: false,
      status: "in_progress",
      isPaused: false,
      ...stamp(),
    }));
  };

  const pauseSession  = () => updateInspection({ isPaused: true,  status: "paused" });
  const resumeSession = () => updateInspection({ isPaused: false, status: "in_progress" });
  const finishSession = () => updateInspection({ completed: true, status: "completed", isPaused: false });
  const setIsListening = (value: boolean) => updateInspection({ isListening: value });

  return {
    session,
    updateInspection,
    updateSection,
    updateItem,
    addQuoteLine,
    updateQuoteLines,
    updateQuoteLine,   // ⬅️ expose the targeted updater
    startSession,
    pauseSession,
    resumeSession,
    finishSession,
    setIsListening,
    isPaused: session.isPaused,
  };
}
===== FILE: ./features/inspections/lib/inspection/PauseResume.tsx =====
"use client";

import {
  stopVoiceRecognition,
  startVoiceRecognition,
} from "@inspections/lib/inspection/voiceControl";

interface PauseResumeButtonProps {
  isPaused: boolean;
  onPause: () => void;
  onResume: () => void;
  isListening: boolean;
  setIsListening: (val: boolean) => void;
  recognitionInstance: SpeechRecognition | null;
  onTranscript?: (text: string) => void;
  setRecognitionRef: (instance: SpeechRecognition | null) => void;
}

const PauseResumeButton = ({
  isPaused,
  onPause,
  onResume,
  setIsListening,
  recognitionInstance,
  onTranscript,
  setRecognitionRef,
}: PauseResumeButtonProps) => {
  const handlePause = () => {
    stopVoiceRecognition(recognitionInstance);
    onPause();
    setIsListening(false);
  };

  const handleResume = () => {
    const newInstance = startVoiceRecognition((text: string) => {
      onTranscript?.(text);
    });
    setRecognitionRef(newInstance);
    onResume();
    setIsListening(true);
  };

  return (
    <div className="text-center mt-2">
      {isPaused ? (
        <button
          onClick={handleResume}
          className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded"
        >
          Resume
        </button>
      ) : (
        <button
          onClick={handlePause}
          className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded"
        >
          Pause
        </button>
      )}
    </div>
  );
};

export default PauseResumeButton;

===== FILE: ./features/inspections/lib/inspection/StartListeningButton.tsx =====
"use client";



interface StartListeningButtonProps {
  isListening: boolean;
  setIsListening: (val: boolean) => void;
  onStart: () => void;
}

export default function StartListeningButton(props: any) {
  const { isListening, setIsListening, onStart } =
    props as StartListeningButtonProps;

  const handleStart = () => {
    setIsListening(true);
    onStart(); // Trigger the actual startListening logic from parent
  };

  return (
    <button
      type="button"
      onClick={handleStart}
      disabled={isListening}
      className="px-4 py-2 bg-green-600 text-white rounded disabled:opacity-50"
    >
      {isListening ? "Listening..." : "Start Listening"}
    </button>
  );
}
===== FILE: ./features/inspections/lib/inspection/ProgressTracker.tsx =====
// lib/inspection/ProgressTracker.tsx



interface ProgressTrackerProps {
  currentItem: number;
  currentSection: number;
  totalSections: number;
  totalItems: number;
}

const ProgressTracker = ({
  currentItem,
  currentSection,
  totalSections,
  totalItems,
}: ProgressTrackerProps) => {
  return (
    <div className="text-xs text-gray-400 text-center mb-2">
      Section {currentSection + 1} of {totalSections} • Item {currentItem + 1}{" "}
      of {totalItems}
    </div>
  );
};

export default ProgressTracker;

===== FILE: ./features/inspections/lib/inspection/ui/AxlesCornerGrid.tsx =====
// shared/components/ui/AxlesCornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  /** Optional unit resolver when an item has no unit */
  unitHint?: (label: string) => string;
  /** Only shown (and used) for AIR mode */
  onAddAxle?: (axleLabel: string) => void;
};

/* ---------------------------- shared helpers ---------------------------- */

const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const HYD_FULL_RE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

type Side = "Left" | "Right";
type Region = "Front" | "Rear";
type CornerKey = "LF" | "RF" | "LR" | "RR";

const cornerToRegion: Record<CornerKey, { side: Side; region: Region }> = {
  LF: { side: "Left", region: "Front" },
  RF: { side: "Right", region: "Front" },
  LR: { side: "Left", region: "Rear" },
  RR: { side: "Right", region: "Rear" },
};

const normalizeCorner = (raw: string): CornerKey | null => {
  const s = raw.toLowerCase();
  if (s.startsWith("lf") || s === "left front") return "LF";
  if (s.startsWith("rf") || s === "right front") return "RF";
  if (s.startsWith("lr") || s === "left rear") return "LR";
  if (s.startsWith("rr") || s === "right rear") return "RR";
  return null;
};

const isPressureMetric = (label: string) => /pressure/i.test(label);
const kpaFromPsi = (psiStr: string) => {
  const n = Number(psiStr);
  return isFinite(n) ? Math.round(n * 6.894757) : null;
};

/* --------------------- strict ordering for AIR (matches steer) --------------------- */
const airPriority = (metric: string): [number, number] => {
  const m = metric.toLowerCase();

  if (/tire\s*pressure/i.test(m)) {
    const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
    return [0, second];
  }
  if (/(tire\s*)?tread\s*depth|tire\s*tread/i.test(m)) {
    const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
    return [1, second];
  }
  if (/(lining|shoe|pad)/i.test(m)) return [2, 0];
  if (/(drum|rotor)/i.test(m)) return [3, 0];
  if (/push\s*rod/i.test(m)) return [4, 0];
  if (/wheel\s*torque/i.test(m)) return [5, /inner/i.test(m) ? 1 : 0];
  return [99, 0];
};
const airCompare = (a: string, b: string) => {
  const [pa, sa] = airPriority(a);
  const [pb, sb] = airPriority(b);
  return pa !== pb ? pa - pb : sa - sb;
};

/* ---------------------- ordering for HYD (CornerGrid parity) ---------------------- */
const hydMetricOrder = [
  "Tire Pressure",
  "Tire Tread",
  "Brake Pad",
  "Rotor",
  "Rotor Condition",
  "Rotor Thickness",
  "Wheel Torque",
];
const hydCompare = (a: string, b: string) => {
  const ai = hydMetricOrder.findIndex((x) =>
    a.toLowerCase().includes(x.toLowerCase()),
  );
  const bi = hydMetricOrder.findIndex((x) =>
    b.toLowerCase().includes(x.toLowerCase()),
  );
  const A = ai === -1 ? Number.MAX_SAFE_INTEGER : ai;
  const B = bi === -1 ? Number.MAX_SAFE_INTEGER : bi;
  return A - B;
};

export default function AxlesCornerGrid({
  sectionIndex,
  items,
  unitHint,
  onAddAxle,
}: Props) {
  const { updateItem } = useInspectionForm();

  // Detect mode from the item labels
  const mode: "air" | "hyd" = useMemo(() => {
    for (const it of items) {
      const label = it.item ?? "";
      if (AIR_RE.test(label)) return "air";
      if (HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label)) return "hyd";
    }
    return "hyd"; // safe default
  }, [items]);

  /* ------------------------------------------------------------------ */
  /* HYDRAULIC (LF/RF/LR/RR) — matches CornerGrid layout                */
  /* ------------------------------------------------------------------ */

  type HydCell = {
    idx: number;
    metric: string;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type HydRow = { metric: string; left?: HydCell; right?: HydCell };

  const hydGroups = useMemo(() => {
    if (mode !== "hyd") return [] as Array<{ region: Region; rows: HydRow[] }>;

    const byRegion = new Map<Region, Map<string, HydRow>>();
    const ensureRegion = (r: Region) =>
      byRegion.get(r) ?? byRegion.set(r, new Map()).get(r)!;

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      let ck: CornerKey | null = null;
      let metric = "";

      const m1 = label.match(HYD_ABBR_RE);
      if (m1?.groups) {
        ck = normalizeCorner(m1.groups.corner);
        metric = m1.groups.metric.trim();
      } else {
        const m2 = label.match(HYD_FULL_RE);
        if (m2?.groups) {
          ck = normalizeCorner(m2.groups.corner);
          metric = m2.groups.metric.trim();
        }
      }
      if (!ck) return;

      const { side, region } = cornerToRegion[ck];
      const reg = ensureRegion(region);

      const key = metric.toLowerCase();
      if (!reg.has(key)) reg.set(key, { metric });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: HydCell = {
        idx,
        metric,
        unit,
        fullLabel: label,
        isPressure: isPressureMetric(metric),
        initial: String(it.value ?? ""),
      };

      const row = reg.get(key)!;
      if (side === "Left") row.left = cell;
      else row.right = cell;
    });

    const out: Array<{ region: Region; rows: HydRow[] }> = [];
    (["Front", "Rear"] as Region[]).forEach((region) => {
      const reg = byRegion.get(region);
      if (!reg) return;
      const rows = Array.from(reg.values()).sort((a, b) =>
        hydCompare(a.metric, b.metric),
      );
      out.push({ region, rows });
    });
    return out;
  }, [items, unitHint, mode]);

  /* ------------------------------------------------------------------ */
  /* AIR (Steer / Drive / Trailer … Left | Item | Right)                */
  /* ------------------------------------------------------------------ */

  type AirCell = {
    metric: string;
    idx: number;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type AirGroup = { axle: string; left: AirCell[]; right: AirCell[] };
  type AirRow = { metric: string; left?: AirCell; right?: AirCell };

  const isDualAxle = (axle: string) => {
    const a = axle.toLowerCase();
    if (a.startsWith("drive") || a.startsWith("trailer") || a.includes("rear"))
      return true;
    if (a.startsWith("tag") || a.startsWith("steer")) return false;
    return false;
  };

  const isDualizable = (metric: string) =>
    /tire\s*pressure/i.test(metric) ||
    /(tire\s*)?tread\s*depth|tire\s*tread/i.test(metric);
  const hasInnerOuter = (m: string) => /(inner|outer)/i.test(m);

  function expandDuals(axle: string, cells: AirCell[]): AirCell[] {
    if (!isDualAxle(axle)) return cells;
    const out: AirCell[] = [];
    for (const c of cells) {
      if (isDualizable(c.metric) && !hasInnerOuter(c.metric)) {
        const base = c.metric.replace(/\s*\((inner|outer)\)\s*/i, "").trim();
        out.push({ ...c, metric: `${base} (Outer)` });
        out.push({ ...c, metric: `${base} (Inner)` });
      } else {
        out.push(c);
      }
    }
    return out;
  }

  const airGroups = useMemo(() => {
    if (mode !== "air") return [] as AirGroup[];

    const byAxle = new Map<string, { Left: AirCell[]; Right: AirCell[] }>();

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const m = label.match(AIR_RE);
      if (!m?.groups) return;

      const axle = m.groups.axle.trim();
      const side = (m.groups.side as Side) || "Left";
      const metric = m.groups.metric.trim();

      if (!byAxle.has(axle)) byAxle.set(axle, { Left: [], Right: [] });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: AirCell = {
        metric,
        idx,
        unit,
        fullLabel: label,
        isPressure: isPressureMetric(metric),
        initial: String(it.value ?? ""),
      };

      byAxle.get(axle)![side].push(cell);
    });

    return Array.from(byAxle.entries()).map(([axle, sides]) => {
      const left = expandDuals(axle, sides.Left).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      const right = expandDuals(axle, sides.Right).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      return { axle, left, right };
    });
  }, [items, unitHint, mode]);

  // build rows for AIR like AirCornerGrid (merge left/right by metric)
  const airRowsPerAxle: Array<{ axle: string; rows: AirRow[] }> = useMemo(() => {
    if (mode !== "air") return [];
    const rows: Array<{ axle: string; rows: AirRow[] }> = [];

    for (const g of airGroups) {
      const map = new Map<string, AirRow>();
      const add = (c: AirCell, which: "left" | "right") => {
        const k = c.metric.toLowerCase();
        const existing = map.get(k) || { metric: c.metric };
        map.set(k, { ...existing, metric: c.metric, [which]: c } as AirRow);
      };
      g.left.forEach((c) => add(c, "left"));
      g.right.forEach((c) => add(c, "right"));
      const merged = Array.from(map.values()).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      rows.push({ axle: g.axle, rows: merged });
    }
    return rows;
  }, [airGroups, mode]);

  /* ---------------------------- UI state ---------------------------- */

  const [open, setOpen] = useState(true);
  const [showKpa, setShowKpa] = useState(true);
  const [filledMap, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });
  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    setFilledMap((p) =>
      p[idx] === !!value.trim() ? p : { ...p, [idx]: !!value.trim() },
    );
  };

  /* ------------------- shared input used by both modes ------------------ */

  const InputWithInlineUnit = ({
    idx,
    isPressureRow,
    unit,
    defaultValue,
  }: {
    idx: number;
    isPressureRow: boolean;
    unit: string;
    defaultValue: string;
  }) => {
    const spanRef = useRef<HTMLSpanElement | null>(null);

    const seedText = () => {
      if (!isPressureRow) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpa) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressureRow || !spanRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpa) {
        spanRef.current.textContent = "psi";
      } else if (k != null) {
        spanRef.current.textContent = `psi (${k} kPa)`;
      } else {
        spanRef.current.textContent = "psi (— kPa)";
      }
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) =>
            e.key === "Enter" &&
            (e.currentTarget as HTMLInputElement).blur()
          }
        />
        <span
          ref={spanRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 whitespace-nowrap text-[11px] text-neutral-400"
        >
          {seedText()}
        </span>
      </div>
    );
  };

  /* ---------------------------- HYD UI ---------------------------- */

  const HydRegionCard = ({ region, rows }: { region: Region; rows: HydRow[] }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {region}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${region}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputWithInlineUnit
                    idx={row.left.idx}
                    isPressureRow={row.left.isPressure}
                    unit={row.left.unit}
                    defaultValue={row.left.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputWithInlineUnit
                    idx={row.right.idx}
                    isPressureRow={row.right.isPressure}
                    unit={row.right.unit}
                    defaultValue={row.right.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  /* ----------------------------- AIR UI ----------------------------- */

  const AirAxleCard = ({ axle, rows }: { axle: string; rows: AirRow[] }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {axle}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${axle}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputWithInlineUnit
                    idx={row.left.idx}
                    isPressureRow={row.left.isPressure}
                    unit={row.left.unit}
                    defaultValue={row.left.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputWithInlineUnit
                    idx={row.right.idx}
                    isPressureRow={row.right.isPressure}
                    unit={row.right.unit}
                    defaultValue={row.right.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  const countFilled = (cells: Array<{ idx: number }>) =>
    cells.reduce((sum, c) => sum + (filledMap[c.idx] ? 1 : 0), 0);

  /* ------------------------------- render ------------------------------ */

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-between gap-3 px-1">
        {/* progress strip for AIR mode */}
        {mode === "air" ? (
          <div
            className="hidden text-xs text-neutral-400 md:block"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {airGroups.map((g, i) => {
              const filled = countFilled(g.left) + countFilled(g.right);
              const total = g.left.length + g.right.length;
              return (
                <span key={g.axle}>
                  {g.axle} {filled}/{total}
                  {i < airGroups.length - 1 ? "  |  " : ""}
                </span>
              );
            })}
          </div>
        ) : (
          <div />
        )}

        <div className="flex items-center gap-3">
          <label className="flex select-none items-center gap-2 text-xs text-neutral-300">
            <input
              type="checkbox"
              className="h-3 w-3 accent-orange-500"
              checked={showKpa}
              onChange={(e) => setShowKpa(e.target.checked)}
              tabIndex={-1}
            />
            kPa hint
          </label>

          <button
            onClick={() => setOpen((v) => !v)}
            className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
            title={open ? "Collapse" : "Expand"}
            tabIndex={-1}
          >
            {open ? "Collapse" : "Expand"}
          </button>
        </div>
      </div>

      {/* inline axle picker only for AIR and when provided */}
      {mode === "air" && onAddAxle && (
        <AddAxlePicker
          existingAxles={airGroups.map((g) => g.axle)}
          onAddAxle={onAddAxle}
        />
      )}

      {mode === "hyd" ? (
        <div className="grid gap-4">
          {hydGroups.map((g) => (
            <HydRegionCard key={g.region} region={g.region} rows={g.rows} />
          ))}
        </div>
      ) : (
        <>
          {airRowsPerAxle.map(({ axle, rows }) => (
            <AirAxleCard key={axle} axle={axle} rows={rows} />
          ))}
        </>
      )}
    </div>
  );
}

/* -------------------------- Add Axle (AIR only) -------------------------- */

function AddAxlePicker({
  existingAxles,
  onAddAxle,
}: {
  existingAxles: string[];
  onAddAxle: (axleLabel: string) => void;
}) {
  const [pending, setPending] = useState<string>("");

  const candidates = useMemo(() => {
    const wants: string[] = [];
    for (let i = 1; i <= 2; i++) wants.push(`Steer ${i}`);
    for (let i = 1; i <= 4; i++) wants.push(`Drive ${i}`);
    wants.push("Tag", "Trailer 1", "Trailer 2", "Trailer 3");
    return wants.filter((l) => !existingAxles.includes(l));
  }, [existingAxles]);

  return (
    <div className="flex items-center gap-2 px-1">
      <select
        className="rounded-lg border border-neutral-700 bg-neutral-900/80 px-2 py-1 text-sm text-white"
        value={pending}
        onChange={(e) => setPending(e.target.value)}
      >
        <option value="">Add axle…</option>
        {candidates.map((l) => (
          <option key={l} value={l}>
            {l}
          </option>
        ))}
      </select>
      <button
        className="rounded-lg bg-accent px-3 py-1 text-sm font-semibold text-black hover:bg-orange-500 disabled:opacity-40"
        onClick={() => pending && onAddAxle(pending)}
        disabled={!pending}
      >
        + Add
      </button>
    </div>
  );
}
===== FILE: ./features/inspections/lib/inspection/ui/InspectionFormContext.tsx =====
"use client";

import { createContext, useContext } from "react";
import type { InspectionItem } from "@inspections/lib/inspection/types";

// The shape of the context value (includes a function—totally fine here)
export type UpdateItemFn = (
  sectionIdx: number,
  itemIdx: number,
  patch: Partial<InspectionItem>
) => void;

type Ctx = {
  updateItem: UpdateItemFn;
};

// Export the context itself (no wrapper component!)
export const InspectionFormCtx = createContext<Ctx | null>(null);

export function useInspectionForm(): Ctx {
  const ctx = useContext(InspectionFormCtx);
  if (!ctx) {
    throw new Error("useInspectionForm must be used inside <InspectionFormCtx.Provider>");
  }
  return ctx;
}

===== FILE: ./shared/components/ui/dialog.tsx =====
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { cn } from "@shared/lib/utils";

export const Dialog = DialogPrimitive.Root;
export const DialogTrigger = DialogPrimitive.Trigger;

export const DialogPortal = ({
  children,
  ...props
}: DialogPrimitive.DialogPortalProps) => (
  <DialogPrimitive.Portal {...props}>{children}</DialogPrimitive.Portal>
);

export const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-40 bg-black/70 backdrop-blur-sm transition-opacity data-[state=open]:opacity-100 data-[state=closed]:opacity-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

export const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-1/2 top-1/2 z-50 w-[95%] max-w-lg -translate-x-1/2 -translate-y-1/2 rounded-xl border border-white/10 bg-black/80 p-6 shadow-xl backdrop-blur-xl",
        "data-[state=open]:animate-in data-[state=closed]:animate-out",
        "data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        "data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
        className
      )}
      {...props}
    >
      {children}
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

export const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col gap-1 border-b border-white/10 pb-3",
      className
    )}
    {...props}
  />
);

export const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-blackops uppercase tracking-[0.18em] text-neutral-300",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

export const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-neutral-400", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "mt-4 flex w-full items-center justify-end gap-2 border-t border-white/10 pt-3",
      className
    )}
    {...props}
  />
);


===== FILE: ./unified-inspections-snapshot.txt =====
===== FILE: ./app/api/inspections/unified/session/[lineId]/finish/route.ts =====

import { NextResponse } from "next/server";

export async function POST(
  req: Request,
  { params }: { params: { lineId: string } },
) {
  const body = await req.json().catch(() => null);
  // TODO: mark inspection finished, write inspection_results + quote lines
  return NextResponse.json({ ok: true, lineId: params.lineId, body });
}


===== FILE: ./app/api/inspections/unified/session/[lineId]/quote/route.ts =====

import { NextResponse } from "next/server";

export async function POST(
  req: Request,
  { params }: { params: { lineId: string } },
) {
  const body = await req.json().catch(() => null);
  // TODO: send to parts / work_order_quote_lines / parts_quote_requests
  return NextResponse.json({ ok: true, lineId: params.lineId, body });
}


===== FILE: ./app/api/inspections/unified/session/[lineId]/route.ts =====

import { NextResponse } from "next/server";

export async function GET(
  _req: Request,
  { params }: { params: { lineId: string } },
) {
  // TODO: load from Supabase (inspection_sessions + templates)
  return NextResponse.json({ ok: true, lineId: params.lineId });
}

export async function POST(
  req: Request,
  { params }: { params: { lineId: string } },
) {
  const body = await req.json().catch(() => null);
  // TODO: persist unified session state
  return NextResponse.json({ ok: true, lineId: params.lineId, body });
}


===== FILE: ./features/inspections/unified/custom-draft/page.tsx =====

"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import type {
  InspectionSession,
  InspectionSection,
} from "@inspections/lib/inspection/types";
import InspectionUnifiedScreen from "@/features/inspections/unified/ui/InspectionUnifiedScreen";
import { saveInspectionSessionUnified } from "@/features/inspections/unified/data/saveSession";

function safeParseSections(raw: string | null): InspectionSection[] {
  if (!raw) return [];
  try {
    const parsed = JSON.parse(raw) as unknown;
    if (!Array.isArray(parsed)) return [];
    // already shaped by custom builder / draft
    return parsed as InspectionSection[];
  } catch {
    return [];
  }
}

export default function UnifiedCustomDraftPage() {
  const router = useRouter();
  const sp = useSearchParams();

  const [session, setSession] = useState<InspectionSession | null>(null);
  const [bootError, setBootError] = useState<string | null>(null);

  const sessionIdFromUrl = sp.get("sessionId");
  const workOrderId = sp.get("workOrderId") ?? "";
  const vehicleId = sp.get("vehicleId") ?? "";
  const customerId = sp.get("customerId") ?? "";
  const templateId = sp.get("templateId") ?? "";
  const location = sp.get("location") ?? "";

  const sessionId = useMemo(
    () =>
      sessionIdFromUrl ||
      (typeof crypto !== "undefined" && "randomUUID" in crypto
        ? crypto.randomUUID()
        : `local-${Date.now()}`),
    [sessionIdFromUrl],
  );

  useEffect(() => {
    if (typeof window === "undefined") return;

    // Pull staged sections from the classic custom builder / draft
    const sectionsRaw = window.sessionStorage.getItem(
      "customInspection:sections",
    );
    const titleFromStorage =
      window.sessionStorage.getItem("customInspection:title") ?? "";
    const dutyClass =
      window.sessionStorage.getItem("customInspection:dutyClass") ?? "";

    const sections = safeParseSections(sectionsRaw);

    if (!sections.length) {
      setBootError("No staged sections found for custom inspection.");
      return;
    }

    const title =
      titleFromStorage ||
      sp.get("template") ||
      "Custom Inspection (Unified)";

    const now = new Date().toISOString();

    const unifiedSession: InspectionSession = {
      id: sessionId,
      workOrderId,
      vehicleId,
      customerId,
      templateId,
      templateName: title,
      location,
      currentSectionIndex: 0,
      currentItemIndex: 0,
      transcript: "",
      status: "in_progress",
      started: true,
      completed: false,
      isPaused: false,
      isListening: false,
      quote: [],
      lastUpdated: now,
      customer: {
        first_name: "",
        last_name: "",
        phone: "",
        email: "",
        address: "",
        city: "",
        province: "",
        postal_code: "",
      },
      vehicle: {
        year: "",
        make: "",
        model: "",
        vin: "",
        license_plate: "",
        mileage: "",
        color: "",
      },
      sections,
      // extra metadata – allowed by the updated types
      meta: {
        dutyClass,
        source: "custom-builder",
      } as any,
    };

    setSession(unifiedSession);
  }, [
    sessionId,
    workOrderId,
    vehicleId,
    customerId,
    templateId,
    location,
    sp,
  ]);

  const handleUpdateSession = async (patch: Partial<InspectionSession>) => {
    if (!session) return;
    const next: InspectionSession = {
      ...session,
      ...patch,
      lastUpdated: new Date().toISOString(),
    };
    setSession(next);

    try {
      await saveInspectionSessionUnified(next);
    } catch (e) {
      // currently a stub – keep UI quiet
      // eslint-disable-next-line no-console
      console.debug("saveInspectionSessionUnified error (stub)", e);
    }
  };

  if (bootError) {
    return (
      <div className="min-h-[60vh] bg-gradient-to-b from-black via-slate-950 to-slate-950 px-4 py-6 text-sm text-red-200">
        <div className="mx-auto max-w-3xl rounded-2xl border border-red-500/40 bg-red-950/40 px-4 py-3 shadow-[0_18px_45px_rgba(0,0,0,0.85)]">
          <div className="mb-2 text-xs font-semibold uppercase tracking-[0.18em] text-red-200/80">
            Custom Inspection
          </div>
          <p>{bootError}</p>
          <button
            type="button"
            onClick={() => router.back()}
            className="mt-3 inline-flex items-center rounded-full border border-red-500/70 bg-red-600/80 px-3 py-1.5 text-[11px] font-semibold text-black hover:bg-red-500"
          >
            ← Back
          </button>
        </div>
      </div>
    );
  }

  if (!session) {
    return (
      <div className="min-h-[60vh] bg-gradient-to-b from-black via-slate-950 to-slate-950 px-4 py-6 text-sm text-neutral-300">
        <div className="mx-auto max-w-3xl rounded-2xl border border-white/10 bg-black/60 px-4 py-3 shadow-[0_18px_45px_rgba(0,0,0,0.85)]">
          Preparing unified inspection…
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-[60vh] bg-gradient-to-b from-black via-slate-950 to-slate-950 px-4 py-6">
      <div className="mx-auto max-w-6xl rounded-2xl border border-white/10 bg-black/60 p-4 shadow-[0_22px_55px_rgba(0,0,0,0.95)]">
        <div className="mb-3 flex items-center justify-between gap-2">
          <div>
            <h1 className="text-sm font-semibold uppercase tracking-[0.18em] text-neutral-300">
              Unified Inspection
            </h1>
            <p className="text-xs text-neutral-500">
              Built from custom template draft ·{" "}
              <span className="text-[color:var(--accent-copper-light,#fb923c)]">
                {session.templateName || "Custom Inspection"}
              </span>
            </p>
          </div>
        </div>

        <InspectionUnifiedScreen
          session={session}
          onUpdateSession={handleUpdateSession}
        />
      </div>
    </div>
  );
}

===== FILE: ./features/inspections/unified/data/finishSession.ts =====

import type { InspectionSession } from "@inspections/lib/inspection/types";

export async function finishInspectionSessionUnified(
  session: InspectionSession,
): Promise<void> {
  console.debug("finishInspectionSessionUnified (stub)", session.id);
}


===== FILE: ./features/inspections/unified/data/loadSession.ts =====

import type { InspectionSession } from "@inspections/lib/inspection/types";

export async function loadInspectionSession(
  lineId: string,
): Promise<InspectionSession | null> {
  console.debug("loadInspectionSession (stub)", lineId);
  return null;
}


===== FILE: ./features/inspections/unified/data/saveSession.ts =====

import type { InspectionSession } from "@inspections/lib/inspection/types";

export async function saveInspectionSessionUnified(
  session: InspectionSession,
): Promise<void> {
  console.debug("saveInspectionSessionUnified (stub)", session.id);
}


===== FILE: ./features/inspections/unified/data/sessionStore.ts =====

import type { InspectionSession } from "@inspections/lib/inspection/types";

let inMemoryStore: Record<string, InspectionSession> = {};

export function getSessionFromStore(id: string): InspectionSession | null {
  return inMemoryStore[id] ?? null;
}

export function saveSessionToStore(id: string, session: InspectionSession) {
  inMemoryStore[id] = session;
}


===== FILE: ./features/inspections/unified/data/templateLoader.ts =====

import type {
  InspectionTemplate,
  InspectionSection,
} from "@inspections/lib/inspection/types";

export async function loadInspectionTemplateUnified(
  templateId: string,
): Promise<InspectionTemplate | null> {
  console.debug("loadInspectionTemplateUnified (stub)", templateId);
  return null;
}

export function templateToSectionsUnified(
  template: InspectionTemplate,
): InspectionSection[] {
  return (template.sections as InspectionSection[]) ?? [];
}


===== FILE: ./features/inspections/unified/data/toQuoteLines.ts =====

import type {
  InspectionSession,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

export function inspectionToQuoteLinesUnified(
  session: InspectionSession,
): QuoteLineItem[] {
  console.debug("inspectionToQuoteLinesUnified (stub)", session.id);
  return [];
}


===== FILE: ./features/inspections/unified/hooks/useInspectionTemplate.ts =====

"use client";

import { useEffect, useState } from "react";
import type {
  InspectionTemplate,
} from "@inspections/lib/inspection/types";
import { loadInspectionTemplateUnified } from "../data/templateLoader";

export function useInspectionTemplate(templateId: string | null) {
  const [template, setTemplate] = useState<InspectionTemplate | null>(null);

  useEffect(() => {
    if (!templateId) return;
    loadInspectionTemplateUnified(templateId).then(setTemplate);
  }, [templateId]);

  return { template };
}


===== FILE: ./features/inspections/unified/hooks/useUnifiedInspection.ts =====

"use client";

import { useState } from "react";
import type { InspectionSession } from "@inspections/lib/inspection/types";

export default function useUnifiedInspection(initial: InspectionSession) {
  const [session, setSession] = useState<InspectionSession>(initial);

  const updateSession = (patch: Partial<InspectionSession>) =>
    setSession((prev) => ({ ...prev, ...patch }));

  return {
    session,
    updateSession,
  };
}


===== FILE: ./features/inspections/unified/SectionDisplay.tsx =====

// features/inspections/unified/ui/SectionDisplay.tsx
"use client";

import { useMemo, useState } from "react";
import type {
  InspectionSection,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";
import { Button } from "@shared/components/ui/Button";

type SectionDisplayProps = {
  title: string;
  section: InspectionSection;
  sectionIndex: number;
  showNotes: boolean;
  showPhotos: boolean;
  onUpdateStatus: (
    sectionIndex: number,
    itemIndex: number,
    status: InspectionItemStatus,
  ) => void;
  onUpdateNote: (
    sectionIndex: number,
    itemIndex: number,
    note: string,
  ) => void;
  onUpload: (
    photoUrl: string,
    sectionIndex: number,
    itemIndex: number,
  ) => void;
};

export default function SectionDisplay({
  title,
  section,
  sectionIndex,
  showNotes,
  showPhotos,
  onUpdateStatus,
  onUpdateNote,
  onUpload,
}: SectionDisplayProps) {
  const [open, setOpen] = useState<boolean>(true);

  const stats = useMemo(() => {
    const total = section.items.length;
    const counts: Record<
      "ok" | "fail" | "na" | "recommend" | "unset",
      number
    > = { ok: 0, fail: 0, na: 0, recommend: 0, unset: 0 };

    for (const it of section.items) {
      const status = (it.status ?? "unset") as keyof typeof counts;
      if (status in counts) counts[status] += 1;
      else counts.unset += 1;
    }

    return { total, ...counts };
  }, [section.items]);

  const markAll = (status: InspectionItemStatus) => {
    section.items.forEach((_item, itemIndex) =>
      onUpdateStatus(sectionIndex, itemIndex, status),
    );
  };

  return (
    <div className="mb-6 rounded-2xl border border-white/8 bg-black/30 px-4 py-3 shadow-card backdrop-blur-md md:px-5 md:py-4">
      {/* Header */}
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-white/5 pb-3">
        <button
          type="button"
          onClick={() => setOpen((v) => !v)}
          className="text-left text-lg font-semibold tracking-wide text-orange-400"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
          aria-expanded={open}
        >
          {title}
        </button>

        <div className="flex flex-wrap items-center gap-2">
          <span
            className="hidden text-[11px] uppercase tracking-wide text-neutral-400 md:inline"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {stats.ok} OK · {stats.fail} FAIL · {stats.na} NA ·{" "}
            {stats.recommend} REC · {stats.unset} —
          </span>

          <div className="flex flex-wrap items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("ok")}
            >
              All OK
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("fail")}
            >
              All FAIL
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("na")}
            >
              All NA
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              type="button"
              onClick={() => markAll("recommend")}
            >
              All REC
            </Button>

            <Button
              variant="ghost"
              size="sm"
              className="ml-1 h-7 px-2 text-[11px]"
              type="button"
              onClick={() => setOpen((v) => !v)}
              aria-expanded={open}
              title={open ? "Collapse section" : "Expand section"}
            >
              {open ? "Collapse" : "Expand"}
            </Button>
          </div>
        </div>
      </div>

      {/* Body */}
      {open && (
        <div className="space-y-3 pt-3">
          {section.items.map((item, itemIndex) => {
            const keyBase =
              item.item ?? item.name ?? `item-${sectionIndex}-${itemIndex}`;

            const status = (item.status ?? "").toString().toLowerCase();
            const note = (item.notes ?? "").toString();
            const photoUrls = (item.photoUrls ?? []) as string[];

            return (
              <div
                key={`${keyBase}-${itemIndex}`}
                className="rounded-xl border border-white/5 bg-black/40 p-3 md:p-3.5"
              >
                {/* Top row: label + status buttons */}
                <div className="flex flex-wrap items-center justify-between gap-2">
                  <div className="min-w-0 flex-1 text-sm font-medium text-white">
                    {item.item ?? item.name ?? "Item"}
                  </div>

                  <div className="flex flex-wrap items-center gap-1">
                    {(["ok", "fail", "na", "recommend"] as const).map(
                      (s) => (
                        <Button
                          key={s}
                          type="button"
                          size="sm"
                          variant={
                            (status as InspectionItemStatus) === s
                              ? "orange"
                              : "outline"
                          }
                          className="h-7 px-2 text-[11px]"
                          onClick={() =>
                            onUpdateStatus(
                              sectionIndex,
                              itemIndex,
                              s as InspectionItemStatus,
                            )
                          }
                        >
                          {s.toUpperCase()}
                        </Button>
                      ),
                    )}
                  </div>
                </div>

                {/* Measurement + notes/photos */}
                <div className="mt-2 space-y-2 text-xs text-neutral-200">
                  <div className="flex flex-wrap items-center gap-2">
                    <span className="text-neutral-400">Value:</span>
                    <span>
                      {item.value ?? "—"}
                      {item.unit ? ` ${item.unit}` : ""}
                    </span>
                  </div>

                  {showNotes && (
                    <div className="space-y-1">
                      <div className="text-neutral-400">Notes</div>
                      <textarea
                        className="min-h-[60px] w-full rounded-md border border-white/10 bg-black/40 px-2 py-1 text-xs text-white outline-none focus:border-orange-400 focus:ring-1 focus:ring-orange-400"
                        value={note}
                        onChange={(e) =>
                          onUpdateNote(
                            sectionIndex,
                            itemIndex,
                            e.currentTarget.value,
                          )
                        }
                      />
                    </div>
                  )}

                  {showPhotos && (
                    <div className="space-y-1">
                      <div className="flex items-center justify-between text-neutral-400">
                        <span>Photos ({photoUrls.length})</span>
                        {/* hook up to actual uploader later */}
                        <Button
                          type="button"
                          size="xs"
                          variant="outline"
                          className="h-6 px-2 text-[10px]"
                          onClick={() => {
                            const dummyUrl = window.prompt(
                              "Photo URL (stub for now)",
                            );
                            if (!dummyUrl) return;
                            onUpload(dummyUrl, sectionIndex, itemIndex);
                          }}
                        >
                          + Add
                        </Button>
                      </div>

                      {photoUrls.length > 0 && (
                        <div className="flex flex-wrap gap-2">
                          {photoUrls.map((url) => (
                            <div
                              key={url}
                              className="h-12 w-12 overflow-hidden rounded border border-white/10 bg-neutral-900"
                            >
                              {/* eslint-disable-next-line @next/next/no-img-element */}
                              <img
                                src={url}
                                alt="Inspection"
                                className="h-full w-full object-cover"
                              />
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}

===== FILE: ./features/inspections/unified/ui/AxleGrid.tsx =====

"use client";


import type { InspectionItem } from "@inspections/lib/inspection/types";

type GridUnitMode = "metric" | "imperial";
type Side = "left" | "right";
type Variant = "main" | "inner" | "outer";

interface AxleGridProps {
  title?: string;
  sectionIndex: number;
  items: InspectionItem[];
  unitMode: GridUnitMode;
  showKpaHint: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
  onAddAxle?: () => void;
}

interface AxleCell {
  itemIndex: number;
  item: InspectionItem;
}

interface AxleSideInputs {
  main?: AxleCell;
  inner?: AxleCell;
  outer?: AxleCell;
}

interface AxleMetricRow {
  metricKey: string;
  metricLabel: string;
  left: AxleSideInputs;
  right: AxleSideInputs;
}

interface AxleBlock {
  axleName: string;
  rows: AxleMetricRow[];
}

interface ParsedAirLabel {
  axle: string;
  side: Side;
  variant: Variant;
  metric: string;
  metricBase: string;
}

function normaliseMetric(metric: string): string {
  return metric
    .replace(/\(\s*(inner|outer)\s*\)/gi, "")
    .replace(/\b(inner|outer)\b/gi, "")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/**
 * Supported label shapes:
 *  - "Steer Left Tire Pressure"
 *  - "Drive 1 Right Inner Tire Tread"
 *  - "Drive 2 LRI Pushrod Travel"
 *  - "Trailer 1 RRO Drum / Rotor Thickness"
 */
function parseAirLabel(labelRaw: string): ParsedAirLabel | null {
  const label = labelRaw.trim();
  if (!label) return null;

  // Abbreviation: "<axle> <code> <metric>"
  const abbrMatch = label.match(
    /^(?<axle>.+?)\s+(?<code>LRI|LRO|RRI|RRO|LF|RF|LR|RR)\s+(?<metric>.+)$/i,
  );
  if (abbrMatch && abbrMatch.groups) {
    const axle = abbrMatch.groups.axle.trim();
    const code = abbrMatch.groups.code.toUpperCase();
    const metric = abbrMatch.groups.metric.trim();
    if (!axle || !metric) return null;

    const side: Side = code.startsWith("L") ? "left" : "right";
    let variant: Variant = "main";
    if (code.endsWith("I")) variant = "inner";
    if (code.endsWith("O")) variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      axle,
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  // Text form: "<axle> Left [Inner|Outer] Metric..."
  const textMatch = label.match(
    /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?:(?<io>Inner|Outer)\s+)?(?<metric>.+)$/i,
  );
  if (textMatch && textMatch.groups) {
    const axle = textMatch.groups.axle.trim();
    const side: Side =
      textMatch.groups.side.toLowerCase() === "left" ? "left" : "right";
    const ioRaw = (textMatch.groups.io ?? "").toLowerCase();
    const metric = textMatch.groups.metric.trim();
    if (!axle || !metric) return null;

    let variant: Variant = "main";
    if (ioRaw === "inner") variant = "inner";
    if (ioRaw === "outer") variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      axle,
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  return null;
}

function buildAxles(items: InspectionItem[]): {
  axles: AxleBlock[];
  loose: Array<{ itemIndex: number; item: InspectionItem }>;
} {
  const perAxle = new Map<string, Map<string, AxleMetricRow>>();
  const loose: Array<{ itemIndex: number; item: InspectionItem }> = [];

  items.forEach((item, idx) => {
    const label = item.item ?? item.name ?? "";
    const parsed = parseAirLabel(label);
    if (!parsed) {
      loose.push({ itemIndex: idx, item });
      return;
    }

    const axleMap =
      perAxle.get(parsed.axle) ?? new Map<string, AxleMetricRow>();

    const existingRow =
      axleMap.get(parsed.metricBase) ??
      ({
        metricKey: parsed.metricBase,
        metricLabel: parsed.metricBase,
        left: {},
        right: {},
      } as AxleMetricRow);

    const cell: AxleCell = { itemIndex: idx, item };

    if (parsed.side === "left") {
      existingRow.left[parsed.variant] = cell;
    } else {
      existingRow.right[parsed.variant] = cell;
    }

    axleMap.set(parsed.metricBase, existingRow);
    perAxle.set(parsed.axle, axleMap);
  });

  const axles: AxleBlock[] = Array.from(perAxle.entries()).map(
    ([axleName, rowsMap]) => ({
      axleName,
      rows: Array.from(rowsMap.values()),
    }),
  );

  return { axles, loose };
}

function getUnitLabel(metricLabel: string, unitMode: GridUnitMode): string {
  const lower = metricLabel.toLowerCase();

  // Air pressure always psi, regardless of unit toggle.
  if (lower.includes("pressure")) return "psi";

  // Pushrod travel / drum / rotor / shoe thickness etc.
  if (
    lower.includes("tread") ||
    lower.includes("pad") ||
    lower.includes("shoe") ||
    lower.includes("drum") ||
    lower.includes("rotor") ||
    lower.includes("thickness") ||
    lower.includes("pushrod") ||
    lower.includes("push-rod") ||
    lower.includes("push rod")
  ) {
    return unitMode === "metric" ? "mm" : "in";
  }

  return unitMode === "metric" ? "mm" : "in";
}

interface ValueInputProps {
  value: string | number | null | undefined;
  unit: string;
  showKpaHint?: boolean;
  isPressure?: boolean;
  onChange: (next: string) => void;
}

const ValueInput: React.FC<ValueInputProps> = ({
  value,
  unit,
  showKpaHint,
  isPressure,
  onChange,
}) => {
  const display = value ?? "";

  return (
    <div className="flex items-center gap-2 rounded-xl border border-[color:var(--metal-border-soft)] bg-black/70 px-3 py-1.5 text-xs shadow-[0_10px_25px_rgba(0,0,0,0.9)] backdrop-blur-md">
      <input
        type="number"
        inputMode="decimal"
        className="w-full bg-transparent text-sm text-white placeholder:text-neutral-500 focus:outline-none"
        placeholder="Value"
        value={display}
        onChange={(e) => onChange(e.target.value)}
      />
      <div className="flex flex-col items-end text-[10px] leading-tight text-neutral-400">
        <span>{unit}</span>
        {isPressure && showKpaHint && (
          <span className="text-[9px] text-neutral-500">kPa hint</span>
        )}
      </div>
    </div>
  );
};

interface SideStackProps {
  sideLabel: string; // "Left" / "Right"
  side: AxleSideInputs;
  sectionIndex: number;
  unit: string;
  isPressure: boolean;
  showKpaHint: boolean;
  alignRight?: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

const SideStack: React.FC<SideStackProps> = ({
  sideLabel,
  side,
  sectionIndex,
  unit,
  isPressure,
  showKpaHint,
  alignRight = false,
  onUpdateItem,
}) => {
  const pieces: Array<{ key: string; caption: string; cell: AxleCell }> = [];

  if (side.main) {
    pieces.push({ key: "main", caption: sideLabel, cell: side.main });
  }
  if (side.outer) {
    pieces.push({
      key: "outer",
      caption: `${sideLabel} Outer`,
      cell: side.outer,
    });
  }
  if (side.inner) {
    pieces.push({
      key: "inner",
      caption: `${sideLabel} Inner`,
      cell: side.inner,
    });
  }

  if (!pieces.length) return null;

  return (
    <div className="space-y-1 sm:max-w-[40%]">
      {pieces.map(({ key, caption, cell }) => (
        <div key={key} className="space-y-1">
          <div
            className={`text-[11px] font-medium uppercase tracking-[0.18em] text-neutral-400 ${
              alignRight ? "text-right" : ""
            }`}
          >
            {caption}
          </div>
          <ValueInput
            value={cell.item.value}
            unit={unit}
            isPressure={isPressure}
            showKpaHint={isPressure && showKpaHint}
            onChange={(next) =>
              onUpdateItem(sectionIndex, cell.itemIndex, { value: next })
            }
          />
        </div>
      ))}
    </div>
  );
};

const AxleGrid: React.FC<AxleGridProps> = ({
  title,
  sectionIndex,
  items,
  unitMode,
  showKpaHint,
  onUpdateItem,
  onAddAxle,
}) => {
  const { axles, loose } = buildAxles(items);

  if (axles.length === 0 && loose.length === 0) return null;

  return (
    <section className="space-y-4">
      <div className="flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title ?? "Axle Measurements (Air Brake)"}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Steer, drive, and trailer axles – tire pressure, tread depth,
            push-rod travel, drum/rotor, pads/shoes. Values only.
          </p>
        </div>
        {onAddAxle && (
          <button
            type="button"
            onClick={onAddAxle}
            className="rounded-full bg-[color:var(--accent-copper)] px-3 py-1.5 text-[11px] font-semibold text-black shadow-[0_0_20px_rgba(193,102,59,0.75)] hover:bg-[color:var(--accent-copper-soft)]"
          >
            + Add axle
          </button>
        )}
      </div>

      <div className="space-y-4">
        {axles.map((axle) => (
          <div
            key={axle.axleName}
            className="metal-card rounded-2xl p-4 shadow-[0_18px_45px_rgba(0,0,0,0.9)]"
          >
            <div className="mb-3 flex items-center justify-between gap-2">
              <div className="text-xs font-semibold uppercase tracking-[0.18em] text-neutral-400">
                {axle.axleName}
              </div>
            </div>

            {/* Desktop header */}
            <div className="hidden text-[11px] text-neutral-400 sm:grid sm:grid-cols-[minmax(0,1fr)_minmax(0,2fr)_minmax(0,1fr)] sm:gap-2 sm:border-t sm:border-white/10 sm:pt-2">
              <div className="px-2 py-1">Left</div>
              <div className="px-2 py-1 text-center">Item</div>
              <div className="px-2 py-1 text-right">Right</div>
            </div>

            <div className="space-y-3 pt-1">
              {axle.rows.map((row) => {
                const unit = getUnitLabel(row.metricLabel, unitMode);
                const isPressure =
                  row.metricLabel.toLowerCase().includes("pressure");

                return (
                  <div
                    key={row.metricKey}
                    className="rounded-xl border border-white/10 bg-black/65 p-3 backdrop-blur-md"
                  >
                    <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
                      <SideStack
                        sideLabel="Left"
                        side={row.left}
                        sectionIndex={sectionIndex}
                        unit={unit}
                        isPressure={isPressure}
                        showKpaHint={showKpaHint}
                        onUpdateItem={onUpdateItem}
                      />

                      <div className="flex-1 text-center text-sm font-medium text-neutral-100">
                        {row.metricLabel}
                      </div>

                      <SideStack
                        sideLabel="Right"
                        side={row.right}
                        sectionIndex={sectionIndex}
                        unit={unit}
                        isPressure={isPressure}
                        showKpaHint={showKpaHint}
                        alignRight
                        onUpdateItem={onUpdateItem}
                      />
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        ))}
      </div>

      {loose.length > 0 && (
        <div className="rounded-xl border border-amber-500/30 bg-amber-950/30 p-3 text-[11px] text-amber-100">
          <div className="mb-1 font-semibold tracking-wide">
            Other axle measurements
          </div>
          <div className="space-y-2">
            {loose.map(({ item, itemIndex }) => {
              const label = item.item ?? item.name ?? "Item";
              const unit = getUnitLabel(label, unitMode);
              const isPressure = label.toLowerCase().includes("pressure");

              return (
                <div key={itemIndex} className="space-y-1">
                  <div className="text-[11px] text-amber-100/80">
                    {label}
                  </div>
                  <ValueInput
                    value={item.value}
                    unit={unit}
                    isPressure={isPressure}
                    showKpaHint={showKpaHint}
                    onChange={(next) =>
                      onUpdateItem(sectionIndex, itemIndex, { value: next })
                    }
                  />
                </div>
              );
            })}
          </div>
        </div>
      )}
    </section>
  );
};

export default AxleGrid;

===== FILE: ./features/inspections/unified/ui/BatteryGrid.tsx =====

"use client";



export interface BatteryMeasurement {
  label: string;
  factoryCca: number | null;
  testedCca: number | null;
  notes?: string;
}

interface BatteryGridProps {
  title?: string;
  batteries: BatteryMeasurement[];
  onChange: (index: number, patch: Partial<BatteryMeasurement>) => void;
  onAddBattery: () => void;
  onRemoveBattery?: (index: number) => void;
}

const BatteryGrid: React.FC<BatteryGridProps> = ({
  title = "Battery Measurements",
  batteries,
  onChange,
  onAddBattery,
  onRemoveBattery,
}) => {
  return (
    <section className="metal-card rounded-2xl p-4 sm:p-5">
      <div className="mb-3 flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Capture factory and tested CCA for each battery. Values only – any
            FAIL / RECOMMEND status is handled in the main inspection sections.
          </p>
        </div>
        <button
          type="button"
          onClick={onAddBattery}
          className="rounded-full bg-[color:var(--accent-copper)] px-3 py-1.5 text-[11px] font-semibold text-black shadow-[0_0_20px_rgba(193,102,59,0.75)] hover:bg-[color:var(--accent-copper-soft)]"
        >
          + Add battery
        </button>
      </div>

      {batteries.length === 0 ? (
        <p className="text-xs text-neutral-400">
          No batteries added yet. Use “Add battery” to start.
        </p>
      ) : (
        <div className="space-y-3">
          {batteries.map((batt, idx) => (
            <div
              key={idx}
              className="rounded-xl border border-white/10 bg-black/65 p-3 shadow-[0_12px_30px_rgba(0,0,0,0.9)] backdrop-blur-md"
            >
              <div className="mb-2 flex items-center justify-between gap-2">
                <div className="flex flex-col">
                  <span className="text-[11px] font-semibold uppercase tracking-[0.18em] text-neutral-400">
                    Battery {idx + 1}
                  </span>
                  <input
                    type="text"
                    className="mt-1 w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="Location / label (Start, Aux, LH, RH...)"
                    value={batt.label}
                    onChange={(e) =>
                      onChange(idx, { label: e.target.value })
                    }
                  />
                </div>

                {onRemoveBattery && batteries.length > 1 && (
                  <button
                    type="button"
                    onClick={() => onRemoveBattery(idx)}
                    className="rounded-full border border-red-500/70 px-2 py-1 text-[10px] font-medium text-red-100 hover:bg-red-500/10"
                  >
                    Remove
                  </button>
                )}
              </div>

              <div className="grid gap-3 text-xs sm:grid-cols-3">
                <div className="space-y-1">
                  <div className="text-[11px] text-neutral-400">
                    Factory CCA
                  </div>
                  <input
                    type="number"
                    inputMode="numeric"
                    className="w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="e.g. 750"
                    value={batt.factoryCca ?? ""}
                    onChange={(e) =>
                      onChange(idx, {
                        factoryCca:
                          e.target.value === ""
                            ? null
                            : Number(e.target.value),
                      })
                    }
                  />
                </div>

                <div className="space-y-1">
                  <div className="text-[11px] text-neutral-400">
                    Tested CCA
                  </div>
                  <input
                    type="number"
                    inputMode="numeric"
                    className="w-full rounded border border-white/15 bg-black/40 px-2 py-1 text-sm text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="e.g. 680"
                    value={batt.testedCca ?? ""}
                    onChange={(e) =>
                      onChange(idx, {
                        testedCca:
                          e.target.value === ""
                            ? null
                            : Number(e.target.value),
                      })
                    }
                  />
                </div>

                <div className="space-y-1 sm:col-span-1">
                  <div className="text-[11px] text-neutral-400">Notes</div>
                  <textarea
                    rows={2}
                    className="w-full resize-none rounded border border-white/15 bg-black/40 px-2 py-1 text-xs text-white placeholder:text-neutral-500 focus:outline-none"
                    placeholder="Additional info (age, location, condition...)"
                    value={batt.notes ?? ""}
                    onChange={(e) =>
                      onChange(idx, { notes: e.target.value })
                    }
                  />
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </section>
  );
};

export default BatteryGrid;

===== FILE: ./features/inspections/unified/ui/CornerGrid.tsx =====

"use client";


import type { InspectionItem } from "@inspections/lib/inspection/types";

type GridUnitMode = "metric" | "imperial";
type Side = "left" | "right";
type Variant = "main" | "inner" | "outer";

interface CornerGridProps {
  title?: string;
  sectionIndex: number;
  items: InspectionItem[];
  unitMode: GridUnitMode;
  showKpaHint: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

interface CornerCell {
  itemIndex: number;
  item: InspectionItem;
}

interface CornerSideInputs {
  main?: CornerCell; // LF / RF / LR / RR
  inner?: CornerCell; // LRI / RRI
  outer?: CornerCell; // LRO / RRO
}

interface CornerRow {
  metricKey: string;
  metricLabel: string;
  left: CornerSideInputs;
  right: CornerSideInputs;
}

interface ParsedHydLocation {
  side: Side;
  variant: Variant;
  metric: string;
  metricBase: string;
}

/**
 * Remove "Inner" / "Outer" markup from a metric to group rows,
 * e.g. "Tire Tread (Outer)" + "Tire Tread (Inner)" → "Tire Tread".
 */
function normaliseMetric(metric: string): string {
  return metric
    .replace(/\(\s*(inner|outer)\s*\)/gi, "")
    .replace(/\b(inner|outer)\b/gi, "")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/**
 * Support:
 *  - "LF Tire Pressure"
 *  - "RRI Brake Pad Thickness"
 *  - "Left Front Tire Tread"
 *  - "Right Rear Inner Tire Tread (Outer)"
 */
function parseHydLabel(labelRaw: string): ParsedHydLocation | null {
  const label = labelRaw.trim();
  if (!label) return null;

  // Abbreviated location codes
  const abbrMatch = label.match(
    /^(LF|RF|LR|RR|LRI|LRO|RRI|RRO)\s+(.+)$/i,
  );
  if (abbrMatch) {
    const code = abbrMatch[1].toUpperCase();
    const metric = abbrMatch[2].trim();
    if (!metric) return null;

    const side: Side = code.startsWith("L") ? "left" : "right";
    let variant: Variant = "main";

    if (code.endsWith("I")) variant = "inner";
    if (code.endsWith("O")) variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  // Full text – e.g. "Left Rear Inner Tire Tread"
  const fullMatch = label.match(
    /^(Left|Right)\s+(Front|Rear)(?:\s+(Inner|Outer))?\s+(.+)$/i,
  );
  if (fullMatch) {
    const side: Side = fullMatch[1].toLowerCase() === "left" ? "left" : "right";
    const innerOuter = (fullMatch[3] ?? "").toLowerCase();
    const metric = fullMatch[4].trim();
    if (!metric) return null;

    let variant: Variant = "main";
    if (innerOuter === "inner") variant = "inner";
    if (innerOuter === "outer") variant = "outer";

    const metricBase = normaliseMetric(metric);

    return {
      side,
      variant,
      metric,
      metricBase: metricBase || metric,
    };
  }

  return null;
}

function buildRows(items: InspectionItem[]): {
  rows: CornerRow[];
  loose: Array<{ itemIndex: number; item: InspectionItem }>;
} {
  const rowsMap = new Map<string, CornerRow>();
  const loose: Array<{ itemIndex: number; item: InspectionItem }> = [];

  items.forEach((item, idx) => {
    const label = item.item ?? item.name ?? "";
    const parsed = parseHydLabel(label);
    if (!parsed) {
      loose.push({ itemIndex: idx, item });
      return;
    }

    const existing =
      rowsMap.get(parsed.metricBase) ??
      ({
        metricKey: parsed.metricBase,
        metricLabel: parsed.metricBase,
        left: {},
        right: {},
      } as CornerRow);

    const cell: CornerCell = { itemIndex: idx, item };

    if (parsed.side === "left") {
      existing.left[parsed.variant] = cell;
    } else {
      existing.right[parsed.variant] = cell;
    }

    rowsMap.set(parsed.metricBase, existing);
  });

  return { rows: Array.from(rowsMap.values()), loose };
}

function getUnitLabel(metricLabel: string, unitMode: GridUnitMode): string {
  const lower = metricLabel.toLowerCase();

  // Pressure is always psi – unit toggle does not affect this.
  if (lower.includes("pressure")) return "psi";

  // Everything else here is a length/thickness-style measurement.
  if (
    lower.includes("tread") ||
    lower.includes("pad") ||
    lower.includes("rotor") ||
    lower.includes("thickness")
  ) {
    return unitMode === "metric" ? "mm" : "in";
  }

  return unitMode === "metric" ? "mm" : "in";
}

interface ValueInputProps {
  value: string | number | null | undefined;
  unit: string;
  showKpaHint?: boolean;
  isPressure?: boolean;
  placeholder?: string;
  onChange: (next: string) => void;
}

const ValueInput: React.FC<ValueInputProps> = ({
  value,
  unit,
  showKpaHint,
  isPressure,
  placeholder = "Value",
  onChange,
}) => {
  const display = value ?? "";

  return (
    <div className="flex items-center gap-2 rounded-xl border border-[color:var(--metal-border-soft)] bg-black/70 px-3 py-1.5 text-xs shadow-[0_10px_25px_rgba(0,0,0,0.9)] backdrop-blur-md">
      <input
        type="number"
        inputMode="decimal"
        className="w-full bg-transparent text-sm text-white placeholder:text-neutral-500 focus:outline-none"
        placeholder={placeholder}
        value={display}
        onChange={(e) => onChange(e.target.value)}
      />
      <div className="flex flex-col items-end text-[10px] leading-tight text-neutral-400">
        <span>{unit}</span>
        {isPressure && showKpaHint && (
          <span className="text-[9px] text-neutral-500">kPa hint</span>
        )}
      </div>
    </div>
  );
};

interface SideStackProps {
  label: string;
  side: CornerSideInputs;
  sectionIndex: number;
  unit: string;
  isPressure: boolean;
  showKpaHint: boolean;
  alignRight?: boolean;
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
}

const SideStack: React.FC<SideStackProps> = ({
  label,
  side,
  sectionIndex,
  unit,
  isPressure,
  showKpaHint,
  alignRight = false,
  onUpdateItem,
}) => {
  const pieces: Array<{ key: string; caption: string; cell: CornerCell }> = [];

  if (side.main) {
    pieces.push({ key: "main", caption: label, cell: side.main });
  }
  if (side.outer) {
    pieces.push({ key: "outer", caption: `${label} Outer`, cell: side.outer });
  }
  if (side.inner) {
    pieces.push({ key: "inner", caption: `${label} Inner`, cell: side.inner });
  }

  if (!pieces.length) return null;

  return (
    <div className="space-y-1 sm:max-w-[40%]">
      {pieces.map(({ key, caption, cell }) => (
        <div key={key} className="space-y-1">
          <div
            className={`text-[11px] font-medium uppercase tracking-[0.18em] text-neutral-400 ${
              alignRight ? "text-right" : ""
            }`}
          >
            {caption}
          </div>
          <ValueInput
            value={cell.item.value}
            unit={unit}
            isPressure={isPressure}
            showKpaHint={isPressure && showKpaHint}
            onChange={(next) =>
              onUpdateItem(sectionIndex, cell.itemIndex, { value: next })
            }
          />
        </div>
      ))}
    </div>
  );
};

const CornerGrid: React.FC<CornerGridProps> = ({
  title,
  sectionIndex,
  items,
  unitMode,
  showKpaHint,
  onUpdateItem,
}) => {
  const { rows, loose } = buildRows(items);

  if (rows.length === 0 && loose.length === 0) return null;

  return (
    <section className="metal-card rounded-2xl p-4 sm:p-5">
      <div className="mb-3 flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-white sm:text-base">
            {title ?? "Measurements (Hydraulic)"}
          </h3>
          <p className="text-[11px] text-neutral-400">
            Corner-based measurements: tire pressure, tread depth, pad / rotor
            thickness. Values only – statuses live in other sections.
          </p>
        </div>
      </div>

      {/* Desktop header */}
      <div className="hidden text-[11px] text-neutral-400 sm:grid sm:grid-cols-[minmax(0,1fr)_minmax(0,2fr)_minmax(0,1fr)] sm:gap-2 sm:border-t sm:border-white/10 sm:pt-3">
        <div className="px-2 py-1">Left</div>
        <div className="px-2 py-1 text-center">Item</div>
        <div className="px-2 py-1 text-right">Right</div>
      </div>

      <div className="space-y-3 pt-1">
        {rows.map((row) => {
          const unit = getUnitLabel(row.metricLabel, unitMode);
          const isPressure = row.metricLabel.toLowerCase().includes("pressure");

          return (
            <div
              key={row.metricKey}
              className="rounded-xl border border-white/10 bg-black/60 p-3 shadow-[0_12px_30px_rgba(0,0,0,0.9)] backdrop-blur-md"
            >
              <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
                <SideStack
                  label="Left"
                  side={row.left}
                  sectionIndex={sectionIndex}
                  unit={unit}
                  isPressure={isPressure}
                  showKpaHint={showKpaHint}
                  onUpdateItem={onUpdateItem}
                />

                <div className="flex-1 text-center text-sm font-medium text-neutral-100">
                  {row.metricLabel}
                </div>

                <SideStack
                  label="Right"
                  side={row.right}
                  sectionIndex={sectionIndex}
                  unit={unit}
                  isPressure={isPressure}
                  showKpaHint={showKpaHint}
                  alignRight
                  onUpdateItem={onUpdateItem}
                />
              </div>
            </div>
          );
        })}
      </div>

      {loose.length > 0 && (
        <div className="mt-4 rounded-xl border border-amber-500/30 bg-amber-950/30 p-3 text-[11px] text-amber-100">
          <div className="mb-1 font-semibold tracking-wide">
            Other measurements
          </div>
          <div className="space-y-2">
            {loose.map(({ item, itemIndex }) => {
              const label = item.item ?? item.name ?? "Item";
              const unit = getUnitLabel(label, unitMode);
              const isPressure = label.toLowerCase().includes("pressure");

              return (
                <div key={itemIndex} className="space-y-1">
                  <div className="text-[11px] text-amber-100/80">
                    {label}
                  </div>
                  <ValueInput
                    value={item.value}
                    unit={unit}
                    isPressure={isPressure}
                    showKpaHint={showKpaHint}
                    onChange={(next) =>
                      onUpdateItem(sectionIndex, itemIndex, { value: next })
                    }
                  />
                </div>
              );
            })}
          </div>
        </div>
      )}
    </section>
  );
};

export default CornerGrid;

===== FILE: ./features/inspections/unified/ui/InspectionActionBar.tsx =====

"use client";



type Props = {
  onSave?: () => void;
  onFinish?: () => void;
  onStartVoice?: () => void;
  onStopVoice?: () => void;
  isListening?: boolean;
};

export default function InspectionActionBar({
  onSave,
  onFinish,
  onStartVoice,
  onStopVoice,
  isListening,
}: Props) {
  return (
    <div className="flex flex-wrap items-center justify-between gap-2 rounded-xl border border-white/10 bg-black/40 p-3 text-xs">
      <div className="font-semibold text-neutral-200">Inspection actions</div>
      <div className="flex gap-2">
        <button
          type="button"
          onClick={onSave}
          className="rounded bg-neutral-800 px-3 py-1 text-xs text-white"
        >
          Save
        </button>
        <button
          type="button"
          onClick={onFinish}
          className="rounded bg-orange-600 px-3 py-1 text-xs text-white"
        >
          Finish
        </button>
        {isListening ? (
          <button
            type="button"
            onClick={onStopVoice}
            className="rounded bg-red-600 px-3 py-1 text-xs text-white"
          >
            Stop voice
          </button>
        ) : (
          <button
            type="button"
            onClick={onStartVoice}
            className="rounded bg-green-600 px-3 py-1 text-xs text-white"
          >
            Start voice
          </button>
        )}
      </div>
    </div>
  );
}


===== FILE: ./features/inspections/unified/ui/InspectionHeader.tsx =====

"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";

type Props = {
  session: InspectionSession;
};

export default function InspectionHeader({ session }: Props) {
  return (
    <div className="flex flex-col gap-1 rounded-xl border border-white/10 bg-black/40 p-3 text-xs text-neutral-200">
      <div className="text-sm font-semibold text-orange-400">
        {session.templateName || "Inspection"}
      </div>
      <div>
        Vehicle:{" "}
        {session.vehicle?.year} {session.vehicle?.make}{" "}
        {session.vehicle?.model}
      </div>
      <div>Customer: {session.customer?.first_name} {session.customer?.last_name}</div>
      <div>Status: {session.status}</div>
    </div>
  );
}


===== FILE: ./features/inspections/unified/ui/InspectionSummary.tsx =====

"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";

type Props = {
  session: InspectionSession;
};

export default function InspectionSummary({ session }: Props) {
  const sections = session.sections ?? [];
  const totalItems = sections.reduce(
    (sum, s) => sum + (s.items?.length ?? 0),
    0,
  );

  return (
    <div className="rounded-xl border border-white/10 bg-black/40 p-3 text-xs text-neutral-200">
      <div className="mb-1 text-sm font-semibold text-orange-400">
        Quick summary
      </div>
      <div>Sections: {sections.length}</div>
      <div>Items: {totalItems}</div>
      <div>Status: {session.status}</div>
    </div>
  );
}


===== FILE: ./features/inspections/unified/ui/InspectionUnifiedScreen.tsx =====

"use client";


import type { InspectionSession } from "@inspections/lib/inspection/types";
import SectionRenderer from "./SectionRenderer";

type Props = {
  session: InspectionSession;
  onUpdateSession: (patch: Partial<InspectionSession>) => void;
};

export default function InspectionUnifiedScreen({ session, onUpdateSession }: Props) {
  // thin stub – we’ll wire real logic later
  return (
    <div className="flex flex-col gap-4">
      <h1 className="text-xl font-semibold text-orange-400">
        Unified Inspection (beta)
      </h1>
      <SectionRenderer
        sections={session.sections ?? []}
        onUpdateItem={(sectionIndex, itemIndex, patch) => {
          const next = { ...(session as InspectionSession) };
          const sections = [...(next.sections ?? [])];
          if (!sections[sectionIndex]) return;
          const items = [...(sections[sectionIndex].items ?? [])];
          if (!items[itemIndex]) return;
          items[itemIndex] = { ...items[itemIndex], ...patch };
          sections[sectionIndex] = { ...sections[sectionIndex], items };
          onUpdateSession({ sections });
        }}
      />
    </div>
  );
}


===== FILE: ./features/inspections/unified/ui/SectionRenderer.tsx =====

"use client";


import type {
  InspectionSection,
  InspectionItem,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";

import CornerGrid from "@inspections/unified/ui/CornerGrid";
import AxleGrid from "@inspections/unified/ui/AxleGrid";
import SectionDisplay from "@inspections/unified/SectionDisplay";

type Props = {
  sections: InspectionSection[];
  onUpdateItem: (
    sectionIndex: number,
    itemIndex: number,
    patch: Partial<InspectionItem>,
  ) => void;
};

// Steer / Drive / Trailer Left|Right ...
const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
// LF / RF / LR / RR ...
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
// Left Front / Right Rear ...
const HYD_FULL_RE =
  /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

function detectLayout(items: InspectionItem[]): "air" | "hyd" | "plain" {
  let airMatches = 0;
  let hydMatches = 0;

  for (const it of items) {
    const label = it.item ?? it.name ?? "";
    if (!label) continue;

    if (AIR_RE.test(label)) airMatches += 1;
    if (HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label)) hydMatches += 1;
  }

  if (airMatches > 0) return "air";
  if (hydMatches > 0) return "hyd";
  return "plain";
}

export default function SectionRenderer({ sections, onUpdateItem }: Props) {
  return (
    <div className="flex flex-col gap-4">
      {sections.map((section, sectionIndex) => {
        const items = section.items ?? [];
        const layout = detectLayout(items);

        // HYDRAULIC CORNER GRID (LF/RF/LR/RR + metrics)
        if (layout === "hyd") {
          return (
            <CornerGrid
              key={`${sectionIndex}-${section.title || "hyd"}`}
              sectionIndex={sectionIndex}
              items={items}
              onUpdateItem={onUpdateItem}
            />
          );
        }

        // AIR / AXLE GRID (Steer / Drive / Trailer Left/Right + metrics)
        if (layout === "air") {
          return (
            <AxleGrid
              key={`${sectionIndex}-${section.title || "air"}`}
              sectionIndex={sectionIndex}
              items={items}
              onUpdateItem={onUpdateItem}
            />
          );
        }

        // GENERIC “CARD” SECTION – unified theme, no legacy imports
        return (
          <SectionDisplay
            key={`${sectionIndex}-${section.title || "plain"}`}
            title={section.title ?? `Section ${sectionIndex + 1}`}
            section={section}
            sectionIndex={sectionIndex}
            showNotes
            showPhotos
            onUpdateStatus={(
              secIdx: number,
              itemIdx: number,
              status: InspectionItemStatus,
            ) => onUpdateItem(secIdx, itemIdx, { status })}
            onUpdateNote={(
              secIdx: number,
              itemIdx: number,
              note: string,
            ) => onUpdateItem(secIdx, itemIdx, { notes: note })}
            onUpload={(
              photoUrl: string,
              secIdx: number,
              itemIdx: number,
            ) => {
              const item = sections[secIdx]?.items?.[itemIdx];
              const existing = (item?.photoUrls ?? []) as string[];
              onUpdateItem(secIdx, itemIdx, {
                photoUrls: [...existing, photoUrl],
              });
            }}
          />
        );
      })}
    </div>
  );
}

===== FILE: ./features/inspections/unified/voice/commandMapper.ts =====

import type { VoiceCommand } from "./voiceTypes";
import type {
  InspectionSession,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";

type UpdateSessionFn = (patch: Partial<InspectionSession>) => void;

export function applyVoiceCommands(
  commands: VoiceCommand[],
  session: InspectionSession,
  updateSession: UpdateSessionFn,
) {
  // stub that does nothing yet – safe placeholder
  console.debug("applyVoiceCommands (stub)", commands.length);
}


===== FILE: ./features/inspections/unified/voice/interpretTranscript.ts =====

import type { VoiceCommand } from "./voiceTypes";

/**
 * Thin wrapper around your AI interpreter (to be implemented).
 * For now we just return an empty array.
 */
export async function interpretTranscript(
  transcript: string,
): Promise<VoiceCommand[]> {
  console.debug("interpretTranscript (stub)", transcript);
  return [];
}


===== FILE: ./features/inspections/unified/voice/VoiceInspectionController.tsx =====

"use client";

import { useState } from "react";
import type { InspectionSession } from "@inspections/lib/inspection/types";
import { interpretTranscript } from "./interpretTranscript";
import { applyVoiceCommands } from "./commandMapper";

type Props = {
  session: InspectionSession;
  onUpdateSession: (patch: Partial<InspectionSession>) => void;
};

export default function VoiceInspectionController({ session, onUpdateSession }: Props) {
  const [isListening, setIsListening] = useState(false);

  // We'll wire browser SpeechRecognition here later
  const handleFakeTranscript = async () => {
    const transcript = "dummy transcript";
    const cmds = await interpretTranscript(transcript);
    applyVoiceCommands(cmds, session, onUpdateSession);
  };

  return (
    <div className="mt-2 text-xs text-neutral-300">
      <button
        type="button"
        onClick={handleFakeTranscript}
        className="rounded bg-neutral-800 px-3 py-1 text-xs text-white"
      >
        Test voice (stub)
      </button>
    </div>
  );
}


===== FILE: ./features/inspections/unified/voice/voiceTypes.ts =====

export type VoiceCommandType =
  | "update_status"
  | "measurement"
  | "add_note"
  | "recommend"
  | "complete_item";

export type VoiceCommand = {
  type: VoiceCommandType;
  raw: string;
  sectionName?: string;
  itemName?: string;
  value?: string | number;
  unit?: string;
  status?: string;
  note?: string;
};




===== FILE: ./app/mobile/layout.tsx =====
// app/mobile/layout.tsx
"use client";


import { MobileShell } from "components/layout/MobileShell";

export default function MobileLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <MobileShell>{children}</MobileShell>;
}

===== FILE: ./app/mobile/sign-in/page.tsx =====
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;

// same synthetic-username domain as portal sign-in
const SHOP_USER_DOMAIN = "local.profix-internal";

export default function MobileSignInPage() {
  const router = useRouter();
  const supabase = createClientComponentClient<DB>();

  const [identifier, setIdentifier] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string>("");
  const [loading, setLoading] = useState(false);

  // If already signed in, gate by onboarding before letting them into mobile
  useEffect(() => {
    (async () => {
      const { data } = await supabase.auth.getSession();
      const session = data.session;
      if (!session?.user) return;

      const { data: profile } = await supabase
        .from("profiles")
        .select("completed_onboarding, shop_id")
        .eq("id", session.user.id)
        .maybeSingle();

      const hasShop = !!profile?.shop_id;
      const isOnboarded = !!profile?.completed_onboarding || hasShop;

      if (!isOnboarded) {
        router.replace("/onboarding");
        return;
      }

      router.replace("/mobile/dashboard");
    })();
  }, [router, supabase]);

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError("");

    const raw = identifier.trim();
    let emailToUse = raw;

    // username → synthetic email (same behavior as main sign-in)
    if (!raw.includes("@")) {
      emailToUse = `${raw.toLowerCase()}@${SHOP_USER_DOMAIN}`;
    }

    const { error: signInErr } = await supabase.auth.signInWithPassword({
      email: emailToUse,
      password,
    });

    if (signInErr) {
      setError(signInErr.message || "Sign in failed.");
      setLoading(false);
      return;
    }

    await supabase.auth.refreshSession();

    const { data: u } = await supabase.auth.getUser();
    if (!u.user) {
      setError("Signed in, but no session is visible yet. Try again.");
      setLoading(false);
      return;
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("completed_onboarding, shop_id")
      .eq("id", u.user.id)
      .maybeSingle();

    const hasShop = !!profile?.shop_id;
    const isOnboarded = !!profile?.completed_onboarding || hasShop;

    if (!isOnboarded) {
      // must finish setup in the full portal first
      router.replace("/onboarding");
    } else {
      // ✅ fully onboarded → go straight to mobile companion
      router.replace("/mobile/dashboard");
    }

    setLoading(false);
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-black via-neutral-950 to-black px-4 text-white">
      <div className="mx-auto flex min-h-screen max-w-md flex-col items-center justify-center">
        <div className="w-full rounded-2xl border border-neutral-800 bg-neutral-950/90 p-6 shadow-xl shadow-black/40 sm:p-8">
          {/* Brand / title */}
          <div className="mb-6 space-y-2 text-center">
            <div className="inline-flex items-center rounded-full border border-neutral-800 bg-neutral-900 px-3 py-1 text-[11px] uppercase tracking-[0.2em] text-neutral-400">
              ProFixIQ Mobile Companion
            </div>
            <h1 className="mt-2 text-3xl font-blackops text-orange-500 sm:text-4xl">
              Sign in
            </h1>
            <p className="text-xs text-neutral-400 sm:text-sm">
              Use your shop username or email. Only onboarded users can use the
              mobile companion.
            </p>
          </div>

          {/* Error */}
          {error && (
            <div className="mb-3 rounded-lg border border-red-500/60 bg-red-950/60 px-3 py-2 text-xs text-red-100">
              {error}
            </div>
          )}

          {/* Form */}
          <form onSubmit={handleSignIn} className="space-y-4">
            <div className="space-y-1 text-sm">
              <label className="block text-xs font-medium text-neutral-300">
                Email or username
              </label>
              <input
                type="text"
                placeholder="jane@shop.com or shop username"
                autoComplete="username"
                value={identifier}
                onChange={(e) => setIdentifier(e.target.value)}
                className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none focus:ring-0"
                required
              />
              <p className="text-[11px] text-neutral-500">
                Shop accounts can sign in using the username provided by your
                admin.
              </p>
            </div>

            <div className="space-y-1 text-sm">
              <label className="block text-xs font-medium text-neutral-300">
                Password
              </label>
              <input
                type="password"
                placeholder="••••••••"
                autoComplete="current-password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none focus:ring-0"
                required
                minLength={6}
              />
            </div>

            <button
              type="submit"
              className="mt-2 w-full rounded-md bg-orange-500 py-2.5 text-center text-sm font-blackops text-black tracking-wide transition hover:bg-orange-400 disabled:cursor-not-allowed disabled:opacity-60"
              disabled={loading}
            >
              {loading ? "Signing in…" : "Sign in"}
            </button>
          </form>

          {/* Link back to full portal sign-in */}
          <div className="mt-4 text-center text-[11px] text-neutral-500">
            Need the full desktop portal?{" "}
            <button
              type="button"
              onClick={() => router.push("/sign-in")}
              className="font-medium text-orange-400 hover:text-orange-300 hover:underline"
            >
              Open portal sign in
            </button>
          </div>

          <div className="mt-6 text-center text-[11px] text-neutral-500">
            <p>
              By continuing you agree to our{" "}
              <a
                href="/terms"
                className="font-medium text-orange-400 hover:text-orange-300 hover:underline"
              >
                Terms
              </a>{" "}
              and{" "}
              <a
                href="/privacy"
                className="font-medium text-orange-400 hover:text-orange-300 hover:underline"
              >
                Privacy Policy
              </a>
              .
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}

===== FILE: ./app/vehicle/VinCaptureModal.tsx =====
"use client";

import { 
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { useRouter } from "next/navigation";

import ModalShell from "@/features/shared/components/ModalShell";
import VinCaptureModalContent from "@/features/vehicles/components/VinCaptureModal";
import { decodeVin } from "@/features/shared/lib/vin/decodeVin";
import { useWorkOrderDraft } from "app/work-orders/state/useWorkOrderDraft";

// Optional: tame TS around experimental BarcodeDetector
declare global {
  interface Window {
    BarcodeDetector?: new (opts?: { formats?: string[] }) => {
      detect: (source: CanvasImageSource) => Promise<Array<{ rawValue?: string }>>;
    };
  }
}

export type VinDecodedDetail = {
  vin: string;
  year: string | null;
  make: string | null;
  model: string | null;
  trim: string | null;
  engine?: string | null;

  // extra fields from /api/vin
  engineDisplacementL?: string | null;
  engineCylinders?: string | null;
  fuelType?: string | null;
  transmission?: string | null;
  driveType?: string | null;
  bodyClass?: string | null;
};

type Props = {
  userId: string;
  onDecoded?: (data: VinDecodedDetail) => void;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
  children?: React.ReactNode;
  /** server route that upserts (defaults to /api/vin) */
  action?: string;
  triggerClassName?: string;
};

type DecodeVinResponse = Awaited<ReturnType<typeof decodeVin>>;

type DecodeVinResponseExtended = DecodeVinResponse & {
  engineDisplacementL?: string | null;
  engineCylinders?: string | null;
  fuelType?: string | null;
  transmission?: string | null;
  driveType?: string | null;
  bodyClass?: string | null;
};

function isLikelyVin(s: string) {
  const vin = s.replace(/[^A-Z0-9]/gi, "").toUpperCase();
  return vin.length === 17 && !/[IOQ]/.test(vin);
}

/** Scanner pane used in scanSlot */
function ScannerPane({
  onFoundVin,
  isBusy,
}: {
  userId: string;
  onFoundVin: (vin: string) => void;
  isBusy: boolean;
}) {
  const videoRef = useRef<HTMLVideoElement | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [active, setActive] = useState(false);
  const lockedRef = useRef(false);

  useEffect(() => {
    let stream: MediaStream | null = null;
    let raf = 0;
    let detector:
      | InstanceType<NonNullable<typeof window.BarcodeDetector>>
      | null = null;

    const start = async () => {
      setError(null);
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio: false,
        });
        if (!videoRef.current) return;
        videoRef.current.srcObject = stream;
        await videoRef.current.play();
        setActive(true);

        if (window.BarcodeDetector) {
          detector = new window.BarcodeDetector({
            formats: ["code_39", "code_128", "pdf417", "data_matrix"],
          });

          const scan = async () => {
            if (!videoRef.current || lockedRef.current) return;
            try {
              const bitmap = await createImageBitmap(videoRef.current);
              const codes = await detector!.detect(bitmap);
              if (codes?.length) {
                for (const c of codes) {
                  const raw = String(c.rawValue ?? "");
                  const cleaned = raw.replace(/[^A-Z0-9]/gi, "").toUpperCase();
                  if (isLikelyVin(cleaned)) {
                    lockedRef.current = true;
                    onFoundVin(cleaned);
                    return;
                  }
                }
              }
            } catch {
              /* ignore transient decode errors */
            }
            raf = requestAnimationFrame(scan);
          };
          raf = requestAnimationFrame(scan);
        } else {
          setError(
            "Live barcode detection not supported in this browser. Use photo upload below.",
          );
        }
      } catch {
        setError("Camera unavailable. Use photo upload below.");
      }
    };

    start();

    return () => {
      cancelAnimationFrame(raf);
      setActive(false);
      try {
        stream?.getTracks()?.forEach((t) => t.stop());
      } catch {
        /* no-op */
      }
    };
  }, [onFoundVin]);

  return (
    <div
      className={`space-y-3 ${
        isBusy ? "ring-2 ring-orange-500 rounded-md animate-pulse" : ""
      }`}
    >
      {isBusy && (
        <div className="flex items-center gap-2 rounded border border-orange-500/60 bg-neutral-950 px-3 py-2">
          <span className="inline-block h-4 w-4 rounded-full border-2 border-orange-500 border-t-transparent animate-spin" />
          <span className="text-xs text-orange-300">
            Decoding VIN… this can take a moment
          </span>
        </div>
      )}

      <div className="rounded border border-neutral-800 bg-neutral-950 p-2">
        <video
          ref={videoRef}
          className="aspect-video w-full rounded bg-black"
          playsInline
          muted
          autoPlay
        />
      </div>

      {error ? (
        <div className="text-xs text-amber-300">{error}</div>
      ) : (
        <div className="text-xs text-neutral-400">
          {active
            ? "Point the camera at the VIN barcode / label…"
            : "Initializing camera…"}
        </div>
      )}

      {/* Photo upload → OCR route */}
      <div className="rounded border border-neutral-800 bg-neutral-950 p-3">
        <div className="mb-2 text-sm text-neutral-200">
          Or upload a photo of the VIN label
        </div>
        <input
          type="file"
          accept="image/*"
          disabled={isBusy}
          className="block w-full text-xs text-neutral-300 file:mr-3 file:rounded file:border-0 file:bg-orange-500 file:px-3 file:py-1.5 file:text-sm file:font-semibold file:text-black hover:file:bg-orange-400 disabled:opacity-60"
          onChange={async (e) => {
            if (isBusy) return;
            const file = e.target.files?.[0];
            if (!file) return;

            try {
              const formData = new FormData();
              formData.append("image", file);

              const res = await fetch("/api/vin/extract-from-image", {
                method: "POST",
                body: formData,
              });

              if (!res.ok) {
                alert("Could not read VIN from image. Please try again.");
                e.target.value = "";
                return;
              }

              const data = (await res.json()) as { vin?: string | null };
              const vin = data?.vin?.toString().toUpperCase() ?? "";
              if (!vin || !isLikelyVin(vin)) {
                alert(
                  "No clear VIN found in the photo. Please retake or type it manually.",
                );
                e.target.value = "";
                return;
              }

              onFoundVin(vin);
            } catch (err) {
              console.error(err);
              alert(
                "Error reading VIN from image. Please try again or enter it manually.",
              );
            } finally {
              e.target.value = "";
            }
          }}
        />
        <div className="mt-2 text-[11px] text-neutral-500">
          Tip: Take a close, well-lit photo of the VIN sticker on the door frame or
          dash.
        </div>
      </div>

      <div className="text-[11px] text-neutral-500">
        We will decode with NHTSA and store it to your account.
      </div>
    </div>
  );
}

export default function VinCaptureModal({
  userId,
  onDecoded,
  open,
  onOpenChange,
  children,
  action = "/api/vin",
  triggerClassName,
}: Props) {
  const [internalOpen, setInternalOpen] = useState(false);
  const [isDecoding, setIsDecoding] = useState(false);

  const isControlled = typeof open === "boolean";
  const isOpen = isControlled ? (open as boolean) : internalOpen;

  const setOpen = useCallback(
    (val: boolean) => {
      if (isControlled) onOpenChange?.(val);
      else setInternalOpen(val);
    },
    [isControlled, onOpenChange],
  );

  const router = useRouter();
  const setVehicleDraft = useWorkOrderDraft((s) => s.setVehicle);

  // Lock body scroll when modal is open
  useEffect(() => {
    if (!isOpen) return;
    const original = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = original;
    };
  }, [isOpen]);

  // Keep latest onDecoded
  const onDecodedRef = useRef<Props["onDecoded"]>(onDecoded);
  useEffect(() => {
    onDecodedRef.current = onDecoded;
  }, [onDecoded]);

  // Listen for result events (if server form posts and emits later)
  useEffect(() => {
    const handler = (evt: Event) => {
      const ce = evt as CustomEvent<VinDecodedDetail>;
      const detail = ce?.detail;
      if (detail?.vin) {
        onDecodedRef.current?.(detail);
        setOpen(false);
      }
    };
    window.addEventListener("vin:decoded", handler as EventListener);
    return () =>
      window.removeEventListener("vin:decoded", handler as EventListener);
  }, [setOpen]);

  const handleFoundVin = useCallback(
    async (vin: string) => {
      if (isDecoding) return; // prevent double fires
      setIsDecoding(true);
      try {
        const resp = await decodeVin(vin, userId);
        if (resp?.error) {
          alert(resp.error);
          return;
        }

        const extended = resp as DecodeVinResponseExtended;

        // hydrate shared draft
        setVehicleDraft({
          vin,
          year: resp.year ?? null,
          make: resp.make ?? null,
          model: resp.model ?? null,
          trim: resp.trim ?? null,
          engine: resp.engine ?? null,
        });

        const detail: VinDecodedDetail = {
          vin,
          year: resp.year ?? null,
          make: resp.make ?? null,
          model: resp.model ?? null,
          trim: resp.trim ?? null,
          engine: resp.engine ?? null,
          engineDisplacementL: extended.engineDisplacementL ?? null,
          engineCylinders: extended.engineCylinders ?? null,
          fuelType: extended.fuelType ?? null,
          transmission: extended.transmission ?? null,
          driveType: extended.driveType ?? null,
          bodyClass: extended.bodyClass ?? null,
        };

        onDecodedRef.current?.(detail);

        // fire-and-forget recalls fetch
        try {
          void fetch("/api/recalls/fetch", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              vin,
              year: resp.year ?? undefined,
              make: resp.make ?? undefined,
              model: resp.model ?? undefined,
              user_id: userId,
            }),
            keepalive: true,
          });
        } catch {
          /* non-blocking */
        }

        setOpen(false);
        router.push("/work-orders/create?source=vin");
      } finally {
        setIsDecoding(false);
      }
    },
    [userId, setVehicleDraft, router, setOpen, isDecoding],
  );

  const defaultTrigger = useMemo(
    () => (
      <button
        type="button"
        onClick={() => setOpen(true)}
        className={
          triggerClassName ??
          "rounded border border-orange-400 bg-neutral-950 px-3 py-1.5 text-sm font-semibold text-white hover:bg-neutral-900"
        }
        title="Open VIN capture"
      >
        Add by VIN / Scan
      </button>
    ),
    [setOpen, triggerClassName],
  );

  return (
    <>
      {children ? (
        <span
          onClick={() => setOpen(true)}
          role="button"
          style={{ cursor: "pointer" }}
        >
          {children}
        </span>
      ) : (
        defaultTrigger
      )}

      <ModalShell
        isOpen={isOpen}
        onClose={() => setOpen(false)}
        title="Add Vehicle by VIN"
        size="md"
        hideFooter={true}
      >
        <VinCaptureModalContent
          action={action}
          userId={userId}
          scanSlot={
            <ScannerPane
              userId={userId}
              onFoundVin={handleFoundVin}
              isBusy={isDecoding}
            />
          }
        />
      </ModalShell>
    </>
  );
}

===== FILE: ./app/(landing)/layout.tsx =====
import "./globals.css";
import type { Metadata } from "next";
import Providers from "../providers";
import { Toaster } from "sonner";

export const metadata: Metadata = {
  title: "ProFixIQ",
  description: "AI-powered vehicle diagnostics and repair assistant",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head />
      <body
        id="root"
        className="bg-gradient-to-br from-black via-neutral-900 to-[#1a1a1a] text-white font-header"
      >
        <Providers initialSession={null}>
          <Toaster position="top-center" />
          {children}
        </Providers>
      </body>
    </html>
  );
}

===== FILE: ./app/portal/auth/sign-up/PortalSignUpForm.tsx =====
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

import type { Database } from "@shared/types/types/supabase";
import { Input } from "@shared/components/ui/input";
import { Button } from "@shared/components/ui/Button";

export default function PortalSignUpForm() {
  const router = useRouter();
  const supabase = createClientComponentClient<Database>();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const [error, setError] = useState("");
  const [notice, setNotice] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setNotice("");
    setLoading(true);

    try {
      const origin =
        typeof window !== "undefined"
          ? window.location.origin
          : process.env.NEXT_PUBLIC_SITE_URL;

      const emailRedirectTo = `${origin
        ?.replace(/\/$/, "")
        .toString()}/portal/auth/confirm`;

      const { data, error: signUpError } = await supabase.auth.signUp({
        email: email.trim().toLowerCase(),
        password,
        options: { emailRedirectTo },
      });

      if (signUpError) {
        setError(signUpError.message);
      } else if (!data.session) {
        setNotice(
          "Check your email to confirm your account. After confirming, you’ll land on your profile."
        );
      } else {
        router.replace("/portal/profile");
      }
    } catch (err: unknown) {
      const message =
        err instanceof Error
          ? err.message
          : "Unable to create your account right now.";
      setError(message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gradient-to-b from-black via-neutral-950 to-black px-4 text-white">
      <div className="w-full max-w-md rounded-2xl border border-orange-500/40 bg-neutral-950/80 p-6 shadow-xl shadow-orange-500/10 backdrop-blur">
        <div className="mb-4 text-center">
          <h1 className="text-2xl font-blackops text-orange-400">
            Create Portal Account
          </h1>
          <p className="mt-1 text-xs text-neutral-400">
            Use your email to securely access your service history and
            documents.
          </p>
        </div>

        <form onSubmit={handleSignUp} className="space-y-4">
          <div>
            <label className="mb-1 block text-xs font-medium text-neutral-300">
              Email
            </label>
            <Input
              type="email"
              autoComplete="email"
              placeholder="you@example.com"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="bg-neutral-950"
              required
            />
          </div>

          <div>
            <label className="mb-1 block text-xs font-medium text-neutral-300">
              Password
            </label>
            <Input
              type="password"
              autoComplete="new-password"
              placeholder="At least 6 characters"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="bg-neutral-950"
              required
              minLength={6}
            />
          </div>

          {error && (
            <p className="text-xs font-medium text-red-400">{error}</p>
          )}
          {notice && (
            <p className="text-xs font-medium text-emerald-400">{notice}</p>
          )}

          <Button
            type="submit"
            disabled={loading}
            className="mt-1 w-full font-semibold"
          >
            {loading ? "Creating account…" : "Sign Up"}
          </Button>
        </form>

        <div className="mt-4 flex items-center justify-between text-xs text-neutral-400">
          <span>Already have an account?</span>
          <Link
            href="/portal/signin"
            className="font-medium text-orange-400 hover:text-orange-300"
          >
            Sign in
          </Link>
        </div>
      </div>
    </div>
  );
}

===== FILE: ./app/portal/auth/sign-in/PortalSignInForm.tsx =====
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

export default function PortalSignInPage() {
  const router = useRouter();
  const supabase = createClientComponentClient<Database>();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  // If already signed in, bounce to profile
  useEffect(() => {
    (async () => {
      const { data } = await supabase.auth.getUser();
      if (data?.user) router.replace("/portal/profile");
    })();
  }, [router, supabase]);

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError("");

    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (error) {
      setError(error.message);
      setLoading(false);
      return;
    }

    router.replace("/portal/profile");
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-black via-neutral-950 to-black px-4 text-white">
      <div className="mx-auto flex min-h-screen max-w-md flex-col items-center justify-center">
        <div className="w-full rounded-2xl border border-neutral-800 bg-neutral-950/90 p-6 shadow-xl shadow-black/40 sm:p-8">
          {/* Header */}
          <header className="mb-6 space-y-2 text-center">
            <div className="inline-flex items-center rounded-full border border-neutral-800 bg-neutral-900 px-3 py-1 text-[11px] uppercase tracking-[0.2em] text-neutral-400">
              Customer Portal
            </div>
            <h1 className="mt-2 text-3xl font-blackops text-orange-400 sm:text-4xl">
              Portal sign in
            </h1>
            <p className="text-xs text-neutral-400 sm:text-sm">
              Use the email and password you created when you signed up.
            </p>
          </header>

          {/* Error */}
          {error && (
            <p className="mb-3 rounded-lg border border-red-500/60 bg-red-950/60 px-3 py-2 text-xs text-red-100">
              {error}
            </p>
          )}

          {/* Form */}
          <form onSubmit={handleSignIn} className="space-y-4">
            <div className="space-y-1 text-sm">
              <label className="block text-xs font-medium text-neutral-300">
                Email
              </label>
              <input
                type="email"
                autoComplete="email"
                placeholder="you@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none focus:ring-0"
                required
              />
            </div>

            <div className="space-y-1 text-sm">
              <label className="block text-xs font-medium text-neutral-300">
                Password
              </label>
              <input
                type="password"
                autoComplete="current-password"
                placeholder="••••••••"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white placeholder:text-neutral-500 focus:border-orange-500 focus:outline-none focus:ring-0"
                required
              />
            </div>

            <button
              type="submit"
              disabled={loading}
              className="mt-2 w-full rounded-md bg-orange-500 py-2.5 text-center text-sm font-blackops text-black tracking-wide transition hover:bg-orange-400 disabled:cursor-not-allowed disabled:opacity-60"
            >
              {loading ? "Signing in…" : "Sign in"}
            </button>
          </form>

          <div className="mt-6 flex items-center justify-between text-[11px] text-neutral-500">
            <span>Need an account?</span>
            <Link
              href="/portal/signup"
              className="font-medium text-orange-400 hover:text-orange-300 hover:underline"
            >
              Sign up
            </Link>
          </div>
        </div>
      </div>
    </div>
  );
}

===== FILE: ./app/dashboard/layout.tsx =====
// app/dashboard/layout.tsx
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return children;
}

===== FILE: ./app/dashboard/page.tsx =====
// app/dashboard/page.tsx
"use client";

import { useEffect, useState, useCallback } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import Link from "next/link";

type DB = Database;
type WorkOrderLine = DB["public"]["Tables"]["work_order_lines"]["Row"];
type WorkOrder = DB["public"]["Tables"]["work_orders"]["Row"];
type Vehicle = DB["public"]["Tables"]["vehicles"]["Row"];

type CountState = {
  appointments: number | null;
  workOrders: number | null;
  partsRequests: number | null;
};

export default function DashboardPage() {
  const supabase = createClientComponentClient<Database>();

  const [name, setName] = useState<string | null>(null);
  const [role, setRole] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);

  const [counts, setCounts] = useState<CountState>({
    appointments: null,
    workOrders: null,
    partsRequests: null,
  });

  // current punched-in job for this user
  const [currentJob, setCurrentJob] = useState<WorkOrderLine | null>(null);
  const [currentJobWorkOrder, setCurrentJobWorkOrder] =
    useState<WorkOrder | null>(null);
  const [currentJobVehicle, setCurrentJobVehicle] =
    useState<Vehicle | null>(null);
  const [loadingCurrentJob, setLoadingCurrentJob] = useState(false);

  // fetch profile + user id
  useEffect(() => {
    (async () => {
      const {
        data: { session },
      } = await supabase.auth.getSession();
      const uid = session?.user?.id ?? null;
      setUserId(uid);

      if (!uid) return;

      const { data: profile } = await supabase
        .from("profiles")
        .select("full_name, role")
        .eq("id", uid)
        .maybeSingle();

      setName(profile?.full_name ?? null);
      setRole(profile?.role ?? null);
    })();
  }, [supabase]);

  // fetch the 3 counts
  useEffect(() => {
    (async () => {
      const [appt, wo, parts] = await Promise.all([
        supabase
          .from("bookings")
          .select("id", { count: "exact", head: true }),
        supabase
          .from("work_orders")
          .select("id", { count: "exact", head: true }),
        supabase
          .from("parts_requests")
          .select("id", { count: "exact", head: true }),
      ]);

      setCounts({
        appointments: appt.error ? 0 : appt.count ?? 0,
        workOrders: wo.error ? 0 : wo.count ?? 0,
        partsRequests: parts.error ? 0 : parts.count ?? 0,
      });
    })();
  }, [supabase]);

  /* ---------------------------------------------------------------------- */
  /* Current job – job this user is actively punched in on                  */
  /* ---------------------------------------------------------------------- */

  const loadCurrentJob = useCallback(
    async (uid: string | null) => {
      if (!uid) {
        setCurrentJob(null);
        setCurrentJobWorkOrder(null);
        setCurrentJobVehicle(null);
        return;
      }

      setLoadingCurrentJob(true);
      try {
        const { data, error } = await supabase
          .from("work_order_lines")
          .select(
            "id, work_order_id, description, complaint, job_type, punched_in_at, punched_out_at, punched_in_by",
          )
          .eq("punched_in_by", uid)
          .is("punched_out_at", null)
          .order("punched_in_at", { ascending: false })
          .limit(1)
          .maybeSingle();

        if (error) {
          // eslint-disable-next-line no-console
          console.error("[Dashboard] current job load error:", error);
          setCurrentJob(null);
          setCurrentJobWorkOrder(null);
          setCurrentJobVehicle(null);
          return;
        }

        const line = (data as WorkOrderLine | null) ?? null;
        setCurrentJob(line);

        if (!line?.work_order_id) {
          setCurrentJobWorkOrder(null);
          setCurrentJobVehicle(null);
          return;
        }

        // related work order
        const { data: wo, error: woErr } = await supabase
          .from("work_orders")
          .select("id, custom_id, vehicle_id")
          .eq("id", line.work_order_id)
          .maybeSingle<WorkOrder>();

        if (woErr) {
          console.error("[Dashboard] current job WO load error:", woErr);
          setCurrentJobWorkOrder(null);
          setCurrentJobVehicle(null);
          return;
        }

        const workOrder = wo ?? null;
        setCurrentJobWorkOrder(workOrder);

        if (workOrder?.vehicle_id) {
          const { data: veh, error: vehErr } = await supabase
            .from("vehicles")
            .select("id, year, make, model, license_plate")
            .eq("id", workOrder.vehicle_id)
            .maybeSingle<Vehicle>();

          if (vehErr) {
            console.error("[Dashboard] current job vehicle load error:", vehErr);
            setCurrentJobVehicle(null);
          } else {
            setCurrentJobVehicle(veh ?? null);
          }
        } else {
          setCurrentJobVehicle(null);
        }
      } finally {
        setLoadingCurrentJob(false);
      }
    },
    [supabase],
  );

  useEffect(() => {
    void loadCurrentJob(userId);
  }, [userId, loadCurrentJob]);

  const firstName = name ? name.split(" ")[0] : null;

  const isTechRole =
    role === "tech" || role === "mechanic" || role === "technician";

  return (
    <div className="relative space-y-8 fade-in">
      {/* soft gradient background for this page (extra metal wash) */}
      <div
        aria-hidden
        className="pointer-events-none absolute inset-0 -z-10 bg-[radial-gradient(circle_at_top,_rgba(248,113,22,0.18),transparent_55%),radial-gradient(circle_at_bottom,_rgba(15,23,42,0.95),#020617_70%)]"
      />

      {/* welcome panel */}
      <section className="flex items-center justify-between gap-4 rounded-2xl border border-[color:var(--metal-border-soft,#1f2937)] bg-gradient-to-r from-black/80 via-slate-950/90 to-black/80 px-5 py-4 shadow-[0_22px_45px_rgba(0,0,0,0.9)] backdrop-blur-xl">
        <div>
          <h1 className="text-2xl font-semibold text-white">
            {firstName ? `Welcome back, ${firstName} 👋` : "Welcome 👋"}
          </h1>
          <p className="mt-1 text-sm text-neutral-400">
            Here’s a quick view of what matters today in your shop.
          </p>
        </div>
      </section>

      {/* active job pill – only for tech/mechanic roles */}
      {isTechRole && (
        <section>
          <ActiveJobCard
            loading={loadingCurrentJob}
            job={currentJob}
            workOrder={currentJobWorkOrder}
            vehicle={currentJobVehicle}
          />
        </section>
      )}

      {/* overview cards */}
      <section className="grid gap-4 md:grid-cols-4">
        <OverviewCard
          title="Today’s appointments"
          value={
            counts.appointments === null ? "…" : String(counts.appointments)
          }
          href="/portal/appointments"
        />
        <OverviewCard
          title="Open work orders"
          value={counts.workOrders === null ? "…" : String(counts.workOrders)}
          href="/work-orders/view"
        />
        <OverviewCard
          title="Parts requests"
          value={
            counts.partsRequests === null ? "…" : String(counts.partsRequests)
          }
          href="/parts/requests"
        />
        <OverviewCard title="Team chat" value="Open" href="/chat" />
      </section>

      {/* quick actions */}
      <section className="space-y-3">
        <h2 className="text-sm font-medium text-neutral-300">Quick actions</h2>
        <div className="flex flex-wrap gap-3">
          <QuickButton href="/work-orders/create?autostart=1">
            New work order
          </QuickButton>
          <QuickButton href="/portal/appointments">Appointments</QuickButton>
          <QuickButton href="/ai/assistant">AI assistant</QuickButton>
          {role === "owner" || role === "admin" ? (
            <QuickButton href="/dashboard/owner/reports">
              Reports
            </QuickButton>
          ) : null}
        </div>
      </section>
    </div>
  );
}

/* ------------------------------------------------------------------------ */
/* Active Job Card                                                          */
/* ------------------------------------------------------------------------ */

function ActiveJobCard({
  loading,
  job,
  workOrder,
  vehicle,
}: {
  loading: boolean;
  job: WorkOrderLine | null;
  workOrder: WorkOrder | null;
  vehicle: Vehicle | null;
}) {
  if (loading) {
    return (
      <div className="group relative overflow-hidden rounded-2xl border border-[color:var(--metal-border-soft,#1f2937)] bg-gradient-to-r from-black/85 via-slate-950/95 to-black/85 px-4 py-3 shadow-[0_20px_40px_rgba(0,0,0,0.95)]">
        <div className="flex items-center justify-between gap-3">
          <div>
            <p className="text-[11px] uppercase tracking-[0.18em] text-neutral-400">
              Active job
            </p>
            <p className="mt-1 text-sm text-neutral-300">Checking…</p>
          </div>
        </div>
      </div>
    );
  }

  if (!job || !workOrder) {
    return (
      <div className="group relative overflow-hidden rounded-2xl border border-[color:var(--metal-border-soft,#1f2937)] bg-gradient-to-r from-black/85 via-slate-950/95 to-black/85 px-4 py-3 shadow-[0_20px_40px_rgba(0,0,0,0.95)]">
        <div className="flex items-center justify-between gap-3">
          <div>
            <p className="text-[11px] uppercase tracking-[0.18em] text-neutral-500">
              Active job
            </p>
            <p className="mt-1 text-sm text-neutral-400">
              No active job punch.
            </p>
          </div>
        </div>
      </div>
    );
  }

  const jobLabel =
    job.description ||
    job.complaint ||
    String(job.job_type ?? "Job in progress");

  const vehicleLabel = vehicle
    ? `${vehicle.year ?? ""} ${vehicle.make ?? ""} ${vehicle.model ?? ""}`
        .trim()
        .replace(/\s+/g, " ")
    : null;

  const woLabel = workOrder.custom_id || workOrder.id.slice(0, 8);

  // 🔗 Include the line id so the job page can focus that line
  const href = `/work-orders/${workOrder.id}?focus=${job.id}`;

  return (
    <Link
      href={href}
      className="group relative block overflow-hidden rounded-2xl border border-[color:var(--accent-copper,#f97316)]/80 bg-gradient-to-r from-black/85 via-slate-950/95 to-black/85 px-4 py-3 shadow-[0_24px_45px_rgba(0,0,0,0.95),0_0_35px_rgba(249,115,22,0.55)]"
    >
      <div className="pointer-events-none absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(255,255,255,0.12),transparent_60%)] opacity-0 transition-opacity group-hover:opacity-100" />
      <div className="relative flex items-center justify-between gap-3">
        <div>
          <p className="text-[11px] uppercase tracking-[0.18em] text-[color:var(--accent-copper,#f97316)]">
            Active job
          </p>
          <p className="mt-1 line-clamp-1 text-sm font-semibold text-white">
            {jobLabel}
          </p>
          <p className="mt-1 text-xs text-neutral-300">
            WO {woLabel}
            {vehicleLabel ? ` • ${vehicleLabel}` : ""}
          </p>
        </div>
        <span className="text-xs text-[color:var(--accent-copper,#f97316)]">
          Open →
        </span>
      </div>
    </Link>
  );
}

/* ------------------------------------------------------------------------ */
/* Existing cards/buttons                                                   */
/* ------------------------------------------------------------------------ */

function OverviewCard({
  title,
  value,
  href,
}: {
  title: string;
  value: string;
  href?: string;
}) {
  const content = (
    <div className="group relative overflow-hidden rounded-2xl border border-[color:var(--metal-border-soft,#1f2937)] bg-gradient-to-br from-black/80 via-slate-950/90 to-black/85 px-4 py-4 shadow-[0_20px_40px_rgba(0,0,0,0.95)] backdrop-blur-xl transition hover:border-[color:var(--accent-copper,#f97316)]/80 hover:shadow-[0_0_35px_rgba(249,115,22,0.55)]">
      <div className="pointer-events-none absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(255,255,255,0.12),transparent_60%)] opacity-0 transition-opacity group-hover:opacity-100" />
      <div className="relative">
        <p className="text-[11px] uppercase tracking-[0.18em] text-neutral-400">
          {title}
        </p>
        <p className="mt-2 text-2xl font-semibold text-white">{value}</p>
      </div>
    </div>
  );

  if (href) {
    return (
      <Link href={href} className="block">
        {content}
      </Link>
    );
  }
  return content;
}

function QuickButton({
  href,
  children,
}: {
  href: string;
  children: React.ReactNode;
}) {
  return (
    <Link
      href={href}
      className="inline-flex items-center gap-2 rounded-full border border-[color:var(--accent-copper,#f97316)]/70 bg-gradient-to-r from-black/70 via-slate-950/90 to-black/80 px-4 py-2 text-sm text-white shadow-[0_12px_28px_rgba(0,0,0,0.9)] backdrop-blur-md transition hover:bg-[color:var(--accent-copper,#f97316)]/15 hover:border-[color:var(--accent-copper-light,#fed7aa)]"
    >
      {children}
    </Link>
  );
}

===== FILE: ./app/layout.tsx =====
// app/layout.tsx
import "./globals.css";
import { Inter, Black_Ops_One } from "next/font/google";
import Providers from "./providers";
import AppShell from "@/features/shared/components/AppShell";
import TabsBridge from "@/features/shared/components/tabs/TabsBridge";
import { cookies } from "next/headers";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { VoiceProvider } from "@/features/shared/voice/VoiceProvider";

import { Toaster } from "react-hot-toast";

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
  display: "swap",
});
const blackOps = Black_Ops_One({
  weight: "400",
  subsets: ["latin"],
  variable: "--font-blackops",
  display: "swap",
});

export const metadata = {
  title: "ProFixIQ",
  description: "Tech tools for modern shops",
};

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const supabase = createServerComponentClient<Database>({ cookies });
  const {
    data: { session },
  } = await supabase.auth.getSession();

  return (
    <html
      lang="en"
      className={`${inter.variable} ${blackOps.variable} dark`}
      suppressHydrationWarning
    >
      <body
        className="
          min-h-screen
          bg-[radial-gradient(circle_at_top,_rgba(249,115,22,0.18),transparent_55%),radial-gradient(circle_at_bottom,_rgba(15,23,42,0.96),#020617_70%)]
          text-white
          antialiased
        "
      >
        <Providers initialSession={session ?? null}>
          <VoiceProvider>
            <AppShell>
              {session?.user ? (
                <TabsBridge>
                  <main className="relative z-0">{children}</main>
                </TabsBridge>
              ) : (
                <main className="relative z-0">{children}</main>
              )}
            </AppShell>
          </VoiceProvider>
          {/* Legacy toast for older parts of the app – dark metal theme */}
          <Toaster
            position="bottom-center"
            toastOptions={{
              style: {
                background:
                  "radial-gradient(circle at top, rgba(15,23,42,0.96), #020617 70%)",
                border: "1px solid rgba(148, 163, 184, 0.5)",
                color: "#e5e7eb",
              },
            }}
          />
        </Providers>
      </body>
    </html>
  );
}

===== FILE: ./app/parts/inventory/page.tsx =====
"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";
import { v4 as uuidv4 } from "uuid";

/* ----------------------------- Types ----------------------------- */

type DB = Database;
type Part = DB["public"]["Tables"]["parts"]["Row"];
type PartInsert = DB["public"]["Tables"]["parts"]["Insert"];
type PartUpdate = DB["public"]["Tables"]["parts"]["Update"];
type StockLoc = DB["public"]["Tables"]["stock_locations"]["Row"];
type StockMove = DB["public"]["Tables"]["stock_moves"]["Row"];

// app-side view of the enum
type StockMoveReason = "receive" | "adjust" | "consume" | "transfer";

/* --------------------------- UI helpers -------------------------- */

function Modal(props: {
  open: boolean;
  title: string;
  onClose: () => void;
  children: React.ReactNode;
  footer?: React.ReactNode;
  widthClass?: string;
}) {
  const { open, title, onClose, children, footer, widthClass = "max-w-xl" } = props;
  if (!open) return null;
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 p-4">
      <div
        className={`w-full ${widthClass} rounded border border-orange-500 bg-neutral-950 p-4 text-white shadow-xl`}
        onClick={(e) => e.stopPropagation()}
        role="dialog"
        aria-modal="true"
      >
        <div className="mb-3 flex items-center justify-between">
          <h2 className="text-lg font-semibold">{title}</h2>
          <button
            onClick={onClose}
            className="rounded border border-neutral-700 px-2 py-1 text-sm hover:bg-neutral-800"
            aria-label="Close"
          >
            ✕
          </button>
        </div>
        <div>{children}</div>
        {footer ? <div className="mt-4">{footer}</div> : null}
      </div>
    </div>
  );
}

function TextField(props: {
  label: string;
  value: string;
  placeholder?: string;
  onChange: (v: string) => void;
}) {
  const { label, value, placeholder, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <input
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
      />
    </div>
  );
}

function NumberField(props: {
  label: string;
  value: number | "";
  min?: number;
  step?: number;
  onChange: (v: number | "") => void;
}) {
  const { label, value, min = 0, step = 0.01, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <input
        type="number"
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value === "" ? "" : value}
        min={min}
        step={step}
        onChange={(e) => {
          const raw = e.target.value;
          onChange(raw === "" ? "" : Number(raw));
        }}
      />
    </div>
  );
}

function SelectField(props: {
  label: string;
  value: string;
  options: { value: string; label: string }[];
  onChange: (v: string) => void;
}) {
  const { label, value, options, onChange } = props;
  return (
    <div>
      <div className="mb-1 text-xs text-neutral-400">{label}</div>
      <select
        className="w-full rounded border border-neutral-700 bg-neutral-900 p-2"
        value={value}
        onChange={(e) => onChange(e.target.value)}
      >
        {options.map((o) => (
          <option key={o.value} value={o.value}>
            {o.label}
          </option>
        ))}
      </select>
    </div>
  );
}

/* ---------------------- CSV parsing helper ---------------------- */

function parseCSV(text: string): string[][] {
  const rows: string[][] = [];
  let row: string[] = [];
  let cell = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (inQuotes) {
      if (ch === '"') {
        const next = text[i + 1];
        if (next === '"') {
          cell += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        cell += ch;
      }
    } else {
      if (ch === '"') inQuotes = true;
      else if (ch === ",") {
        row.push(cell.trim());
        cell = "";
      } else if (ch === "\n") {
        row.push(cell.trim());
        rows.push(row);
        row = [];
        cell = "";
      } else if (ch !== "\r") {
        cell += ch;
      }
    }
  }
  if (cell.length > 0 || row.length > 0) {
    row.push(cell.trim());
    rows.push(row);
  }
  return rows.filter((r) => r.length > 0 && r.some((c) => c.length > 0));
}

/* ------------------------- Error helper ------------------------- */
function errMsg(err: unknown): string {
  if (typeof err === "string") return err;
  if (err && typeof err === "object" && "message" in err) {
    return String((err as Record<string, unknown>).message);
  }
  try {
    return JSON.stringify(err);
  } catch {
    return String(err);
  }
}

/* ------------------------- RPC helper --------------------------- */
/** Try 6-arg function first; if schema cache hasn’t picked it up,
 * fall back to the 5-arg legacy shape. Strictly typed; ignores return value.
 */
async function applyStockMoveRPC(
  supabase: ReturnType<typeof createClientComponentClient<DB>>,
  args: {
    p_part: string;
    p_loc: string;
    p_qty: number;
    p_reason: StockMoveReason;
    p_ref_kind: string;
    p_ref_id?: string | null;
  },
): Promise<void> {
  type FnArgs = DB["public"]["Functions"]["apply_stock_move"]["Args"];

  // 6-arg (conditionally include p_ref_id so shapes match)
  const payload6 = {
    p_part: args.p_part,
    p_loc: args.p_loc,
    p_qty: args.p_qty,
    p_reason: args.p_reason as FnArgs extends { p_reason: infer R } ? R : never,
    p_ref_kind: args.p_ref_kind,
    ...(args.p_ref_id !== undefined ? { p_ref_id: args.p_ref_id } : {}),
  } as FnArgs;

  const call6 = await supabase.rpc("apply_stock_move", payload6);
  if (!call6.error) return;

  const msg = (call6.error?.message ?? "").toLowerCase();
  const cacheShapeIssue =
    msg.includes("could not find the function") ||
    msg.includes("schema cache") ||
    msg.includes("function apply_stock_move(");

  if (!cacheShapeIssue) throw new Error(call6.error?.message ?? "apply_stock_move failed");

  // 5-arg (legacy, no p_ref_id)
  const payload5 = {
    p_part: args.p_part,
    p_loc: args.p_loc,
    p_qty: args.p_qty,
    p_reason: args.p_reason as FnArgs extends { p_reason: infer R } ? R : never,
    p_ref_kind: args.p_ref_kind,
  } as FnArgs;

  const call5 = await supabase.rpc("apply_stock_move", payload5);
  if (call5.error) {
    throw new Error(call5.error.message ?? "apply_stock_move failed");
  }
}

/* ---------------------------- Page ---------------------------- */

export default function InventoryPage(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [shopId, setShopId] = useState<string>("");
  const [search, setSearch] = useState<string>("");
  const [parts, setParts] = useState<Part[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  // stock locations
  const [locs, setLocs] = useState<StockLoc[]>([]);

  // on-hand map: partId -> total qty
  const [onHand, setOnHand] = useState<Record<string, number>>({});
  // per-location detail modal
  const [ohOpen, setOhOpen] = useState<boolean>(false);
  const [ohForPart, setOhForPart] = useState<Part | null>(null);
  const [ohLines, setOhLines] = useState<{ location: string; qty: number }[]>([]);

  // add modal
  const [addOpen, setAddOpen] = useState<boolean>(false);
  const [name, setName] = useState<string>("");
  const [sku, setSku] = useState<string>("");
  const [category, setCategory] = useState<string>("");
  const [price, setPrice] = useState<number | "">("");

  // initial receive (optional) for Add
  const [initLoc, setInitLoc] = useState<string>("");
  const [initQty, setInitQty] = useState<number | "">("");

  // edit modal
  const [editOpen, setEditOpen] = useState<boolean>(false);
  const [editPart, setEditPart] = useState<Part | null>(null);
  const [editName, setEditName] = useState<string>("");
  const [editSku, setEditSku] = useState<string>("");
  const [editCategory, setEditCategory] = useState<string>("");
  const [editPrice, setEditPrice] = useState<number | "">("");

  // receive modal (standalone quick receive)
  const [recvOpen, setRecvOpen] = useState<boolean>(false);
  const [recvPart, setRecvPart] = useState<Part | null>(null);
  const [recvLoc, setRecvLoc] = useState<string>("");
  const [recvQty, setRecvQty] = useState<number | "">("");

  // CSV Import
  const [csvOpen, setCsvOpen] = useState<boolean>(false);
  const [csvText, setCsvText] = useState<string>("");
  const [csvRows, setCsvRows] = useState<
    { name: string; sku?: string; category?: string; price?: number; qty?: number }[]
  >([]);
  const [csvPreview, setCsvPreview] = useState<boolean>(false);
  const [csvDefaultLoc, setCsvDefaultLoc] = useState<string>("");

  // ---------- on-hand loader (pass sid directly; avoids first-render zeros)
  const loadOnHand = useCallback(
    async (sid: string, partIds: string[]) => {
      if (!partIds.length) {
        setOnHand({});
        return;
      }
      const { data, error } = await supabase
        .from("stock_moves")
        .select("part_id, qty_change")
        .in("part_id", partIds)
        .eq("shop_id", sid);

      if (error || !data) {
        setOnHand({});
        return;
      }

      const totals: Record<string, number> = {};
      (data as StockMove[]).forEach((m) => {
        const delta = Number(m.qty_change) || 0;
        totals[m.part_id] = (totals[m.part_id] ?? 0) + delta;
      });
      setOnHand(totals);
    },
    [supabase],
  );

  const load = async (sid: string) => {
    setLoading(true);
    const base = supabase
      .from("parts")
      .select("*")
      .eq("shop_id", sid)
      .order("name", { ascending: true });

    const { data, error } = await (search.trim()
      ? base.or(
          [
            `name.ilike.%${search}%`,
            `sku.ilike.%${search}%`,
            `category.ilike.%${search}%`,
          ].join(","),
        )
      : base);

    const partRows = (!error && (data as Part[])) || [];
    setParts(partRows);
    setLoading(false);

    void loadOnHand(sid, partRows.map((p) => p.id));
  };

  // --- on-hand detail (per-location)
  const openOnHandDetail = async (p: Part) => {
    setOhForPart(p);
    const { data, error } = await supabase
      .from("stock_moves")
      .select("location_id, qty_change")
      .eq("part_id", p.id)
      .eq("shop_id", shopId);

    if (error || !data) {
      setOhLines([]);
      setOhOpen(true);
      return;
    }

    const byLoc: Record<string, number> = {};
    (data as StockMove[]).forEach((r) => {
      const loc = r.location_id as string;
      const q = Number(r.qty_change) || 0;
      byLoc[loc] = (byLoc[loc] ?? 0) + q;
    });

    const lines = locs
      .map((l) => ({
        location: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
        qty: byLoc[l.id] ?? 0,
      }))
      .filter((x) => x.qty !== 0);

    setOhLines(lines);
    setOhOpen(true);
  };

  /* boot */
  useEffect(() => {
    (async () => {
      const { data: u } = await supabase.auth.getUser();
      const uid = u.user?.id ?? null;
      if (!uid) return;

      const { data: prof } = await supabase
        .from("profiles")
        .select("shop_id")
        .eq("user_id", uid)
        .maybeSingle();

      const sid = (prof?.shop_id as string) || "";
      setShopId(sid);
      if (!sid) return;

      const { data: l } = await supabase
        .from("stock_locations")
        .select("*")
        .eq("shop_id", sid)
        .order("code");

      const locRows = (l as StockLoc[]) ?? [];
      setLocs(locRows);

      const main = locRows.find((x) => (x.code ?? "").toUpperCase() === "MAIN");
      if (main) {
        setInitLoc(main.id);
        setRecvLoc(main.id);
        setCsvDefaultLoc(main.id);
      }

      await load(sid);
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [supabase]);

  /* refetch on search */
  useEffect(() => {
    if (shopId) void load(shopId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [search, shopId]);

  /* ----------------------- CRUD handlers ----------------------- */

  const createPart = async () => {
    if (!shopId || !name.trim()) return;

    const id = uuidv4();
    const insert: PartInsert = {
      id,
      shop_id: shopId,
      name: name.trim(),
      sku: sku.trim() ? sku.trim() : undefined,
      category: category.trim() ? category.trim() : undefined,
      price: typeof price === "number" ? price : undefined,
    };

    const { error } = await supabase.from("parts").insert(insert);
    if (error) {
      alert(error.message);
      return;
    }

    // optional initial receive
    if (initLoc && typeof initQty === "number" && initQty > 0) {
      try {
        await applyStockMoveRPC(supabase, {
          p_part: id,
          p_loc: initLoc,
          p_qty: initQty,
          p_reason: "receive",
          p_ref_kind: "manual_receive",
          p_ref_id: null,
        });
      } catch (err: unknown) {
        alert(`Part created, but stock receive failed: ${errMsg(err)}`);
      }
    }

    setAddOpen(false);
    setName("");
    setSku("");
    setCategory("");
    setPrice("");
    setInitQty("");
    await load(shopId);
  };

  const openEdit = (p: Part) => {
    setEditPart(p);
    setEditName(p.name ?? "");
    setEditSku(p.sku ?? "");
    setEditCategory(p.category ?? "");
    setEditPrice(typeof p.price === "number" ? p.price : "");
    setEditOpen(true);
  };

  const saveEdit = async () => {
    if (!editPart?.id) return;

    const patch: PartUpdate = {
      name: editName.trim() ? editName.trim() : undefined,
      sku: editSku.trim() ? editSku.trim() : undefined,
      category: editCategory.trim() ? editCategory.trim() : undefined,
      price: typeof editPrice === "number" ? editPrice : undefined,
    };

    const { error } = await supabase.from("parts").update(patch).eq("id", editPart.id);
    if (error) {
      alert(error.message);
      return;
    }

    setEditOpen(false);
    await load(shopId);
  };

  const openReceive = (p: Part) => {
    setRecvPart(p);
    setRecvQty("");
    setRecvOpen(true);
  };

  const applyReceive = async () => {
    if (!recvPart?.id || !recvLoc || typeof recvQty !== "number" || recvQty <= 0) return;
    try {
      await applyStockMoveRPC(supabase, {
        p_part: recvPart.id,
        p_loc: recvLoc,
        p_qty: recvQty,
        p_reason: "receive",
        p_ref_kind: "manual_receive",
        p_ref_id: null,
      });
      setRecvOpen(false);
      await load(shopId);
    } catch (err: unknown) {
      alert(errMsg(err));
    }
  };

  /* -------------------------- CSV Import -------------------------- */

  const parseAndPreviewCSV = (raw: string) => {
    const rows = parseCSV(raw);
    if (!rows.length) {
      setCsvRows([]);
      setCsvPreview(false);
      return;
    }
    const header = rows[0].map((h) => h.toLowerCase().trim());
    const idx = {
      name: header.indexOf("name"),
      sku: header.indexOf("sku"),
      category: header.indexOf("category"),
      price: header.indexOf("price"),
      qty: header.indexOf("qty"),
    };

    const out: { name: string; sku?: string; category?: string; price?: number; qty?: number }[] = [];

    for (let r = 1; r < rows.length; r++) {
      const row = rows[r];
      const name = idx.name >= 0 ? row[idx.name] : "";
      if (!name) continue;
      const sku = idx.sku >= 0 ? row[idx.sku] : undefined;
      const category = idx.category >= 0 ? row[idx.category] : undefined;
      const priceStr = idx.price >= 0 ? row[idx.price] : undefined;
      const qtyStr = idx.qty >= 0 ? row[idx.qty] : undefined;

      const price = priceStr && priceStr.length ? Number(priceStr) : undefined;
      const qty = qtyStr && qtyStr.length ? Number(qtyStr) : undefined;

      out.push({
        name,
        sku: sku && sku.length ? sku : undefined,
        category: category && category.length ? category : undefined,
        price: typeof price === "number" && !Number.isNaN(price) ? price : undefined,
        qty: typeof qty === "number" && !Number.isNaN(qty) ? qty : undefined,
      });
    }

    setCsvRows(out);
    setCsvPreview(true);
  };

  const handleCsvFile = async (file: File) => {
    const text = await file.text();
    setCsvText(text);
    parseAndPreviewCSV(text);
  };

  const runCsvImport = async () => {
    if (!shopId || !csvRows.length) return;

    for (const row of csvRows) {
      let partId: string | null = null;

      if (row.sku) {
        const { data: found } = await supabase
          .from("parts")
          .select("id")
          .eq("shop_id", shopId)
          .eq("sku", row.sku)
          .maybeSingle();
        if (found?.id) partId = found.id;
      }

      if (!partId) {
        const id = uuidv4();
        const insert: PartInsert = {
          id,
          shop_id: shopId,
          name: row.name,
          sku: row.sku || undefined,
          category: row.category || undefined,
          price: typeof row.price === "number" ? row.price : undefined,
        };
        const { error } = await supabase.from("parts").insert(insert);
        if (error) {
          console.warn("Insert failed:", row, error.message);
          continue;
        }
        partId = id;
      } else {
        const patch: PartUpdate = {
          name: row.name || undefined,
          sku: row.sku || undefined,
          category: row.category || undefined,
          price: typeof row.price === "number" ? row.price : undefined,
        };
        await supabase.from("parts").update(patch).eq("id", partId);
      }

      if (partId && csvDefaultLoc && typeof row.qty === "number" && row.qty > 0) {
        try {
          await applyStockMoveRPC(supabase, {
            p_part: partId,
            p_loc: csvDefaultLoc,
            p_qty: row.qty,
            p_reason: "receive",
            p_ref_kind: "csv_import",
            p_ref_id: null,
          });
        } catch (err: unknown) {
          console.warn("Stock receive failed for row:", row, errMsg(err));
        }
      }
    }

    setCsvOpen(false);
    setCsvPreview(false);
    setCsvText("");
    setCsvRows([]);
    await load(shopId);
  };

  /* ----------------------------- UI ----------------------------- */

  return (
    <div className="space-y-4 p-6 text-white">
      <div className="flex flex-wrap items-center justify-between gap-3">
        <h1 className="text-2xl font-bold">Inventory</h1>
        <div className="flex items-center gap-2">
          <input
            className="w-64 rounded border border-neutral-700 bg-neutral-900 p-2 text-sm"
            placeholder="Search name / SKU / category"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
          <button
            className="font-header rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
            onClick={() => setAddOpen(true)}
            disabled={!shopId}
          >
            Add Part
          </button>
          <button
            className="font-header rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
            onClick={() => setCsvOpen(true)}
            disabled={!shopId}
          >
            CSV Import
          </button>
        </div>
      </div>

      {loading ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          Loading…
        </div>
      ) : parts.length === 0 ? (
        <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-400">
          No parts yet. Click “Add Part” to create your first item or use CSV Import.
        </div>
      ) : (
        <div className="overflow-hidden rounded border border-neutral-800 bg-neutral-900">
          <table className="w-full text-sm">
            <thead className="bg-neutral-900">
              <tr className="text-left text-neutral-400">
                <th className="p-2">Name</th>
                <th className="p-2">SKU</th>
                <th className="p-2">Category</th>
                <th className="p-2">Price</th>
                <th className="p-2">On hand</th>
                <th className="p-2 w-48 text-right">Actions</th>
              </tr>
            </thead>
            <tbody>
              {parts.map((p) => {
                const total = onHand[p.id] ?? 0;
                return (
                  <tr key={p.id} className="border-t border-neutral-800">
                    <td className="p-2">{p.name}</td>
                    <td className="p-2">{p.sku ?? "—"}</td>
                    <td className="p-2">{p.category ?? "—"}</td>
                    <td className="p-2">
                      {typeof p.price === "number" ? `$${p.price.toFixed(2)}` : "—"}
                    </td>
                    <td className="p-2">
                      <button
                        className="rounded border border-neutral-700 px-2 py-0.5 text-xs hover:bg-neutral-800"
                        onClick={() => openOnHandDetail(p)}
                        title="View per-location balance"
                      >
                        {total}
                      </button>
                    </td>
                    <td className="p-2">
                      <div className="flex justify-end gap-2">
                        <button
                          className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
                          onClick={() => openEdit(p)}
                        >
                          Edit
                        </button>
                        <button
                          className="rounded border border-blue-600 px-2 py-1 text-xs text-blue-300 hover:bg-blue-900/20"
                          onClick={() => openReceive(p)}
                        >
                          Receive
                        </button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      )}

      {/* Add Part */}
      <Modal
        open={addOpen}
        title="Add Part"
        onClose={() => setAddOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setAddOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
              onClick={createPart}
              disabled={!name.trim()}
            >
              Save Part
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <div className="sm:col-span-2">
            <TextField label="Name*" value={name} onChange={setName} placeholder="Part name" />
          </div>
          <TextField label="SKU" value={sku} onChange={setSku} placeholder="Optional" />
          <TextField label="Category" value={category} onChange={setCategory} placeholder="Optional" />
          <NumberField
            label="Price"
            value={price}
            onChange={(v) => setPrice(v === "" ? "" : v)}
          />
        </div>

        <div className="mt-4 rounded border border-neutral-800 bg-neutral-900 p-3">
          <div className="mb-2 text-sm font-semibold">Initial Stock (optional)</div>
          <div className="grid gap-3 sm:grid-cols-2">
            <SelectField
              label="Location"
              value={initLoc}
              onChange={setInitLoc}
              options={[
                { value: "", label: "— none —" },
                ...locs.map((l) => ({
                  value: l.id,
                  label: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
                })),
              ]}
            />
            <NumberField
              label="Qty"
              value={initQty}
              min={0}
              step={1}
              onChange={(v) => setInitQty(v === "" ? "" : Math.max(0, v))}
            />
          </div>
        </div>
      </Modal>

      {/* Edit Part */}
      <Modal
        open={editOpen}
        title="Edit Part"
        onClose={() => setEditOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setEditOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-orange-500 px-3 py-1.5 text-sm hover:bg-orange-500/10 disabled:opacity-60"
              onClick={saveEdit}
              disabled={!editName.trim()}
            >
              Save Changes
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <div className="sm:col-span-2">
            <TextField label="Name*" value={editName} onChange={setEditName} />
          </div>
          <TextField label="SKU" value={editSku} onChange={setEditSku} />
          <TextField label="Category" value={editCategory} onChange={setEditCategory} />
          <NumberField label="Price" value={editPrice} onChange={(v) => setEditPrice(v === "" ? "" : v)} />
        </div>
      </Modal>

      {/* Receive Stock */}
      <Modal
        open={recvOpen}
        title={recvPart ? `Receive — ${recvPart.name}` : "Receive Stock"}
        onClose={() => setRecvOpen(false)}
        footer={
          <div className="flex justify-end gap-2">
            <button
              className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
              onClick={() => setRecvOpen(false)}
            >
              Cancel
            </button>
            <button
              className="rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
              onClick={applyReceive}
              disabled={!recvPart?.id || !recvLoc || typeof recvQty !== "number" || recvQty <= 0}
            >
              Apply Receive
            </button>
          </div>
        }
      >
        <div className="grid gap-3 sm:grid-cols-2">
          <SelectField
            label="Location"
            value={recvLoc}
            onChange={setRecvLoc}
            options={locs.map((l) => ({
              value: l.id,
              label: `${l.code ?? "LOC"} — ${l.name ?? ""}`,
            }))}
          />
          <NumberField
            label="Qty"
            value={recvQty}
            min={0}
            step={1}
            onChange={(v) => setRecvQty(v === "" ? "" : Math.max(0, v))}
          />
        </div>
      </Modal>

      {/* On-hand detail */}
      <Modal
        open={ohOpen}
        title={ohForPart ? `On hand — ${ohForPart.name}` : "On hand"}
        onClose={() => setOhOpen(false)}
        widthClass="max-w-lg"
      >
        {ohLines.length === 0 ? (
          <div className="text-sm text-neutral-400">No movement found for this part.</div>
        ) : (
          <div className="rounded border border-neutral-800">
            <table className="w-full text-sm">
              <thead className="text-left text-neutral-400">
                <tr>
                  <th className="p-2">Location</th>
                  <th className="p-2">Qty</th>
                </tr>
              </thead>
              <tbody>
                {ohLines.map((l, i) => (
                  <tr key={i} className="border-t border-neutral-800">
                    <td className="p-2">{l.location}</td>
                    <td className="p-2">{l.qty}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </Modal>

      {/* CSV Import */}
      <Modal
        open={csvOpen}
        title="CSV Import"
        onClose={() => setCsvOpen(false)}
        widthClass="max-w-3xl"
        footer={
          <div className="flex w-full flex-wrap items-center justify-between gap-3">
            <div className="flex items-center gap-2">
              <SelectField
                label="Default receive location (for rows with qty)"
                value={csvDefaultLoc}
                onChange={setCsvDefaultLoc}
                options={[
                  { value: "", label: "— none —" },
                  ...locs.map((l) => ({ value: l.id, label: `${l.code ?? "LOC"} — ${l.name ?? ""}` })),
                ]}
              />
            </div>
            <div className="flex items-center gap-2">
              <button
                className="rounded border border-neutral-700 px-3 py-1.5 text-sm hover:bg-neutral-800"
                onClick={() => {
                  setCsvPreview(false);
                  setCsvText("");
                  setCsvRows([]);
                  setCsvOpen(false);
                }}
              >
                Close
              </button>
              <button
                className="rounded border border-blue-600 px-3 py-1.5 text-sm text-blue-300 hover:bg-blue-900/20 disabled:opacity-60"
                onClick={runCsvImport}
                disabled={!csvPreview || csvRows.length === 0}
              >
                Import
              </button>
            </div>
          </div>
        }
      >
        <div className="grid gap-3">
          <div className="rounded border border-neutral-800 bg-neutral-900 p-3 text-sm text-neutral-300">
            Expected headers (case-insensitive): <code>name, sku, category, price, qty</code>. Extra columns are ignored.
          </div>

          <div className="flex flex-wrap items-center gap-2">
            <input
              type="file"
              accept=".csv,text/csv"
              onChange={(e) => {
                const f = e.target.files?.[0];
                if (f) void handleCsvFile(f);
              }}
              className="text-sm"
            />
            <button
              className="rounded border border-neutral-700 px-2 py-1 text-xs hover:bg-neutral-800"
              onClick={() => {
                if (csvText.trim().length) parseAndPreviewCSV(csvText);
              }}
            >
              Parse text
            </button>
          </div>

          <textarea
            rows={8}
            className="w-full rounded border border-neutral-700 bg-neutral-900 p-2 text-sm"
            placeholder={`Paste CSV here… e.g.:
name,sku,category,price,qty
Oil Filter – Ford,OF-FORD-01,Filters,9.95,10
Spark Plug – Iridium,SP-IR-01,Ignition,9.95,24
`}
            value={csvText}
            onChange={(e) => setCsvText(e.target.value)}
          />

          {csvPreview && (
            <div className="rounded border border-neutral-800">
              <table className="w-full text-sm">
                <thead className="text-left text-neutral-400">
                  <tr>
                    <th className="p-2">Name</th>
                    <th className="p-2">SKU</th>
                    <th className="p-2">Category</th>
                    <th className="p-2">Price</th>
                    <th className="p-2">Qty</th>
                  </tr>
                </thead>
                <tbody>
                  {csvRows.map((r, i) => (
                    <tr key={i} className="border-t border-neutral-800">
                      <td className="p-2">{r.name}</td>
                      <td className="p-2">{r.sku ?? "—"}</td>
                      <td className="p-2">{r.category ?? "—"}</td>
                      <td className="p-2">{typeof r.price === "number" ? r.price.toFixed(2) : "—"}</td>
                      <td className="p-2">{typeof r.qty === "number" ? r.qty : "—"}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </Modal>
    </div>
  );
}

===== FILE: ./app/parts/page.tsx =====
"use client";

import { useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Database } from "@shared/types/types/supabase";

type DB = Database;
type PartRow = DB["public"]["Tables"]["parts"]["Row"];
type StockMoveRow = DB["public"]["Tables"]["stock_moves"]["Row"];
type RequestRow = DB["public"]["Tables"]["part_requests"]["Row"];

// ---------- UI helpers ----------

function Sparkline({
  points,
  width = 120,
  height = 28,
}: {
  points: number[];
  width?: number;
  height?: number;
}) {
  if (!points.length) {
    return (
      <svg width={width} height={height} aria-hidden>
        <line
          x1="0"
          x2={width}
          y1={height / 2}
          y2={height / 2}
          stroke="currentColor"
          opacity={0.2}
        />
      </svg>
    );
  }
  const min = Math.min(...points);
  const max = Math.max(...points);
  const range = max - min || 1;
  const stepX = width / Math.max(1, points.length - 1);
  const path = points
    .map((v, i) => {
      const x = i * stepX;
      const y = height - ((v - min) / range) * height;
      return `${i === 0 ? "M" : "L"} ${x.toFixed(2)} ${y.toFixed(2)}`;
    })
    .join(" ");
  return (
    <svg width={width} height={height} aria-hidden>
      <path d={path} fill="none" stroke="currentColor" />
    </svg>
  );
}

// shared card primitives (mirrors main dashboard look)
function OverviewCard({
  title,
  value,
  href,
}: {
  title: string;
  value: React.ReactNode;
  href?: string;
}) {
  const content = (
    <div className="group relative overflow-hidden rounded-xl border border-white/10 bg-white/[0.04] px-4 py-4 shadow-card backdrop-blur-md transition hover:border-accent hover:shadow-glow">
      <div className="pointer-events-none absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(255,255,255,0.12),transparent_60%)] opacity-0 transition-opacity group-hover:opacity-100" />
      <div className="relative">
        <p className="text-[11px] uppercase tracking-[0.18em] text-neutral-400">
          {title}
        </p>
        <div className="mt-2 text-2xl font-semibold text-white">{value}</div>
      </div>
    </div>
  );

  if (href) {
    return (
      <Link href={href} className="block">
        {content}
      </Link>
    );
  }
  return content;
}

function QuickButton({
  href,
  children,
  accent,
}: {
  href: string;
  children: React.ReactNode;
  accent?: boolean;
}) {
  return (
    <Link
      href={href}
      className={`inline-flex items-center gap-2 rounded-md border px-4 py-2 text-sm text-whitetypedefs shadow-sm backdrop-blur-md transition ${
        accent
          ? "border-orange-400/60 bg-white/[0.03] hover:bg-orange-500/10 hover:border-orange-400"
          : "border-neutral-700 bg-white/[0.02] hover:bg-neutral-800/80"
      }`}
    >
      {children}
    </Link>
  );
}

// ---------- Page ----------
export default function PartsDashboardPage(): JSX.Element {
  const supabase = useMemo(() => createClientComponentClient<DB>(), []);
  const [loading, setLoading] = useState(true);

  // KPIs
  const [skuTotal, setSkuTotal] = useState<number>(0);
  const [skuNewThis7d, setSkuNewThis7d] = useState<number>(0);

  const [moves7dCount, setMoves7dCount] = useState<number>(0);
  const [moves30Spark, setMoves30Spark] = useState<number[]>([]);

  const [openRequestsCount, setOpenRequestsCount] = useState<number | null>(
    null,
  );

  // Recent moves (list)
  const [recentMoves, setRecentMoves] = useState<
    Pick<
      StockMoveRow,
      "id" | "created_at" | "reason" | "qty_change" | "part_id"
    >[]
  >([]);

  useEffect(() => {
    (async () => {
      setLoading(true);

      const now = new Date();
      const d7Ago = new Date(now.getTime() - 7 * 24 * 3600 * 1000);
      const d30Ago = new Date(now.getTime() - 30 * 24 * 3600 * 1000);

      // -------- parts (for SKUs + 7d new) --------
      const { data: parts, error: perr } = await supabase
        .from("parts")
        .select("id, created_at");

      if (perr) {
        // eslint-disable-next-line no-console
        console.error("[parts] load failed:", perr);
      }
      const partsRows = (parts ?? []) as Pick<
        PartRow,
        "id" | "created_at"
      >[];

      setSkuTotal(partsRows.length);

      const createdInLast7 = partsRows.filter((p) => {
        const ts = p.created_at ? new Date(p.created_at) : null;
        return !!ts && ts >= d7Ago && ts < now;
      }).length;
      setSkuNewThis7d(createdInLast7);

      // -------- stock_moves (for 7d count + 30d sparkline + list) --------
      const { data: moves, error: merr } = await supabase
        .from("stock_moves")
        .select("id, part_id, qty_change, reason, created_at")
        .gte("created_at", d30Ago.toISOString())
        .order("created_at", { ascending: true });

      if (merr) {
        // eslint-disable-next-line no-console
        console.error("[stock_moves] load failed:", merr);
      }

      const mv = (moves ?? []) as Pick<
        StockMoveRow,
        "id" | "part_id" | "qty_change" | "reason" | "created_at"
      >[];

      // 7d moves count
      setMoves7dCount(
        mv.filter((m) => new Date(m.created_at) >= d7Ago).length,
      );

      // 30-day sparkline (daily net qty_change)
      const days = 30;
      const buckets = Array<number>(days).fill(0);
      for (const m of mv) {
        const dt = new Date(m.created_at);
        const idx = Math.min(
          days - 1,
          Math.max(
            0,
            Math.floor(
              (dt.getTime() - d30Ago.getTime()) / (24 * 3600 * 1000),
            ),
          ),
        );
        buckets[idx] += Number(m.qty_change ?? 0);
      }
      setMoves30Spark(buckets);

      // Recent list (latest 10, descending)
      const recent = [...mv]
        .sort(
          (a, b) =>
            new Date(b.created_at).getTime() -
            new Date(a.created_at).getTime(),
        )
        .slice(0, 10);
      setRecentMoves(recent);

      // -------- open parts requests count --------
      const {
        count: openCount,
        error: rerr,
      } = await supabase
        .from("part_requests")
        .select("id", { count: "exact", head: true })
        .in("status", ["requested", "quoted", "approved"] as RequestRow["status"][]);

      if (rerr) {
        // eslint-disable-next-line no-console
        console.error("[part_requests] count failed:", rerr);
        setOpenRequestsCount(0);
      } else {
        setOpenRequestsCount(openCount ?? 0);
      }

      setLoading(false);
    })();
  }, [supabase]);

  const skuTotalDisplay = loading ? "…" : skuTotal.toLocaleString();
  const newSkuDisplay = loading ? "…" : String(skuNewThis7d);
  const moves7dDisplay = loading ? "…" : moves7dCount.toLocaleString();
  const openReqDisplay =
    openRequestsCount === null || loading
      ? "…"
      : openRequestsCount.toLocaleString();

  return (
    <div className="relative space-y-8 p-6 text-white fade-in">
      {/* soft gradient background for this page */}
      <div
        aria-hidden
        className="pointer-events-none absolute inset-0 -z-10 bg-[radial-gradient(circle_at_top,_rgba(249,115,22,0.14),transparent_55%),radial-gradient(circle_at_bottom,_rgba(15,23,42,0.9),#020617_70%)]"
      />

      {/* welcome panel */}
      <section className="flex items-center justify-between gap-4 rounded-xl border border-white/10 bg-white/[0.03] px-5 py-4 shadow-card backdrop-blur-md">
        <div>
          <h1 className="text-2xl font-semibold text-white">
            Parts dashboard
          </h1>
          <p className="mt-1 text-sm text-neutral-400">
            Overview of your catalog, movement, and open requests.
          </p>
        </div>
      </section>

      {/* overview cards */}
      <section className="grid gap-4 md:grid-cols-4">
        <OverviewCard
          title="SKUs in catalog"
          value={skuTotalDisplay}
          href="/parts/inventory"
        />
        <OverviewCard
          title="New SKUs (7 days)"
          value={newSkuDisplay}
          href="/parts/inventory"
        />
        <OverviewCard
          title="Stock moves (7 days)"
          value={moves7dDisplay}
          href="/parts/inventory"
        />
        <OverviewCard
          title="Open parts requests"
          value={openReqDisplay}
          href="/parts/requests"
        />
      </section>

      {/* quick actions */}
      <section className="space-y-3">
        <h2 className="text-sm font-medium text-neutral-300">Quick actions</h2>
        <div className="flex flex-wrap gap-3">
          <QuickButton href="/parts/po" accent>
            Create PO
          </QuickButton>
          <QuickButton href="/parts/inventory">Inventory</QuickButton>
          <QuickButton href="/parts/receive">Scan to receive</QuickButton>
          <QuickButton href="/parts/requests">Requests</QuickButton>
          <QuickButton href="/parts/vendors">Vendors</QuickButton>
        </div>
      </section>

      {/* recent moves */}
      <section className="rounded-xl border border-white/10 bg-white/[0.03] px-5 py-4 shadow-card backdrop-blur-md">
        <div className="mb-2 flex items-center justify-between gap-4">
          <div>
            <h2 className="text-lg font-semibold">Recent stock moves</h2>
            <p className="text-xs text-neutral-400">
              Last 30 days of inventory activity.
            </p>
          </div>
          <Sparkline points={moves30Spark} />
        </div>

        {loading ? (
          <div className="text-sm text-neutral-400">Loading…</div>
        ) : recentMoves.length === 0 ? (
          <div className="text-sm text-neutral-400">No recent moves</div>
        ) : (
          <ul className="divide-y divide-neutral-800 text-sm">
            {recentMoves.map((m) => (
              <li
                key={m.id}
                className="flex items-center justify-between py-2"
              >
                <div className="min-w-0">
                  <div className="font-medium">
                    {String(m.reason ?? "move").replaceAll("_", " ")}
                  </div>
                  <div className="text-xs text-neutral-500">
                    {new Date(m.created_at as string).toLocaleString()}
                  </div>
                </div>
                <div className="pl-3 font-semibold">
                  {Number(m.qty_change ?? 0) >= 0 ? "+" : ""}
                  {Number(m.qty_change ?? 0)}
                </div>
              </li>
            ))}
          </ul>
        )}
      </section>
    </div>
  );
}

===== FILE: ./app/providers.tsx =====
"use client";

import { useMemo } from "react";
import { SessionContextProvider } from "@supabase/auth-helpers-react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import type { Session } from "@supabase/supabase-js";
import type { Database } from "@shared/types/types/supabase";

export default function Providers({
  children,
  initialSession,
}: {
  children: React.ReactNode;
  initialSession: Session | null;
}) {
  const supabase = useMemo(() => createClientComponentClient<Database>(), []);
  return (
    <SessionContextProvider supabaseClient={supabase} initialSession={initialSession}>
      {children}
    </SessionContextProvider>
  );
}

