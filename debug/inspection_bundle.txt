// shared/components/ui/CornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  unitHint?: (label: string) => string;
};

type CornerKey = "LF" | "RF" | "LR" | "RR";
type Side = "Left" | "Right";
type Region = "Front" | "Rear";

const cornerToRegion: Record<CornerKey, { side: Side; region: Region }> = {
  LF: { side: "Left", region: "Front" },
  RF: { side: "Right", region: "Front" },
  LR: { side: "Left", region: "Rear" },
  RR: { side: "Right", region: "Rear" },
};

const abbrevRE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const fullRE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

const metricOrder = [
  "Tire Pressure",
  "Tire Tread",
  "Brake Pad",
  "Rotor",
  "Rotor Condition",
  "Rotor Thickness",
  "Wheel Torque",
];
const orderIndex = (m: string) => {
  const i = metricOrder.findIndex((x) =>
    m.toLowerCase().includes(x.toLowerCase()),
  );
  return i === -1 ? Number.MAX_SAFE_INTEGER : i;
};

export default function CornerGrid({ sectionIndex, items, unitHint }: Props) {
  const { updateItem } = useInspectionForm();

  const parseCorner = (
    label: string,
  ): { corner: CornerKey | null; metric: string } => {
    let corner: CornerKey | null = null;
    let metric = "";

    const m1 = label.match(abbrevRE);
    if (m1?.groups) {
      corner = (m1.groups.corner.toUpperCase() as CornerKey) || null;
      metric = m1.groups.metric.trim();
      return { corner, metric };
    }

    const m2 = label.match(fullRE);
    if (m2?.groups) {
      const c = m2.groups.corner.toLowerCase();
      if (c === "left front") corner = "LF";
      if (c === "right front") corner = "RF";
      if (c === "left rear") corner = "LR";
      if (c === "right rear") corner = "RR";
      metric = m2.groups.metric.trim();
      return { corner, metric };
    }

    return { corner: null, metric: "" };
  };

  type MetricCell = {
    idx: number;
    metric: string;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };

  type RowTriplet = { metric: string; left?: MetricCell; right?: MetricCell };

  const groups = useMemo(() => {
    const byRegion = new Map<Region, Map<string, RowTriplet>>();
    const ensureRegion = (r: Region) =>
      byRegion.get(r) ?? byRegion.set(r, new Map()).get(r)!;

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const { corner, metric } = parseCorner(label);
      if (!corner) return;

      const { side, region } = cornerToRegion[corner];
      const reg = ensureRegion(region);

      const key = metric.toLowerCase();
      if (!reg.has(key)) reg.set(key, { metric });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: MetricCell = {
        idx,
        metric,
        unit,
        fullLabel: label,
        isPressure: /pressure/i.test(metric),
        initial: String(it.value ?? ""),
      };

      const row = reg.get(key)!;
      if (side === "Left") row.left = cell;
      else row.right = cell;
    });

    const sorted: Array<{ region: Region; rows: RowTriplet[] }> = [];
    (["Front", "Rear"] as Region[]).forEach((region) => {
      const reg = byRegion.get(region);
      if (!reg) return;
      const rows = Array.from(reg.values()).sort(
        (a, b) => orderIndex(a.metric) - orderIndex(b.metric),
      );
      sorted.push({ region, rows });
    });

    return sorted;
  }, [items, unitHint]);

  const [open, setOpen] = useState(true);
  const [showKpaHint, setShowKpaHint] = useState(true);

  const [, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });

  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    const has = value.trim().length > 0;
    setFilledMap((p) => (p[idx] === has ? p : { ...p, [idx]: has }));
  };

  const kpaFromPsi = (psiStr: string) => {
    const n = Number(psiStr);
    return isFinite(n) ? Math.round(n * 6.894757) : null;
  };

  const InputCell = ({
    idx,
    defaultValue,
    isPressure,
    unit,
  }: {
    idx: number;
    defaultValue: string;
    isPressure: boolean;
    unit: string;
  }) => {
    const kpaRef = useRef<HTMLSpanElement | null>(null);

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressure || !kpaRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpaHint) {
        kpaRef.current.textContent = "psi";
      } else if (k != null) {
        kpaRef.current.textContent = `psi (${k} kPa)`;
      } else {
        kpaRef.current.textContent = "psi (— kPa)";
      }
    };

    // seed text
    const seed = () => {
      if (!isPressure) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpaHint) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          name={`hyd-${idx}`}
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          autoCorrect="off"
          autoCapitalize="off"
          spellCheck={false}
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) => {
            if (e.key === "Enter") (e.currentTarget as HTMLInputElement).blur();
          }}
        />
        <span
          ref={kpaRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 text-[11px] text-neutral-400"
        >
          {seed()}
        </span>
      </div>
    );
  };

  const RegionCard = ({
    region,
    rows,
  }: {
    region: Region;
    rows: RowTriplet[];
  }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {region}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${region}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputCell
                    idx={row.left.idx}
                    defaultValue={row.left.initial}
                    isPressure={row.left.isPressure}
                    unit={row.left.unit}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputCell
                    idx={row.right.idx}
                    defaultValue={row.right.initial}
                    isPressure={row.right.isPressure}
                    unit={row.right.unit}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-end gap-3 px-1">
        <label className="flex items-center gap-2 select-none text-xs text-neutral-400">
          <input
            type="checkbox"
            className="h-3 w-3 accent-orange-500"
            checked={showKpaHint}
            onChange={(e) => setShowKpaHint(e.target.checked)}
            tabIndex={-1}
          />
          kPa hint
        </label>

        <button
          onClick={() => setOpen((v) => !v)}
          className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
          aria-expanded={open}
          title={open ? "Collapse" : "Expand"}
          tabIndex={-1}
        >
          {open ? "Collapse" : "Expand"}
        </button>
      </div>

      <div className="grid gap-4">
        {groups.map((g) => (
          <RegionCard key={g.region} region={g.region} rows={g.rows} />
        ))}
      </div>
    </div>
  );
}// shared/components/ui/AirCornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  unitHint?: (label: string) => string;
  onAddAxle?: (axleLabel: string) => void;
};

export default function AirCornerGrid({
  sectionIndex,
  items,
  unitHint,
  onAddAxle,
}: Props) {
  const { updateItem } = useInspectionForm();

  type Side = "Left" | "Right";
  const labelRe = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;

  type MetricCell = {
    metric: string;
    idx: number;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type AxleGroup = { axle: string; left: MetricCell[]; right: MetricCell[] };

  const airPriority = (metric: string): [number, number] => {
    const m = metric.toLowerCase();
    if (/tire\s*pressure/i.test(m)) {
      const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
      return [0, second];
    }
    if (/(tire\s*)?tread\s*depth|tire\s*tread/i.test(m)) {
      const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
      return [1, second];
    }
    if (/(lining|shoe|pad)/i.test(m)) return [2, 0];
    if (/(drum|rotor)/i.test(m)) return [3, 0];
    if (/push\s*rod/i.test(m)) return [4, 0];
    if (/wheel\s*torque/i.test(m)) return [5, /inner/i.test(m) ? 1 : 0];
    return [99, 0];
  };
  const orderCompare = (a: string, b: string) => {
    const [pa, sa] = airPriority(a);
    const [pb, sb] = airPriority(b);
    return pa !== pb ? pa - pb : sa - sb;
  };

  const isDualAxle = (axleLabel: string) => {
    const a = axleLabel.toLowerCase();
    if (a.startsWith("drive") || a.startsWith("trailer") || a.includes("rear"))
      return true;
    if (a.startsWith("tag") || a.startsWith("steer")) return false;
    return false;
  };

  const isDualizableMetric = (metric: string) =>
    /tire\s*pressure/i.test(metric) ||
    /(tire\s*)?tread\s*depth|tire\s*tread/i.test(metric);
  const hasInnerOuter = (metric: string) => /(inner|outer)/i.test(metric);

  function expandDuals(axle: string, cells: MetricCell[]): MetricCell[] {
    if (!isDualAxle(axle)) return cells;

    const out: MetricCell[] = [];
    for (const c of cells) {
      if (isDualizableMetric(c.metric) && !hasInnerOuter(c.metric)) {
        const base = c.metric.replace(/\s*\((inner|outer)\)\s*/i, "").trim();
        out.push({ ...c, metric: `${base} (Outer)` });
        out.push({ ...c, metric: `${base} (Inner)` });
      } else {
        out.push(c);
      }
    }
    return out;
  }

  const groups: AxleGroup[] = useMemo(() => {
    const byAxle = new Map<string, { Left: MetricCell[]; Right: MetricCell[] }>();

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const m = label.match(labelRe);
      if (!m?.groups) return;

      const axle = m.groups.axle.trim();
      const side = (m.groups.side as Side) || "Left";
      const metric = m.groups.metric.trim();

      if (!byAxle.has(axle)) byAxle.set(axle, { Left: [], Right: [] });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: MetricCell = {
        metric,
        idx,
        unit,
        fullLabel: label,
        isPressure: /pressure/i.test(metric),
        initial: String(it.value ?? ""),
      };

      byAxle.get(axle)![side].push(cell);
    });

    return Array.from(byAxle.entries()).map(([axle, sides]) => {
      const left = expandDuals(axle, sides.Left).sort((a, b) =>
        orderCompare(a.metric, b.metric),
      );
      const right = expandDuals(axle, sides.Right).sort((a, b) =>
        orderCompare(a.metric, b.metric),
      );
      return { axle, left, right };
    });
  }, [items, unitHint]);

  const [open, setOpen] = useState(true);
  const [showKpa, setShowKpa] = useState(true);

  const [filledMap, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });
  const count = (cells: MetricCell[]) =>
    cells.reduce((a, r) => a + (filledMap[r.idx] ? 1 : 0), 0);

  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    const has = value.trim().length > 0;
    setFilledMap((p) => (p[idx] === has ? p : { ...p, [idx]: has }));
  };

  const kpaFromPsi = (psiStr: string) => {
    const n = Number(psiStr);
    return isFinite(n) ? Math.round(n * 6.894757) : null;
  };

  type RowTriplet = { metric: string; left?: MetricCell; right?: MetricCell };

  const buildTriplets = (g: AxleGroup): RowTriplet[] => {
    const map = new Map<string, RowTriplet>();
    const add = (c: MetricCell, which: "left" | "right") => {
      const k = c.metric.toLowerCase();
      const existing = map.get(k) || { metric: c.metric };
      map.set(k, { ...existing, metric: c.metric, [which]: c });
    };
    g.left.forEach((c) => add(c, "left"));
    g.right.forEach((c) => add(c, "right"));
    return Array.from(map.values()).sort((a, b) =>
      orderCompare(a.metric, b.metric),
    );
  };

  const InputWithInlineUnit = ({
    idx,
    isPressure,
    unit,
    defaultValue,
    showKpaHint,
  }: {
    idx: number;
    isPressure: boolean;
    unit: string;
    defaultValue: string;
    showKpaHint: boolean;
  }) => {
    const spanRef = useRef<HTMLSpanElement | null>(null);

    const kSeed = () => {
      if (!isPressure) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpaHint) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressure || !spanRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpaHint) {
        spanRef.current.textContent = "psi";
      } else if (k != null) {
        spanRef.current.textContent = `psi (${k} kPa)`;
      } else {
        spanRef.current.textContent = "psi (— kPa)";
      }
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          name={`air-${idx}`}
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) =>
            e.key === "Enter" &&
            (e.currentTarget as HTMLInputElement).blur()
          }
        />
        <span
          ref={spanRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 whitespace-nowrap text-[11px] text-neutral-400"
        >
          {kSeed()}
        </span>
      </div>
    );
  };

  const AxleCard = ({ g }: { g: AxleGroup }) => {
    const rows = buildTriplets(g);
    return (
      <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
        <div
          className="mb-3 text-lg font-semibold text-accent"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
        >
          {g.axle}
        </div>

        <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
          <div>Left</div>
          <div className="text-center">Item</div>
          <div className="text-right">Right</div>
        </div>

        {open && (
          <div className="space-y-3">
            {rows.map((row, i) => {
              const leftUnit =
                row.left?.unit ??
                (unitHint ? unitHint(row.left?.fullLabel ?? "") : "") ??
                "";
              const rightUnit =
                row.right?.unit ??
                (unitHint ? unitHint(row.right?.fullLabel ?? "") : "") ??
                "";
              return (
                <div
                  key={`${row.metric}-${i}`}
                  className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
                >
                  <div>
                    {row.left ? (
                      <InputWithInlineUnit
                        idx={row.left.idx}
                        isPressure={row.left.isPressure}
                        unit={leftUnit}
                        defaultValue={row.left.initial}
                        showKpaHint={showKpa}
                      />
                    ) : (
                      <div className="h-[34px]" />
                    )}
                  </div>

                  <div
                    className="min-w-0 truncate text-center text-sm font-semibold text-white"
                    style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                    title={row.metric}
                  >
                    {row.metric}
                  </div>

                  <div className="justify-self-end">
                    {row.right ? (
                      <InputWithInlineUnit
                        idx={row.right.idx}
                        isPressure={row.right.isPressure}
                        unit={rightUnit}
                        defaultValue={row.right.initial}
                        showKpaHint={showKpa}
                      />
                    ) : (
                      <div className="h-[34px]" />
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-between gap-3 px-1">
        <div
          className="hidden text-xs text-neutral-400 md:block"
          style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
        >
          {groups.map((g, i) => {
            const filled = count(g.left) + count(g.right);
            const total = g.left.length + g.right.length;
            return (
              <span key={g.axle}>
                {g.axle} {filled}/{total}
                {i < groups.length - 1 ? "  |  " : ""}
              </span>
            );
          })}
        </div>

        <div className="flex items-center gap-3">
          <label className="flex select-none items-center gap-2 text-xs text-neutral-300">
            <input
              type="checkbox"
              className="h-3 w-3 accent-orange-500"
              checked={showKpa}
              onChange={(e) => setShowKpa(e.target.checked)}
              tabIndex={-1}
            />
            kPa hint
          </label>

          <button
            onClick={() => setOpen((v) => !v)}
            className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
            tabIndex={-1}
          >
            {open ? "Collapse" : "Expand"}
          </button>
        </div>
      </div>

      {onAddAxle && <AddAxlePicker groups={groups} onAddAxle={onAddAxle} />}

      {groups.map((g) => (
        <AxleCard key={g.axle} g={g} />
      ))}
    </div>
  );
}

/** Inline axle picker (same, but glassy) */
function AddAxlePicker({
  groups,
  onAddAxle,
}: {
  groups: { axle: string }[];
  onAddAxle: (axleLabel: string) => void;
}) {
  const existing = useMemo(() => groups.map((g) => g.axle), [groups]);
  const [pending, setPending] = useState<string>("");

  const candidates = useMemo(() => {
    const wants: string[] = [];
    for (let i = 1; i <= 2; i++) wants.push(`Steer ${i}`);
    for (let i = 1; i <= 4; i++) wants.push(`Drive ${i}`);
    wants.push("Tag", "Trailer 1", "Trailer 2", "Trailer 3");
    return wants.filter((l) => !existing.includes(l));
  }, [existing]);

  return (
    <div className="flex items-center gap-2 px-1">
      <select
        className="rounded-lg border border-neutral-700 bg-neutral-900/80 px-2 py-1 text-sm text-white"
        value={pending}
        onChange={(e) => setPending(e.target.value)}
      >
        <option value="">Add axle…</option>
        {candidates.map((l) => (
          <option key={l} value={l}>
            {l}
          </option>
        ))}
      </select>
      <button
        className="rounded-lg bg-accent px-3 py-1 text-sm font-semibold text-black hover:bg-orange-500 disabled:opacity-40"
        onClick={() => pending && onAddAxle(pending)}
        disabled={!pending}
      >
        + Add
      </button>
    </div>
  );
}// shared/components/ui/AxlesCornerGrid.tsx
"use client";

import { useMemo, useRef, useState } from "react";
import { useInspectionForm } from "@inspections/lib/inspection/ui/InspectionFormContext";
import type { InspectionItem } from "@inspections/lib/inspection/types";

type Props = {
  sectionIndex: number;
  items: InspectionItem[];
  /** Optional unit resolver when an item has no unit */
  unitHint?: (label: string) => string;
  /** Only shown (and used) for AIR mode */
  onAddAxle?: (axleLabel: string) => void;
};

/* ---------------------------- shared helpers ---------------------------- */

const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const HYD_FULL_RE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

type Side = "Left" | "Right";
type Region = "Front" | "Rear";
type CornerKey = "LF" | "RF" | "LR" | "RR";

const cornerToRegion: Record<CornerKey, { side: Side; region: Region }> = {
  LF: { side: "Left", region: "Front" },
  RF: { side: "Right", region: "Front" },
  LR: { side: "Left", region: "Rear" },
  RR: { side: "Right", region: "Rear" },
};

const normalizeCorner = (raw: string): CornerKey | null => {
  const s = raw.toLowerCase();
  if (s.startsWith("lf") || s === "left front") return "LF";
  if (s.startsWith("rf") || s === "right front") return "RF";
  if (s.startsWith("lr") || s === "left rear") return "LR";
  if (s.startsWith("rr") || s === "right rear") return "RR";
  return null;
};

const isPressureMetric = (label: string) => /pressure/i.test(label);
const kpaFromPsi = (psiStr: string) => {
  const n = Number(psiStr);
  return isFinite(n) ? Math.round(n * 6.894757) : null;
};

/* --------------------- strict ordering for AIR (matches steer) --------------------- */
const airPriority = (metric: string): [number, number] => {
  const m = metric.toLowerCase();

  if (/tire\s*pressure/i.test(m)) {
    const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
    return [0, second];
  }
  if (/(tire\s*)?tread\s*depth|tire\s*tread/i.test(m)) {
    const second = /outer/i.test(m) ? 0 : /inner/i.test(m) ? 1 : 0;
    return [1, second];
  }
  if (/(lining|shoe|pad)/i.test(m)) return [2, 0];
  if (/(drum|rotor)/i.test(m)) return [3, 0];
  if (/push\s*rod/i.test(m)) return [4, 0];
  if (/wheel\s*torque/i.test(m)) return [5, /inner/i.test(m) ? 1 : 0];
  return [99, 0];
};
const airCompare = (a: string, b: string) => {
  const [pa, sa] = airPriority(a);
  const [pb, sb] = airPriority(b);
  return pa !== pb ? pa - pb : sa - sb;
};

/* ---------------------- ordering for HYD (CornerGrid parity) ---------------------- */
const hydMetricOrder = [
  "Tire Pressure",
  "Tire Tread",
  "Brake Pad",
  "Rotor",
  "Rotor Condition",
  "Rotor Thickness",
  "Wheel Torque",
];
const hydCompare = (a: string, b: string) => {
  const ai = hydMetricOrder.findIndex((x) =>
    a.toLowerCase().includes(x.toLowerCase()),
  );
  const bi = hydMetricOrder.findIndex((x) =>
    b.toLowerCase().includes(x.toLowerCase()),
  );
  const A = ai === -1 ? Number.MAX_SAFE_INTEGER : ai;
  const B = bi === -1 ? Number.MAX_SAFE_INTEGER : bi;
  return A - B;
};

export default function AxlesCornerGrid({
  sectionIndex,
  items,
  unitHint,
  onAddAxle,
}: Props) {
  const { updateItem } = useInspectionForm();

  // Detect mode from the item labels
  const mode: "air" | "hyd" = useMemo(() => {
    for (const it of items) {
      const label = it.item ?? "";
      if (AIR_RE.test(label)) return "air";
      if (HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label)) return "hyd";
    }
    return "hyd"; // safe default
  }, [items]);

  /* ------------------------------------------------------------------ */
  /* HYDRAULIC (LF/RF/LR/RR) — matches CornerGrid layout                */
  /* ------------------------------------------------------------------ */

  type HydCell = {
    idx: number;
    metric: string;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type HydRow = { metric: string; left?: HydCell; right?: HydCell };

  const hydGroups = useMemo(() => {
    if (mode !== "hyd") return [] as Array<{ region: Region; rows: HydRow[] }>;

    const byRegion = new Map<Region, Map<string, HydRow>>();
    const ensureRegion = (r: Region) =>
      byRegion.get(r) ?? byRegion.set(r, new Map()).get(r)!;

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      let ck: CornerKey | null = null;
      let metric = "";

      const m1 = label.match(HYD_ABBR_RE);
      if (m1?.groups) {
        ck = normalizeCorner(m1.groups.corner);
        metric = m1.groups.metric.trim();
      } else {
        const m2 = label.match(HYD_FULL_RE);
        if (m2?.groups) {
          ck = normalizeCorner(m2.groups.corner);
          metric = m2.groups.metric.trim();
        }
      }
      if (!ck) return;

      const { side, region } = cornerToRegion[ck];
      const reg = ensureRegion(region);

      const key = metric.toLowerCase();
      if (!reg.has(key)) reg.set(key, { metric });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: HydCell = {
        idx,
        metric,
        unit,
        fullLabel: label,
        isPressure: isPressureMetric(metric),
        initial: String(it.value ?? ""),
      };

      const row = reg.get(key)!;
      if (side === "Left") row.left = cell;
      else row.right = cell;
    });

    const out: Array<{ region: Region; rows: HydRow[] }> = [];
    (["Front", "Rear"] as Region[]).forEach((region) => {
      const reg = byRegion.get(region);
      if (!reg) return;
      const rows = Array.from(reg.values()).sort((a, b) =>
        hydCompare(a.metric, b.metric),
      );
      out.push({ region, rows });
    });
    return out;
  }, [items, unitHint, mode]);

  /* ------------------------------------------------------------------ */
  /* AIR (Steer / Drive / Trailer … Left | Item | Right)                */
  /* ------------------------------------------------------------------ */

  type AirCell = {
    metric: string;
    idx: number;
    unit: string;
    fullLabel: string;
    isPressure: boolean;
    initial: string;
  };
  type AirGroup = { axle: string; left: AirCell[]; right: AirCell[] };
  type AirRow = { metric: string; left?: AirCell; right?: AirCell };

  const isDualAxle = (axle: string) => {
    const a = axle.toLowerCase();
    if (a.startsWith("drive") || a.startsWith("trailer") || a.includes("rear"))
      return true;
    if (a.startsWith("tag") || a.startsWith("steer")) return false;
    return false;
  };

  const isDualizable = (metric: string) =>
    /tire\s*pressure/i.test(metric) ||
    /(tire\s*)?tread\s*depth|tire\s*tread/i.test(metric);
  const hasInnerOuter = (m: string) => /(inner|outer)/i.test(m);

  function expandDuals(axle: string, cells: AirCell[]): AirCell[] {
    if (!isDualAxle(axle)) return cells;
    const out: AirCell[] = [];
    for (const c of cells) {
      if (isDualizable(c.metric) && !hasInnerOuter(c.metric)) {
        const base = c.metric.replace(/\s*\((inner|outer)\)\s*/i, "").trim();
        out.push({ ...c, metric: `${base} (Outer)` });
        out.push({ ...c, metric: `${base} (Inner)` });
      } else {
        out.push(c);
      }
    }
    return out;
  }

  const airGroups = useMemo(() => {
    if (mode !== "air") return [] as AirGroup[];

    const byAxle = new Map<string, { Left: AirCell[]; Right: AirCell[] }>();

    items.forEach((it, idx) => {
      const label = it.item ?? "";
      const m = label.match(AIR_RE);
      if (!m?.groups) return;

      const axle = m.groups.axle.trim();
      const side = (m.groups.side as Side) || "Left";
      const metric = m.groups.metric.trim();

      if (!byAxle.has(axle)) byAxle.set(axle, { Left: [], Right: [] });

      const unit =
        (it.unit ?? "") || (unitHint ? unitHint(label) : "") || "";
      const cell: AirCell = {
        metric,
        idx,
        unit,
        fullLabel: label,
        isPressure: isPressureMetric(metric),
        initial: String(it.value ?? ""),
      };

      byAxle.get(axle)![side].push(cell);
    });

    return Array.from(byAxle.entries()).map(([axle, sides]) => {
      const left = expandDuals(axle, sides.Left).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      const right = expandDuals(axle, sides.Right).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      return { axle, left, right };
    });
  }, [items, unitHint, mode]);

  // build rows for AIR like AirCornerGrid (merge left/right by metric)
  const airRowsPerAxle: Array<{ axle: string; rows: AirRow[] }> = useMemo(() => {
    if (mode !== "air") return [];
    const rows: Array<{ axle: string; rows: AirRow[] }> = [];

    for (const g of airGroups) {
      const map = new Map<string, AirRow>();
      const add = (c: AirCell, which: "left" | "right") => {
        const k = c.metric.toLowerCase();
        const existing = map.get(k) || { metric: c.metric };
        map.set(k, { ...existing, metric: c.metric, [which]: c } as AirRow);
      };
      g.left.forEach((c) => add(c, "left"));
      g.right.forEach((c) => add(c, "right"));
      const merged = Array.from(map.values()).sort((a, b) =>
        airCompare(a.metric, b.metric),
      );
      rows.push({ axle: g.axle, rows: merged });
    }
    return rows;
  }, [airGroups, mode]);

  /* ---------------------------- UI state ---------------------------- */

  const [open, setOpen] = useState(true);
  const [showKpa, setShowKpa] = useState(true);
  const [filledMap, setFilledMap] = useState<Record<number, boolean>>(() => {
    const m: Record<number, boolean> = {};
    items.forEach((it, i) => (m[i] = !!String(it.value ?? "").trim()));
    return m;
  });
  const commit = (idx: number, el: HTMLInputElement | null) => {
    if (!el) return;
    const value = el.value;
    updateItem(sectionIndex, idx, { value });
    setFilledMap((p) =>
      p[idx] === !!value.trim() ? p : { ...p, [idx]: !!value.trim() },
    );
  };

  /* ------------------- shared input used by both modes ------------------ */

  const InputWithInlineUnit = ({
    idx,
    isPressureRow,
    unit,
    defaultValue,
  }: {
    idx: number;
    isPressureRow: boolean;
    unit: string;
    defaultValue: string;
  }) => {
    const spanRef = useRef<HTMLSpanElement | null>(null);

    const seedText = () => {
      if (!isPressureRow) return unit;
      const k = kpaFromPsi(defaultValue);
      if (!showKpa) return "psi";
      return k != null ? `psi (${k} kPa)` : "psi (— kPa)";
    };

    const onInput = (e: React.FormEvent<HTMLInputElement>) => {
      if (!isPressureRow || !spanRef.current) return;
      const k = kpaFromPsi(e.currentTarget.value);
      if (!showKpa) {
        spanRef.current.textContent = "psi";
      } else if (k != null) {
        spanRef.current.textContent = `psi (${k} kPa)`;
      } else {
        spanRef.current.textContent = "psi (— kPa)";
      }
    };

    return (
      <div className="relative w-full max-w-[11rem]">
        <input
          defaultValue={defaultValue}
          tabIndex={0}
          className="w-full rounded-lg border border-neutral-700 bg-neutral-900/80 px-3 py-1.5 pr-20 text-sm text-white placeholder:text-neutral-500 focus:ring-2 focus:ring-orange-500 focus:border-orange-500"
          placeholder="Value"
          autoComplete="off"
          inputMode="decimal"
          onInput={onInput}
          onBlur={(e) => commit(idx, e.currentTarget)}
          onKeyDown={(e) =>
            e.key === "Enter" &&
            (e.currentTarget as HTMLInputElement).blur()
          }
        />
        <span
          ref={spanRef}
          className="pointer-events-none absolute right-2 top-1/2 -translate-y-1/2 whitespace-nowrap text-[11px] text-neutral-400"
        >
          {seedText()}
        </span>
      </div>
    );
  };

  /* ---------------------------- HYD UI ---------------------------- */

  const HydRegionCard = ({ region, rows }: { region: Region; rows: HydRow[] }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {region}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${region}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputWithInlineUnit
                    idx={row.left.idx}
                    isPressureRow={row.left.isPressure}
                    unit={row.left.unit}
                    defaultValue={row.left.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputWithInlineUnit
                    idx={row.right.idx}
                    isPressureRow={row.right.isPressure}
                    unit={row.right.unit}
                    defaultValue={row.right.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  /* ----------------------------- AIR UI ----------------------------- */

  const AirAxleCard = ({ axle, rows }: { axle: string; rows: AirRow[] }) => (
    <div className="rounded-2xl border border-white/8 bg-black/40 p-4 shadow-card backdrop-blur-md">
      <div
        className="mb-3 text-lg font-semibold text-accent"
        style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
      >
        {axle}
      </div>

      <div className="mb-2 grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-xs text-neutral-400">
        <div>Left</div>
        <div className="text-center">Item</div>
        <div className="text-right">Right</div>
      </div>

      {open && (
        <div className="space-y-3">
          {rows.map((row, i) => (
            <div
              key={`${axle}-${row.metric}-${i}`}
              className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 rounded-xl bg-neutral-950/70 p-3"
            >
              <div>
                {row.left ? (
                  <InputWithInlineUnit
                    idx={row.left.idx}
                    isPressureRow={row.left.isPressure}
                    unit={row.left.unit}
                    defaultValue={row.left.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>

              <div
                className="min-w-0 truncate text-center text-sm font-semibold text-white"
                style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
                title={row.metric}
              >
                {row.metric}
              </div>

              <div className="justify-self-end">
                {row.right ? (
                  <InputWithInlineUnit
                    idx={row.right.idx}
                    isPressureRow={row.right.isPressure}
                    unit={row.right.unit}
                    defaultValue={row.right.initial}
                  />
                ) : (
                  <div className="h-[34px]" />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  const countFilled = (cells: Array<{ idx: number }>) =>
    cells.reduce((sum, c) => sum + (filledMap[c.idx] ? 1 : 0), 0);

  /* ------------------------------- render ------------------------------ */

  return (
    <div className="grid gap-3">
      <div className="flex items-center justify-between gap-3 px-1">
        {/* progress strip for AIR mode */}
        {mode === "air" ? (
          <div
            className="hidden text-xs text-neutral-400 md:block"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {airGroups.map((g, i) => {
              const filled = countFilled(g.left) + countFilled(g.right);
              const total = g.left.length + g.right.length;
              return (
                <span key={g.axle}>
                  {g.axle} {filled}/{total}
                  {i < airGroups.length - 1 ? "  |  " : ""}
                </span>
              );
            })}
          </div>
        ) : (
          <div />
        )}

        <div className="flex items-center gap-3">
          <label className="flex select-none items-center gap-2 text-xs text-neutral-300">
            <input
              type="checkbox"
              className="h-3 w-3 accent-orange-500"
              checked={showKpa}
              onChange={(e) => setShowKpa(e.target.checked)}
              tabIndex={-1}
            />
            kPa hint
          </label>

          <button
            onClick={() => setOpen((v) => !v)}
            className="rounded-md border border-white/10 bg-white/5 px-2 py-1 text-xs text-white hover:border-accent hover:bg-white/10"
            title={open ? "Collapse" : "Expand"}
            tabIndex={-1}
          >
            {open ? "Collapse" : "Expand"}
          </button>
        </div>
      </div>

      {/* inline axle picker only for AIR and when provided */}
      {mode === "air" && onAddAxle && (
        <AddAxlePicker
          existingAxles={airGroups.map((g) => g.axle)}
          onAddAxle={onAddAxle}
        />
      )}

      {mode === "hyd" ? (
        <div className="grid gap-4">
          {hydGroups.map((g) => (
            <HydRegionCard key={g.region} region={g.region} rows={g.rows} />
          ))}
        </div>
      ) : (
        <>
          {airRowsPerAxle.map(({ axle, rows }) => (
            <AirAxleCard key={axle} axle={axle} rows={rows} />
          ))}
        </>
      )}
    </div>
  );
}

/* -------------------------- Add Axle (AIR only) -------------------------- */

function AddAxlePicker({
  existingAxles,
  onAddAxle,
}: {
  existingAxles: string[];
  onAddAxle: (axleLabel: string) => void;
}) {
  const [pending, setPending] = useState<string>("");

  const candidates = useMemo(() => {
    const wants: string[] = [];
    for (let i = 1; i <= 2; i++) wants.push(`Steer ${i}`);
    for (let i = 1; i <= 4; i++) wants.push(`Drive ${i}`);
    wants.push("Tag", "Trailer 1", "Trailer 2", "Trailer 3");
    return wants.filter((l) => !existingAxles.includes(l));
  }, [existingAxles]);

  return (
    <div className="flex items-center gap-2 px-1">
      <select
        className="rounded-lg border border-neutral-700 bg-neutral-900/80 px-2 py-1 text-sm text-white"
        value={pending}
        onChange={(e) => setPending(e.target.value)}
      >
        <option value="">Add axle…</option>
        {candidates.map((l) => (
          <option key={l} value={l}>
            {l}
          </option>
        ))}
      </select>
      <button
        className="rounded-lg bg-accent px-3 py-1 text-sm font-semibold text-black hover:bg-orange-500 disabled:opacity-40"
        onClick={() => pending && onAddAxle(pending)}
        disabled={!pending}
      >
        + Add
      </button>
    </div>
  );
}// shared/components/Section.tsx
"use client";


import { cn } from "@shared/lib/utils";

interface SectionProps {
  children: React.ReactNode;
  className?: string;
  id?: string;
  ariaLabel?: string;
}

export default function Section({
  children,
  className,
  id,
  ariaLabel,
}: SectionProps) {
  return (
    <section
      id={id}
      aria-label={ariaLabel || id || undefined}
      className={cn(
        "w-full py-10 md:py-14 lg:py-20 px-4 sm:px-6",
        "fade-in",
        "bg-transparent",
        className,
      )}
    >
      {children}
    </section>
  );
}"use client";

import { useState, useMemo } from "react";
import {
  InspectionSection,
  InspectionItemStatus,
} from "@inspections/lib/inspection/types";
import InspectionItemCard from "./InspectionItemCard";
import { Button } from "@shared/components/ui/Button";

interface SectionDisplayProps {
  title: string;
  section: InspectionSection;
  sectionIndex: number;
  showNotes: boolean;
  showPhotos: boolean;
  onUpdateStatus: (
    sectionIndex: number,
    itemIndex: number,
    status: InspectionItemStatus,
  ) => void;
  onUpdateNote: (
    sectionIndex: number,
    itemIndex: number,
    note: string,
  ) => void;
  onUpload: (
    photoUrl: string,
    sectionIndex: number,
    itemIndex: number,
  ) => void;

  /** require a note and show a Submit button for AI */
  requireNoteForAI?: boolean;
  /** handler to run AI + persist, invoked per item */
  onSubmitAI?: (sectionIndex: number, itemIndex: number) => void;
  /** let parent indicate a submit is in-flight for this item */
  isSubmittingAI?: (sectionIndex: number, itemIndex: number) => boolean;
}

export default function SectionDisplay(props: SectionDisplayProps) {
  const {
    title,
    section,
    sectionIndex,
    showNotes = false,
    showPhotos = true,
    onUpdateStatus,
    onUpdateNote,
    onUpload,
    requireNoteForAI,
    onSubmitAI,
    isSubmittingAI,
  } = props;

  const [open, setOpen] = useState(true);

  const stats = useMemo(() => {
    const total = section.items.length || 0;
    const counts = { ok: 0, fail: 0, na: 0, recommend: 0, unset: 0 };
    for (const it of section.items) {
      const s = (it.status ?? "unset") as keyof typeof counts;
      if (counts[s] !== undefined) counts[s] += 1;
      else counts.unset += 1;
    }
    return { total, ...counts };
  }, [section.items]);

  const markAll = (status: InspectionItemStatus) => {
    section.items.forEach((_item, idx) =>
      onUpdateStatus(sectionIndex, idx, status),
    );
  };

  return (
    <div className="mb-6 rounded-2xl border border-white/8 bg-black/30 px-4 py-3 shadow-card backdrop-blur-md md:px-5 md:py-4">
      {/* Header */}
      <div className="flex flex-wrap items-center justify-between gap-3 border-b border-white/5 pb-3">
        {/* Title still toggles open/closed */}
        <button
          onClick={() => setOpen((v) => !v)}
          className="text-left text-lg font-semibold tracking-wide text-orange-400"
          style={{ fontFamily: "Black Ops One, system-ui, sans-serif" }}
          aria-expanded={open}
        >
          {title}
        </button>

        <div className="flex flex-wrap items-center gap-2">
          <span
            className="hidden text-[11px] uppercase tracking-wide text-neutral-400 md:inline"
            style={{ fontFamily: "Roboto, system-ui, sans-serif" }}
          >
            {stats.ok} OK · {stats.fail} FAIL · {stats.na} NA ·{" "}
            {stats.recommend} REC · {stats.unset} —
          </span>

          <div className="flex flex-wrap items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("ok")}
              title="Mark all OK"
              type="button"
            >
              All OK
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("fail")}
              title="Mark all FAIL"
              type="button"
            >
              All FAIL
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("na")}
              title="Mark all NA"
              type="button"
            >
              All NA
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-7 px-2 text-[11px]"
              onClick={() => markAll("recommend")}
              title="Mark all Recommend"
              type="button"
            >
              All REC
            </Button>

            {/* explicit collapse/expand control */}
            <Button
              variant="ghost"
              size="sm"
              className="ml-1 h-7 px-2 text-[11px]"
              onClick={() => setOpen((v) => !v)}
              aria-expanded={open}
              title={open ? "Collapse section" : "Expand section"}
              type="button"
            >
              {open ? "Collapse" : "Expand"}
            </Button>
          </div>
        </div>
      </div>

      {/* Body */}
      {open && (
        <div className="space-y-3 pt-3">
          {section.items.map((item, itemIndex) => {
            const key =
              (item.item ?? item.name ?? `item-${sectionIndex}-${itemIndex}`) +
              `-${itemIndex}`;

            const status = String(item.status ?? "").toLowerCase();
            const isFailOrRec = status === "fail" || status === "recommend";
            const note = (item.notes ?? "").trim();
            const canShowSubmit =
              !!requireNoteForAI &&
              isFailOrRec &&
              note.length > 0 &&
              typeof onSubmitAI === "function";

            const submitting =
              isSubmittingAI?.(sectionIndex, itemIndex) ?? false;

            return (
              <div
                key={key}
                className="rounded-xl border border-white/5 bg-black/40 p-3 md:p-3.5"
              >
                <InspectionItemCard
                  item={item}
                  sectionIndex={sectionIndex}
                  itemIndex={itemIndex}
                  showNotes={showNotes}
                  showPhotos={showPhotos}
                  onUpdateStatus={onUpdateStatus}
                  onUpdateNote={onUpdateNote}
                  onUpload={onUpload}
                />

                {canShowSubmit && (
                  <div className="mt-3 flex items-center justify-end">
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      className="px-3"
                      disabled={submitting}
                      onClick={() => onSubmitAI!(sectionIndex, itemIndex)}
                    >
                      {submitting ? "Submitting…" : "Submit for estimate"}
                    </Button>
                  </div>
                )}
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}// components/inspection/SectionWrapper.tsx
import { useState } from "react";

interface SectionWrapperProps {
  title: string;
  children: React.ReactNode;
  defaultOpen?: boolean;
}

const SectionWrapper: React.FC<SectionWrapperProps> = ({
  title,
  children,
  defaultOpen = true,
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className="mb-4 rounded-lg bg-black/40 p-4 shadow-md">
      <button
        className="w-full text-left font-black text-lg text-orange-400 mb-2 flex justify-between items-center"
        onClick={() => setIsOpen(!isOpen)}
      >
        <span>{title}</span>
        <span>{isOpen ? "−" : "+"}</span>
      </button>
      {isOpen && <div className="space-y-2">{children}</div>}
    </div>
  );
};

export default SectionWrapper;
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import { v4 as uuidv4 } from "uuid";
import toast from "react-hot-toast";

import PauseResumeButton from "@inspections/lib/inspection/PauseResume";
import StartListeningButton from "@inspections/lib/inspection/StartListeningButton";
import ProgressTracker from "@inspections/lib/inspection/ProgressTracker";
import useInspectionSession from "@inspections/hooks/useInspectionSession";

import { handleTranscriptFn } from "@inspections/lib/inspection/handleTranscript";
import { interpretCommand } from "@inspections/components/inspection/interpretCommand";
import { requestQuoteSuggestion } from "@inspections/lib/inspection/aiQuote";
import { addWorkOrderLineFromSuggestion } from "@inspections/lib/inspection/addWorkOrderLine";

import type {
  ParsedCommand,
  InspectionItemStatus,
  InspectionStatus,
  InspectionSection,
  InspectionSession,
  SessionCustomer,
  SessionVehicle,
  QuoteLineItem,
} from "@inspections/lib/inspection/types";

import SectionDisplay from "@inspections/lib/inspection/SectionDisplay";
import AxlesCornerGrid from "@inspections/lib/inspection/ui/AxlesCornerGrid";

import { InspectionFormCtx } from "@inspections/lib/inspection/ui/InspectionFormContext";
import { SaveInspectionButton } from "@inspections/components/inspection/SaveInspectionButton";
import FinishInspectionButton from "@inspections/components/inspection/FinishInspectionButton";
import CustomerVehicleHeader from "@inspections/lib/inspection/ui/CustomerVehicleHeader";
import PageShell from "@/features/shared/components/PageShell";
import { Button } from "@shared/components/ui/Button";

/* -------------------------- helpers -------------------------- */

function toHeaderCustomer(c?: SessionCustomer | null) {
  return {
    first_name: c?.first_name ?? "",
    last_name: c?.last_name ?? "",
    phone: c?.phone ?? "",
    email: c?.email ?? "",
    address: c?.address ?? "",
    city: c?.city ?? "",
    province: c?.province ?? "",
    postal_code: c?.postal_code ?? "",
  };
}
function toHeaderVehicle(v?: SessionVehicle | null) {
  return {
    year: v?.year ?? "",
    make: v?.make ?? "",
    model: v?.model ?? "",
    vin: v?.vin ?? "",
    license_plate: v?.license_plate ?? "",
    mileage: v?.mileage ?? "",
    color: v?.color ?? "",
    unit_number: v?.unit_number ?? "",
    engine_hours: v?.engine_hours ?? "",
  };
}

/** Try to give a sensible unit hint for common labels */
function unitHintGeneric(label: string, mode: "metric" | "imperial"): string {
  const l = (label || "").toLowerCase();
  if (l.includes("pressure")) return mode === "imperial" ? "psi" : "kPa";
  if (l.includes("tread")) return mode === "metric" ? "mm" : "in";
  if (l.includes("pad") || l.includes("lining") || l.includes("shoe"))
    return mode === "metric" ? "mm" : "in";
  if (l.includes("rotor") || l.includes("drum")) return mode === "metric" ? "mm" : "in";
  if (l.includes("push rod")) return mode === "metric" ? "mm" : "in";
  if (l.includes("torque")) return mode === "metric" ? "N·m" : "ft·lb";
  if (l.includes("leak rate")) return mode === "metric" ? "kPa/min" : "psi/min";
  if (l.includes("gov cut") || l.includes("warning")) return mode === "metric" ? "kPa" : "psi";
  return "";
}

/** Safe reader for sessionStorage JSON */
function readStaged<T>(key: string): T | null {
  try {
    if (typeof window === "undefined") return null;
    const raw = sessionStorage.getItem(key);
    return raw ? (JSON.parse(raw) as T) : null;
  } catch {
    return null;
  }
}

/** Normalize + merge sections (copy name→item; merge same titles; dedupe items) */
function normalizeSections(input: unknown): InspectionSection[] {
  try {
    const arr = Array.isArray(input) ? input : [];
    const byTitle = new Map<string, InspectionSection>();

    for (const s of arr as any[]) {
      const title = String(s?.title ?? "").trim();
      if (!title) continue;

      const itemsRaw = Array.isArray(s?.items) ? s.items : [];
      const items = itemsRaw
        .map((it: any) => {
          const label = String(it?.item ?? it?.name ?? "").trim();
          if (!label) return null;
          return {
            ...it,
            item: label,
            unit: it?.unit ?? null,
          };
        })
        .filter(Boolean);

      if (!byTitle.has(title)) byTitle.set(title, { title, items: [] });
      const bucket = byTitle.get(title)!;
      const seen = new Set((bucket.items ?? []).map((x) => (x.item ?? "").toLowerCase()));
      for (const it of items as any[]) {
        const key = (it.item ?? "").toLowerCase();
        if (!seen.has(key)) {
          bucket.items = [...(bucket.items ?? []), it];
          seen.add(key);
        }
      }
    }

    return Array.from(byTitle.values()).filter((s) => (s.items?.length ?? 0) > 0);
  } catch {
    return [];
  }
}

/* -------- smarter corner-grid detector -------- */

const AIR_RE = /^(?<axle>.+?)\s+(?<side>Left|Right)\s+(?<metric>.+)$/i;
const HYD_ABBR_RE = /^(?<corner>LF|RF|LR|RR)\s+(?<metric>.+)$/i;
const HYD_FULL_RE = /^(?<corner>(Left|Right)\s+(Front|Rear))\s+(?<metric>.+)$/i;

function shouldRenderCornerGrid(
  title: string | undefined,
  items: { item?: string | null }[] = []
): boolean {
  const t = (title || "").toLowerCase();

  if (
    t.includes("corner grid") ||
    t.includes("tires & brakes — truck") ||
    t.includes("tires & brakes — air") ||
    t.includes("axle grid")
  ) {
    return true;
  }

  if (!items || items.length < 4) return false;

  const hasStrongPattern = items.some((it) => {
    const label = it.item ?? "";
    return AIR_RE.test(label) || HYD_ABBR_RE.test(label) || HYD_FULL_RE.test(label);
  });

  const measurementKeywords = [
    "tread",
    "pressure",
    "lining",
    "shoe",
    "drum",
    "rotor",
    "push rod",
    "pad",
    "torque",
  ];
  const measurementLikeCount = items.reduce((count, it) => {
    const label = (it.item || "").toLowerCase();
    const isMeasurement = measurementKeywords.some((kw) => label.includes(kw));
    return count + (isMeasurement ? 1 : 0);
  }, 0);

  const enoughMeasurements = measurementLikeCount >= Math.floor(items.length / 2);

  const titleSuggestsMeasurement =
    t.includes("tire") ||
    t.includes("tires") ||
    t.includes("brake") ||
    t.includes("measurement") ||
    t.includes("axle");

  return hasStrongPattern || (titleSuggestsMeasurement && enoughMeasurements);
}

/* -------------------------------------------------------------------- */
/* Component                                                            */
/* -------------------------------------------------------------------- */

export default function GenericInspectionScreen(): JSX.Element {
  const sp = useSearchParams();
  const rootRef = useRef<HTMLDivElement | null>(null);

  // 🔸 only the mobile companion should use voice
  const isMobileView =
    (sp.get("view") || "").toLowerCase() === "mobile";

  // Embed for iframe/modal
  const isEmbed = useMemo(
    () =>
      ["1", "true", "yes"].includes(
        (sp.get("embed") || sp.get("compact") || "").toLowerCase()
      ),
    [sp]
  );

  const workOrderId = sp.get("workOrderId") || null;
  const workOrderLineId = sp.get("workOrderLineId") || "";
  const templateName =
    (typeof window !== "undefined" ? sessionStorage.getItem("inspection:title") : null) ||
    (sp.get("template") || "Inspection");

  const customer: SessionCustomer = {
    first_name: sp.get("first_name") || "",
    last_name: sp.get("last_name") || "",
    phone: sp.get("phone") || "",
    email: sp.get("email") || "",
    address: sp.get("address") || "",
    city: sp.get("city") || "",
    province: sp.get("province") || "",
    postal_code: sp.get("postal_code") || "",
  };
  const vehicle: SessionVehicle = {
    year: sp.get("year") || "",
    make: sp.get("make") || "",
    model: sp.get("model") || "",
    vin: sp.get("vin") || "",
    license_plate: sp.get("license_plate") || "",
    mileage: sp.get("mileage") || "",
    color: sp.get("color") || "",
    unit_number: sp.get("unit_number") || "",
    engine_hours: sp.get("engine_hours") || "",
  };

  const bootSections = useMemo<InspectionSection[]>(() => {
    const staged = readStaged<InspectionSection[]>("inspection:sections");
    if (Array.isArray(staged) && staged.length) return normalizeSections(staged);

    try {
      const legacy =
        typeof window !== "undefined"
          ? sessionStorage.getItem("customInspection:sections")
          : null;
      if (legacy) {
        const parsed = JSON.parse(legacy) as InspectionSection[];
        const norm = normalizeSections(parsed);
        return norm;
      }
    } catch {}

    return [
      {
        title: "General",
        items: [{ item: "Visual walkaround" }, { item: "Record warning lights" }],
      },
    ];
  }, [sp]);

  const inspectionId = useMemo(
    () => sp.get("inspectionId") || uuidv4(),
    [sp]
  );

  // 🔸 try to hydrate from localStorage
  const persistedSession = useMemo(() => {
    if (typeof window === "undefined") return null;
    const raw = localStorage.getItem(`inspection-${inspectionId}`);
    if (!raw) return null;
    try {
      return JSON.parse(raw) as InspectionSession;
    } catch {
      return null;
    }
  }, [inspectionId]);

  const [unit, setUnit] = useState<"metric" | "imperial">("metric");
  const [isListening, setIsListening] = useState(false);
  const [isPaused, setIsPaused] = useState(false);

  // 🔴 wake-word state
  const [wakeActive, setWakeActive] = useState(false);
  const wakeTimeoutRef = useRef<number | null>(null);

  // openai realtime refs
  const wsRef = useRef<WebSocket | null>(null);
  const mediaRef = useRef<MediaStream | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);

  const initialSession = useMemo<Partial<InspectionSession>>(
    () => ({
      id: inspectionId,
      templateitem: templateName,
      status: "not_started" as InspectionStatus,
      isPaused: false,
      isListening: false,
      transcript: "",
      quote: [],
      customer,
      vehicle,
      sections: [],
    }),
    [inspectionId, templateName, customer, vehicle]
  );

  const {
    session,
    updateInspection,
    updateItem,
    updateSection,
    startSession,
    finishSession,
    resumeSession,
    pauseSession,
    addQuoteLine,
    updateQuoteLine,
  } = useInspectionSession(persistedSession ?? initialSession);

  // start
  useEffect(() => {
    if (persistedSession) {
      startSession(persistedSession);
    } else {
      startSession(initialSession);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [persistedSession]);
  useEffect(() => {
    if (session && (session.sections?.length ?? 0) === 0) {
      updateInspection({ sections: bootSections });
    }
  }, [session, bootSections, updateInspection]);

  // persist
  useEffect(() => {
    if (!session) return;
    const key = `inspection-${inspectionId}`;
    localStorage.setItem(key, JSON.stringify(session));
  }, [session, inspectionId]);

  // persist on unload
  useEffect(() => {
    const key = `inspection-${inspectionId}`;
    const persistNow = () => {
      try {
        const payload = session ?? initialSession;
        localStorage.setItem(key, JSON.stringify(payload));
      } catch {}
    };
    const onVisibility = () => {
      if (document.visibilityState === "hidden") persistNow();
    };
    window.addEventListener("beforeunload", persistNow);
    window.addEventListener("pagehide", persistNow);
    document.addEventListener("visibilitychange", onVisibility);
    return () => {
      window.removeEventListener("beforeunload", persistNow);
      window.removeEventListener("pagehide", persistNow);
      document.removeEventListener("visibilitychange", onVisibility);
    };
  }, [session, inspectionId, initialSession]);

  // 🔸 turn final text into inspection commands
  const handleTranscript = async (text: string): Promise<void> => {
    const commands: ParsedCommand[] = await interpretCommand(text);
    const sess = session;
    if (!sess) return;
    for (const command of commands) {
      await handleTranscriptFn({
        command,
        session: sess,
        updateInspection,
        updateItem,
        updateSection,
        finishSession,
      });
    }
  };

  // 🔔 wake-word helper
  function maybeHandleWakeWord(raw: string): string | null {
    const lower = raw.toLowerCase().trim();
    const WAKE_WORDS = ["hey techy", "hey techie", "hey teki", "hey tekky"];

    if (!wakeActive) {
      const hit = WAKE_WORDS.find((w) => lower.startsWith(w));
      if (hit) {
        setWakeActive(true);
        if (wakeTimeoutRef.current) window.clearTimeout(wakeTimeoutRef.current);
        wakeTimeoutRef.current = window.setTimeout(() => {
          setWakeActive(false);
        }, 8000);
        return lower.slice(hit.length).trim();
      }
      return null;
    }

    if (wakeTimeoutRef.current) window.clearTimeout(wakeTimeoutRef.current);
    wakeTimeoutRef.current = window.setTimeout(() => {
      setWakeActive(false);
    }, 8000);

    return raw;
  }

  // 🔊 openai realtime start (used only when mobile buttons are visible)
  const startListening = async (): Promise<void> => {
    if (isListening) return;
    try {
      const res = await fetch("/api/openai/realtime-token");
      const { apiKey } = (await res.json()) as { apiKey: string };
      if (!apiKey) throw new Error("Missing OpenAI key");

      const ws = new WebSocket("wss://api.openai.com/v1/realtime?intent=transcription");
      wsRef.current = ws;

      ws.onopen = async () => {
        ws.send(
          JSON.stringify({
            type: "authorization",
            authorization: `Bearer ${apiKey}`,
          })
        );

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRef.current = stream;

        const mr = new MediaRecorder(stream, { mimeType: "audio/webm" });
        mediaRecorderRef.current = mr;
        mr.ondataavailable = (evt) => {
          if (evt.data.size > 0 && ws.readyState === WebSocket.OPEN) {
            ws.send(evt.data);
          }
        };
        mr.start(250);

        setIsListening(true);
      };

      ws.onmessage = async (evt) => {
        if (typeof evt.data !== "string") return;
        try {
          const msg = JSON.parse(evt.data);
          const text: string =
            msg.text || msg.transcript || msg.output || msg.content || "";
          if (!text) return;

          const maybeText = maybeHandleWakeWord(text);
          if (!maybeText) return;

          const lower = maybeText.toLowerCase();
          if (lower === "stop listening" || lower === "go to sleep") {
            setWakeActive(false);
            return;
          }

          await handleTranscript(maybeText);
        } catch {
          // ignore parse errors
        }
      };

      ws.onerror = (err) => {
        console.error("realtime ws error", err);
        toast.error("Voice connection error");
        stopListening();
      };

      ws.onclose = () => {
        stopListening();
      };
    } catch (e: any) {
      console.error(e);
      toast.error(e?.message || "Unable to start voice");
      stopListening();
    }
  };

  const stopListening = (): void => {
    mediaRecorderRef.current?.stop();
    mediaRecorderRef.current = null;

    mediaRef.current?.getTracks().forEach((t) => t.stop());
    mediaRef.current = null;

    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.close();
    }
    wsRef.current = null;
    setIsListening(false);
    setWakeActive(false);
    if (wakeTimeoutRef.current) {
      window.clearTimeout(wakeTimeoutRef.current);
      wakeTimeoutRef.current = null;
    }
  };

  useEffect(() => {
    return () => {
      stopListening();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // AI submit flow
  const inFlightRef = useRef<Set<string>>(new Set());
  const isSubmittingAI = (secIdx: number, itemIdx: number): boolean =>
    inFlightRef.current.has(`${secIdx}:${itemIdx}`);

  const submitAIForItem = async (secIdx: number, itemIdx: number): Promise<void> => {
    if (!session) return;
    const key = `${secIdx}:${itemIdx}`;
    if (inFlightRef.current.has(key)) return;

    const it = session.sections[secIdx].items[itemIdx];
    const status = String(it.status ?? "").toLowerCase();
    const note = (it.notes ?? "").trim();

    if (!(status === "fail" || status === "recommend")) return;
    if (note.length === 0) {
      toast.error("Add a note before submitting.");
      return;
    }

    inFlightRef.current.add(key);
    try {
      const desc = it.item ?? (it as any).name ?? "Item";

      const id = uuidv4();
      const placeholder: QuoteLineItem = {
        id,
        description: desc,
        item: desc,
        name: desc,
        status: status as "fail" | "recommend",
        notes: it.notes ?? "",
        price: 0,
        laborTime: 0.5,
        laborRate: 0,
        editable: true,
        source: "inspection",
        value: it.value ?? "",
        photoUrls: it.photoUrls ?? [],
        aiState: "loading",
      };
      addQuoteLine(placeholder);

      const tId = toast.loading("Getting AI estimate…");
      const suggestion = await requestQuoteSuggestion({
        item: desc,
        notes: it.notes ?? "",
        section: session.sections[secIdx].title,
        status,
        vehicle: session.vehicle ?? undefined,
      });

      if (!suggestion) {
        updateQuoteLine(id, { aiState: "error" });
        toast.error("No AI suggestion available", { id: tId });
        return;
      }

      const partsTotal =
        suggestion.parts?.reduce((sum, p) => sum + (p.cost || 0), 0) ?? 0;
      const laborRate = suggestion.laborRate ?? 0;
      const laborTime = suggestion.laborHours ?? 0.5;
      const price = Math.max(0, partsTotal + laborRate * laborTime);

      updateQuoteLine(id, {
        price,
        laborTime,
        laborRate,
        ai: {
          summary: suggestion.summary,
          confidence: suggestion.confidence,
          parts: suggestion.parts ?? [],
        },
        aiState: "done",
      });

      if (workOrderId) {
        await addWorkOrderLineFromSuggestion({
          workOrderId,
          description: desc,
          section: session.sections[secIdx].title,
          status: status as "fail" | "recommend",
          suggestion,
          source: "inspection",
          jobType: "inspection",
        });
        toast.success("Added to work order (awaiting approval)", { id: tId });
      } else {
        toast.error("Missing work order id — saved locally only", { id: tId });
      }
    } catch (e) {
      console.error("Submit AI failed:", e);
      toast.error("Couldn't add to work order");
    } finally {
      inFlightRef.current.delete(key);
    }
  };

  // 🧹 embed-safe scrubber (for iframe / modal host)
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const BAD = [
      "h-screen",
      "min-h-screen",
      "max-h-screen",
      "overflow-hidden",
      "fixed",
      "inset-0",
      "w-screen",
      "overscroll-contain",
      "touch-pan-y",
    ];

    const scrub = (el: HTMLElement) => {
      if (!el.className) return;
      const classes = el.className.split(" ");
      const filtered = classes.filter((c) => c && !BAD.includes(c));
      if (filtered.length !== classes.length) {
        el.className = filtered.join(" ");
      }
      if (el.style?.overflow === "hidden") {
        el.style.overflow = "visible";
      }
    };

    root.querySelectorAll<HTMLElement>("*").forEach(scrub);

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes" && m.target instanceof HTMLElement) {
          scrub(m.target);
        }
        if (m.type === "childList") {
          m.addedNodes.forEach((n) => {
            if (n instanceof HTMLElement) {
              scrub(n);
              n.querySelectorAll?.("*")?.forEach((child) => {
                if (child instanceof HTMLElement) scrub(child as HTMLElement);
              });
            }
          });
        }
      }
    });

    obs.observe(root, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    return () => obs.disconnect();
  }, [isEmbed]);

  // 🔐 Focus trap so Tab stays inside the inspection when embedded in modal
  useEffect(() => {
    if (!isEmbed) return;
    const root = rootRef.current;
    if (!root) return;

    const selector =
      'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;

      const focusables = Array.from(
        root.querySelectorAll<HTMLElement>(selector)
      ).filter(
        (el) =>
          !el.hasAttribute("disabled") &&
          el.tabIndex !== -1 &&
          el.getAttribute("aria-hidden") !== "true"
      );

      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement as HTMLElement | null;

      // If focus is already outside the root, jump to first
      if (!active || !root.contains(active)) {
        e.preventDefault();
        first.focus();
        return;
      }

      if (e.shiftKey) {
        // Shift+Tab: if we're on first, loop to last
        if (active === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        // Tab forward: if we're on last, loop to first
        if (active === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };

    root.addEventListener("keydown", handleKeyDown);
    return () => root.removeEventListener("keydown", handleKeyDown);
  }, [isEmbed]);

  if (!session || !session.sections || session.sections.length === 0) {
    return (
      <div className="p-4 text-sm text-neutral-300">
        Loading inspection…
      </div>
    );
  }

  const shell = isEmbed
    ? "mx-auto max-w-[1100px] px-3 pb-8"
    : "max-w-5xl mx-auto px-3 md:px-6 pb-16";

  const cardBase =
    "rounded-2xl border border-white/10 bg-black/30 backdrop-blur-md shadow-card";
  const headerCard = `${cardBase} px-4 py-4 md:px-6 md:py-5 mb-6`;
  const sectionCard = `${cardBase} px-4 py-4 md:px-5 md:py-5 mb-6`;

  const sectionTitle =
    "text-lg md:text-xl font-semibold text-accent text-center tracking-wide";
  const hint =
    "mt-1 block text-center text-[11px] uppercase tracking-[0.12em] text-neutral-500";

  const body = (
    <div
      ref={rootRef}
      className={shell + (isEmbed ? " inspection-embed" : "")}
    >
      {isEmbed && (
        <style jsx global>{`
          .inspection-embed,
          .inspection-embed * {
            overscroll-behavior: auto !important;
          }
        `}</style>
      )}

      {/* Header card */}
      <div className={headerCard}>
        <div className="mb-2 text-center">
          <div className="text-xs font-blackops uppercase tracking-[0.18em] text-neutral-400">
            Inspection
          </div>
          <div className="mt-1 text-xl font-blackops text-white">
            {session?.templateitem || templateName || "Inspection"}
          </div>
        </div>

        <CustomerVehicleHeader
          templateName=""
          customer={toHeaderCustomer(session.customer ?? null)}
          vehicle={toHeaderVehicle(session.vehicle ?? null)}
        />
      </div>

      {/* Controls row */}
      <div className="mb-4 grid grid-cols-1 gap-2 sm:grid-cols-3">
        {/* Voice only in mobile companion */}
        {isMobileView && (
          <StartListeningButton
            isListening={isListening}
            setIsListening={setIsListening}
            onStart={startListening}
          />
        )}

        {isMobileView && (
          <PauseResumeButton
            isPaused={isPaused}
            isListening={isListening}
            setIsListening={setIsListening}
            onPause={(): void => {
              setIsPaused(true);
              pauseSession();
              stopListening();
            }}
            onResume={(): void => {
              setIsPaused(false);
              resumeSession();
              void startListening();
            }}
            recognitionInstance={null}
            onTranscript={handleTranscript}
            setRecognitionRef={(): void => {
              /* noop – using OpenAI now */
            }}
          />
        )}

        {/* Unit toggle stays on both desktop + mobile */}
        <Button
          type="button"
          variant="outline"
          className="w-full justify-center"
          onClick={(): void =>
            setUnit(unit === "metric" ? "imperial" : "metric")
          }
        >
          Unit: {unit === "metric" ? "Metric (mm / kPa)" : "Imperial (in / psi)"}
        </Button>
      </div>

      {/* Progress */}
      <div className="mb-6 rounded-2xl border border-white/5 bg-black/20 px-4 py-3 backdrop-blur">
        <ProgressTracker
          currentItem={session.currentItemIndex}
          currentSection={session.currentSectionIndex}
          totalSections={session.sections.length}
          totalItems={
            session.sections[session.currentSectionIndex]?.items.length || 0
          }
        />
      </div>

      <InspectionFormCtx.Provider value={{ updateItem }}>
        {session.sections.map((section: InspectionSection, sectionIndex: number) => {
          const itemsWithHints = section.items.map((it) => ({
            ...it,
            unit: it.unit || unitHintGeneric(it.item ?? "", unit),
          }));

          const useGrid = shouldRenderCornerGrid(section.title, itemsWithHints);

          return (
            <div key={`${section.title}-${sectionIndex}`} className={sectionCard}>
              <h2 className={sectionTitle}>{section.title}</h2>
              {useGrid && (
                <span className={hint}>
                  {unit === "metric"
                    ? "Enter mm / kPa / N·m"
                    : "Enter in / psi / ft·lb"}
                </span>
              )}

              <div className="mt-4">
                {useGrid ? (
                  <AxlesCornerGrid
                    sectionIndex={sectionIndex}
                    items={itemsWithHints}
                  />
                ) : (
                  <SectionDisplay
                    title=""
                    section={{ ...section, items: itemsWithHints }}
                    sectionIndex={sectionIndex}
                    showNotes
                    showPhotos
                    onUpdateStatus={(
                      secIdx: number,
                      itemIdx: number,
                      status: InspectionItemStatus
                    ) => {
                      updateItem(secIdx, itemIdx, { status });
                    }}
                    onUpdateNote={(secIdx, itemIdx, note) => {
                      updateItem(secIdx, itemIdx, { notes: note });
                    }}
                    onUpload={(photoUrl, secIdx, itemIdx) => {
                      const prev =
                        session.sections[secIdx].items[itemIdx].photoUrls ?? [];
                      updateItem(secIdx, itemIdx, {
                        photoUrls: [...prev, photoUrl],
                      });
                    }}
                    requireNoteForAI
                    onSubmitAI={(secIdx, itemIdx) => {
                      void submitAIForItem(secIdx, itemIdx);
                    }}
                    isSubmittingAI={isSubmittingAI}
                  />
                )}
              </div>
            </div>
          );
        })}
      </InspectionFormCtx.Provider>

      {/* Footer actions */}
      <div className="mt-8 flex flex-col gap-4 border-t border-white/5 pt-4 md:flex-row md:items-center md:justify-between">
        <div className="flex flex-wrap items-center gap-3">
          <SaveInspectionButton session={session} workOrderLineId={workOrderLineId} />
          <FinishInspectionButton session={session} workOrderLineId={workOrderLineId} />
          {!workOrderLineId && (
            <div className="text-xs text-red-400">
              Missing <code>workOrderLineId</code> — save/finish will be blocked.
            </div>
          )}
        </div>

        <div className="text-xs text-neutral-400 md:text-right">
          <span className="font-semibold text-neutral-200">Legend:</span>{" "}
          P = Pass &nbsp;•&nbsp; F = Fail &nbsp;•&nbsp; NA = Not applicable
        </div>
      </div>
    </div>
  );

  if (isEmbed) return body;

  return (
    <PageShell
      title={session?.templateitem || templateName || "Inspection"}
      description="Run guided inspections, capture notes, and push items into work orders."
    >
      {body}
    </PageShell>
  );
}/** ---------- Item / Section ---------- */
export type InspectionItemStatus = "ok" | "fail" | "na" | "recommend";
export type BrakeType = "air" | "hydraulic";

export interface InspectionItem {
  /** Primary label. Some code uses `item`, some uses `name` — support both. */
  item?: string;
  name?: string;

  status?: InspectionItemStatus;
  notes?: string;
  /** Some AI/normalizers use singular `note`. */
  note?: string;

  value?: string | number | null;
  unit?: string | null;

  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionCategory {
  title: string;
  items: InspectionItem[];
}

/** Many places import `InspectionSection`; keep it as an alias. */
export type InspectionSection = InspectionCategory;

/** ---------- Parsed voice/AI commands (support both shapes) ---------- */
/** Older, name-based command shape used by dispatchCommand/interpreter */
export type ParsedCommandNameBased =
  | { type: "status"; section: string; item: string; status: InspectionItemStatus }
  | { type: "add"; section: string; item: string; note: string }
  | { type: "recommend"; section: string; item: string; note: string }
  | {
      type: "measurement";
      section: string;
      item: string;
      value: number | string;
      unit?: string;
    };

/** Newer, index-based command shape used by convertParsedCommands.ts */
export type ParsedCommandIndexed = {
  command:
    | "update_status"
    | "update_value"
    | "add_note"
    | "recommend"
    | "complete_item"
    | "skip_item"
    | "pause_inspection"
    | "finish_inspection";
  sectionIndex?: number;
  itemIndex?: number;
  status?: InspectionItemStatus;
  value?: string | number;
  unit?: string;
  notes?: string;
  recommend?: string;
};

/** Unified ParsedCommand covering both shapes */
export type ParsedCommand = ParsedCommandNameBased | ParsedCommandIndexed;

/**
 * Commands consumed by dispatchCommand (older name-based shape),
 * plus a simple "pause" variant used in a few places.
 */
export type InspectionCommand =
  | ParsedCommandNameBased
  | { type: "pause"; section?: string; item?: string };

/** ---------- Runtime command objects (AI → actions) ---------- */
export type Command =
  | {
      type: "update_status";
      sectionIndex: number;
      itemIndex: number;
      status: InspectionItemStatus;
    }
  | {
      type: "update_value";
      sectionIndex: number;
      itemIndex: number;
      value: string | number;
      unit?: string;
    }
  | {
      type: "add_note";
      sectionIndex: number;
      itemIndex: number;
      notes: string;
    }
  | {
      type: "recommend";
      sectionIndex: number;
      itemIndex: number;
      recommendation: string;
    }
  | {
      type: "complete";
      sectionIndex: number;
      itemIndex: number;
    }
  | {
      type: "skip";
      sectionIndex: number;
      itemIndex: number;
    }
  | { type: "pause" }
  | { type: "finish" };

/** ---------- Quote shapes ---------- */
/** Rich source descriptor for where a line came from. */
export type QuoteSource = "inspection" | "manual" | string;

/**
 * Lightweight line produced by AI generators / costing flows.
 * Extended to include fields your costing + menu matching code writes.
 */
export interface QuoteLine {
  /** Core */
  description: string;

  /** IDs / provenance */
  id?: string;
  source?: QuoteSource;

  /** Names used across flows */
  item?: string;             // selected service/menu name
  name?: string;             // occasional alias
  inspectionItem?: string;   // originating inspection item text

  /** Status / notes */
  status?: InspectionItemStatus;
  notes?: string;

  /** Time & rates */
  hours?: number;
  rate?: number;
  total?: number;
  laborHours?: number | null;
  laborTime?: number;        // alias used on some screens
  laborRate?: number;

  /** Parts */
  parts?: Array<{ name?: string; number?: string; price?: number; type?: string }>;
  partNumber?: string | null;
  partName?: string;
  unitPrice?: number | null;

  /** Roll-up / pricing */
  qty?: number;
  price?: number;            // some code writes final line price here
  totalCost?: number;
}

/** Detailed line used by PDF/store. */
export interface QuoteLineItem {
  id: string;

  /** Some places map description into both `item` and `name`. */
  item?: string;
  name?: string;
  description: string;

  status: InspectionItemStatus;
  notes?: string;

  /** Unified commercial fields */
  price: number; // line price/total
  laborHours?: number;
  /** Additional variants used in some flows */
  laborTime?: number; // alias used on some pages
  laborRate?: number;

  /** Item-level measurement value (rare) */
  value?: string | number | null;

  /** Parts can be object or split fields */
  part?: { name: string; price: number };
  partName?: string;
  partPrice?: number | null;

  /** Old-style fields occasionally present */
  qty?: number;
  unitPrice?: number | null;

  /** Misc UI helpers */
  photoUrls?: string[];
  editable?: boolean;
  source?: QuoteSource;

  /** Collections used by some UIs */
  parts?: Array<{ name?: string; number?: string; price?: number }>;
  totalCost?: number;

  /** Optional back-reference to the inspection item */
  inspectionItem?: string;

  /** Optional AI suggestion metadata */
  ai?: {
    summary: string;
    confidence?: string;
    parts?: { name: string; qty?: number; cost?: number; notes?: string }[];
  };

  /** UI-only: track AI enrichment progress for this line */
  aiState?: "idle" | "loading" | "done" | "error";
}

/** ---------- Inspection Summary ---------- */
export interface SummaryItem {
  section: string;
  item: string;
  status: InspectionItemStatus;
  note?: string;
  value?: string | number | null;
  unit?: string | null;
  photoUrls?: string[];
  recommend?: string[];
}

export interface InspectionSummary {
  templateName?: string | null;
  date: string;
  items: SummaryItem[];
  summaryText: string;
}

/** ---------- Session (customer/vehicle) ---------- */
export interface SessionCustomer {
  first_name: string | null;
  last_name: string | null;
  phone: string | null;
  email: string | null;
  address: string | null;
  city: string | null;
  province: string | null;
  postal_code: string | null;
}

export interface SessionVehicle {
  year: string | null;
  make: string | null;
  model: string | null;
  vin: string | null;
  license_plate: string | null;
  mileage: string | null;
  color: string | null;
  /** Added for your form */
  unit_number?: string | null;
  engine_hours?: string | null;
}

/** ---------- Session status ---------- */
export type InspectionStatus = "not_started" | "in_progress" | "paused" | "completed";

/** ---------- Full session ---------- */
export interface InspectionSession {
  id?: string;

  /** Links to other records */
  customerId?: string | null;
  vehicleId?: string | null;
  workOrderId?: string | null;

  /** Template meta */
  templateId?: string | null;
  templateName?: string | null;
  /** Legacy alias still used by some pages */
  templateitem?: string | null;

  /** Selected brake system for rendering/units */
  brakeType?: BrakeType;

  location?: string | null;

  /** Progress */
  currentSectionIndex: number;
  currentItemIndex: number;

  /** Voice */
  transcript?: string;
  isListening: boolean;

  /** Lifecycle */
  status: InspectionStatus;
  started: boolean;
  completed: boolean;
  isPaused: boolean;

  /** Audit */
  lastUpdated?: string;

  /** Entities */
  customer?: SessionCustomer | null;
  vehicle?: SessionVehicle | null;

  /** Content */
  sections: InspectionCategory[];

  /** Quotes can be DB-sourced or UI-generated — accept both */
  quote?: Array<QuoteLine | QuoteLineItem>;
}"use client";

import { useState } from "react";
import {
  InspectionItem,
  InspectionSection,
  InspectionSession,
  QuoteLineItem,      // ⬅️ use only QuoteLineItem here
  BrakeType,
} from "@inspections/lib/inspection/types";

type AxleLayoutConfig = { axleCount: number; brakeType: BrakeType };

function generateAxleSections({ axleCount, brakeType }: AxleLayoutConfig): InspectionSection[] {
  const sections: InspectionSection[] = [];

  for (let i = 1; i <= axleCount; i++) {
    const title = `Axle ${i}`;
    const items: InspectionItem[] = [
      { item: "Left Tread Depth",  name: "Left Tread Depth",  value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Right Tread Depth", name: "Right Tread Depth", value: null, unit: "mm",  notes: "",  photoUrls: [] },
      { item: "Left Tire Pressure",  name: "Left Tire Pressure",  value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Right Tire Pressure", name: "Right Tire Pressure", value: null, unit: "psi", notes: "", photoUrls: [] },
      { item: "Left Lining Thickness",  name: "Left Lining Thickness",  value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Right Lining Thickness", name: "Right Lining Thickness", value: null, unit: "mm", notes: "", photoUrls: [] },
      { item: "Wheel Torque", name: "Wheel Torque", value: null, unit: "ft lbs", notes: "", photoUrls: [] },
    ];

    if (brakeType === "air") {
      items.push(
        { item: "Left Push Rod Travel",  name: "Left Push Rod Travel",  value: null, unit: "in", notes: "", photoUrls: [] },
        { item: "Right Push Rod Travel", name: "Right Push Rod Travel", value: null, unit: "in", notes: "", photoUrls: [] },
      );
    }

    sections.push({ title, items });
  }

  return sections;
}

export default function useInspectionSession(initialSession?: Partial<InspectionSession>) {
  const [session, setSession] = useState<InspectionSession>(() => ({
    id: "",
    vehicleId: "",
    customerId: "",
    workOrderId: "",
    templateId: "",
    templateName: "",
    location: "",
    currentSectionIndex: 0,
    currentItemIndex: 0,
    transcript: "",
    status: "not_started",
    started: false,
    completed: false,
    isListening: false,
    isPaused: false,
    quote: [],                                 // ⬅️ QuoteLineItem[]
    lastUpdated: new Date().toISOString(),
    customer: {
      first_name: "",
      last_name: "",
      phone: "",
      email: "",
      address: "",
      city: "",
      province: "",
      postal_code: "",
    },
    vehicle: {
      year: "",
      make: "",
      model: "",
      vin: "",
      license_plate: "",
      mileage: "",
      color: "",
    },
    sections: [],
    ...initialSession,
  }));

  const stamp = () => ({ lastUpdated: new Date().toISOString() });

  const updateInspection = (updates: Partial<InspectionSession>) =>
    setSession(prev => ({ ...prev, ...updates, ...stamp() }));

  const updateSection = (sectionIndex: number, updates: Partial<InspectionSection>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      sections[sectionIndex] = { ...sections[sectionIndex], ...updates };
      return { ...prev, sections, ...stamp() };
    });

  const updateItem = (sectionIndex: number, itemIndex: number, updates: Partial<InspectionItem>) =>
    setSession(prev => {
      const sections = [...prev.sections];
      const items = [...sections[sectionIndex].items];
      items[itemIndex] = { ...items[itemIndex], ...updates };
      sections[sectionIndex] = { ...sections[sectionIndex], items };
      return { ...prev, sections, ...stamp() };
    });

  // ✅ strictly QuoteLineItem (the normalized/store+PDF shape)
  const addQuoteLine = (line: QuoteLineItem) =>
    setSession(prev => ({ ...prev, quote: [...(prev.quote ?? []), line], ...stamp() }));

  const updateQuoteLines = (lines: QuoteLineItem[]) =>
    setSession(prev => ({ ...prev, quote: lines, ...stamp() }));

  // ✅ targeted updater for enriching a single line (AI merge, edits, etc.)
  const updateQuoteLine = (id: string, patch: Partial<QuoteLineItem>) =>
    setSession(prev => ({
      ...prev,
      quote: (prev.quote ?? []).map((l) => (l.id === id ? { ...l, ...patch } : l)),
      ...stamp(),
    }));

  const startSession = (sessionData: Partial<InspectionSession> & { axleConfig?: AxleLayoutConfig }) => {
    const { axleConfig, ...rest } = sessionData;
    const newSections =
      axleConfig?.axleCount && axleConfig?.brakeType
        ? generateAxleSections(axleConfig)
        : sessionData.sections || session.sections;

    setSession(prev => ({
      ...prev,
      ...rest,
      sections: newSections,
      currentSectionIndex: 0,
      currentItemIndex: 0,
      transcript: "",
      started: true,
      completed: false,
      status: "in_progress",
      isPaused: false,
      ...stamp(),
    }));
  };

  const pauseSession  = () => updateInspection({ isPaused: true,  status: "paused" });
  const resumeSession = () => updateInspection({ isPaused: false, status: "in_progress" });
  const finishSession = () => updateInspection({ completed: true, status: "completed", isPaused: false });
  const setIsListening = (value: boolean) => updateInspection({ isListening: value });

  return {
    session,
    updateInspection,
    updateSection,
    updateItem,
    addQuoteLine,
    updateQuoteLines,
    updateQuoteLine,   // ⬅️ expose the targeted updater
    startSession,
    pauseSession,
    resumeSession,
    finishSession,
    setIsListening,
    isPaused: session.isPaused,
  };
}"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { Dialog } from "@headlessui/react";
import InspectionHost from "@/features/inspections/components/inspectionHost";

type Props = {
  open: boolean;
  src: string | null;
  title?: string;
  onClose?: () => void;
};

function paramsToObject(sp: URLSearchParams) {
  const out: Record<string, string> = {};
  sp.forEach((v, k) => (out[k] = v));
  return out;
}

export default function InspectionModal({
  open,
  src,
  title = "Inspection",
  onClose,
}: Props) {
  const [compact, setCompact] = useState(true);
  const scrollRef = useRef<HTMLDivElement | null>(null);

  const derived = useMemo(() => {
    if (!src)
      return { template: null as string | null, params: {}, missingWOLine: false };
    try {
      const base =
        typeof window !== "undefined" ? window.location.origin : "http://localhost";
      const url = new URL(src, base);
      const parts = url.pathname.split("/").filter(Boolean);
      const idx = parts.findIndex((p) => p === "inspection" || p === "inspections");
      const template = idx >= 0 ? parts[idx + 1] : parts[parts.length - 1];
      const params = paramsToObject(url.searchParams);
      const missingWOLine = !url.searchParams.get("workOrderLineId");
      return { template, params, missingWOLine };
    } catch {
      return { template: src.replace(/^\//, ""), params: {}, missingWOLine: false };
    }
  }, [src]);

  const close = () => {
    onClose?.();
    if (typeof window !== "undefined") {
      window.dispatchEvent(new CustomEvent("inspection:close"));
    }
  };

  // 💡 wheel/touch guard: keep scroll inside THIS box
  useEffect(() => {
    if (!open) return;
    const el = scrollRef.current;
    if (!el) return;

    const onWheel = (e: WheelEvent) => {
      const target = el;
      const { scrollTop, scrollHeight, clientHeight } = target;
      const atTop = scrollTop <= 0;
      const atBottom = scrollTop + clientHeight >= scrollHeight - 1;

      if (e.deltaY > 0 && atBottom) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      if (e.deltaY < 0 && atTop) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    };

    let lastY = 0;
    const onTouchStart = (e: TouchEvent) => {
      lastY = e.touches[0]?.clientY ?? 0;
    };
    const onTouchMove = (e: TouchEvent) => {
      const target = el;
      const { scrollTop, scrollHeight, clientHeight } = target;
      const atTop = scrollTop <= 0;
      const atBottom = scrollTop + clientHeight >= scrollHeight - 1;
      const currentY = e.touches[0]?.clientY ?? 0;
      const goingDown = lastY > currentY;
      const goingUp = lastY < currentY;
      lastY = currentY;

      if ((goingDown && atBottom) || (goingUp && atTop)) {
        e.preventDefault();
        e.stopPropagation();
      }
    };

    el.addEventListener("wheel", onWheel, { passive: false });
    el.addEventListener("touchstart", onTouchStart, { passive: true });
    el.addEventListener("touchmove", onTouchMove, { passive: false });

    return () => {
      el.removeEventListener("wheel", onWheel);
      el.removeEventListener("touchstart", onTouchStart);
      el.removeEventListener("touchmove", onTouchMove);
    };
  }, [open]);

  const panelWidth = compact ? "max-w-4xl" : "max-w-6xl";
  const bodyHeight = compact ? "max-h-[80vh]" : "max-h-[92vh]";

  return (
    <Dialog
      open={open}
      onClose={close}
      className="fixed inset-0 z-[300] flex items-center justify-center px-2 py-6 sm:px-4"
    >
      {/* Backdrop */}
      <div
        className="fixed inset-0 z-[300] bg-black/70 backdrop-blur-sm"
        aria-hidden="true"
      />

      {/* Panel */}
      <Dialog.Panel
        className={`relative z-[310] mx-auto w-full ${panelWidth}`}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="mb-2 flex items-start justify-between gap-3 rounded-t-lg border border-b-0 border-orange-500 bg-neutral-950/90 px-4 py-3">
          <div className="space-y-1">
            <Dialog.Title className="text-base font-blackops tracking-wide text-orange-400 sm:text-lg">
              {title}
            </Dialog.Title>
            {derived.template && (
              <p className="text-[11px] text-neutral-400">
                Template:{" "}
                <span className="font-mono text-neutral-200">
                  {derived.template}
                </span>
              </p>
            )}
          </div>
          <div className="flex items-center gap-2">
            <button
              type="button"
              onClick={() => setCompact((v) => !v)}
              className="rounded border border-neutral-700 bg-neutral-900 px-3 py-1.5 text-[11px] text-neutral-100 hover:border-orange-500 hover:bg-neutral-800"
            >
              {compact ? "Expand" : "Shrink"}
            </button>
            <button
              type="button"
              onClick={close}
              className="rounded border border-neutral-700 bg-neutral-900 px-2 py-1 text-xs text-neutral-200 hover:bg-neutral-800"
            >
              ✕
            </button>
          </div>
        </div>

        {/* Scrollable body */}
        <div
          ref={scrollRef}
          className={`${bodyHeight} overflow-y-auto overscroll-contain rounded-b-lg border border-orange-500 bg-neutral-950 p-4 text-white shadow-xl`}
          style={{
            WebkitOverflowScrolling: "touch",
            scrollbarGutter: "stable both-edges",
          }}
        >
          {derived.missingWOLine && (
            <div className="mb-3 rounded border border-yellow-700 bg-yellow-900/30 px-3 py-2 text-xs text-yellow-200">
              <strong>Heads up:</strong>{" "}
              <code className="font-mono text-yellow-100">workOrderLineId</code>{" "}
              is missing; Save/Finish may be blocked.
            </div>
          )}

          {!derived.template ? (
            <div className="rounded border border-neutral-800 bg-neutral-900 px-4 py-6 text-center text-sm text-neutral-400">
              No inspection selected.
            </div>
          ) : (
            <div className="mx-auto w-full max-w-5xl">
              <InspectionHost
                template={derived.template}
                embed
                params={derived.params}
              />
            </div>
          )}

          {/* Footer actions */}
          <div className="mt-4 flex flex-col gap-2 border-t border-neutral-800 pt-3 sm:flex-row sm:items-center sm:justify-between">
            <button
              type="button"
              onClick={() => setCompact((v) => !v)}
              className="inline-flex items-center justify-center rounded border border-neutral-700 bg-neutral-900 px-3 py-1.5 text-xs text-neutral-100 hover:border-orange-500 hover:bg-neutral-800 sm:text-[11px]"
            >
              {compact ? "Expand View" : "Shrink View"}
            </button>
            <div className="flex justify-end gap-2">
              <button
                type="button"
                onClick={close}
                className="rounded border border-neutral-700 bg-neutral-900 px-4 py-1.5 text-xs sm:text-sm text-neutral-200 hover:bg-neutral-800"
              >
                Cancel
              </button>
              <button
                type="button"
                onClick={close}
                className="rounded border border-orange-500 bg-orange-500/10 px-4 py-1.5 text-xs sm:text-sm font-medium text-orange-100 hover:bg-orange-500/20"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </Dialog.Panel>
    </Dialog>
  );
}