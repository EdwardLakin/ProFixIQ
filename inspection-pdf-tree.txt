# === INSPECTION PDF FLOW SNAPSHOT ===
# Generated on: $(date)
# Repo: ProFixIQ


===============================
FILE: app/api/inspections/complete/route.ts
===============================
â”‚ // app/api/inspections/complete/route.ts âœ… FULL FILE REPLACEMENT (NO any)
â”‚ import "server-only";
â”‚ 
â”‚ export const runtime = "nodejs";
â”‚ 
â”‚ import { NextResponse, type NextRequest } from "next/server";
â”‚ import { cookies } from "next/headers";
â”‚ import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
â”‚ import type { Database, TablesInsert } from "@shared/types/types/supabase";
â”‚ 
â”‚ import type { InspectionItem } from "@/features/inspections/lib/inspection/types";
â”‚ import { generateQuoteFromInspection } from "@quotes/lib/quote/generateQuoteFromInspection";
â”‚ import { normalizeQuoteLine } from "@quotes/lib/quote/normalizeQuoteLine";
â”‚ 
â”‚ type DB = Database;
â”‚ type QuoteLinesInsert = TablesInsert<"quote_lines">;
â”‚ 
â”‚ /* ----------------------------- Type guards ----------------------------- */
â”‚ function isRecord(v: unknown): v is Record<string, unknown> {
â”‚   return typeof v === "object" && v !== null;
â”‚ }
â”‚ 
â”‚ function isInspectionItem(value: unknown): value is InspectionItem {
â”‚   // lightweight structural check â€” your InspectionItem is very flexible
â”‚   return isRecord(value);
â”‚ }
â”‚ 
â”‚ function isInspectionItemArray(value: unknown): value is InspectionItem[] {
â”‚   return Array.isArray(value) && value.every(isInspectionItem);
â”‚ }
â”‚ 
â”‚ /* -------------------------------- Types -------------------------------- */
â”‚ type CompleteRequest = {
â”‚   workOrderId: string;
â”‚   workOrderLineId: string;
â”‚   results: InspectionItem[];
â”‚   templateName?: string | null;
â”‚ };
â”‚ 
â”‚ /* --------------------------------- Route -------------------------------- */
â”‚ export async function POST(req: NextRequest) {
â”‚   const supabase = createRouteHandlerClient<DB>({ cookies });
â”‚ 
â”‚   try {
â”‚     // 1) Parse & validate
â”‚     const body = (await req.json().catch(() => null)) as unknown;
â”‚ 
â”‚     if (!isRecord(body)) {
â”‚       return NextResponse.json({ error: "Invalid JSON body." }, { status: 400 });
â”‚     }
â”‚ 
â”‚     const workOrderId = String(body.workOrderId ?? "").trim();
â”‚     const workOrderLineId = String(body.workOrderLineId ?? "").trim();
â”‚     const results = (body as Partial<CompleteRequest>).results;
â”‚ 
â”‚     if (!workOrderId || !workOrderLineId) {
â”‚       return NextResponse.json(
â”‚         { error: "Missing workOrderId or workOrderLineId." },
â”‚         { status: 400 },
â”‚       );
â”‚     }
â”‚ 
â”‚     if (!isInspectionItemArray(results)) {
â”‚       return NextResponse.json(
â”‚         { error: "results must be an array of InspectionItem." },
â”‚         { status: 400 },
â”‚       );
â”‚     }
â”‚ 
â”‚     // current user (for quote_lines.user_id)
â”‚     const {
â”‚       data: { user },
â”‚       error: userErr,
â”‚     } = await supabase.auth.getUser();
â”‚ 
â”‚     if (userErr) {
â”‚       return NextResponse.json({ error: userErr.message }, { status: 500 });
â”‚     }
â”‚ 
â”‚     const userId = user?.id ?? null;
â”‚ 
â”‚     // 2) Verify the WO line exists
â”‚     const { data: line, error: lineErr } = await supabase
â”‚       .from("work_order_lines")
â”‚       .select("id, work_order_id")
â”‚       .eq("id", workOrderLineId)
â”‚       .maybeSingle();
â”‚ 
â”‚     if (lineErr) {
â”‚       return NextResponse.json(
â”‚         { error: `Failed to load work order line: ${lineErr.message}` },
â”‚         { status: 500 },
â”‚       );
â”‚     }
â”‚     if (!line) {
â”‚       return NextResponse.json({ error: "Work order line not found." }, { status: 404 });
â”‚     }
â”‚ 
â”‚     // Optional safety: ensure line belongs to the same WO passed
â”‚     if (typeof line.work_order_id === "string" && line.work_order_id !== workOrderId) {
â”‚       return NextResponse.json(
â”‚         { error: "workOrderId does not match the line's work_order_id." },
â”‚         { status: 400 },
â”‚       );
â”‚     }
â”‚ 
â”‚     // 3) Generate AI summary and quote lines from inspection results
â”‚     const { summary, quote } = await generateQuoteFromInspection(results);
â”‚     const normalized = await Promise.all(quote.map((q) => normalizeQuoteLine(q)));
â”‚ 
â”‚     // 4) Insert quote_lines (match your schema exactly)
â”‚     const nowIso = new Date().toISOString();
â”‚ 
â”‚     const quoteRows: QuoteLinesInsert[] = normalized.map((n): QuoteLinesInsert => ({
â”‚       work_order_id: workOrderId,
â”‚ 
â”‚       // text columns used by your UI
â”‚       description: n.description,
â”‚       item: n.item ?? n.name ?? n.description,
â”‚       name: n.name ?? n.description,
â”‚       title: n.description,
â”‚ 
â”‚       // pricing / labor
â”‚       quantity: 1,
â”‚       labor_time: typeof n.laborHours === "number" ? n.laborHours : null,
â”‚       price: typeof n.price === "number" ? n.price : null,
â”‚       total: typeof n.price === "number" ? n.price : null,
â”‚ 
â”‚       // parts info
â”‚       part_name: n.part?.name ?? n.partName ?? null,
â”‚       part_price:
â”‚         typeof n.part?.price === "number" ? n.part.price : n.partPrice ?? null,
â”‚ 
â”‚       // misc columns
â”‚       photo_urls: Array.isArray(n.photoUrls) ? n.photoUrls : null,
â”‚       status: "draft",
â”‚       user_id: userId,
â”‚       updated_at: nowIso,
â”‚     }));
â”‚ 
â”‚     if (quoteRows.length > 0) {
â”‚       const { error: insErr } = await supabase.from("quote_lines").insert(quoteRows);
â”‚       if (insErr) {
â”‚         return NextResponse.json(
â”‚           { error: `Failed to insert quote lines: ${insErr.message}` },
â”‚           { status: 500 },
â”‚         );
â”‚       }
â”‚     }
â”‚ 
â”‚     // 5) Mark the inspection line complete & store AI summary in correction
â”‚     // âš ï¸ DO NOT write columns that don't exist (e.g. completed_by)
â”‚     const updatePayload: DB["public"]["Tables"]["work_order_lines"]["Update"] = {
â”‚       status: "completed",
â”‚       correction: summary ?? null,
â”‚       updated_at: nowIso,
â”‚       punched_out_at: nowIso,
â”‚     };
â”‚ 
â”‚     const { error: updErr } = await supabase
â”‚       .from("work_order_lines")
â”‚       .update(updatePayload)
â”‚       .eq("id", workOrderLineId);
â”‚ 
â”‚     if (updErr) {
â”‚       return NextResponse.json(
â”‚         { error: `Failed to update work order line: ${updErr.message}` },
â”‚         { status: 500 },
â”‚       );
â”‚     }
â”‚ 
â”‚     // 6) Done
â”‚     return NextResponse.json({
â”‚       ok: true,
â”‚       workOrderId,
â”‚       workOrderLineId,
â”‚       summary,
â”‚       inserted: quoteRows.length,
â”‚     });
â”‚   } catch (err) {
â”‚     const message =
â”‚       err instanceof Error ? err.message : "Unexpected error handling inspection completion.";
â”‚     return NextResponse.json({ error: message }, { status: 500 });
â”‚   }
â”‚ }

===============================
FILE: app/api/inspections/photos/upload/route.ts
===============================
â”‚ import "server-only";
â”‚ 
â”‚ export const runtime = "nodejs";
â”‚ 
â”‚ import { NextResponse, type NextRequest } from "next/server";
â”‚ import { cookies } from "next/headers";
â”‚ import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
â”‚ import type { Database } from "@shared/types/types/supabase";
â”‚ import crypto from "crypto";
â”‚ 
â”‚ type DB = Database;
â”‚ 
â”‚ function asString(v: FormDataEntryValue | null): string | null {
â”‚   if (typeof v !== "string") return null;
â”‚   const t = v.trim();
â”‚   return t.length ? t : null;
â”‚ }
â”‚ 
â”‚ function safeFilePart(x: string): string {
â”‚   return x.replace(/[^a-zA-Z0-9._-]/g, "_");
â”‚ }
â”‚ 
â”‚ function extFromMime(mime: string | null): "jpg" | "png" {
â”‚   const m = (mime ?? "").toLowerCase();
â”‚   if (m.includes("png")) return "png";
â”‚   return "jpg";
â”‚ }
â”‚ 
â”‚ export async function POST(req: NextRequest) {
â”‚   const supabase = createRouteHandlerClient<DB>({ cookies });
â”‚ 
â”‚   // auth
â”‚   const {
â”‚     data: { user },
â”‚     error: userErr,
â”‚   } = await supabase.auth.getUser();
â”‚ 
â”‚   if (userErr || !user) {
â”‚     return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
â”‚   }
â”‚ 
â”‚   // parse multipart
â”‚   const form = await req.formData().catch(() => null);
â”‚   if (!form) {
â”‚     return NextResponse.json({ error: "Expected multipart/form-data" }, { status: 400 });
â”‚   }
â”‚ 
â”‚   const inspectionId = asString(form.get("inspectionId"));
â”‚   const itemName = asString(form.get("itemName"));
â”‚   const notes = asString(form.get("notes"));
â”‚   const file = form.get("file");
â”‚ 
â”‚   if (!inspectionId) {
â”‚     return NextResponse.json({ error: "Missing inspectionId" }, { status: 400 });
â”‚   }
â”‚   if (!(file instanceof File)) {
â”‚     return NextResponse.json({ error: "Missing file" }, { status: 400 });
â”‚   }
â”‚ 
â”‚   // resolve shop_id for policy + path
â”‚   const { data: insp, error: inspErr } = await supabase
â”‚     .from("inspections")
â”‚     .select("id, shop_id")
â”‚     .eq("id", inspectionId)
â”‚     .maybeSingle<{ id: string; shop_id: string | null }>();
â”‚ 
â”‚   if (inspErr) {
â”‚     // eslint-disable-next-line no-console
â”‚     console.error("[inspections/photos/upload] inspections lookup failed", inspErr);
â”‚     return NextResponse.json({ error: "Failed to load inspection" }, { status: 500 });
â”‚   }
â”‚ 
â”‚   const shopId = insp?.shop_id ?? null;
â”‚   if (!shopId) {
â”‚     return NextResponse.json({ error: "Inspection missing shop_id" }, { status: 400 });
â”‚   }
â”‚ 
â”‚   // ensure storage policy that depends on current_shop_id() can evaluate
â”‚   const { error: ctxErr } = await supabase.rpc("set_current_shop_id", { p_shop_id: shopId });
â”‚   if (ctxErr) {
â”‚     // eslint-disable-next-line no-console
â”‚     console.error("[inspections/photos/upload] set_current_shop_id failed", ctxErr);
â”‚     return NextResponse.json({ error: "Failed to set shop context" }, { status: 500 });
â”‚   }
â”‚ 
â”‚   // build storage path
â”‚   const bucket = "inspection_photos";
â”‚   const shopPart = safeFilePart(shopId);
â”‚   const inspPart = safeFilePart(inspectionId);
â”‚   const idPart = crypto.randomUUID();
â”‚   const ext = extFromMime(file.type);
â”‚ 
â”‚   const path = `shops/${shopPart}/inspections/${inspPart}/${idPart}.${ext}`;
â”‚ 
â”‚   const bytes = Buffer.from(await file.arrayBuffer());
â”‚ 
â”‚   const { error: upErr } = await supabase.storage
â”‚     .from(bucket)
â”‚     .upload(path, bytes, { contentType: file.type || (ext === "png" ? "image/png" : "image/jpeg"), upsert: false });
â”‚ 
â”‚   if (upErr) {
â”‚     // eslint-disable-next-line no-console
â”‚     console.error("[inspections/photos/upload] storage upload failed", upErr);
â”‚     return NextResponse.json({ error: upErr.message }, { status: 500 });
â”‚   }
â”‚ 
â”‚   // signed url for UI/PDF (30 days)
â”‚   const { data: signed, error: signErr } = await supabase.storage
â”‚     .from(bucket)
â”‚     .createSignedUrl(path, 60 * 60 * 24 * 30);
â”‚ 
â”‚   if (signErr || !signed?.signedUrl) {
â”‚     // eslint-disable-next-line no-console
â”‚     console.warn("[inspections/photos/upload] createSignedUrl failed", signErr);
â”‚   }
â”‚ 
â”‚   const imageUrl = signed?.signedUrl ?? null;
â”‚ 
â”‚   // insert row in inspection_photos (you currently only have image_url column)
â”‚   const { data: row, error: insErr } = await supabase
â”‚     .from("inspection_photos")
â”‚     .insert({
â”‚       inspection_id: inspectionId,
â”‚       item_name: itemName,
â”‚       image_url: imageUrl ?? path, // fallback: store path if signed url missing
â”‚       notes: notes ?? null,
â”‚       user_id: user.id,
â”‚     })
â”‚     .select("id, image_url, item_name")
â”‚     .single();
â”‚ 
â”‚   if (insErr) {
â”‚     // eslint-disable-next-line no-console
â”‚     console.error("[inspections/photos/upload] inspection_photos insert failed", insErr);
â”‚     return NextResponse.json({ error: insErr.message }, { status: 500 });
â”‚   }
â”‚ 
â”‚   return NextResponse.json({
â”‚     ok: true,
â”‚     bucket,
â”‚     path,
â”‚     inspectionId,
â”‚     itemName,
â”‚     url: row?.image_url ?? imageUrl,
â”‚     photo: row,
â”‚   });
â”‚ }

===============================
FILE: features/inspections/lib/inspection/pdf.ts
===============================
â”‚ // features/inspections/lib/inspection/pdf.ts âœ… FULL FILE REPLACEMENT (NO any)
â”‚ import { PDFDocument, rgb, StandardFonts, type PDFImage } from "pdf-lib";
â”‚ import type {
â”‚   InspectionSession,
â”‚   InspectionItem,
â”‚   InspectionItemStatus,
â”‚   InspectionSection,
â”‚ } from "./types";
â”‚ 
â”‚ function safeStr(v: unknown): string {
â”‚   return typeof v === "string" ? v : v == null ? "" : String(v);
â”‚ }
â”‚ 
â”‚ function wrapText(text: string, maxChars: number): string[] {
â”‚   const t = safeStr(text).trim();
â”‚   if (!t) return ["â€”"];
â”‚   const words = t.split(/\s+/);
â”‚   const lines: string[] = [];
â”‚   let cur = "";
â”‚ 
â”‚   for (const w of words) {
â”‚     if (!cur) {
â”‚       cur = w;
â”‚       continue;
â”‚     }
â”‚     if ((cur + " " + w).length <= maxChars) cur = cur + " " + w;
â”‚     else {
â”‚       lines.push(cur);
â”‚       cur = w;
â”‚     }
â”‚   }
â”‚   if (cur) lines.push(cur);
â”‚   return lines.length ? lines : ["â€”"];
â”‚ }
â”‚ 
â”‚ function statusLabel(s: InspectionItemStatus | undefined): string {
â”‚   if (!s) return "â€”";
â”‚   return s.toUpperCase();
â”‚ }
â”‚ 
â”‚ function getItemLabel(it: InspectionItem): string {
â”‚   return safeStr(it.item ?? it.name).trim() || "Item";
â”‚ }
â”‚ 
â”‚ function isStringArray(v: unknown): v is string[] {
â”‚   return Array.isArray(v) && v.every((x) => typeof x === "string");
â”‚ }
â”‚ 
â”‚ async function tryEmbedImage(pdfDoc: PDFDocument, url: string): Promise<PDFImage> {
â”‚   // Node runtime supports fetch in Next (nodejs runtime).
â”‚   const res = await fetch(url);
â”‚   if (!res.ok) throw new Error(`fetch ${res.status}`);
â”‚   const buf = new Uint8Array(await res.arrayBuffer());
â”‚ 
â”‚   // try jpg then png
â”‚   try {
â”‚     return await pdfDoc.embedJpg(buf);
â”‚   } catch {
â”‚     return await pdfDoc.embedPng(buf);
â”‚   }
â”‚ }
â”‚ 
â”‚ export async function generateInspectionPDF(
â”‚   session: InspectionSession,
â”‚ ): Promise<Uint8Array> {
â”‚   const pdfDoc = await PDFDocument.create();
â”‚ 
â”‚   const PAGE_W = 595.28; // A4
â”‚   const PAGE_H = 841.89;
â”‚ 
â”‚   const margin = 48;
â”‚   const fontSize = 11;
â”‚   const lineHeight = fontSize + 7;
â”‚ 
â”‚   const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
â”‚   const bold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
â”‚ 
â”‚   const C_TEXT = rgb(0.05, 0.05, 0.05);
â”‚   const C_MUTED = rgb(0.35, 0.35, 0.35);
â”‚   const C_RULE = rgb(0.85, 0.85, 0.85);
â”‚ 
â”‚   let page = pdfDoc.addPage([PAGE_W, PAGE_H]);
â”‚   let y = PAGE_H - margin;
â”‚ 
â”‚   const newPage = () => {
â”‚     page = pdfDoc.addPage([PAGE_W, PAGE_H]);
â”‚     y = PAGE_H - margin;
â”‚   };
â”‚ 
â”‚   const ensureSpace = (needed: number) => {
â”‚     if (y - needed < margin) newPage();
â”‚   };
â”‚ 
â”‚   const hr = () => {
â”‚     ensureSpace(16);
â”‚     page.drawLine({
â”‚       start: { x: margin, y: y - 6 },
â”‚       end: { x: PAGE_W - margin, y: y - 6 },
â”‚       thickness: 1,
â”‚       color: C_RULE,
â”‚     });
â”‚     y -= 16;
â”‚   };
â”‚ 
â”‚   const drawLine = (
â”‚     text: string,
â”‚     opts?: { bold?: boolean; color?: ReturnType<typeof rgb> },
â”‚   ) => {
â”‚     ensureSpace(lineHeight);
â”‚     page.drawText(text, {
â”‚       x: margin,
â”‚       y,
â”‚       size: fontSize,
â”‚       font: opts?.bold ? bold : font,
â”‚       color: opts?.color ?? C_TEXT,
â”‚     });
â”‚     y -= lineHeight;
â”‚   };
â”‚ 
â”‚   const drawWrapped = (label: string, value: unknown, maxChars = 92, indent = "") => {
â”‚     const v = safeStr(value).trim();
â”‚     const out = v.length ? v : "â€”";
â”‚     const lines = wrapText(out, maxChars);
â”‚     drawLine(`${indent}${label}: ${lines[0]}`, { color: C_MUTED });
â”‚     for (const extra of lines.slice(1)) {
â”‚       drawLine(`${indent}   ${extra}`, { color: C_MUTED });
â”‚     }
â”‚   };
â”‚ 
â”‚   // ---- Header ---------------------------------------------------------------
â”‚   drawLine("Inspection Report", { bold: true });
â”‚   drawLine(`Template: ${safeStr(session.templateName).trim() || "â€”"}`, {
â”‚     color: C_MUTED,
â”‚   });
â”‚   drawLine(
â”‚     `Status: ${safeStr(session.status).trim() || "unknown"} â€¢ Completed: ${
â”‚       session.completed ? "Yes" : "No"
â”‚     }`,
â”‚     { color: C_MUTED },
â”‚   );
â”‚   hr();
â”‚ 
â”‚   // ---- Customer Info --------------------------------------------------------
â”‚   drawLine("Customer", { bold: true });
â”‚   const firstName = safeStr(session.customer?.first_name).trim();
â”‚   const lastName = safeStr(session.customer?.last_name).trim();
â”‚   const fullName =
â”‚     `${firstName} ${lastName}`.trim() ||
â”‚     safeStr(session.customer?.name).trim() ||
â”‚     "â€”";
â”‚   drawLine(`Name: ${fullName}`, { color: C_MUTED });
â”‚   drawLine(`Phone: ${safeStr(session.customer?.phone).trim() || "â€”"}`, {
â”‚     color: C_MUTED,
â”‚   });
â”‚   drawLine(`Email: ${safeStr(session.customer?.email).trim() || "â€”"}`, {
â”‚     color: C_MUTED,
â”‚   });
â”‚   hr();
â”‚ 
â”‚   // ---- Vehicle Info ---------------------------------------------------------
â”‚   drawLine("Vehicle", { bold: true });
â”‚   const year = safeStr(session.vehicle?.year).trim();
â”‚   const make = safeStr(session.vehicle?.make).trim();
â”‚   const model = safeStr(session.vehicle?.model).trim();
â”‚   drawLine(
â”‚     `Year/Make/Model: ${[year, make, model].filter(Boolean).join(" ") || "â€”"}`,
â”‚     { color: C_MUTED },
â”‚   );
â”‚   drawLine(`VIN: ${safeStr(session.vehicle?.vin).trim() || "â€”"}`, { color: C_MUTED });
â”‚   drawLine(
â”‚     `License Plate: ${safeStr(session.vehicle?.license_plate).trim() || "â€”"}`,
â”‚     { color: C_MUTED },
â”‚   );
â”‚   drawLine(`Mileage: ${safeStr(session.vehicle?.mileage).trim() || "â€”"}`, {
â”‚     color: C_MUTED,
â”‚   });
â”‚   drawLine(`Color: ${safeStr(session.vehicle?.color).trim() || "â€”"}`, { color: C_MUTED });
â”‚   hr();
â”‚ 
â”‚   // ---- Summary --------------------------------------------------------------
â”‚   const sections: InspectionSection[] = Array.isArray(session.sections)
â”‚     ? session.sections
â”‚     : [];
â”‚ 
â”‚   let ok = 0;
â”‚   let fail = 0;
â”‚   let rec = 0;
â”‚   let na = 0;
â”‚ 
â”‚   for (const s of sections) {
â”‚     const items = Array.isArray(s.items) ? s.items : [];
â”‚     for (const it of items) {
â”‚       const st = it.status;
â”‚       if (st === "ok") ok++;
â”‚       else if (st === "fail") fail++;
â”‚       else if (st === "recommend") rec++;
â”‚       else if (st === "na") na++;
â”‚     }
â”‚   }
â”‚ 
â”‚   drawLine("Summary", { bold: true });
â”‚   drawLine(`OK: ${ok}   FAIL: ${fail}   RECOMMEND: ${rec}   NA: ${na}`, {
â”‚     color: C_MUTED,
â”‚   });
â”‚ 
â”‚   const transcript = safeStr(session.transcript).trim();
â”‚   if (transcript.length) drawWrapped("Transcript", transcript, 92);
â”‚   hr();
â”‚ 
â”‚   // ---- Sections / Items -----------------------------------------------------
â”‚   for (let sIdx = 0; sIdx < sections.length; sIdx++) {
â”‚     const section = sections[sIdx];
â”‚     const title = safeStr(section.title).trim() || `Section ${sIdx + 1}`;
â”‚ 
â”‚     drawLine(title, { bold: true });
â”‚ 
â”‚     const items = Array.isArray(section.items) ? section.items : [];
â”‚     if (!items.length) {
â”‚       drawLine("â€” No items â€”", { color: C_MUTED });
â”‚       drawLine("");
â”‚       continue;
â”‚     }
â”‚ 
â”‚     for (const it of items) {
â”‚       const itemName = getItemLabel(it);
â”‚       const status = it.status;
â”‚ 
â”‚       drawLine(`â€¢ ${itemName}`, { bold: true });
â”‚       drawLine(`  Status: ${statusLabel(status)}`, { color: C_MUTED });
â”‚ 
â”‚       const value = it.value;
â”‚       if (value !== undefined && value !== null && safeStr(value).trim().length) {
â”‚         drawLine(`  Value: ${safeStr(value).trim()}`, { color: C_MUTED });
â”‚       }
â”‚ 
â”‚       const unit = safeStr(it.unit).trim();
â”‚       if (unit.length) drawLine(`  Unit: ${unit}`, { color: C_MUTED });
â”‚ 
â”‚       const notes = safeStr(it.notes ?? it.note).trim();
â”‚       if (notes.length) drawWrapped("  Notes", notes, 88, "");
â”‚ 
â”‚       const recommend = it.recommend;
â”‚       if (Array.isArray(recommend) && recommend.length > 0) {
â”‚         drawWrapped("  Recommend", recommend.join(", "), 88, "");
â”‚       }
â”‚ 
â”‚       const photoUrls = it.photoUrls;
â”‚       if (isStringArray(photoUrls) && photoUrls.length > 0) {
â”‚         // Embed up to 2 thumbnails if possible; fallback to listing urls.
â”‚         const toTry = photoUrls.slice(0, 2);
â”‚         let embeddedAny = false;
â”‚ 
â”‚         for (const u of toTry) {
â”‚           try {
â”‚             const img = await tryEmbedImage(pdfDoc, u);
â”‚             const maxW = 160;
â”‚             const maxH = 120;
â”‚             const scale = Math.min(maxW / img.width, maxH / img.height, 1);
â”‚             const w = img.width * scale;
â”‚             const h = img.height * scale;
â”‚ 
â”‚             ensureSpace(h + 22);
â”‚             page.drawText("  Photo:", { x: margin, y, size: 10, font, color: C_MUTED });
â”‚             y -= 14;
â”‚ 
â”‚             page.drawImage(img, {
â”‚               x: margin + 18,
â”‚               y: y - h,
â”‚               width: w,
â”‚               height: h,
â”‚             });
â”‚             y -= h + 8;
â”‚             embeddedAny = true;
â”‚           } catch {
â”‚             // continue trying next, but don't throw
â”‚           }
â”‚         }
â”‚ 
â”‚         if (!embeddedAny) {
â”‚           drawWrapped("  Photos", photoUrls.slice(0, 6).join(", "), 88, "");
â”‚           if (photoUrls.length > 6) {
â”‚             drawLine(`  â€¦and ${photoUrls.length - 6} more`, { color: C_MUTED });
â”‚           }
â”‚         }
â”‚       }
â”‚ 
â”‚       drawLine("");
â”‚     }
â”‚ 
â”‚     hr();
â”‚   }
â”‚ 
â”‚   return pdfDoc.save();
â”‚ }

===============================
FILE: features/inspections/lib/inspection/InspectionItemCard.tsx
===============================
â”‚ /// features/inspections/lib/inspection/InspectionItemCard.tsx âœ… FULL FILE REPLACEMENT (NO any)
â”‚ "use client";
â”‚ 
â”‚ import type React from "react";
â”‚ import { useEffect, useRef, useState } from "react";
â”‚ import type { InspectionItem, InspectionItemStatus } from "@inspections/lib/inspection/types";
â”‚ import StatusButtons from "./StatusButtons";
â”‚ import PhotoUploadButton from "./PhotoUploadButton";
â”‚ import PhotoThumbnail from "@inspections/components/inspection/PhotoThumbnail";
â”‚ 
â”‚ interface InspectionItemCardProps {
â”‚   item: InspectionItem;
â”‚   sectionIndex: number;
â”‚   itemIndex: number;
â”‚   showNotes: boolean;
â”‚   showPhotos: boolean;
â”‚ 
â”‚   /** âœ… required for uploading photos */
â”‚   inspectionId: string;
â”‚ 
â”‚   onUpdateNote: (sectionIndex: number, itemIndex: number, note: string) => void;
â”‚   onUpload: (photoUrl: string, sectionIndex: number, itemIndex: number) => void;
â”‚   onUpdateStatus: (
â”‚     sectionIndex: number,
â”‚     itemIndex: number,
â”‚     status: InspectionItemStatus,
â”‚   ) => void;
â”‚   onUpdateValue?: (sectionIndex: number, itemIndex: number, value: string) => void;
â”‚   onUpdateUnit?: (sectionIndex: number, itemIndex: number, unit: string) => void;
â”‚ 
â”‚   /** UI only: render as compact row */
â”‚   variant?: "card" | "row";
â”‚ }
â”‚ 
â”‚ function getItemLabel(raw: InspectionItem): string {
â”‚   const it = raw as unknown as {
â”‚     item?: unknown;
â”‚     name?: unknown;
â”‚     label?: unknown;
â”‚     description?: unknown;
â”‚     title?: unknown;
â”‚   };
â”‚ 
â”‚   return String(it.item ?? it.name ?? it.label ?? it.description ?? it.title ?? "").trim();
â”‚ }
â”‚ 
â”‚ /** âœ… unify legacy note vs notes */
â”‚ function getNotesValue(raw: InspectionItem): string {
â”‚   const it = raw as unknown as { notes?: unknown; note?: unknown };
â”‚   const v = it.notes ?? it.note ?? "";
â”‚   return typeof v === "string" ? v : String(v ?? "");
â”‚ }
â”‚ 
â”‚ function isTruncated(el: HTMLElement): boolean {
â”‚   return el.scrollWidth > el.clientWidth + 1;
â”‚ }
â”‚ 
â”‚ export default function InspectionItemCard(props: InspectionItemCardProps) {
â”‚   const {
â”‚     item,
â”‚     sectionIndex,
â”‚     itemIndex,
â”‚     showNotes,
â”‚     showPhotos,
â”‚     inspectionId,
â”‚     onUpdateNote,
â”‚     onUpload,
â”‚     onUpdateStatus,
â”‚     onUpdateValue,
â”‚     onUpdateUnit,
â”‚     variant = "card",
â”‚   } = props;
â”‚ 
â”‚   const label = getItemLabel(item);
â”‚   const nameLower = label.toLowerCase();
â”‚ 
â”‚   const isMeasurementItem =
â”‚     nameLower.includes("wheel torque") ||
â”‚     nameLower.includes("park lining") ||
â”‚     nameLower.includes("labor hours") ||
â”‚     nameLower.includes("hours");
â”‚ 
â”‚   const status = String(item.status ?? "").toLowerCase();
â”‚   const isFail = status === "fail";
â”‚   const isRec = status === "recommend";
â”‚ 
â”‚   const rowGlow = isFail
â”‚     ? "shadow-[0_0_0_1px_rgba(239,68,68,0.15)]"
â”‚     : isRec
â”‚       ? "shadow-[0_0_0_1px_rgba(245,158,11,0.15)]"
â”‚       : "";
â”‚ 
â”‚   // âœ… tooltip only when truncated
â”‚   const labelRef = useRef<HTMLSpanElement | null>(null);
â”‚   const [showTip, setShowTip] = useState(false);
â”‚   const [tipEnabled, setTipEnabled] = useState(false);
â”‚   const holdTimerRef = useRef<number | null>(null);
â”‚ 
â”‚   useEffect(() => {
â”‚     const el = labelRef.current;
â”‚     if (!el) {
â”‚       setTipEnabled(false);
â”‚       return;
â”‚     }
â”‚ 
â”‚     const compute = () => {
â”‚       const truncated = isTruncated(el);
â”‚       setTipEnabled(truncated && label.trim().length > 0);
â”‚     };
â”‚ 
â”‚     compute();
â”‚ 
â”‚     const onResize = () => compute();
â”‚     window.addEventListener("resize", onResize);
â”‚     return () => window.removeEventListener("resize", onResize);
â”‚   }, [label]);
â”‚ 
â”‚   const clearHold = () => {
â”‚     if (holdTimerRef.current) {
â”‚       window.clearTimeout(holdTimerRef.current);
â”‚       holdTimerRef.current = null;
â”‚     }
â”‚   };
â”‚ 
â”‚   const openTip = () => {
â”‚     if (!tipEnabled) return;
â”‚     setShowTip(true);
â”‚   };
â”‚ 
â”‚   const closeTip = () => {
â”‚     setShowTip(false);
â”‚     clearHold();
â”‚   };
â”‚ 
â”‚   const onMouseEnter = () => openTip();
â”‚   const onMouseLeave = () => closeTip();
â”‚ 
â”‚   const onTouchStart = () => {
â”‚     if (!tipEnabled) return;
â”‚     clearHold();
â”‚     holdTimerRef.current = window.setTimeout(() => setShowTip(true), 450);
â”‚   };
â”‚ 
â”‚   const onTouchEnd = () => closeTip();
â”‚ 
â”‚   if (variant === "row") {
â”‚     return (
â”‚       <div className={["grid gap-2", rowGlow].join(" ")}>
â”‚         <div className="grid items-start gap-2 lg:grid-cols-[minmax(0,1fr)_240px] lg:gap-3">
â”‚           {/* Item */}
â”‚           <div className="min-w-0">
â”‚             <div className="relative text-[15px] font-semibold text-white">
â”‚               <span
â”‚                 ref={labelRef}
â”‚                 className="block line-clamp-2 lg:truncate"
â”‚                 onMouseEnter={onMouseEnter}
â”‚                 onMouseLeave={onMouseLeave}
â”‚                 onTouchStart={onTouchStart}
â”‚                 onTouchEnd={onTouchEnd}
â”‚                 onTouchCancel={onTouchEnd}
â”‚               >
â”‚                 {label || "â€”"}
â”‚               </span>
â”‚ 
â”‚               {showTip && tipEnabled && (
â”‚                 <div
â”‚                   className={[
â”‚                     "pointer-events-none absolute left-0 top-full z-30 mt-2",
â”‚                     "max-w-[min(520px,90vw)] rounded-lg border border-white/10",
â”‚                     "bg-black/85 px-3 py-2 text-[12px] font-normal text-neutral-100 shadow-[0_18px_45px_rgba(0,0,0,0.75)]",
â”‚                     "backdrop-blur-md",
â”‚                   ].join(" ")}
â”‚                 >
â”‚                   {label}
â”‚                 </div>
â”‚               )}
â”‚             </div>
â”‚           </div>
â”‚ 
â”‚           {/* Checkboxes / Measurement */}
â”‚           <div className="min-w-0">
â”‚             {isMeasurementItem ? (
â”‚               <div className="flex flex-wrap items-center gap-2">
â”‚                 <input
â”‚                   type="number"
â”‚                   inputMode="decimal"
â”‚                   value={item.value ?? ""}
â”‚                   onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
â”‚                     onUpdateValue?.(sectionIndex, itemIndex, e.target.value)
â”‚                   }
â”‚                   placeholder="Value"
â”‚                   className="h-9 w-24 rounded-md border border-white/10 bg-black/50 px-2 py-1 text-[12px] text-white placeholder:text-neutral-500 focus:border-accent focus:outline-none focus:ring-2 focus:ring-accent/60"
â”‚                 />
â”‚                 <input
â”‚                   type="text"
â”‚                   value={item.unit ?? ""}
â”‚                   onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
â”‚                     onUpdateUnit?.(sectionIndex, itemIndex, e.target.value)
â”‚                   }
â”‚                   placeholder="Unit"
â”‚                   className="h-9 w-20 rounded-md border border-white/10 bg-black/50 px-2 py-1 text-[12px] text-white placeholder:text-neutral-500 focus:border-accent focus:outline-none focus:ring-2 focus:ring-accent/60"
â”‚                 />
â”‚               </div>
â”‚             ) : (
â”‚               <StatusButtons
â”‚                 item={item}
â”‚                 sectionIndex={sectionIndex}
â”‚                 itemIndex={itemIndex}
â”‚                 updateItem={(secIdx: number, itmIdx: number, updates: Partial<InspectionItem>) => {
â”‚                   if (updates.status) onUpdateStatus(secIdx, itmIdx, updates.status);
â”‚                 }}
â”‚                 onStatusChange={(s: InspectionItemStatus) =>
â”‚                   onUpdateStatus(sectionIndex, itemIndex, s)
â”‚                 }
â”‚                 compact
â”‚                 wrap
â”‚               />
â”‚             )}
â”‚           </div>
â”‚         </div>
â”‚ 
â”‚         {showNotes ? (
â”‚           <div className="min-w-0">
â”‚             <textarea
â”‚               rows={1}
â”‚               className={[
â”‚                 "h-9 w-full resize-y rounded-lg border border-white/10 bg-black/45 px-2.5 py-2",
â”‚                 "text-[12px] text-white outline-none placeholder:text-neutral-500",
â”‚                 "focus:border-accent focus:ring-2 focus:ring-accent/60",
â”‚               ].join(" ")}
â”‚               placeholder="Notesâ€¦"
â”‚               value={getNotesValue(item)}
â”‚               onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
â”‚                 onUpdateNote(sectionIndex, itemIndex, e.target.value)
â”‚               }
â”‚             />
â”‚           </div>
â”‚         ) : null}
â”‚ 
â”‚         {showPhotos && (item.status === "fail" || item.status === "recommend") && (
â”‚           <div className="mt-1">
â”‚             <div className="rounded-lg border border-white/10 bg-black/25 p-2.5">
â”‚               <div className="flex flex-wrap items-center justify-between gap-2">
â”‚                 <div className="text-[11px] uppercase tracking-[0.16em] text-neutral-400">
â”‚                   Photos
â”‚                 </div>
â”‚ 
â”‚                 <PhotoUploadButton
â”‚                   inspectionId={inspectionId}
â”‚                   itemName={label || null}
â”‚                   photoUrls={item.photoUrls ?? []}
â”‚                   onChange={(urls: string[]) => {
â”‚                     const newUrl = urls[urls.length - 1];
â”‚                     if (newUrl) onUpload(newUrl, sectionIndex, itemIndex);
â”‚                   }}
â”‚                 />
â”‚               </div>
â”‚ 
â”‚               {Array.isArray(item.photoUrls) && item.photoUrls.length > 0 && (
â”‚                 <div className="mt-2 flex gap-2 overflow-x-auto pb-1">
â”‚                   {item.photoUrls.map((url, i) => (
â”‚                     <PhotoThumbnail key={url + i} url={url} />
â”‚                   ))}
â”‚                 </div>
â”‚               )}
â”‚             </div>
â”‚           </div>
â”‚         )}
â”‚       </div>
â”‚     );
â”‚   }
â”‚ 
â”‚   // Card variant
â”‚   return (
â”‚     <div className="rounded-md border border-zinc-800 bg-zinc-950 p-3">
â”‚       <div className="min-w-0">
â”‚         <h3 className="truncate text-[15px] font-semibold text-white">
â”‚           {label || "â€”"}
â”‚         </h3>
â”‚ 
â”‚         {isMeasurementItem ? (
â”‚           <div className="mt-2 flex flex-wrap items-center gap-2">
â”‚             <input
â”‚               type="number"
â”‚               inputMode="decimal"
â”‚               value={item.value ?? ""}
â”‚               onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
â”‚                 onUpdateValue?.(sectionIndex, itemIndex, e.target.value)
â”‚               }
â”‚               placeholder="Value"
â”‚               className="w-24 rounded-md border border-white/10 bg-black/50 px-2 py-1 text-[12px] text-white placeholder:text-neutral-500 focus:border-accent focus:outline-none focus:ring-2 focus:ring-accent/60"
â”‚             />
â”‚             <input
â”‚               type="text"
â”‚               value={item.unit ?? ""}
â”‚               onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
â”‚                 onUpdateUnit?.(sectionIndex, itemIndex, e.target.value)
â”‚               }
â”‚               placeholder="Unit"
â”‚               className="w-20 rounded-md border border-white/10 bg-black/50 px-2 py-1 text-[12px] text-white placeholder:text-neutral-500 focus:border-accent focus:outline-none focus:ring-2 focus:ring-accent/60"
â”‚             />
â”‚           </div>
â”‚         ) : (
â”‚           <div className="mt-2">
â”‚             <StatusButtons
â”‚               item={item}
â”‚               sectionIndex={sectionIndex}
â”‚               itemIndex={itemIndex}
â”‚               updateItem={(secIdx: number, itmIdx: number, updates: Partial<InspectionItem>) => {
â”‚                 if (updates.status) onUpdateStatus(secIdx, itmIdx, updates.status);
â”‚               }}
â”‚               onStatusChange={(s: InspectionItemStatus) =>
â”‚                 onUpdateStatus(sectionIndex, itemIndex, s)
â”‚               }
â”‚             />
â”‚           </div>
â”‚         )}
â”‚       </div>
â”‚ 
â”‚       {showNotes && (
â”‚         <div className="mt-2">
â”‚           <textarea
â”‚             className={[
â”‚               "w-full resize-y rounded-lg border border-white/10 bg-black/45 px-2.5 py-2",
â”‚               "text-[12px] text-white outline-none placeholder:text-neutral-500",
â”‚               "focus:border-accent focus:ring-2 focus:ring-accent/60",
â”‚               "h-[44px]",
â”‚             ].join(" ")}
â”‚             placeholder="Enter notes..."
â”‚             value={getNotesValue(item)}
â”‚             onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
â”‚               onUpdateNote(sectionIndex, itemIndex, e.target.value)
â”‚             }
â”‚           />
â”‚         </div>
â”‚       )}
â”‚ 
â”‚       {showPhotos && (item.status === "fail" || item.status === "recommend") && (
â”‚         <div className="mt-2">
â”‚           <div className="rounded-lg border border-white/10 bg-black/25 p-2.5">
â”‚             <div className="flex flex-wrap items-center justify-between gap-2">
â”‚               <div className="text-[11px] uppercase tracking-[0.16em] text-neutral-400">
â”‚                 Photos
â”‚               </div>
â”‚               <PhotoUploadButton
â”‚                 inspectionId={inspectionId}
â”‚                 itemName={label || null}
â”‚                 photoUrls={item.photoUrls ?? []}
â”‚                 onChange={(urls: string[]) => {
â”‚                   const newUrl = urls[urls.length - 1];
â”‚                   if (newUrl) onUpload(newUrl, sectionIndex, itemIndex);
â”‚                 }}
â”‚               />
â”‚             </div>
â”‚ 
â”‚             {Array.isArray(item.photoUrls) && item.photoUrls.length > 0 && (
â”‚               <div className="mt-2 flex gap-2 overflow-x-auto pb-1">
â”‚                 {item.photoUrls.map((url, i) => (
â”‚                   <PhotoThumbnail key={url + i} url={url} />
â”‚                 ))}
â”‚               </div>
â”‚             )}
â”‚           </div>
â”‚         </div>
â”‚       )}
â”‚     </div>
â”‚   );
â”‚ }

===============================
FILE: features/inspections/lib/inspection/PhotoUploadButton.tsx
===============================
â”‚ // features/inspections/lib/inspection/PhotoUploadButton.tsx âœ… FULL FILE REPLACEMENT (NO any)
â”‚ "use client";
â”‚ 
â”‚ import { useEffect, useState } from "react";
â”‚ import { toast } from "sonner";
â”‚ import PhotoThumbnail from "@inspections/components/inspection/PhotoThumbnail";
â”‚ 
â”‚ type PhotoUploadButtonProps = {
â”‚   photoUrls: string[];
â”‚   onChange: (urls: string[]) => void;
â”‚   inspectionId: string;
â”‚   itemName?: string | null;
â”‚ };
â”‚ 
â”‚ function isRecord(v: unknown): v is Record<string, unknown> {
â”‚   return typeof v === "object" && v !== null;
â”‚ }
â”‚ 
â”‚ function getString(v: unknown): string | null {
â”‚   return typeof v === "string" && v.trim().length ? v.trim() : null;
â”‚ }
â”‚ 
â”‚ export default function PhotoUploadButton({
â”‚   photoUrls,
â”‚   onChange,
â”‚   inspectionId,
â”‚   itemName,
â”‚ }: PhotoUploadButtonProps) {
â”‚   const [urls, setUrls] = useState<string[]>(photoUrls ?? []);
â”‚   const [uploading, setUploading] = useState(false);
â”‚ 
â”‚   useEffect(() => {
â”‚     setUrls(photoUrls ?? []);
â”‚   }, [photoUrls]);
â”‚ 
â”‚   async function uploadOne(file: File): Promise<string | null> {
â”‚     const fd = new FormData();
â”‚     fd.set("inspectionId", inspectionId);
â”‚     const safeItem = getString(itemName);
â”‚     if (safeItem) fd.set("itemName", safeItem);
â”‚     fd.set("file", file);
â”‚ 
â”‚     const res = await fetch("/api/inspections/photos/upload", {
â”‚       method: "POST",
â”‚       body: fd,
â”‚     });
â”‚ 
â”‚     const json = (await res.json().catch(() => null)) as unknown;
â”‚ 
â”‚     if (!res.ok) {
â”‚       const msg =
â”‚         isRecord(json) && typeof json.error === "string"
â”‚           ? json.error
â”‚           : "Upload failed";
â”‚       throw new Error(msg);
â”‚     }
â”‚ 
â”‚     const url =
â”‚       isRecord(json) && typeof json.url === "string" ? json.url : null;
â”‚ 
â”‚     return url;
â”‚   }
â”‚ 
â”‚   const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
â”‚     const files = Array.from(e.target.files ?? []);
â”‚     if (!files.length) return;
â”‚ 
â”‚     setUploading(true);
â”‚     try {
â”‚       const uploaded: string[] = [];
â”‚ 
â”‚       for (const f of files) {
â”‚         const url = await uploadOne(f);
â”‚         if (url) uploaded.push(url);
â”‚       }
â”‚ 
â”‚       const updated = [...urls, ...uploaded];
â”‚       setUrls(updated);
â”‚       onChange(updated);
â”‚ 
â”‚       toast.success(
â”‚         `Uploaded ${uploaded.length} photo${uploaded.length === 1 ? "" : "s"}`,
â”‚       );
â”‚     } catch (err) {
â”‚       const msg = err instanceof Error ? err.message : "Photo upload failed";
â”‚       toast.error(msg);
â”‚     } finally {
â”‚       setUploading(false);
â”‚       e.target.value = "";
â”‚     }
â”‚   };
â”‚ 
â”‚   const handleRemove = (index: number) => {
â”‚     const updated = urls.filter((_, i) => i !== index);
â”‚     setUrls(updated);
â”‚     onChange(updated);
â”‚   };
â”‚ 
â”‚   return (
â”‚     <div className="mt-2">
â”‚       <label className="mb-1 block text-xs font-bold text-white">
â”‚         Upload Photos
â”‚       </label>
â”‚ 
â”‚       <div className="flex flex-wrap">
â”‚         {urls.map((url, i) => (
â”‚           <PhotoThumbnail
â”‚             key={url + i}
â”‚             url={url}
â”‚             onRemove={() => handleRemove(i)}
â”‚           />
â”‚         ))}
â”‚       </div>
â”‚ 
â”‚       <input
â”‚         type="file"
â”‚         multiple
â”‚         accept="image/*"
â”‚         onChange={handleFileChange}
â”‚         disabled={uploading || !inspectionId}
â”‚         className="mt-2 block text-sm text-gray-300 file:rounded-full file:border-0
â”‚         file:bg-orange-700 file:text-sm file:font-semibold file:text-white
â”‚         hover:file:bg-orange-600 disabled:opacity-60"
â”‚       />
â”‚     </div>
â”‚   );
â”‚ }

===============================
FILE: features/shared/components/PhotoCapture.tsx
===============================
â”‚ // features/shared/components/PhotoCapture.tsx
â”‚ "use client";
â”‚ 
â”‚ import { useRef, useState } from "react";
â”‚ import Image from "next/image";
â”‚ 
â”‚ type Props = {
â”‚   onImageSelect: (file: File) => void;
â”‚ };
â”‚ 
â”‚ export default function PhotoCapture({ onImageSelect }: Props) {
â”‚   const captureInputRef = useRef<HTMLInputElement>(null);
â”‚   const uploadInputRef = useRef<HTMLInputElement>(null);
â”‚   const [previewUrl, setPreviewUrl] = useState<string | null>(null);
â”‚ 
â”‚   const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
â”‚     const file = e.target.files?.[0];
â”‚     if (!file) return;
â”‚ 
â”‚     const url = URL.createObjectURL(file);
â”‚     setPreviewUrl(url);
â”‚     onImageSelect(file);
â”‚   };
â”‚ 
â”‚   return (
â”‚     <div className="space-y-4">
â”‚       <div className="flex justify-center gap-4">
â”‚         <button
â”‚           type="button"
â”‚           onClick={() => captureInputRef.current?.click()}
â”‚           className="rounded bg-blue-600 px-4 py-2 font-bold font-header text-white shadow-card hover:bg-blue-700"
â”‚         >
â”‚           ğŸ“· Capture Photo
â”‚         </button>
â”‚         <button
â”‚           type="button"
â”‚           onClick={() => uploadInputRef.current?.click()}
â”‚           className="rounded bg-gray-700 px-4 py-2 font-bold font-header text-white shadow-card hover:bg-gray-800"
â”‚         >
â”‚           ğŸ“ Upload Photo
â”‚         </button>
â”‚       </div>
â”‚ 
â”‚       {/* Hidden Inputs */}
â”‚       <input
â”‚         ref={captureInputRef}
â”‚         type="file"
â”‚         accept="image/*"
â”‚         capture="environment"
â”‚         onChange={handleFileChange}
â”‚         className="hidden"
â”‚       />
â”‚       <input
â”‚         ref={uploadInputRef}
â”‚         type="file"
â”‚         accept="image/*"
â”‚         onChange={handleFileChange}
â”‚         className="hidden"
â”‚       />
â”‚ 
â”‚       {previewUrl && (
â”‚         <div className="mt-4 flex justify-center">
â”‚           <div className="relative h-64 w-full max-w-md">
â”‚             <Image
â”‚               src={previewUrl}
â”‚               alt="Preview"
â”‚               fill
â”‚               className="rounded border object-contain shadow-card"
â”‚               unoptimized
â”‚             />
â”‚           </div>
â”‚         </div>
â”‚       )}
â”‚     </div>
â”‚   );
â”‚ }

===============================
FILE: features/work-orders/components/workorders/extras/PhotoCaptureModal.tsx
===============================
â”‚ // features/work-orders/components/workorders/extras/PhotoCaptureModal.tsx âœ… FULL FILE REPLACEMENT (NO any)
â”‚ "use client";
â”‚ 
â”‚ import { useRef, useState } from "react";
â”‚ import ModalShell from "@/features/shared/components/ModalShell";
â”‚ 
â”‚ interface Props {
â”‚   isOpen: boolean;
â”‚   onClose: () => void;
â”‚   onCapture: (file: File) => void | Promise<void>;
â”‚ }
â”‚ 
â”‚ export default function PhotoCaptureModal({ isOpen, onClose, onCapture }: Props) {
â”‚   const [file, setFile] = useState<File | null>(null);
â”‚   const inputRef = useRef<HTMLInputElement | null>(null);
â”‚ 
â”‚   const submit = async () => {
â”‚     if (!file) {
â”‚       onClose();
â”‚       return;
â”‚     }
â”‚     await onCapture(file);
â”‚     onClose();
â”‚     setFile(null);
â”‚     if (inputRef.current) inputRef.current.value = "";
â”‚   };
â”‚ 
â”‚   return (
â”‚     <ModalShell
â”‚       isOpen={isOpen}
â”‚       onClose={onClose}
â”‚       onSubmit={submit}
â”‚       title="Attach Photo"
â”‚       submitText="Upload"
â”‚       size="sm"
â”‚     >
â”‚       <div className="space-y-2">
â”‚         <label className="block text-xs font-medium uppercase tracking-[0.16em] text-neutral-400">
â”‚           Job photo
â”‚         </label>
â”‚         <input
â”‚           ref={inputRef}
â”‚           type="file"
â”‚           accept="image/*"
â”‚           capture="environment"
â”‚           onChange={(e) => setFile(e.target.files?.[0] ?? null)}
â”‚           className="w-full rounded-md border border-neutral-700 bg-neutral-900 px-3 py-2 text-sm text-white file:mr-3 file:rounded-md file:border-0 file:bg-neutral-800 file:px-3 file:py-1.5 file:text-xs file:font-semibold file:text-neutral-100 hover:file:bg-neutral-700 focus:border-[var(--accent-copper-light)] focus:outline-none focus:ring-1 focus:ring-[var(--accent-copper-light)]"
â”‚         />
â”‚         <p className="mt-1 text-[11px] text-neutral-500">
â”‚           On mobile, this will open the camera. On desktop, you can pick an existing image file.
â”‚         </p>
â”‚       </div>
â”‚     </ModalShell>
â”‚   );
â”‚ }